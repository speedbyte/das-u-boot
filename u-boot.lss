
u-boot:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0002edd0  21f00000  21f00000  00008000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .glue_7       00000000  21f2edd0  21f2edd0  00036dd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .glue_7t      00000000  21f2edd0  21f2edd0  00036dd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000043cc  21f2edd0  21f2edd0  00036dd0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .data         00000c14  21f3319c  21f3319c  0003b19c  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .u_boot_cmd   00000334  21f33db0  21f33db0  0003bdb0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          0004d404  21f34200  21f34200  0003c0e4  2**9
                  ALLOC
  7 .debug_line   0000d418  00000000  00000000  0003c0e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   00020f73  00000000  00000000  000494fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 0000461a  00000000  00000000  0006a46f  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000740  00000000  00000000  0006ea90  2**3
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macinfo 0036e589  00000000  00000000  0006f1d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00005e50  00000000  00000000  003dd75c  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubnames 00003c14  00000000  00000000  003e35ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00000798  00000000  00000000  003e71c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      00000898  00000000  00000000  003e7958  2**0
                  CONTENTS, READONLY
Disassembly of section .text:

21f00000 <_start>:
 */


.globl _start
_start:	b       reset
21f00000:	ea000014 	b	21f00058 <reset>
	ldr	pc, _undefined_instruction
21f00004:	e59ff014 	ldr	pc, [pc, #20]	; 21f00020 <_undefined_instruction>
	ldr	pc, _software_interrupt
21f00008:	e59ff014 	ldr	pc, [pc, #20]	; 21f00024 <_software_interrupt>
	ldr	pc, _prefetch_abort
21f0000c:	e59ff014 	ldr	pc, [pc, #20]	; 21f00028 <_prefetch_abort>
	ldr	pc, _data_abort
21f00010:	e59ff014 	ldr	pc, [pc, #20]	; 21f0002c <_data_abort>
	ldr	pc, _not_used
21f00014:	e59ff014 	ldr	pc, [pc, #20]	; 21f00030 <_not_used>
	ldr	pc, _irq
21f00018:	e59ff014 	ldr	pc, [pc, #20]	; 21f00034 <_irq>
	ldr	pc, _fiq
21f0001c:	e59ff014 	ldr	pc, [pc, #20]	; 21f00038 <_fiq>

21f00020 <_undefined_instruction>:
21f00020:	21f00120 	mvncss	r0, r0, lsr #2

21f00024 <_software_interrupt>:
21f00024:	21f00180 	mvncss	r0, r0, lsl #3

21f00028 <_prefetch_abort>:
21f00028:	21f001e0 	mvncss	r0, r0, ror #3

21f0002c <_data_abort>:
21f0002c:	21f00240 	mvncss	r0, r0, asr #4

21f00030 <_not_used>:
21f00030:	21f002a0 	mvncss	r0, r0, lsr #5

21f00034 <_irq>:
21f00034:	21f00300 	mvncss	r0, r0, lsl #6

21f00038 <_fiq>:
21f00038:	21f00340 	mvncss	r0, r0, asr #6
21f0003c:	deadbeef 	cdple	14, 10, cr11, cr13, cr15, {7}

21f00040 <_TEXT_BASE>:
21f00040:	21f00000 	mvncss	r0, r0

21f00044 <_armboot_start>:
21f00044:	21f00000 	mvncss	r0, r0

21f00048 <_bss_start>:
21f00048:	21f340e4 	mvncss	r4, r4, ror #1

21f0004c <_bss_end>:
21f0004c:	21f81604 	mvncss	r1, r4, lsl #12

21f00050 <IRQ_STACK_START>:
21f00050:	0badc0de 	bleq	20a703d0 <.text-0x148fc30>

21f00054 <FIQ_STACK_START>:
21f00054:	0badc0de 	bleq	20a703d4 <.text-0x148fc2c>

21f00058 <reset>:

_undefined_instruction:	.word undefined_instruction
_software_interrupt:	.word software_interrupt
_prefetch_abort:	.word prefetch_abort
_data_abort:		.word data_abort
_not_used:		.word not_used
_irq:			.word irq
_fiq:			.word fiq

	.balignl 16,0xdeadbeef


/*
 *************************************************************************
 *
 * Startup Code (reset vector)
 *
 * do important init only if we don't start from memory!
 * relocate armboot to ram
 * setup stack
 * jump to second stage
 *
 *************************************************************************
 */

_TEXT_BASE:
	.word	TEXT_BASE

.globl _armboot_start
_armboot_start:
	.word _start

/*
 * These are defined in the board-specific linker script.
 */
.globl _bss_start
_bss_start:
	.word __bss_start

.globl _bss_end
_bss_end:
	.word _end

#ifdef CONFIG_USE_IRQ
/* IRQ stack memory (calculated at run-time) */
.globl IRQ_STACK_START
IRQ_STACK_START:
	.word	0x0badc0de

/* IRQ stack memory (calculated at run-time) */
.globl FIQ_STACK_START
FIQ_STACK_START:
	.word 0x0badc0de
#endif


/*
 * the actual reset code
 */

reset:
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0,cpsr
21f00058:	e10f0000 	mrs	r0, CPSR
	bic	r0,r0,#0x1f
21f0005c:	e3c0001f 	bic	r0, r0, #31	; 0x1f
	orr	r0,r0,#0xd3
21f00060:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
21f00064:	e129f000 	msr	CPSR_fc, r0

/* turn off the watchdog */
#if defined(CONFIG_S3C2400)
# define pWTCON		0x15300000
# define INTMSK		0x14400008	/* Interupt-Controller base addresses */
# define CLKDIVN	0x14800014	/* clock divisor register */
#elif defined(CONFIG_S3C2410)
# define pWTCON		0x53000000
# define INTMSK		0x4A000008	/* Interupt-Controller base addresses */
# define INTSUBMSK	0x4A00001C
# define CLKDIVN	0x4C000014	/* clock divisor register */
#endif

#if defined(CONFIG_S3C2400) || defined(CONFIG_S3C2410)
	ldr     r0, =pWTCON
	mov     r1, #0x0
	str     r1, [r0]

	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xffffffff
	ldr	r0, =INTMSK
	str	r1, [r0]
# if defined(CONFIG_S3C2410)
	ldr	r1, =0x3ff
	ldr	r0, =INTSUBMSK
	str	r1, [r0]
# endif

	/* FCLK:HCLK:PCLK = 1:2:4 */
	/* default FCLK is 120 MHz ! */
	ldr	r0, =CLKDIVN
	mov	r1, #3
	str	r1, [r0]
#endif	/* CONFIG_S3C2400 || CONFIG_S3C2410 */

	/*
	 * we do sys-critical inits only at reboot,
	 * not when booting from ram!
	 */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_crit
21f00068:	eb000019 	bl	21f000d4 <cpu_init_crit>

21f0006c <relocate>:
#endif

#ifndef CONFIG_SKIP_RELOCATE_UBOOT
relocate:				/* relocate U-Boot to RAM	    */
	adr	r0, _start		/* r0 <- current position of code   */
21f0006c:	e24f0074 	sub	r0, pc, #116	; 0x74
	ldr	r1, _TEXT_BASE		/* test if we run from flash or RAM */
21f00070:	e51f1038 	ldr	r1, [pc, #-56]	; 21f00040 <_TEXT_BASE>
	cmp     r0, r1                  /* don't reloc during debug         */
21f00074:	e1500001 	cmp	r0, r1
	beq     stack_setup
21f00078:	0a000007 	beq	21f0009c <stack_setup>

	ldr	r2, _armboot_start
21f0007c:	e51f2040 	ldr	r2, [pc, #-64]	; 21f00044 <_armboot_start>
	ldr	r3, _bss_start
21f00080:	e51f3040 	ldr	r3, [pc, #-64]	; 21f00048 <_bss_start>
	sub	r2, r3, r2		/* r2 <- size of armboot            */
21f00084:	e0432002 	sub	r2, r3, r2
	add	r2, r0, r2		/* r2 <- source end address         */
21f00088:	e0802002 	add	r2, r0, r2

21f0008c <copy_loop>:

copy_loop:
	ldmia	r0!, {r3-r10}		/* copy from source address [r0]    */
21f0008c:	e8b007f8 	ldmia	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
	stmia	r1!, {r3-r10}		/* copy to   target address [r1]    */
21f00090:	e8a107f8 	stmia	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
	cmp	r0, r2			/* until source end addreee [r2]    */
21f00094:	e1500002 	cmp	r0, r2
	ble	copy_loop
21f00098:	dafffffb 	ble	21f0008c <copy_loop>

21f0009c <stack_setup>:
#endif	/* CONFIG_SKIP_RELOCATE_UBOOT */

	/* Set up the stack						    */
stack_setup:
	ldr	r0, _TEXT_BASE		/* upper 128 KiB: relocated uboot   */
21f0009c:	e51f0064 	ldr	r0, [pc, #-100]	; 21f00040 <_TEXT_BASE>
	sub	r0, r0, #CFG_MALLOC_LEN	/* malloc area                      */
21f000a0:	e2400a22 	sub	r0, r0, #139264	; 0x22000
	sub	r0, r0, #CFG_GBL_DATA_SIZE /* bdinfo                        */
21f000a4:	e2400080 	sub	r0, r0, #128	; 0x80
#ifdef CONFIG_USE_IRQ
	sub	r0, r0, #(CONFIG_STACKSIZE_IRQ+CONFIG_STACKSIZE_FIQ)
21f000a8:	e2400080 	sub	r0, r0, #128	; 0x80
#endif
	sub	sp, r0, #12		/* leave 3 words for abort-stack    */
21f000ac:	e240d00c 	sub	sp, r0, #12	; 0xc

21f000b0 <clear_bss>:

clear_bss:
	ldr	r0, _bss_start		/* find start of bss segment        */
21f000b0:	e51f0070 	ldr	r0, [pc, #-112]	; 21f00048 <_bss_start>
	ldr	r1, _bss_end		/* stop here                        */
21f000b4:	e51f1070 	ldr	r1, [pc, #-112]	; 21f0004c <_bss_end>
	mov 	r2, #0x00000000		/* clear                            */
21f000b8:	e3a02000 	mov	r2, #0	; 0x0

21f000bc <clbss_l>:

clbss_l:str	r2, [r0]		/* clear loop...                    */
21f000bc:	e5802000 	str	r2, [r0]
	add	r0, r0, #4
21f000c0:	e2800004 	add	r0, r0, #4	; 0x4
	cmp	r0, r1
21f000c4:	e1500001 	cmp	r0, r1
	ble	clbss_l
21f000c8:	dafffffb 	ble	21f000bc <clbss_l>

#if 0
	/* try doing this stuff after the relocation */
	ldr     r0, =pWTCON
	mov     r1, #0x0
	str     r1, [r0]

	/*
	 * mask all IRQs by setting all bits in the INTMR - default
	 */
	mov	r1, #0xffffffff
	ldr	r0, =INTMR
	str	r1, [r0]

	/* FCLK:HCLK:PCLK = 1:2:4 */
	/* default FCLK is 120 MHz ! */
	ldr	r0, =CLKDIVN
	mov	r1, #3
	str	r1, [r0]
	/* END stuff after relocation */
#endif

	ldr	pc, _start_armboot
21f000cc:	e51ff004 	ldr	pc, [pc, #-4]	; 21f000d0 <_start_armboot>

21f000d0 <_start_armboot>:
21f000d0:	21f05eb4 	ldrcsh	r5, [r0, #228]!

21f000d4 <cpu_init_crit>:

_start_armboot:	.word start_armboot


/*
 *************************************************************************
 *
 * CPU_init_critical registers
 *
 * setup important registers
 * setup memory timing
 *
 *************************************************************************
 */


#ifndef CONFIG_SKIP_LOWLEVEL_INIT
cpu_init_crit:
	/*
	 * flush v4 I/D caches
	 */
	mov	r0, #0
21f000d4:	e3a00000 	mov	r0, #0	; 0x0
	mcr	p15, 0, r0, c7, c7, 0	/* flush v3/v4 cache */
21f000d8:	ee070f17 	mcr	15, 0, r0, cr7, cr7, {0}
	mcr	p15, 0, r0, c8, c7, 0	/* flush v4 TLB */
21f000dc:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
21f000e0:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002300	@ clear bits 13, 9:8 (--V- --RS)
21f000e4:	e3c00c23 	bic	r0, r0, #8960	; 0x2300
	bic	r0, r0, #0x00000087	@ clear bits 7, 2:0 (B--- -CAM)
21f000e8:	e3c00087 	bic	r0, r0, #135	; 0x87
	orr	r0, r0, #0x00000002	@ set bit 2 (A) Align
21f000ec:	e3800002 	orr	r0, r0, #2	; 0x2
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-Cache
21f000f0:	e3800a01 	orr	r0, r0, #4096	; 0x1000
	mcr	p15, 0, r0, c1, c0, 0
21f000f4:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/*
	 * before relocating, we have to setup RAM timing
	 * because memory timing is board-dependend, you will
	 * find a lowlevel_init.S in your board directory.
	 */
	mov	ip, lr
21f000f8:	e1a0c00e 	mov	ip, lr
	bl	lowlevel_init
21f000fc:	eb0001b7 	bl	21f007e0 <lowlevel_init>
	mov	lr, ip
21f00100:	e1a0e00c 	mov	lr, ip
	mov	pc, lr
21f00104:	e1a0f00e 	mov	pc, lr
	...

21f00120 <undefined_instruction>:
#endif /* CONFIG_SKIP_LOWLEVEL_INIT */

/*
 *************************************************************************
 *
 * Interrupt handling
 *
 *************************************************************************
 */

@
@ IRQ stack frame.
@
#define S_FRAME_SIZE	72

#define S_OLD_R0	68
#define S_PSR		64
#define S_PC		60
#define S_LR		56
#define S_SP		52

#define S_IP		48
#define S_FP		44
#define S_R10		40
#define S_R9		36
#define S_R8		32
#define S_R7		28
#define S_R6		24
#define S_R5		20
#define S_R4		16
#define S_R3		12
#define S_R2		8
#define S_R1		4
#define S_R0		0

#define MODE_SVC 0x13
#define I_BIT	 0x80

/*
 * use bad_save_user_regs for abort/prefetch/undef/swi ...
 * use irq_save_user_regs / irq_restore_user_regs for IRQ/FIQ handling
 */

	.macro	bad_save_user_regs
	sub	sp, sp, #S_FRAME_SIZE
	stmia	sp, {r0 - r12}			@ Calling r0-r12
	ldr	r2, _armboot_start
	sub	r2, r2, #(CONFIG_STACKSIZE+CFG_MALLOC_LEN)
	sub	r2, r2, #(CFG_GBL_DATA_SIZE+8)  @ set base 2 words into abort stack
	ldmia	r2, {r2 - r3}			@ get pc, cpsr
	add	r0, sp, #S_FRAME_SIZE		@ restore sp_SVC

	add	r5, sp, #S_SP
	mov	r1, lr
	stmia	r5, {r0 - r3}			@ save sp_SVC, lr_SVC, pc, cpsr
	mov	r0, sp
	.endm

	.macro	irq_save_user_regs
	sub	sp, sp, #S_FRAME_SIZE
	stmia	sp, {r0 - r12}			@ Calling r0-r12
	add     r8, sp, #S_PC
	stmdb   r8, {sp, lr}^                   @ Calling SP, LR
	str     lr, [r8, #0]                    @ Save calling PC
	mrs     r6, spsr
	str     r6, [r8, #4]                    @ Save CPSR
	str     r0, [r8, #8]                    @ Save OLD_R0
	mov	r0, sp
	.endm

	.macro	irq_restore_user_regs
	ldmia	sp, {r0 - lr}^			@ Calling r0 - lr
	mov	r0, r0
	ldr	lr, [sp, #S_PC]			@ Get PC
	add	sp, sp, #S_FRAME_SIZE
	subs	pc, lr, #4			@ return & move spsr_svc into cpsr
	.endm

	.macro get_bad_stack
	ldr	r13, _armboot_start		@ setup our mode stack
	sub	r13, r13, #(CONFIG_STACKSIZE+CFG_MALLOC_LEN)
	sub	r13, r13, #(CFG_GBL_DATA_SIZE+8) @ reserved a couple spots in abort stack

	str	lr, [r13]			@ save caller lr / spsr
	mrs	lr, spsr
	str     lr, [r13, #4]

	mov	r13, #MODE_SVC			@ prepare SVC-Mode
	@ msr	spsr_c, r13
	msr	spsr, r13
	mov	lr, pc
	movs	pc, lr
	.endm

	.macro get_irq_stack			@ setup IRQ stack
	ldr	sp, IRQ_STACK_START
	.endm

	.macro get_fiq_stack			@ setup FIQ stack
	ldr	sp, FIQ_STACK_START
	.endm

/*
 * exception handlers
 */
	.align  5
undefined_instruction:
	get_bad_stack
21f00120:	e51fd0e4 	ldr	sp, [pc, #-228]	; 21f00044 <_armboot_start>
21f00124:	e24dda2a 	sub	sp, sp, #172032	; 0x2a000
21f00128:	e24dd088 	sub	sp, sp, #136	; 0x88
21f0012c:	e58de000 	str	lr, [sp]
21f00130:	e14fe000 	mrs	lr, SPSR
21f00134:	e58de004 	str	lr, [sp, #4]
21f00138:	e3a0d013 	mov	sp, #19	; 0x13
21f0013c:	e169f00d 	msr	SPSR_fc, sp
21f00140:	e1a0e00f 	mov	lr, pc
21f00144:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
21f00148:	e24dd048 	sub	sp, sp, #72	; 0x48
21f0014c:	e88d1fff 	stmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
21f00150:	e51f2114 	ldr	r2, [pc, #-276]	; 21f00044 <_armboot_start>
21f00154:	e2422a2a 	sub	r2, r2, #172032	; 0x2a000
21f00158:	e2422088 	sub	r2, r2, #136	; 0x88
21f0015c:	e892000c 	ldmia	r2, {r2, r3}
21f00160:	e28d0048 	add	r0, sp, #72	; 0x48
21f00164:	e28d5034 	add	r5, sp, #52	; 0x34
21f00168:	e1a0100e 	mov	r1, lr
21f0016c:	e885000f 	stmia	r5, {r0, r1, r2, r3}
21f00170:	e1a0000d 	mov	r0, sp
	bl 	do_undefined_instruction
21f00174:	eb000149 	bl	21f006a0 <do_undefined_instruction>
	...

21f00180 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack
21f00180:	e51fd144 	ldr	sp, [pc, #-324]	; 21f00044 <_armboot_start>
21f00184:	e24dda2a 	sub	sp, sp, #172032	; 0x2a000
21f00188:	e24dd088 	sub	sp, sp, #136	; 0x88
21f0018c:	e58de000 	str	lr, [sp]
21f00190:	e14fe000 	mrs	lr, SPSR
21f00194:	e58de004 	str	lr, [sp, #4]
21f00198:	e3a0d013 	mov	sp, #19	; 0x13
21f0019c:	e169f00d 	msr	SPSR_fc, sp
21f001a0:	e1a0e00f 	mov	lr, pc
21f001a4:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
21f001a8:	e24dd048 	sub	sp, sp, #72	; 0x48
21f001ac:	e88d1fff 	stmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
21f001b0:	e51f2174 	ldr	r2, [pc, #-372]	; 21f00044 <_armboot_start>
21f001b4:	e2422a2a 	sub	r2, r2, #172032	; 0x2a000
21f001b8:	e2422088 	sub	r2, r2, #136	; 0x88
21f001bc:	e892000c 	ldmia	r2, {r2, r3}
21f001c0:	e28d0048 	add	r0, sp, #72	; 0x48
21f001c4:	e28d5034 	add	r5, sp, #52	; 0x34
21f001c8:	e1a0100e 	mov	r1, lr
21f001cc:	e885000f 	stmia	r5, {r0, r1, r2, r3}
21f001d0:	e1a0000d 	mov	r0, sp
	bl 	do_software_interrupt
21f001d4:	eb00013d 	bl	21f006d0 <do_software_interrupt>
	...

21f001e0 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
21f001e0:	e51fd1a4 	ldr	sp, [pc, #-420]	; 21f00044 <_armboot_start>
21f001e4:	e24dda2a 	sub	sp, sp, #172032	; 0x2a000
21f001e8:	e24dd088 	sub	sp, sp, #136	; 0x88
21f001ec:	e58de000 	str	lr, [sp]
21f001f0:	e14fe000 	mrs	lr, SPSR
21f001f4:	e58de004 	str	lr, [sp, #4]
21f001f8:	e3a0d013 	mov	sp, #19	; 0x13
21f001fc:	e169f00d 	msr	SPSR_fc, sp
21f00200:	e1a0e00f 	mov	lr, pc
21f00204:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
21f00208:	e24dd048 	sub	sp, sp, #72	; 0x48
21f0020c:	e88d1fff 	stmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
21f00210:	e51f21d4 	ldr	r2, [pc, #-468]	; 21f00044 <_armboot_start>
21f00214:	e2422a2a 	sub	r2, r2, #172032	; 0x2a000
21f00218:	e2422088 	sub	r2, r2, #136	; 0x88
21f0021c:	e892000c 	ldmia	r2, {r2, r3}
21f00220:	e28d0048 	add	r0, sp, #72	; 0x48
21f00224:	e28d5034 	add	r5, sp, #52	; 0x34
21f00228:	e1a0100e 	mov	r1, lr
21f0022c:	e885000f 	stmia	r5, {r0, r1, r2, r3}
21f00230:	e1a0000d 	mov	r0, sp
	bl 	do_prefetch_abort
21f00234:	eb000131 	bl	21f00700 <do_prefetch_abort>
	...

21f00240 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
21f00240:	e51fd204 	ldr	sp, [pc, #-516]	; 21f00044 <_armboot_start>
21f00244:	e24dda2a 	sub	sp, sp, #172032	; 0x2a000
21f00248:	e24dd088 	sub	sp, sp, #136	; 0x88
21f0024c:	e58de000 	str	lr, [sp]
21f00250:	e14fe000 	mrs	lr, SPSR
21f00254:	e58de004 	str	lr, [sp, #4]
21f00258:	e3a0d013 	mov	sp, #19	; 0x13
21f0025c:	e169f00d 	msr	SPSR_fc, sp
21f00260:	e1a0e00f 	mov	lr, pc
21f00264:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
21f00268:	e24dd048 	sub	sp, sp, #72	; 0x48
21f0026c:	e88d1fff 	stmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
21f00270:	e51f2234 	ldr	r2, [pc, #-564]	; 21f00044 <_armboot_start>
21f00274:	e2422a2a 	sub	r2, r2, #172032	; 0x2a000
21f00278:	e2422088 	sub	r2, r2, #136	; 0x88
21f0027c:	e892000c 	ldmia	r2, {r2, r3}
21f00280:	e28d0048 	add	r0, sp, #72	; 0x48
21f00284:	e28d5034 	add	r5, sp, #52	; 0x34
21f00288:	e1a0100e 	mov	r1, lr
21f0028c:	e885000f 	stmia	r5, {r0, r1, r2, r3}
21f00290:	e1a0000d 	mov	r0, sp
	bl 	do_data_abort
21f00294:	eb000125 	bl	21f00730 <do_data_abort>
	...

21f002a0 <not_used>:

	.align	5
not_used:
	get_bad_stack
21f002a0:	e51fd264 	ldr	sp, [pc, #-612]	; 21f00044 <_armboot_start>
21f002a4:	e24dda2a 	sub	sp, sp, #172032	; 0x2a000
21f002a8:	e24dd088 	sub	sp, sp, #136	; 0x88
21f002ac:	e58de000 	str	lr, [sp]
21f002b0:	e14fe000 	mrs	lr, SPSR
21f002b4:	e58de004 	str	lr, [sp, #4]
21f002b8:	e3a0d013 	mov	sp, #19	; 0x13
21f002bc:	e169f00d 	msr	SPSR_fc, sp
21f002c0:	e1a0e00f 	mov	lr, pc
21f002c4:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
21f002c8:	e24dd048 	sub	sp, sp, #72	; 0x48
21f002cc:	e88d1fff 	stmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
21f002d0:	e51f2294 	ldr	r2, [pc, #-660]	; 21f00044 <_armboot_start>
21f002d4:	e2422a2a 	sub	r2, r2, #172032	; 0x2a000
21f002d8:	e2422088 	sub	r2, r2, #136	; 0x88
21f002dc:	e892000c 	ldmia	r2, {r2, r3}
21f002e0:	e28d0048 	add	r0, sp, #72	; 0x48
21f002e4:	e28d5034 	add	r5, sp, #52	; 0x34
21f002e8:	e1a0100e 	mov	r1, lr
21f002ec:	e885000f 	stmia	r5, {r0, r1, r2, r3}
21f002f0:	e1a0000d 	mov	r0, sp
	bl 	do_not_used
21f002f4:	eb000119 	bl	21f00760 <do_not_used>
	...

21f00300 <irq>:

#ifdef CONFIG_USE_IRQ

	.align	5
irq:
	get_irq_stack
21f00300:	e51fd2b8 	ldr	sp, [pc, #-696]	; 21f00050 <IRQ_STACK_START>
	irq_save_user_regs
21f00304:	e24dd048 	sub	sp, sp, #72	; 0x48
21f00308:	e88d1fff 	stmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
21f0030c:	e28d803c 	add	r8, sp, #60	; 0x3c
21f00310:	e9486000 	stmdb	r8, {sp, lr}^
21f00314:	e588e000 	str	lr, [r8]
21f00318:	e14f6000 	mrs	r6, SPSR
21f0031c:	e5886004 	str	r6, [r8, #4]
21f00320:	e5880008 	str	r0, [r8, #8]
21f00324:	e1a0000d 	mov	r0, sp
	bl 	do_irq
21f00328:	eb000124 	bl	21f007c0 <do_irq>
	irq_restore_user_regs
21f0032c:	e8dd7fff 	ldmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
21f00330:	e1a00000 	nop			(mov r0,r0)
21f00334:	e59de03c 	ldr	lr, [sp, #60]
21f00338:	e28dd048 	add	sp, sp, #72	; 0x48
21f0033c:	e25ef004 	subs	pc, lr, #4	; 0x4

21f00340 <fiq>:

	.align	5
fiq:
	get_fiq_stack
21f00340:	e51fd2f4 	ldr	sp, [pc, #-756]	; 21f00054 <FIQ_STACK_START>
	/* someone ought to write a more effiction fiq_save_user_regs */
	irq_save_user_regs
21f00344:	e24dd048 	sub	sp, sp, #72	; 0x48
21f00348:	e88d1fff 	stmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
21f0034c:	e28d803c 	add	r8, sp, #60	; 0x3c
21f00350:	e9486000 	stmdb	r8, {sp, lr}^
21f00354:	e588e000 	str	lr, [r8]
21f00358:	e14f6000 	mrs	r6, SPSR
21f0035c:	e5886004 	str	r6, [r8, #4]
21f00360:	e5880008 	str	r0, [r8, #8]
21f00364:	e1a0000d 	mov	r0, sp
	bl 	do_fiq
21f00368:	eb000108 	bl	21f00790 <do_fiq>
	irq_restore_user_regs
21f0036c:	e8dd7fff 	ldmia	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
21f00370:	e1a00000 	nop			(mov r0,r0)
21f00374:	e59de03c 	ldr	lr, [sp, #60]
21f00378:	e28dd048 	add	sp, sp, #72	; 0x48
21f0037c:	e25ef004 	subs	pc, lr, #4	; 0x4

21f00380 <enable_interrupts>:

#ifdef CONFIG_USE_IRQ
/* enable IRQ interrupts */
void enable_interrupts (void)
{
21f00380:	e1a0c00d 	mov	ip, sp
21f00384:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00388:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0038c:	e24dd004 	sub	sp, sp, #4	; 0x4
	unsigned long temp;
	__asm__ __volatile__("mrs %0, cpsr\n"
21f00390:	e10f3000 	mrs	r3, CPSR
21f00394:	e3c33080 	bic	r3, r3, #128	; 0x80
21f00398:	e121f003 	msr	CPSR_c, r3
21f0039c:	e50b3010 	str	r3, [fp, #-16]
			     "bic %0, %0, #0x80\n"
			     "msr cpsr_c, %0"
			     : "=r" (temp)
			     :
			     : "memory");
}
21f003a0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f003a4 <disable_interrupts>:


/*
 * disable IRQ/FIQ interrupts
 * returns true if interrupts had been enabled before we disabled them
 */
int disable_interrupts (void)
{
21f003a4:	e1a0c00d 	mov	ip, sp
21f003a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f003ac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f003b0:	e24dd008 	sub	sp, sp, #8	; 0x8
	unsigned long old,temp;
	__asm__ __volatile__("mrs %0, cpsr\n"
21f003b4:	e10f3000 	mrs	r3, CPSR
21f003b8:	e38320c0 	orr	r2, r3, #192	; 0xc0
21f003bc:	e121f002 	msr	CPSR_c, r2
21f003c0:	e50b3014 	str	r3, [fp, #-20]
21f003c4:	e50b2010 	str	r2, [fp, #-16]
			     "orr %1, %0, #0xc0\n"
			     "msr cpsr_c, %1"
			     : "=r" (old), "=r" (temp)
			     :
			     : "memory");
	return (old & 0x80) == 0;
21f003c8:	e51b3014 	ldr	r3, [fp, #-20]
21f003cc:	e1a033a3 	mov	r3, r3, lsr #7
21f003d0:	e2233001 	eor	r3, r3, #1	; 0x1
21f003d4:	e2033001 	and	r3, r3, #1	; 0x1
}
21f003d8:	e1a00003 	mov	r0, r3
21f003dc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f003e0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f003e4 <bad_mode>:
#else
void enable_interrupts (void)
{
	return;
}
int disable_interrupts (void)
{
	return 0;
}
#endif


void bad_mode (void)
{
21f003e4:	e1a0c00d 	mov	ip, sp
21f003e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f003ec:	e24cb004 	sub	fp, ip, #4	; 0x4
	panic ("Resetting CPU ...\n");
21f003f0:	e59f000c 	ldr	r0, [pc, #12]	; 21f00404 <.text+0x404>
21f003f4:	eb0090c6 	bl	21f24714 <panic>
	reset_cpu (0);
21f003f8:	e3a00000 	mov	r0, #0	; 0x0
21f003fc:	eb000230 	bl	21f00cc4 <reset_cpu>
}
21f00400:	e89da800 	ldmia	sp, {fp, sp, pc}
21f00404:	21f2edd0 	ldrcssb	lr, [r2, #208]!

21f00408 <show_regs>:

void show_regs (struct pt_regs *regs)
{
21f00408:	e1a0c00d 	mov	ip, sp
21f0040c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00410:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00414:	e24dd0a8 	sub	sp, sp, #168	; 0xa8
21f00418:	e50b0094 	str	r0, [fp, #-148]
	unsigned long flags;
	const char *processor_modes[] = {
	"USER_26",	"FIQ_26",	"IRQ_26",	"SVC_26",
	"UK4_26",	"UK5_26",	"UK6_26",	"UK7_26",
	"UK8_26",	"UK9_26",	"UK10_26",	"UK11_26",
	"UK12_26",	"UK13_26",	"UK14_26",	"UK15_26",
	"USER_32",	"FIQ_32",	"IRQ_32",	"SVC_32",
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};
21f0041c:	e59f3254 	ldr	r3, [pc, #596]	; 21f00678 <.text+0x678>
21f00420:	e24b2090 	sub	r2, fp, #144	; 0x90
21f00424:	e3a0c080 	mov	ip, #128	; 0x80
21f00428:	e1a00002 	mov	r0, r2
21f0042c:	e1a01003 	mov	r1, r3
21f00430:	e1a0200c 	mov	r2, ip
21f00434:	eb008b64 	bl	21f231cc <memcpy>

	flags = condition_codes (regs);
21f00438:	e51b3094 	ldr	r3, [fp, #-148]
21f0043c:	e5933040 	ldr	r3, [r3, #64]
21f00440:	e203320f 	and	r3, r3, #-268435456	; 0xf0000000
21f00444:	e50b3010 	str	r3, [fp, #-16]

	printf ("pc : [<%08lx>]    lr : [<%08lx>]\n"
21f00448:	e51b3094 	ldr	r3, [fp, #-148]
21f0044c:	e593103c 	ldr	r1, [r3, #60]
21f00450:	e51b3094 	ldr	r3, [fp, #-148]
21f00454:	e593e038 	ldr	lr, [r3, #56]
21f00458:	e51b3094 	ldr	r3, [fp, #-148]
21f0045c:	e593c034 	ldr	ip, [r3, #52]
21f00460:	e51b3094 	ldr	r3, [fp, #-148]
21f00464:	e5932030 	ldr	r2, [r3, #48]
21f00468:	e51b3094 	ldr	r3, [fp, #-148]
21f0046c:	e593302c 	ldr	r3, [r3, #44]
21f00470:	e58d2000 	str	r2, [sp]
21f00474:	e58d3004 	str	r3, [sp, #4]
21f00478:	e59f01fc 	ldr	r0, [pc, #508]	; 21f0067c <.text+0x67c>
21f0047c:	e1a0200e 	mov	r2, lr
21f00480:	e1a0300c 	mov	r3, ip
21f00484:	eb006d80 	bl	21f1ba8c <printf>
		"sp : %08lx  ip : %08lx  fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx  r8 : %08lx\n",
21f00488:	e51b3094 	ldr	r3, [fp, #-148]
21f0048c:	e5931028 	ldr	r1, [r3, #40]
21f00490:	e51b3094 	ldr	r3, [fp, #-148]
21f00494:	e5932024 	ldr	r2, [r3, #36]
21f00498:	e51b3094 	ldr	r3, [fp, #-148]
21f0049c:	e5933020 	ldr	r3, [r3, #32]
21f004a0:	e59f01d8 	ldr	r0, [pc, #472]	; 21f00680 <.text+0x680>
21f004a4:	eb006d78 	bl	21f1ba8c <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx  r5 : %08lx  r4 : %08lx\n",
21f004a8:	e51b3094 	ldr	r3, [fp, #-148]
21f004ac:	e593201c 	ldr	r2, [r3, #28]
21f004b0:	e51b3094 	ldr	r3, [fp, #-148]
21f004b4:	e593c018 	ldr	ip, [r3, #24]
21f004b8:	e51b3094 	ldr	r3, [fp, #-148]
21f004bc:	e593e014 	ldr	lr, [r3, #20]
21f004c0:	e51b3094 	ldr	r3, [fp, #-148]
21f004c4:	e5933010 	ldr	r3, [r3, #16]
21f004c8:	e58d3000 	str	r3, [sp]
21f004cc:	e59f01b0 	ldr	r0, [pc, #432]	; 21f00684 <.text+0x684>
21f004d0:	e1a01002 	mov	r1, r2
21f004d4:	e1a0200c 	mov	r2, ip
21f004d8:	e1a0300e 	mov	r3, lr
21f004dc:	eb006d6a 	bl	21f1ba8c <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx  r1 : %08lx  r0 : %08lx\n",
21f004e0:	e51b3094 	ldr	r3, [fp, #-148]
21f004e4:	e593200c 	ldr	r2, [r3, #12]
21f004e8:	e51b3094 	ldr	r3, [fp, #-148]
21f004ec:	e593c008 	ldr	ip, [r3, #8]
21f004f0:	e51b3094 	ldr	r3, [fp, #-148]
21f004f4:	e593e004 	ldr	lr, [r3, #4]
21f004f8:	e51b3094 	ldr	r3, [fp, #-148]
21f004fc:	e5933000 	ldr	r3, [r3]
21f00500:	e58d3000 	str	r3, [sp]
21f00504:	e59f017c 	ldr	r0, [pc, #380]	; 21f00688 <.text+0x688>
21f00508:	e1a01002 	mov	r1, r2
21f0050c:	e1a0200c 	mov	r2, ip
21f00510:	e1a0300e 	mov	r3, lr
21f00514:	eb006d5c 	bl	21f1ba8c <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
21f00518:	e51b3010 	ldr	r3, [fp, #-16]
21f0051c:	e3530000 	cmp	r3, #0	; 0x0
21f00520:	aa000002 	bge	21f00530 <show_regs+0x128>
21f00524:	e3a0104e 	mov	r1, #78	; 0x4e
21f00528:	e50b10ac 	str	r1, [fp, #-172]
21f0052c:	ea000001 	b	21f00538 <show_regs+0x130>
21f00530:	e3a0306e 	mov	r3, #110	; 0x6e
21f00534:	e50b30ac 	str	r3, [fp, #-172]
21f00538:	e51b3010 	ldr	r3, [fp, #-16]
21f0053c:	e1a03f23 	mov	r3, r3, lsr #30
21f00540:	e2033001 	and	r3, r3, #1	; 0x1
21f00544:	e20330ff 	and	r3, r3, #255	; 0xff
21f00548:	e3530000 	cmp	r3, #0	; 0x0
21f0054c:	0a000002 	beq	21f0055c <show_regs+0x154>
21f00550:	e3a0105a 	mov	r1, #90	; 0x5a
21f00554:	e50b10a8 	str	r1, [fp, #-168]
21f00558:	ea000001 	b	21f00564 <show_regs+0x15c>
21f0055c:	e3a0307a 	mov	r3, #122	; 0x7a
21f00560:	e50b30a8 	str	r3, [fp, #-168]
21f00564:	e51b3010 	ldr	r3, [fp, #-16]
21f00568:	e1a03ea3 	mov	r3, r3, lsr #29
21f0056c:	e2033001 	and	r3, r3, #1	; 0x1
21f00570:	e20330ff 	and	r3, r3, #255	; 0xff
21f00574:	e3530000 	cmp	r3, #0	; 0x0
21f00578:	0a000002 	beq	21f00588 <show_regs+0x180>
21f0057c:	e3a01043 	mov	r1, #67	; 0x43
21f00580:	e50b10a4 	str	r1, [fp, #-164]
21f00584:	ea000001 	b	21f00590 <show_regs+0x188>
21f00588:	e3a03063 	mov	r3, #99	; 0x63
21f0058c:	e50b30a4 	str	r3, [fp, #-164]
21f00590:	e51b3010 	ldr	r3, [fp, #-16]
21f00594:	e1a03e23 	mov	r3, r3, lsr #28
21f00598:	e2033001 	and	r3, r3, #1	; 0x1
21f0059c:	e20330ff 	and	r3, r3, #255	; 0xff
21f005a0:	e3530000 	cmp	r3, #0	; 0x0
21f005a4:	0a000002 	beq	21f005b4 <show_regs+0x1ac>
21f005a8:	e3a01056 	mov	r1, #86	; 0x56
21f005ac:	e50b10a0 	str	r1, [fp, #-160]
21f005b0:	ea000001 	b	21f005bc <show_regs+0x1b4>
21f005b4:	e3a03076 	mov	r3, #118	; 0x76
21f005b8:	e50b30a0 	str	r3, [fp, #-160]
21f005bc:	e51b10a0 	ldr	r1, [fp, #-160]
21f005c0:	e58d1000 	str	r1, [sp]
21f005c4:	e59f00c0 	ldr	r0, [pc, #192]	; 21f0068c <.text+0x68c>
21f005c8:	e51b10ac 	ldr	r1, [fp, #-172]
21f005cc:	e51b20a8 	ldr	r2, [fp, #-168]
21f005d0:	e51b30a4 	ldr	r3, [fp, #-164]
21f005d4:	eb006d2c 	bl	21f1ba8c <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
21f005d8:	e51b3094 	ldr	r3, [fp, #-148]
21f005dc:	e5933040 	ldr	r3, [r3, #64]
21f005e0:	e1a033a3 	mov	r3, r3, lsr #7
21f005e4:	e2033001 	and	r3, r3, #1	; 0x1
21f005e8:	e3530000 	cmp	r3, #0	; 0x0
21f005ec:	1a000002 	bne	21f005fc <show_regs+0x1f4>
21f005f0:	e59f3098 	ldr	r3, [pc, #152]	; 21f00690 <.text+0x690>
21f005f4:	e50b309c 	str	r3, [fp, #-156]
21f005f8:	ea000001 	b	21f00604 <show_regs+0x1fc>
21f005fc:	e59f1090 	ldr	r1, [pc, #144]	; 21f00694 <.text+0x694>
21f00600:	e50b109c 	str	r1, [fp, #-156]
21f00604:	e51b3094 	ldr	r3, [fp, #-148]
21f00608:	e5933040 	ldr	r3, [r3, #64]
21f0060c:	e1a03323 	mov	r3, r3, lsr #6
21f00610:	e2033001 	and	r3, r3, #1	; 0x1
21f00614:	e3530000 	cmp	r3, #0	; 0x0
21f00618:	1a000002 	bne	21f00628 <show_regs+0x220>
21f0061c:	e59f306c 	ldr	r3, [pc, #108]	; 21f00690 <.text+0x690>
21f00620:	e50b3098 	str	r3, [fp, #-152]
21f00624:	ea000001 	b	21f00630 <show_regs+0x228>
21f00628:	e59f1064 	ldr	r1, [pc, #100]	; 21f00694 <.text+0x694>
21f0062c:	e50b1098 	str	r1, [fp, #-152]
21f00630:	e51b3094 	ldr	r3, [fp, #-148]
21f00634:	e5933040 	ldr	r3, [r3, #64]
21f00638:	e203301f 	and	r3, r3, #31	; 0x1f
21f0063c:	e3e02083 	mvn	r2, #131	; 0x83
21f00640:	e1a03103 	mov	r3, r3, lsl #2
21f00644:	e24b100c 	sub	r1, fp, #12	; 0xc
21f00648:	e0833001 	add	r3, r3, r1
21f0064c:	e0833002 	add	r3, r3, r2
21f00650:	e593c000 	ldr	ip, [r3]
21f00654:	e59f303c 	ldr	r3, [pc, #60]	; 21f00698 <.text+0x698>
21f00658:	e58d3000 	str	r3, [sp]
21f0065c:	e59f0038 	ldr	r0, [pc, #56]	; 21f0069c <.text+0x69c>
21f00660:	e51b109c 	ldr	r1, [fp, #-156]
21f00664:	e51b2098 	ldr	r2, [fp, #-152]
21f00668:	e1a0300c 	mov	r3, ip
21f0066c:	eb006d06 	bl	21f1ba8c <printf>
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
		thumb_mode (regs) ? " (T)" : "");
}
21f00670:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f00674:	e89da800 	ldmia	sp, {fp, sp, pc}
21f00678:	21f2eee4 	mvncss	lr, r4, ror #29
21f0067c:	21f2ef64 	mvncss	lr, r4, ror #30
21f00680:	21f2efac 	mvncss	lr, ip, lsr #31
21f00684:	21f2efd0 	ldrcssb	lr, [r2, #240]!
21f00688:	21f2f000 	mvncss	pc, r0
21f0068c:	21f2f030 	mvncss	pc, r0, lsr r0
21f00690:	21f2f040 	mvncss	pc, r0, asr #32
21f00694:	21f2f044 	mvncss	pc, r4, asr #32
21f00698:	21f2f068 	mvncss	pc, r8, rrx
21f0069c:	21f2f048 	mvncss	pc, r8, asr #32

21f006a0 <do_undefined_instruction>:

void do_undefined_instruction (struct pt_regs *pt_regs)
{
21f006a0:	e1a0c00d 	mov	ip, sp
21f006a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f006a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f006ac:	e24dd004 	sub	sp, sp, #4	; 0x4
21f006b0:	e50b0010 	str	r0, [fp, #-16]
	printf ("undefined instruction\n");
21f006b4:	e59f0010 	ldr	r0, [pc, #16]	; 21f006cc <.text+0x6cc>
21f006b8:	eb006cf3 	bl	21f1ba8c <printf>
	show_regs (pt_regs);
21f006bc:	e51b0010 	ldr	r0, [fp, #-16]
21f006c0:	ebffff50 	bl	21f00408 <show_regs>
	bad_mode ();
21f006c4:	ebffff46 	bl	21f003e4 <bad_mode>
}
21f006c8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f006cc:	21f2f06c 	mvncss	pc, ip, rrx

21f006d0 <do_software_interrupt>:

void do_software_interrupt (struct pt_regs *pt_regs)
{
21f006d0:	e1a0c00d 	mov	ip, sp
21f006d4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f006d8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f006dc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f006e0:	e50b0010 	str	r0, [fp, #-16]
	printf ("software interrupt\n");
21f006e4:	e59f0010 	ldr	r0, [pc, #16]	; 21f006fc <.text+0x6fc>
21f006e8:	eb006ce7 	bl	21f1ba8c <printf>
	show_regs (pt_regs);
21f006ec:	e51b0010 	ldr	r0, [fp, #-16]
21f006f0:	ebffff44 	bl	21f00408 <show_regs>
	bad_mode ();
21f006f4:	ebffff3a 	bl	21f003e4 <bad_mode>
}
21f006f8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f006fc:	21f2f084 	mvncss	pc, r4, lsl #1

21f00700 <do_prefetch_abort>:

void do_prefetch_abort (struct pt_regs *pt_regs)
{
21f00700:	e1a0c00d 	mov	ip, sp
21f00704:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00708:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0070c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00710:	e50b0010 	str	r0, [fp, #-16]
	printf ("prefetch abort\n");
21f00714:	e59f0010 	ldr	r0, [pc, #16]	; 21f0072c <.text+0x72c>
21f00718:	eb006cdb 	bl	21f1ba8c <printf>
	show_regs (pt_regs);
21f0071c:	e51b0010 	ldr	r0, [fp, #-16]
21f00720:	ebffff38 	bl	21f00408 <show_regs>
	bad_mode ();
21f00724:	ebffff2e 	bl	21f003e4 <bad_mode>
}
21f00728:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f0072c:	21f2f098 	ldrcsb	pc, [r2, #8]!

21f00730 <do_data_abort>:

void do_data_abort (struct pt_regs *pt_regs)
{
21f00730:	e1a0c00d 	mov	ip, sp
21f00734:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00738:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0073c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00740:	e50b0010 	str	r0, [fp, #-16]
	printf ("data abort\n");
21f00744:	e59f0010 	ldr	r0, [pc, #16]	; 21f0075c <.text+0x75c>
21f00748:	eb006ccf 	bl	21f1ba8c <printf>
	show_regs (pt_regs);
21f0074c:	e51b0010 	ldr	r0, [fp, #-16]
21f00750:	ebffff2c 	bl	21f00408 <show_regs>
	bad_mode ();
21f00754:	ebffff22 	bl	21f003e4 <bad_mode>
}
21f00758:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f0075c:	21f2f0a8 	mvncss	pc, r8, lsr #1

21f00760 <do_not_used>:

void do_not_used (struct pt_regs *pt_regs)
{
21f00760:	e1a0c00d 	mov	ip, sp
21f00764:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00768:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0076c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00770:	e50b0010 	str	r0, [fp, #-16]
	printf ("not used\n");
21f00774:	e59f0010 	ldr	r0, [pc, #16]	; 21f0078c <.text+0x78c>
21f00778:	eb006cc3 	bl	21f1ba8c <printf>
	show_regs (pt_regs);
21f0077c:	e51b0010 	ldr	r0, [fp, #-16]
21f00780:	ebffff20 	bl	21f00408 <show_regs>
	bad_mode ();
21f00784:	ebffff16 	bl	21f003e4 <bad_mode>
}
21f00788:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f0078c:	21f2f0b4 	ldrcsh	pc, [r2, #4]!

21f00790 <do_fiq>:

void do_fiq (struct pt_regs *pt_regs)
{
21f00790:	e1a0c00d 	mov	ip, sp
21f00794:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00798:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0079c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f007a0:	e50b0010 	str	r0, [fp, #-16]
	printf ("fast interrupt request\n");
21f007a4:	e59f0010 	ldr	r0, [pc, #16]	; 21f007bc <.text+0x7bc>
21f007a8:	eb006cb7 	bl	21f1ba8c <printf>
	show_regs (pt_regs);
21f007ac:	e51b0010 	ldr	r0, [fp, #-16]
21f007b0:	ebffff14 	bl	21f00408 <show_regs>
	bad_mode ();
21f007b4:	ebffff0a 	bl	21f003e4 <bad_mode>
}
21f007b8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f007bc:	21f2f0c0 	mvncss	pc, r0, asr #1

21f007c0 <do_irq>:
#if defined ( CONFIG_AT91RM9200 )  && defined (CONFIG_MMC)
extern void AT91F_MCI_Handler(void);
void do_irq (struct pt_regs *pt_regs)
{
21f007c0:	e1a0c00d 	mov	ip, sp
21f007c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f007c8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f007cc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f007d0:	e50b0010 	str	r0, [fp, #-16]
	AT91F_MCI_Handler();
21f007d4:	eb001474 	bl	21f059ac <AT91F_MCI_Handler>
}
21f007d8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f007dc <_MTEXT_BASE>:
21f007dc:	21f00000 	mvncss	r0, r0

21f007e0 <lowlevel_init>:

.globl lowlevel_init
lowlevel_init:
	/* Get the CKGR Base Address */
	ldr     r1, =AT91C_BASE_CKGR
21f007e0:	e59f1074 	ldr	r1, [pc, #116]	; 21f0085c <.text+0x85c>
	/* Main oscillator Enable register */
#ifdef CFG_USE_MAIN_OSCILLATOR
	ldr     r0, =0x0000FF01		/* Enable main oscillator,  OSCOUNT = 0xFF */
21f007e4:	e59f0074 	ldr	r0, [pc, #116]	; 21f00860 <.text+0x860>
#else
	ldr     r0, =0x0000FF00		/* Disable main oscillator, OSCOUNT = 0xFF */
#endif
	str     r0, [r1, #CKGR_MOR]
21f007e8:	e5810000 	str	r0, [r1]
	/* Add loop to compensate Main Oscillator startup time */
	ldr     r0, =0x00000010
21f007ec:	e3a00010 	mov	r0, #16	; 0x10

21f007f0 <LoopOsc>:
LoopOsc:
	subs    r0, r0, #1
21f007f0:	e2500001 	subs	r0, r0, #1	; 0x1
	bhi     LoopOsc
21f007f4:	8afffffd 	bhi	21f007f0 <LoopOsc>

	/* memory control configuration */
	/* this isn't very elegant, but	 what the heck */
	ldr	r0, =SMRDATA
21f007f8:	e59f0064 	ldr	r0, [pc, #100]	; 21f00864 <.text+0x864>
	ldr	r1, _MTEXT_BASE
21f007fc:	e51f1028 	ldr	r1, [pc, #-40]	; 21f007dc <_MTEXT_BASE>
	sub	r0, r0, r1
21f00800:	e0400001 	sub	r0, r0, r1
	add	r2, r0, #80
21f00804:	e2802050 	add	r2, r0, #80	; 0x50
0:
	/* the address */
	ldr	r1, [r0], #4
21f00808:	e4901004 	ldr	r1, [r0], #4
	/* the value */
	ldr	r3, [r0], #4
21f0080c:	e4903004 	ldr	r3, [r0], #4
	str	r3, [r1]
21f00810:	e5813000 	str	r3, [r1]
	cmp	r2, r0
21f00814:	e1520000 	cmp	r2, r0
	bne	0b
21f00818:	1afffffa 	bne	21f00808 <LoopOsc+0x18>
	/* delay - this is all done by guess */
	ldr	r0, =0x00010000
21f0081c:	e3a00801 	mov	r0, #65536	; 0x10000
1:
	subs	r0, r0, #1
21f00820:	e2500001 	subs	r0, r0, #1	; 0x1
	bhi	1b
21f00824:	8afffffd 	bhi	21f00820 <LoopOsc+0x30>
	ldr	r0, =SMRDATA1
21f00828:	e59f0038 	ldr	r0, [pc, #56]	; 21f00868 <.text+0x868>
	ldr	r1, _MTEXT_BASE
21f0082c:	e51f1058 	ldr	r1, [pc, #-88]	; 21f007dc <_MTEXT_BASE>
	sub	r0, r0, r1
21f00830:	e0400001 	sub	r0, r0, r1
	add	r2, r0, #176
21f00834:	e28020b0 	add	r2, r0, #176	; 0xb0
2:
	/* the address */
	ldr	r1, [r0], #4
21f00838:	e4901004 	ldr	r1, [r0], #4
	/* the value */
	ldr	r3, [r0], #4
21f0083c:	e4903004 	ldr	r3, [r0], #4
	str	r3, [r1]
21f00840:	e5813000 	str	r3, [r1]
	cmp	r2, r0
21f00844:	e1520000 	cmp	r2, r0
	bne	2b
21f00848:	1afffffa 	bne	21f00838 <LoopOsc+0x48>

	/* switch from FastBus to Asynchronous clock mode */
	mrc	p15, 0, r0, c1, c0, 0
21f0084c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	orr	r0, r0, #0xC0000000	@ set bit 31 (iA) and 30 (nF)
21f00850:	e3800103 	orr	r0, r0, #-1073741824	; 0xc0000000
	mcr	p15, 0, r0, c1, c0, 0
21f00854:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/* everything is fine now */
	mov	pc, lr
21f00858:	e1a0f00e 	mov	pc, lr
21f0085c:	fffffc20 	swinv	0x00fffc20
21f00860:	0000ff01 	andeq	pc, r0, r1, lsl #30
21f00864:	21f0086c 	mvncss	r0, ip, ror #16
21f00868:	21f008bc 	ldrcsh	r0, [r0, #140]!

21f0086c <SMRDATA>:
21f0086c:	ffffff10 	swinv	0x00ffff10
21f00870:	00000000 	andeq	r0, r0, r0
21f00874:	ffffff50 	swinv	0x00ffff50
21f00878:	00000000 	andeq	r0, r0, r0
21f0087c:	ffffff54 	swinv	0x00ffff54
21f00880:	00000000 	andeq	r0, r0, r0
21f00884:	ffffff04 	swinv	0x00ffff04
21f00888:	00000000 	andeq	r0, r0, r0
21f0088c:	ffffff08 	swinv	0x00ffff08
21f00890:	00000000 	andeq	r0, r0, r0
21f00894:	ffffff64 	swinv	0x00ffff64
21f00898:	00000000 	andeq	r0, r0, r0
21f0089c:	ffffff70 	swinv	0x00ffff70
21f008a0:	00003284 	andeq	r3, r0, r4, lsl #5
21f008a4:	fffffc28 	swinv	0x00fffc28
21f008a8:	20263e04 	eorcs	r3, r6, r4, lsl #28
21f008ac:	fffffc2c 	swinv	0x00fffc2c
21f008b0:	10483e0e 	subne	r3, r8, lr, lsl #28
21f008b4:	fffffc30 	swinv	0x00fffc30
21f008b8:	00000202 	andeq	r0, r0, r2, lsl #4

21f008bc <SMRDATA1>:
21f008bc:	fffff870 	swinv	0x00fff870
21f008c0:	ffff0000 	swinv	0x00ff0000
21f008c4:	fffff874 	swinv	0x00fff874
21f008c8:	00000000 	andeq	r0, r0, r0
21f008cc:	fffff804 	swinv	0x00fff804
21f008d0:	ffff0000 	swinv	0x00ff0000
21f008d4:	ffffff60 	swinv	0x00ffff60
21f008d8:	00000002 	andeq	r0, r0, r2
21f008dc:	ffffff98 	swinv	0x00ffff98
21f008e0:	2188c155 	orrcs	ip, r8, r5, asr r1
21f008e4:	ffffff90 	swinv	0x00ffff90
21f008e8:	00000002 	andeq	r0, r0, r2
21f008ec:	20000000 	andcs	r0, r0, r0
21f008f0:	00000000 	andeq	r0, r0, r0
21f008f4:	ffffff90 	swinv	0x00ffff90
21f008f8:	00000004 	andeq	r0, r0, r4
21f008fc:	20000000 	andcs	r0, r0, r0
21f00900:	00000000 	andeq	r0, r0, r0
21f00904:	20000000 	andcs	r0, r0, r0
21f00908:	00000000 	andeq	r0, r0, r0
21f0090c:	20000000 	andcs	r0, r0, r0
21f00910:	00000000 	andeq	r0, r0, r0
21f00914:	20000000 	andcs	r0, r0, r0
21f00918:	00000000 	andeq	r0, r0, r0
21f0091c:	20000000 	andcs	r0, r0, r0
21f00920:	00000000 	andeq	r0, r0, r0
21f00924:	20000000 	andcs	r0, r0, r0
21f00928:	00000000 	andeq	r0, r0, r0
21f0092c:	20000000 	andcs	r0, r0, r0
21f00930:	00000000 	andeq	r0, r0, r0
21f00934:	20000000 	andcs	r0, r0, r0
21f00938:	00000000 	andeq	r0, r0, r0
21f0093c:	ffffff90 	swinv	0x00ffff90
21f00940:	00000003 	andeq	r0, r0, r3
21f00944:	20000080 	andcs	r0, r0, r0, lsl #1
21f00948:	00000000 	andeq	r0, r0, r0
21f0094c:	ffffff94 	swinv	0x00ffff94
21f00950:	000002e0 	andeq	r0, r0, r0, ror #5
21f00954:	20000000 	andcs	r0, r0, r0
21f00958:	00000000 	andeq	r0, r0, r0
21f0095c:	ffffff90 	swinv	0x00ffff90
21f00960:	00000000 	andeq	r0, r0, r0
21f00964:	20000000 	andcs	r0, r0, r0
21f00968:	00000000 	andeq	r0, r0, r0

21f0096c <interrupt_init>:
static ulong timestamp;
static ulong lastinc;

int interrupt_init (void)
{
21f0096c:	e1a0c00d 	mov	ip, sp
21f00970:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00974:	e24cb004 	sub	fp, ip, #4	; 0x4
	tmr = AT91C_BASE_TC0;
21f00978:	e59f20b4 	ldr	r2, [pc, #180]	; 21f00a34 <.text+0xa34>
21f0097c:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
21f00980:	e1a03643 	mov	r3, r3, asr #12
21f00984:	e5823000 	str	r3, [r2]

	/* enables TC1.0 clock */
	*AT91C_PMC_PCER = 1 << AT91C_ID_TC0;  /* enable clock */
21f00988:	e3a03482 	mov	r3, #-2113929216	; 0x82000000
21f0098c:	e1a03ac3 	mov	r3, r3, asr #21
21f00990:	e3a02802 	mov	r2, #131072	; 0x20000
21f00994:	e5832000 	str	r2, [r3]

	*AT91C_TCB0_BCR = 0;
21f00998:	e3a034ff 	mov	r3, #-16777216	; 0xff000000
21f0099c:	e28338fa 	add	r3, r3, #16384000	; 0xfa0000
21f009a0:	e28330c0 	add	r3, r3, #192	; 0xc0
21f009a4:	e3a02000 	mov	r2, #0	; 0x0
21f009a8:	e5832000 	str	r2, [r3]
	*AT91C_TCB0_BMR = AT91C_TCB_TC0XC0S_NONE | AT91C_TCB_TC1XC1S_NONE | AT91C_TCB_TC2XC2S_NONE;
21f009ac:	e3e03a5f 	mvn	r3, #389120	; 0x5f000
21f009b0:	e2433ef3 	sub	r3, r3, #3888	; 0xf30
21f009b4:	e243300b 	sub	r3, r3, #11	; 0xb
21f009b8:	e3a02015 	mov	r2, #21	; 0x15
21f009bc:	e5832000 	str	r2, [r3]
	tmr->TC_CCR = AT91C_TC_CLKDIS;
21f009c0:	e59f306c 	ldr	r3, [pc, #108]	; 21f00a34 <.text+0xa34>
21f009c4:	e5932000 	ldr	r2, [r3]
21f009c8:	e3a03002 	mov	r3, #2	; 0x2
21f009cc:	e5823000 	str	r3, [r2]
#define AT91C_TC_CMR_CPCTRG (1 << 14)
	/* set to MCLK/2 and restart the timer when the vlaue in TC_RC is reached */
	tmr->TC_CMR = AT91C_TC_TIMER_DIV1_CLOCK | AT91C_TC_CMR_CPCTRG;
21f009d0:	e59f305c 	ldr	r3, [pc, #92]	; 21f00a34 <.text+0xa34>
21f009d4:	e5932000 	ldr	r2, [r3]
21f009d8:	e3a03901 	mov	r3, #16384	; 0x4000
21f009dc:	e5823004 	str	r3, [r2, #4]

	tmr->TC_IDR = ~0ul;
21f009e0:	e59f304c 	ldr	r3, [pc, #76]	; 21f00a34 <.text+0xa34>
21f009e4:	e5932000 	ldr	r2, [r3]
21f009e8:	e3e03000 	mvn	r3, #0	; 0x0
21f009ec:	e5823028 	str	r3, [r2, #40]
	tmr->TC_RC = TIMER_LOAD_VAL;
21f009f0:	e59f303c 	ldr	r3, [pc, #60]	; 21f00a34 <.text+0xa34>
21f009f4:	e5932000 	ldr	r2, [r3]
21f009f8:	e3a03c75 	mov	r3, #29952	; 0x7500
21f009fc:	e582301c 	str	r3, [r2, #28]
	lastinc = 0;
21f00a00:	e59f2030 	ldr	r2, [pc, #48]	; 21f00a38 <.text+0xa38>
21f00a04:	e3a03000 	mov	r3, #0	; 0x0
21f00a08:	e5823000 	str	r3, [r2]
	tmr->TC_CCR = AT91C_TC_SWTRG | AT91C_TC_CLKEN;
21f00a0c:	e59f3020 	ldr	r3, [pc, #32]	; 21f00a34 <.text+0xa34>
21f00a10:	e5932000 	ldr	r2, [r3]
21f00a14:	e3a03005 	mov	r3, #5	; 0x5
21f00a18:	e5823000 	str	r3, [r2]
	timestamp = 0;
21f00a1c:	e59f2018 	ldr	r2, [pc, #24]	; 21f00a3c <.text+0xa3c>
21f00a20:	e3a03000 	mov	r3, #0	; 0x0
21f00a24:	e5823000 	str	r3, [r2]

	return (0);
21f00a28:	e3a03000 	mov	r3, #0	; 0x0
}
21f00a2c:	e1a00003 	mov	r0, r3
21f00a30:	e89da800 	ldmia	sp, {fp, sp, pc}
21f00a34:	21f34200 	mvncss	r4, r0, lsl #4
21f00a38:	21f34208 	mvncss	r4, r8, lsl #4
21f00a3c:	21f34204 	mvncss	r4, r4, lsl #4

21f00a40 <reset_timer>:

/*
 * timer without interrupts
 */

void reset_timer (void)
{
21f00a40:	e1a0c00d 	mov	ip, sp
21f00a44:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00a48:	e24cb004 	sub	fp, ip, #4	; 0x4
	reset_timer_masked ();
21f00a4c:	eb00001d 	bl	21f00ac8 <reset_timer_masked>
}
21f00a50:	e89da800 	ldmia	sp, {fp, sp, pc}

21f00a54 <get_timer>:

ulong get_timer (ulong base)
{
21f00a54:	e1a0c00d 	mov	ip, sp
21f00a58:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00a5c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00a60:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00a64:	e50b0010 	str	r0, [fp, #-16]
	return get_timer_masked () - base;
21f00a68:	eb000054 	bl	21f00bc0 <get_timer_masked>
21f00a6c:	e1a02000 	mov	r2, r0
21f00a70:	e51b3010 	ldr	r3, [fp, #-16]
21f00a74:	e0633002 	rsb	r3, r3, r2
}
21f00a78:	e1a00003 	mov	r0, r3
21f00a7c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00a80 <set_timer>:

void set_timer (ulong t)
{
21f00a80:	e1a0c00d 	mov	ip, sp
21f00a84:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00a88:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00a8c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00a90:	e50b0010 	str	r0, [fp, #-16]
	timestamp = t;
21f00a94:	e59f2008 	ldr	r2, [pc, #8]	; 21f00aa4 <.text+0xaa4>
21f00a98:	e51b3010 	ldr	r3, [fp, #-16]
21f00a9c:	e5823000 	str	r3, [r2]
}
21f00aa0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f00aa4:	21f34204 	mvncss	r4, r4, lsl #4

21f00aa8 <udelay>:

void udelay (unsigned long usec)
{
21f00aa8:	e1a0c00d 	mov	ip, sp
21f00aac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00ab0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00ab4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00ab8:	e50b0010 	str	r0, [fp, #-16]
	udelay_masked(usec);
21f00abc:	e51b0010 	ldr	r0, [fp, #-16]
21f00ac0:	eb00004a 	bl	21f00bf0 <udelay_masked>
}
21f00ac4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00ac8 <reset_timer_masked>:

void reset_timer_masked (void)
{
21f00ac8:	e1a0c00d 	mov	ip, sp
21f00acc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00ad0:	e24cb004 	sub	fp, ip, #4	; 0x4
	/* reset time */
	lastinc = READ_TIMER;
21f00ad4:	e59f3024 	ldr	r3, [pc, #36]	; 21f00b00 <.text+0xb00>
21f00ad8:	e5933000 	ldr	r3, [r3]
21f00adc:	e5933010 	ldr	r3, [r3, #16]
21f00ae0:	e1a03803 	mov	r3, r3, lsl #16
21f00ae4:	e1a03823 	mov	r3, r3, lsr #16
21f00ae8:	e59f2014 	ldr	r2, [pc, #20]	; 21f00b04 <.text+0xb04>
21f00aec:	e5823000 	str	r3, [r2]
	timestamp = 0;
21f00af0:	e59f2010 	ldr	r2, [pc, #16]	; 21f00b08 <.text+0xb08>
21f00af4:	e3a03000 	mov	r3, #0	; 0x0
21f00af8:	e5823000 	str	r3, [r2]
}
21f00afc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f00b00:	21f34200 	mvncss	r4, r0, lsl #4
21f00b04:	21f34208 	mvncss	r4, r8, lsl #4
21f00b08:	21f34204 	mvncss	r4, r4, lsl #4

21f00b0c <get_timer_raw>:

ulong get_timer_raw (void)
{
21f00b0c:	e1a0c00d 	mov	ip, sp
21f00b10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00b14:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00b18:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong now = READ_TIMER;
21f00b1c:	e59f3090 	ldr	r3, [pc, #144]	; 21f00bb4 <.text+0xbb4>
21f00b20:	e5933000 	ldr	r3, [r3]
21f00b24:	e5933010 	ldr	r3, [r3, #16]
21f00b28:	e1a03803 	mov	r3, r3, lsl #16
21f00b2c:	e1a03823 	mov	r3, r3, lsr #16
21f00b30:	e50b3010 	str	r3, [fp, #-16]

	if (now >= lastinc) {
21f00b34:	e59f307c 	ldr	r3, [pc, #124]	; 21f00bb8 <.text+0xbb8>
21f00b38:	e5932000 	ldr	r2, [r3]
21f00b3c:	e51b3010 	ldr	r3, [fp, #-16]
21f00b40:	e1530002 	cmp	r3, r2
21f00b44:	3a000009 	bcc	21f00b70 <get_timer_raw+0x64>
		/* normal mode */
		timestamp += now - lastinc;
21f00b48:	e59f3068 	ldr	r3, [pc, #104]	; 21f00bb8 <.text+0xbb8>
21f00b4c:	e5932000 	ldr	r2, [r3]
21f00b50:	e51b3010 	ldr	r3, [fp, #-16]
21f00b54:	e0622003 	rsb	r2, r2, r3
21f00b58:	e59f305c 	ldr	r3, [pc, #92]	; 21f00bbc <.text+0xbbc>
21f00b5c:	e5933000 	ldr	r3, [r3]
21f00b60:	e0822003 	add	r2, r2, r3
21f00b64:	e59f3050 	ldr	r3, [pc, #80]	; 21f00bbc <.text+0xbbc>
21f00b68:	e5832000 	str	r2, [r3]
21f00b6c:	ea000009 	b	21f00b98 <get_timer_raw+0x8c>
	} else {
		/* we have an overflow ... */
		timestamp += now + TIMER_LOAD_VAL - lastinc;
21f00b70:	e59f3040 	ldr	r3, [pc, #64]	; 21f00bb8 <.text+0xbb8>
21f00b74:	e5932000 	ldr	r2, [r3]
21f00b78:	e51b3010 	ldr	r3, [fp, #-16]
21f00b7c:	e0622003 	rsb	r2, r2, r3
21f00b80:	e59f3034 	ldr	r3, [pc, #52]	; 21f00bbc <.text+0xbbc>
21f00b84:	e5933000 	ldr	r3, [r3]
21f00b88:	e0823003 	add	r3, r2, r3
21f00b8c:	e2832c75 	add	r2, r3, #29952	; 0x7500
21f00b90:	e59f3024 	ldr	r3, [pc, #36]	; 21f00bbc <.text+0xbbc>
21f00b94:	e5832000 	str	r2, [r3]
	}
	lastinc = now;
21f00b98:	e59f2018 	ldr	r2, [pc, #24]	; 21f00bb8 <.text+0xbb8>
21f00b9c:	e51b3010 	ldr	r3, [fp, #-16]
21f00ba0:	e5823000 	str	r3, [r2]

	return timestamp;
21f00ba4:	e59f3010 	ldr	r3, [pc, #16]	; 21f00bbc <.text+0xbbc>
21f00ba8:	e5933000 	ldr	r3, [r3]
}
21f00bac:	e1a00003 	mov	r0, r3
21f00bb0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f00bb4:	21f34200 	mvncss	r4, r0, lsl #4
21f00bb8:	21f34208 	mvncss	r4, r8, lsl #4
21f00bbc:	21f34204 	mvncss	r4, r4, lsl #4

21f00bc0 <get_timer_masked>:

ulong get_timer_masked (void)
{
21f00bc0:	e1a0c00d 	mov	ip, sp
21f00bc4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00bc8:	e24cb004 	sub	fp, ip, #4	; 0x4
	return get_timer_raw()/TIMER_LOAD_VAL;
21f00bcc:	ebffffce 	bl	21f00b0c <get_timer_raw>
21f00bd0:	e1a03000 	mov	r3, r0
21f00bd4:	e1a02423 	mov	r2, r3, lsr #8
21f00bd8:	e3a03623 	mov	r3, #36700160	; 0x2300000
21f00bdc:	e2833c23 	add	r3, r3, #8960	; 0x2300
21f00be0:	e2833004 	add	r3, r3, #4	; 0x4
21f00be4:	e0831392 	umull	r1, r3, r2, r3
}
21f00be8:	e1a00003 	mov	r0, r3
21f00bec:	e89da800 	ldmia	sp, {fp, sp, pc}

21f00bf0 <udelay_masked>:

void udelay_masked (unsigned long usec)
{
21f00bf0:	e1a0c00d 	mov	ip, sp
21f00bf4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00bf8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00bfc:	e24dd014 	sub	sp, sp, #20	; 0x14
21f00c00:	e50b0020 	str	r0, [fp, #-32]
	ulong tmo;
	ulong endtime;
	signed long diff;

	tmo = CFG_HZ_CLOCK / 1000;
21f00c04:	e3a03c75 	mov	r3, #29952	; 0x7500
21f00c08:	e50b301c 	str	r3, [fp, #-28]
	tmo *= usec;
21f00c0c:	e51b201c 	ldr	r2, [fp, #-28]
21f00c10:	e51b3020 	ldr	r3, [fp, #-32]
21f00c14:	e0030392 	mul	r3, r2, r3
21f00c18:	e50b301c 	str	r3, [fp, #-28]
	tmo /= 1000;
21f00c1c:	e51b201c 	ldr	r2, [fp, #-28]
21f00c20:	e59f304c 	ldr	r3, [pc, #76]	; 21f00c74 <.text+0xc74>
21f00c24:	e0831392 	umull	r1, r3, r2, r3
21f00c28:	e1a03323 	mov	r3, r3, lsr #6
21f00c2c:	e50b301c 	str	r3, [fp, #-28]

	endtime = get_timer_raw () + tmo;
21f00c30:	ebffffb5 	bl	21f00b0c <get_timer_raw>
21f00c34:	e1a02000 	mov	r2, r0
21f00c38:	e51b301c 	ldr	r3, [fp, #-28]
21f00c3c:	e0823003 	add	r3, r2, r3
21f00c40:	e50b3018 	str	r3, [fp, #-24]

	do {
		ulong now = get_timer_raw ();
21f00c44:	ebffffb0 	bl	21f00b0c <get_timer_raw>
21f00c48:	e1a03000 	mov	r3, r0
21f00c4c:	e50b3010 	str	r3, [fp, #-16]
		diff = endtime - now;
21f00c50:	e51b2018 	ldr	r2, [fp, #-24]
21f00c54:	e51b3010 	ldr	r3, [fp, #-16]
21f00c58:	e0633002 	rsb	r3, r3, r2
21f00c5c:	e50b3014 	str	r3, [fp, #-20]
	} while (diff >= 0);
21f00c60:	e51b3014 	ldr	r3, [fp, #-20]
21f00c64:	e3530000 	cmp	r3, #0	; 0x0
21f00c68:	aafffff5 	bge	21f00c44 <udelay_masked+0x54>
}
21f00c6c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f00c70:	e89da800 	ldmia	sp, {fp, sp, pc}
21f00c74:	10624dd3 	ldrned	r4, [r2], #-211

21f00c78 <get_ticks>:

/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
21f00c78:	e1a0c00d 	mov	ip, sp
21f00c7c:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f00c80:	e24cb004 	sub	fp, ip, #4	; 0x4
	return get_timer(0);
21f00c84:	e3a00000 	mov	r0, #0	; 0x0
21f00c88:	ebffff71 	bl	21f00a54 <get_timer>
21f00c8c:	e1a03000 	mov	r3, r0
21f00c90:	e3a04000 	mov	r4, #0	; 0x0
}
21f00c94:	e1a01004 	mov	r1, r4
21f00c98:	e1a00003 	mov	r0, r3
21f00c9c:	e89da810 	ldmia	sp, {r4, fp, sp, pc}

21f00ca0 <get_tbclk>:

/*
 * This function is derived from PowerPC code (timebase clock frequency).
 * On ARM it returns the number of timer ticks per second.
 */
ulong get_tbclk (void)
{
21f00ca0:	e1a0c00d 	mov	ip, sp
21f00ca4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00ca8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00cac:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong tbclk;

	tbclk = CFG_HZ;
21f00cb0:	e3a03ffa 	mov	r3, #1000	; 0x3e8
21f00cb4:	e50b3010 	str	r3, [fp, #-16]
	return tbclk;
21f00cb8:	e51b3010 	ldr	r3, [fp, #-16]
}
21f00cbc:	e1a00003 	mov	r0, r3
21f00cc0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00cc4 <reset_cpu>:

/*
 * Reset the cpu by setting up the watchdog timer and let him time out
 * or toggle a GPIO pin on the AT91RM9200DK board
 */
void reset_cpu (ulong ignored)
{
21f00cc4:	e1a0c00d 	mov	ip, sp
21f00cc8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00ccc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00cd0:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f00cd4:	e50b0018 	str	r0, [fp, #-24]

#ifdef CONFIG_DBGU
	AT91PS_USART us = (AT91PS_USART) AT91C_BASE_DBGU;
21f00cd8:	e3a03209 	mov	r3, #-1879048192	; 0x90000000
21f00cdc:	e1a039c3 	mov	r3, r3, asr #19
21f00ce0:	e50b3014 	str	r3, [fp, #-20]
#endif
#ifdef CONFIG_USART0
	AT91PS_USART us = AT91C_BASE_US0;
#endif
#ifdef CONFIG_USART1
	AT91PS_USART us = AT91C_BASE_US1;
#endif
#ifdef CONFIG_AT91RM9200DK
	AT91PS_PIO pio = AT91C_BASE_PIOA;
21f00ce4:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
21f00ce8:	e1a039c3 	mov	r3, r3, asr #19
21f00cec:	e50b3010 	str	r3, [fp, #-16]
#endif

	/*shutdown the console to avoid strange chars during reset */
	us->US_CR = (AT91C_US_RSTRX | AT91C_US_RSTTX);
21f00cf0:	e51b2014 	ldr	r2, [fp, #-20]
21f00cf4:	e3a0300c 	mov	r3, #12	; 0xc
21f00cf8:	e5823000 	str	r3, [r2]

#ifdef CONFIG_AT91RM9200DK
	/* Clear PA19 to trigger the hard reset */
	pio->PIO_CODR = 0x00080000;
21f00cfc:	e51b2010 	ldr	r2, [fp, #-16]
21f00d00:	e3a03702 	mov	r3, #524288	; 0x80000
21f00d04:	e5823034 	str	r3, [r2, #52]
	pio->PIO_OER  = 0x00080000;
21f00d08:	e51b2010 	ldr	r2, [fp, #-16]
21f00d0c:	e3a03702 	mov	r3, #524288	; 0x80000
21f00d10:	e5823010 	str	r3, [r2, #16]
	pio->PIO_PER  = 0x00080000;
21f00d14:	e51b2010 	ldr	r2, [fp, #-16]
21f00d18:	e3a03702 	mov	r3, #524288	; 0x80000
21f00d1c:	e5823000 	str	r3, [r2]
#endif

	/* this is the way Linux does it */

	/* FIXME:
	 * These defines should be moved into
	 * include/asm-arm/arch-at91rm9200/AT91RM9200.h
	 * as soon as the whitespace fix gets applied.
	 */
	#define AT91C_ST_RSTEN (0x1 << 16)
	#define AT91C_ST_EXTEN (0x1 << 17)
	#define AT91C_ST_WDRST (0x1 <<  0)
	#define ST_WDMR *((unsigned long *)0xfffffd08)	/* watchdog mode register */
	#define ST_CR *((unsigned long *)0xfffffd00)	/* system clock control register */

	ST_WDMR = AT91C_ST_RSTEN | AT91C_ST_EXTEN | 1 ;
21f00d20:	e3a024a1 	mov	r2, #-1593835520	; 0xa1000000
21f00d24:	e1a02ac2 	mov	r2, r2, asr #21
21f00d28:	e3a03803 	mov	r3, #196608	; 0x30000
21f00d2c:	e2833001 	add	r3, r3, #1	; 0x1
21f00d30:	e5823000 	str	r3, [r2]
	ST_CR = AT91C_ST_WDRST;
21f00d34:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
21f00d38:	e1a03ac3 	mov	r3, r3, asr #21
21f00d3c:	e3a02001 	mov	r2, #1	; 0x1
21f00d40:	e5832000 	str	r2, [r3]

	while (1);
21f00d44:	eafffffe 	b	21f00d44 <reset_cpu+0x80>

21f00d48 <AT91F_PDC_SetNextRx>:
__inline__ void AT91F_PDC_SetNextRx (
	AT91PS_PDC pPDC,     // \arg pointer to a PDC controller
	char *address,       // \arg address to the next bloc to be received
	unsigned int bytes)  // \arg number of bytes to be received
{
21f00d48:	e1a0c00d 	mov	ip, sp
21f00d4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00d50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00d54:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f00d58:	e50b0010 	str	r0, [fp, #-16]
21f00d5c:	e50b1014 	str	r1, [fp, #-20]
21f00d60:	e50b2018 	str	r2, [fp, #-24]
	pPDC->PDC_RNPR = (unsigned int) address;
21f00d64:	e51b3014 	ldr	r3, [fp, #-20]
21f00d68:	e1a02003 	mov	r2, r3
21f00d6c:	e51b3010 	ldr	r3, [fp, #-16]
21f00d70:	e5832010 	str	r2, [r3, #16]
	pPDC->PDC_RNCR = bytes;
21f00d74:	e51b2010 	ldr	r2, [fp, #-16]
21f00d78:	e51b3018 	ldr	r3, [fp, #-24]
21f00d7c:	e5823014 	str	r3, [r2, #20]
}
21f00d80:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f00d84:	e89da800 	ldmia	sp, {fp, sp, pc}

21f00d88 <AT91F_PDC_SetNextTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_SetNextTx
//* \brief Set the next transmit transfer descriptor
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_SetNextTx (
	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
	char *address,         // \arg address to the next bloc to be transmitted
	unsigned int bytes)    // \arg number of bytes to be transmitted
{
21f00d88:	e1a0c00d 	mov	ip, sp
21f00d8c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00d90:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00d94:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f00d98:	e50b0010 	str	r0, [fp, #-16]
21f00d9c:	e50b1014 	str	r1, [fp, #-20]
21f00da0:	e50b2018 	str	r2, [fp, #-24]
	pPDC->PDC_TNPR = (unsigned int) address;
21f00da4:	e51b3014 	ldr	r3, [fp, #-20]
21f00da8:	e1a02003 	mov	r2, r3
21f00dac:	e51b3010 	ldr	r3, [fp, #-16]
21f00db0:	e5832018 	str	r2, [r3, #24]
	pPDC->PDC_TNCR = bytes;
21f00db4:	e51b2010 	ldr	r2, [fp, #-16]
21f00db8:	e51b3018 	ldr	r3, [fp, #-24]
21f00dbc:	e582301c 	str	r3, [r2, #28]
}
21f00dc0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f00dc4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f00dc8 <AT91F_PDC_SetRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_SetRx
//* \brief Set the receive transfer descriptor
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_SetRx (
	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
	char *address,         // \arg address to the next bloc to be received
	unsigned int bytes)    // \arg number of bytes to be received
{
21f00dc8:	e1a0c00d 	mov	ip, sp
21f00dcc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00dd0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00dd4:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f00dd8:	e50b0010 	str	r0, [fp, #-16]
21f00ddc:	e50b1014 	str	r1, [fp, #-20]
21f00de0:	e50b2018 	str	r2, [fp, #-24]
	pPDC->PDC_RPR = (unsigned int) address;
21f00de4:	e51b3014 	ldr	r3, [fp, #-20]
21f00de8:	e1a02003 	mov	r2, r3
21f00dec:	e51b3010 	ldr	r3, [fp, #-16]
21f00df0:	e5832000 	str	r2, [r3]
	pPDC->PDC_RCR = bytes;
21f00df4:	e51b2010 	ldr	r2, [fp, #-16]
21f00df8:	e51b3018 	ldr	r3, [fp, #-24]
21f00dfc:	e5823004 	str	r3, [r2, #4]
}
21f00e00:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f00e04:	e89da800 	ldmia	sp, {fp, sp, pc}

21f00e08 <AT91F_PDC_SetTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_SetTx
//* \brief Set the transmit transfer descriptor
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_SetTx (
	AT91PS_PDC pPDC,       // \arg pointer to a PDC controller
	char *address,         // \arg address to the next bloc to be transmitted
	unsigned int bytes)    // \arg number of bytes to be transmitted
{
21f00e08:	e1a0c00d 	mov	ip, sp
21f00e0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00e10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00e14:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f00e18:	e50b0010 	str	r0, [fp, #-16]
21f00e1c:	e50b1014 	str	r1, [fp, #-20]
21f00e20:	e50b2018 	str	r2, [fp, #-24]
	pPDC->PDC_TPR = (unsigned int) address;
21f00e24:	e51b3014 	ldr	r3, [fp, #-20]
21f00e28:	e1a02003 	mov	r2, r3
21f00e2c:	e51b3010 	ldr	r3, [fp, #-16]
21f00e30:	e5832008 	str	r2, [r3, #8]
	pPDC->PDC_TCR = bytes;
21f00e34:	e51b2010 	ldr	r2, [fp, #-16]
21f00e38:	e51b3018 	ldr	r3, [fp, #-24]
21f00e3c:	e582300c 	str	r3, [r2, #12]
}
21f00e40:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f00e44:	e89da800 	ldmia	sp, {fp, sp, pc}

21f00e48 <AT91F_PDC_EnableTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_EnableTx
//* \brief Enable transmit
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_EnableTx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00e48:	e1a0c00d 	mov	ip, sp
21f00e4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00e50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00e54:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00e58:	e50b0010 	str	r0, [fp, #-16]
	pPDC->PDC_PTCR = AT91C_PDC_TXTEN;
21f00e5c:	e51b2010 	ldr	r2, [fp, #-16]
21f00e60:	e3a03c01 	mov	r3, #256	; 0x100
21f00e64:	e5823020 	str	r3, [r2, #32]
}
21f00e68:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00e6c <AT91F_PDC_EnableRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_EnableRx
//* \brief Enable receive
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_EnableRx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00e6c:	e1a0c00d 	mov	ip, sp
21f00e70:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00e74:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00e78:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00e7c:	e50b0010 	str	r0, [fp, #-16]
	pPDC->PDC_PTCR = AT91C_PDC_RXTEN;
21f00e80:	e51b2010 	ldr	r2, [fp, #-16]
21f00e84:	e3a03001 	mov	r3, #1	; 0x1
21f00e88:	e5823020 	str	r3, [r2, #32]
}
21f00e8c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00e90 <AT91F_PDC_DisableTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_DisableTx
//* \brief Disable transmit
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_DisableTx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00e90:	e1a0c00d 	mov	ip, sp
21f00e94:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00e98:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00e9c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00ea0:	e50b0010 	str	r0, [fp, #-16]
	pPDC->PDC_PTCR = AT91C_PDC_TXTDIS;
21f00ea4:	e51b2010 	ldr	r2, [fp, #-16]
21f00ea8:	e3a03c02 	mov	r3, #512	; 0x200
21f00eac:	e5823020 	str	r3, [r2, #32]
}
21f00eb0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00eb4 <AT91F_PDC_DisableRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_DisableRx
//* \brief Disable receive
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_DisableRx (
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00eb4:	e1a0c00d 	mov	ip, sp
21f00eb8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00ebc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00ec0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00ec4:	e50b0010 	str	r0, [fp, #-16]
	pPDC->PDC_PTCR = AT91C_PDC_RXTDIS;
21f00ec8:	e51b2010 	ldr	r2, [fp, #-16]
21f00ecc:	e3a03002 	mov	r3, #2	; 0x2
21f00ed0:	e5823020 	str	r3, [r2, #32]
}
21f00ed4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00ed8 <AT91F_PDC_IsTxEmpty>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_IsTxEmpty
//* \brief Test if the current transfer descriptor has been sent
//*----------------------------------------------------------------------------
__inline__ int AT91F_PDC_IsTxEmpty ( // \return return 1 if transfer is complete
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00ed8:	e1a0c00d 	mov	ip, sp
21f00edc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00ee0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00ee4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00ee8:	e50b0010 	str	r0, [fp, #-16]
	return !(pPDC->PDC_TCR);
21f00eec:	e51b3010 	ldr	r3, [fp, #-16]
21f00ef0:	e593300c 	ldr	r3, [r3, #12]
21f00ef4:	e3530000 	cmp	r3, #0	; 0x0
21f00ef8:	13a03000 	movne	r3, #0	; 0x0
21f00efc:	03a03001 	moveq	r3, #1	; 0x1
}
21f00f00:	e1a00003 	mov	r0, r3
21f00f04:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00f08 <AT91F_PDC_IsNextTxEmpty>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_IsNextTxEmpty
//* \brief Test if the next transfer descriptor has been moved to the current td
//*----------------------------------------------------------------------------
__inline__ int AT91F_PDC_IsNextTxEmpty ( // \return return 1 if transfer is complete
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00f08:	e1a0c00d 	mov	ip, sp
21f00f0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00f10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00f14:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00f18:	e50b0010 	str	r0, [fp, #-16]
	return !(pPDC->PDC_TNCR);
21f00f1c:	e51b3010 	ldr	r3, [fp, #-16]
21f00f20:	e593301c 	ldr	r3, [r3, #28]
21f00f24:	e3530000 	cmp	r3, #0	; 0x0
21f00f28:	13a03000 	movne	r3, #0	; 0x0
21f00f2c:	03a03001 	moveq	r3, #1	; 0x1
}
21f00f30:	e1a00003 	mov	r0, r3
21f00f34:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00f38 <AT91F_PDC_IsRxEmpty>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_IsRxEmpty
//* \brief Test if the current transfer descriptor has been filled
//*----------------------------------------------------------------------------
__inline__ int AT91F_PDC_IsRxEmpty ( // \return return 1 if transfer is complete
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00f38:	e1a0c00d 	mov	ip, sp
21f00f3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00f40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00f44:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00f48:	e50b0010 	str	r0, [fp, #-16]
	return !(pPDC->PDC_RCR);
21f00f4c:	e51b3010 	ldr	r3, [fp, #-16]
21f00f50:	e5933004 	ldr	r3, [r3, #4]
21f00f54:	e3530000 	cmp	r3, #0	; 0x0
21f00f58:	13a03000 	movne	r3, #0	; 0x0
21f00f5c:	03a03001 	moveq	r3, #1	; 0x1
}
21f00f60:	e1a00003 	mov	r0, r3
21f00f64:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00f68 <AT91F_PDC_IsNextRxEmpty>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_IsNextRxEmpty
//* \brief Test if the next transfer descriptor has been moved to the current td
//*----------------------------------------------------------------------------
__inline__ int AT91F_PDC_IsNextRxEmpty ( // \return return 1 if transfer is complete
	AT91PS_PDC pPDC )       // \arg pointer to a PDC controller
{
21f00f68:	e1a0c00d 	mov	ip, sp
21f00f6c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00f70:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00f74:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00f78:	e50b0010 	str	r0, [fp, #-16]
	return !(pPDC->PDC_RNCR);
21f00f7c:	e51b3010 	ldr	r3, [fp, #-16]
21f00f80:	e5933014 	ldr	r3, [r3, #20]
21f00f84:	e3530000 	cmp	r3, #0	; 0x0
21f00f88:	13a03000 	movne	r3, #0	; 0x0
21f00f8c:	03a03001 	moveq	r3, #1	; 0x1
}
21f00f90:	e1a00003 	mov	r0, r3
21f00f94:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f00f98 <AT91F_PDC_Open>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_Open
//* \brief Open PDC: disable TX and RX reset transfer descriptors, re-enable RX and TX
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_Open (
	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
{
21f00f98:	e1a0c00d 	mov	ip, sp
21f00f9c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f00fa0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f00fa4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f00fa8:	e50b0010 	str	r0, [fp, #-16]
    //* Disable the RX and TX PDC transfer requests
	AT91F_PDC_DisableRx(pPDC);
21f00fac:	e51b0010 	ldr	r0, [fp, #-16]
21f00fb0:	ebffffbf 	bl	21f00eb4 <AT91F_PDC_DisableRx>
	AT91F_PDC_DisableTx(pPDC);
21f00fb4:	e51b0010 	ldr	r0, [fp, #-16]
21f00fb8:	ebffffb4 	bl	21f00e90 <AT91F_PDC_DisableTx>

	//* Reset all Counter register Next buffer first
	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
21f00fbc:	e51b0010 	ldr	r0, [fp, #-16]
21f00fc0:	e3a01000 	mov	r1, #0	; 0x0
21f00fc4:	e3a02000 	mov	r2, #0	; 0x0
21f00fc8:	ebffff6e 	bl	21f00d88 <AT91F_PDC_SetNextTx>
	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
21f00fcc:	e51b0010 	ldr	r0, [fp, #-16]
21f00fd0:	e3a01000 	mov	r1, #0	; 0x0
21f00fd4:	e3a02000 	mov	r2, #0	; 0x0
21f00fd8:	ebffff5a 	bl	21f00d48 <AT91F_PDC_SetNextRx>
	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
21f00fdc:	e51b0010 	ldr	r0, [fp, #-16]
21f00fe0:	e3a01000 	mov	r1, #0	; 0x0
21f00fe4:	e3a02000 	mov	r2, #0	; 0x0
21f00fe8:	ebffff86 	bl	21f00e08 <AT91F_PDC_SetTx>
	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
21f00fec:	e51b0010 	ldr	r0, [fp, #-16]
21f00ff0:	e3a01000 	mov	r1, #0	; 0x0
21f00ff4:	e3a02000 	mov	r2, #0	; 0x0
21f00ff8:	ebffff72 	bl	21f00dc8 <AT91F_PDC_SetRx>

    //* Enable the RX and TX PDC transfer requests
	AT91F_PDC_EnableRx(pPDC);
21f00ffc:	e51b0010 	ldr	r0, [fp, #-16]
21f01000:	ebffff99 	bl	21f00e6c <AT91F_PDC_EnableRx>
	AT91F_PDC_EnableTx(pPDC);
21f01004:	e51b0010 	ldr	r0, [fp, #-16]
21f01008:	ebffff8e 	bl	21f00e48 <AT91F_PDC_EnableTx>
}
21f0100c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01010 <AT91F_PDC_Close>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_Close
//* \brief Close PDC: disable TX and RX reset transfer descriptors
//*----------------------------------------------------------------------------
__inline__ void AT91F_PDC_Close (
	AT91PS_PDC pPDC)       // \arg pointer to a PDC controller
{
21f01010:	e1a0c00d 	mov	ip, sp
21f01014:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01018:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0101c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01020:	e50b0010 	str	r0, [fp, #-16]
    //* Disable the RX and TX PDC transfer requests
	AT91F_PDC_DisableRx(pPDC);
21f01024:	e51b0010 	ldr	r0, [fp, #-16]
21f01028:	ebffffa1 	bl	21f00eb4 <AT91F_PDC_DisableRx>
	AT91F_PDC_DisableTx(pPDC);
21f0102c:	e51b0010 	ldr	r0, [fp, #-16]
21f01030:	ebffff96 	bl	21f00e90 <AT91F_PDC_DisableTx>

	//* Reset all Counter register Next buffer first
	AT91F_PDC_SetNextTx(pPDC, (char *) 0, 0);
21f01034:	e51b0010 	ldr	r0, [fp, #-16]
21f01038:	e3a01000 	mov	r1, #0	; 0x0
21f0103c:	e3a02000 	mov	r2, #0	; 0x0
21f01040:	ebffff50 	bl	21f00d88 <AT91F_PDC_SetNextTx>
	AT91F_PDC_SetNextRx(pPDC, (char *) 0, 0);
21f01044:	e51b0010 	ldr	r0, [fp, #-16]
21f01048:	e3a01000 	mov	r1, #0	; 0x0
21f0104c:	e3a02000 	mov	r2, #0	; 0x0
21f01050:	ebffff3c 	bl	21f00d48 <AT91F_PDC_SetNextRx>
	AT91F_PDC_SetTx(pPDC, (char *) 0, 0);
21f01054:	e51b0010 	ldr	r0, [fp, #-16]
21f01058:	e3a01000 	mov	r1, #0	; 0x0
21f0105c:	e3a02000 	mov	r2, #0	; 0x0
21f01060:	ebffff68 	bl	21f00e08 <AT91F_PDC_SetTx>
	AT91F_PDC_SetRx(pPDC, (char *) 0, 0);
21f01064:	e51b0010 	ldr	r0, [fp, #-16]
21f01068:	e3a01000 	mov	r1, #0	; 0x0
21f0106c:	e3a02000 	mov	r2, #0	; 0x0
21f01070:	ebffff54 	bl	21f00dc8 <AT91F_PDC_SetRx>

}
21f01074:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01078 <AT91F_PDC_SendFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_SendFrame
//* \brief Close PDC: disable TX and RX reset transfer descriptors
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PDC_SendFrame(
	AT91PS_PDC pPDC,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f01078:	e1a0c00d 	mov	ip, sp
21f0107c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01080:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01084:	e24dd014 	sub	sp, sp, #20	; 0x14
21f01088:	e50b0010 	str	r0, [fp, #-16]
21f0108c:	e50b1014 	str	r1, [fp, #-20]
21f01090:	e50b2018 	str	r2, [fp, #-24]
21f01094:	e50b301c 	str	r3, [fp, #-28]
	if (AT91F_PDC_IsTxEmpty(pPDC)) {
21f01098:	e51b0010 	ldr	r0, [fp, #-16]
21f0109c:	ebffff8d 	bl	21f00ed8 <AT91F_PDC_IsTxEmpty>
21f010a0:	e1a03000 	mov	r3, r0
21f010a4:	e3530000 	cmp	r3, #0	; 0x0
21f010a8:	0a00000a 	beq	21f010d8 <AT91F_PDC_SendFrame+0x60>
		//* Buffer and next buffer can be initialized
		AT91F_PDC_SetTx(pPDC, pBuffer, szBuffer);
21f010ac:	e51b0010 	ldr	r0, [fp, #-16]
21f010b0:	e51b1014 	ldr	r1, [fp, #-20]
21f010b4:	e51b2018 	ldr	r2, [fp, #-24]
21f010b8:	ebffff52 	bl	21f00e08 <AT91F_PDC_SetTx>
		AT91F_PDC_SetNextTx(pPDC, pNextBuffer, szNextBuffer);
21f010bc:	e51b0010 	ldr	r0, [fp, #-16]
21f010c0:	e51b101c 	ldr	r1, [fp, #-28]
21f010c4:	e59b2004 	ldr	r2, [fp, #4]
21f010c8:	ebffff2e 	bl	21f00d88 <AT91F_PDC_SetNextTx>
		return 2;
21f010cc:	e3a03002 	mov	r3, #2	; 0x2
21f010d0:	e50b3020 	str	r3, [fp, #-32]
21f010d4:	ea00000d 	b	21f01110 <AT91F_PDC_SendFrame+0x98>
	}
	else if (AT91F_PDC_IsNextTxEmpty(pPDC)) {
21f010d8:	e51b0010 	ldr	r0, [fp, #-16]
21f010dc:	ebffff89 	bl	21f00f08 <AT91F_PDC_IsNextTxEmpty>
21f010e0:	e1a03000 	mov	r3, r0
21f010e4:	e3530000 	cmp	r3, #0	; 0x0
21f010e8:	0a000006 	beq	21f01108 <AT91F_PDC_SendFrame+0x90>
		//* Only one buffer can be initialized
		AT91F_PDC_SetNextTx(pPDC, pBuffer, szBuffer);
21f010ec:	e51b0010 	ldr	r0, [fp, #-16]
21f010f0:	e51b1014 	ldr	r1, [fp, #-20]
21f010f4:	e51b2018 	ldr	r2, [fp, #-24]
21f010f8:	ebffff22 	bl	21f00d88 <AT91F_PDC_SetNextTx>
		return 1;
21f010fc:	e3a03001 	mov	r3, #1	; 0x1
21f01100:	e50b3020 	str	r3, [fp, #-32]
21f01104:	ea000001 	b	21f01110 <AT91F_PDC_SendFrame+0x98>
	}
	else {
		//* All buffer are in use...
		return 0;
21f01108:	e3a03000 	mov	r3, #0	; 0x0
21f0110c:	e50b3020 	str	r3, [fp, #-32]
21f01110:	e51b3020 	ldr	r3, [fp, #-32]
	}
}
21f01114:	e1a00003 	mov	r0, r3
21f01118:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0111c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01120 <AT91F_PDC_ReceiveFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PDC_ReceiveFrame
//* \brief Close PDC: disable TX and RX reset transfer descriptors
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PDC_ReceiveFrame (
	AT91PS_PDC pPDC,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f01120:	e1a0c00d 	mov	ip, sp
21f01124:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01128:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0112c:	e24dd014 	sub	sp, sp, #20	; 0x14
21f01130:	e50b0010 	str	r0, [fp, #-16]
21f01134:	e50b1014 	str	r1, [fp, #-20]
21f01138:	e50b2018 	str	r2, [fp, #-24]
21f0113c:	e50b301c 	str	r3, [fp, #-28]
	if (AT91F_PDC_IsRxEmpty(pPDC)) {
21f01140:	e51b0010 	ldr	r0, [fp, #-16]
21f01144:	ebffff7b 	bl	21f00f38 <AT91F_PDC_IsRxEmpty>
21f01148:	e1a03000 	mov	r3, r0
21f0114c:	e3530000 	cmp	r3, #0	; 0x0
21f01150:	0a00000a 	beq	21f01180 <AT91F_PDC_ReceiveFrame+0x60>
		//* Buffer and next buffer can be initialized
		AT91F_PDC_SetRx(pPDC, pBuffer, szBuffer);
21f01154:	e51b0010 	ldr	r0, [fp, #-16]
21f01158:	e51b1014 	ldr	r1, [fp, #-20]
21f0115c:	e51b2018 	ldr	r2, [fp, #-24]
21f01160:	ebffff18 	bl	21f00dc8 <AT91F_PDC_SetRx>
		AT91F_PDC_SetNextRx(pPDC, pNextBuffer, szNextBuffer);
21f01164:	e51b0010 	ldr	r0, [fp, #-16]
21f01168:	e51b101c 	ldr	r1, [fp, #-28]
21f0116c:	e59b2004 	ldr	r2, [fp, #4]
21f01170:	ebfffef4 	bl	21f00d48 <AT91F_PDC_SetNextRx>
		return 2;
21f01174:	e3a03002 	mov	r3, #2	; 0x2
21f01178:	e50b3020 	str	r3, [fp, #-32]
21f0117c:	ea00000d 	b	21f011b8 <AT91F_PDC_ReceiveFrame+0x98>
	}
	else if (AT91F_PDC_IsNextRxEmpty(pPDC)) {
21f01180:	e51b0010 	ldr	r0, [fp, #-16]
21f01184:	ebffff77 	bl	21f00f68 <AT91F_PDC_IsNextRxEmpty>
21f01188:	e1a03000 	mov	r3, r0
21f0118c:	e3530000 	cmp	r3, #0	; 0x0
21f01190:	0a000006 	beq	21f011b0 <AT91F_PDC_ReceiveFrame+0x90>
		//* Only one buffer can be initialized
		AT91F_PDC_SetNextRx(pPDC, pBuffer, szBuffer);
21f01194:	e51b0010 	ldr	r0, [fp, #-16]
21f01198:	e51b1014 	ldr	r1, [fp, #-20]
21f0119c:	e51b2018 	ldr	r2, [fp, #-24]
21f011a0:	ebfffee8 	bl	21f00d48 <AT91F_PDC_SetNextRx>
		return 1;
21f011a4:	e3a03001 	mov	r3, #1	; 0x1
21f011a8:	e50b3020 	str	r3, [fp, #-32]
21f011ac:	ea000001 	b	21f011b8 <AT91F_PDC_ReceiveFrame+0x98>
	}
	else {
		//* All buffer are in use...
		return 0;
21f011b0:	e3a03000 	mov	r3, #0	; 0x0
21f011b4:	e50b3020 	str	r3, [fp, #-32]
21f011b8:	e51b3020 	ldr	r3, [fp, #-32]
	}
}
21f011bc:	e1a00003 	mov	r0, r3
21f011c0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f011c4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f011c8 <AT91F_DBGU_InterruptEnable>:
/* *****************************************************************************
                SOFTWARE API FOR DBGU
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_DBGU_InterruptEnable
//* \brief Enable DBGU Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_DBGU_InterruptEnable(
        AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
        unsigned int flag) // \arg  dbgu interrupt to be enabled
{
21f011c8:	e1a0c00d 	mov	ip, sp
21f011cc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f011d0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f011d4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f011d8:	e50b0010 	str	r0, [fp, #-16]
21f011dc:	e50b1014 	str	r1, [fp, #-20]
        pDbgu->DBGU_IER = flag;
21f011e0:	e51b2010 	ldr	r2, [fp, #-16]
21f011e4:	e51b3014 	ldr	r3, [fp, #-20]
21f011e8:	e5823008 	str	r3, [r2, #8]
}
21f011ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f011f0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f011f4 <AT91F_DBGU_InterruptDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_DBGU_InterruptDisable
//* \brief Disable DBGU Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_DBGU_InterruptDisable(
        AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
        unsigned int flag) // \arg  dbgu interrupt to be disabled
{
21f011f4:	e1a0c00d 	mov	ip, sp
21f011f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f011fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01200:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01204:	e50b0010 	str	r0, [fp, #-16]
21f01208:	e50b1014 	str	r1, [fp, #-20]
        pDbgu->DBGU_IDR = flag;
21f0120c:	e51b2010 	ldr	r2, [fp, #-16]
21f01210:	e51b3014 	ldr	r3, [fp, #-20]
21f01214:	e582300c 	str	r3, [r2, #12]
}
21f01218:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0121c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01220 <AT91F_DBGU_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_DBGU_GetInterruptMaskStatus
//* \brief Return DBGU Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_DBGU_GetInterruptMaskStatus( // \return DBGU Interrupt Mask Status
        AT91PS_DBGU pDbgu) // \arg  pointer to a DBGU controller
{
21f01220:	e1a0c00d 	mov	ip, sp
21f01224:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01228:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0122c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01230:	e50b0010 	str	r0, [fp, #-16]
        return pDbgu->DBGU_IMR;
21f01234:	e51b3010 	ldr	r3, [fp, #-16]
21f01238:	e5933010 	ldr	r3, [r3, #16]
}
21f0123c:	e1a00003 	mov	r0, r3
21f01240:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01244 <AT91F_DBGU_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_DBGU_IsInterruptMasked
//* \brief Test if DBGU Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_DBGU_IsInterruptMasked(
        AT91PS_DBGU pDbgu,   // \arg  pointer to a DBGU controller
        unsigned int flag) // \arg  flag to be tested
{
21f01244:	e1a0c00d 	mov	ip, sp
21f01248:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0124c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01250:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01254:	e50b0010 	str	r0, [fp, #-16]
21f01258:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_DBGU_GetInterruptMaskStatus(pDbgu) & flag);
21f0125c:	e51b0010 	ldr	r0, [fp, #-16]
21f01260:	ebffffee 	bl	21f01220 <AT91F_DBGU_GetInterruptMaskStatus>
21f01264:	e1a02000 	mov	r2, r0
21f01268:	e51b3014 	ldr	r3, [fp, #-20]
21f0126c:	e0023003 	and	r3, r2, r3
}
21f01270:	e1a00003 	mov	r0, r3
21f01274:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01278:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0127c <AT91F_RTC_InterruptEnable>:

/* *****************************************************************************
                SOFTWARE API FOR RTC
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_RTC_InterruptEnable
//* \brief Enable RTC Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_RTC_InterruptEnable(
        AT91PS_RTC pRtc,   // \arg  pointer to a RTC controller
        unsigned int flag) // \arg  RTC interrupt to be enabled
{
21f0127c:	e1a0c00d 	mov	ip, sp
21f01280:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01284:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01288:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0128c:	e50b0010 	str	r0, [fp, #-16]
21f01290:	e50b1014 	str	r1, [fp, #-20]
        pRtc->RTC_IER = flag;
21f01294:	e51b2010 	ldr	r2, [fp, #-16]
21f01298:	e51b3014 	ldr	r3, [fp, #-20]
21f0129c:	e5823020 	str	r3, [r2, #32]
}
21f012a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f012a4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f012a8 <AT91F_RTC_InterruptDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_RTC_InterruptDisable
//* \brief Disable RTC Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_RTC_InterruptDisable(
        AT91PS_RTC pRtc,   // \arg  pointer to a RTC controller
        unsigned int flag) // \arg  RTC interrupt to be disabled
{
21f012a8:	e1a0c00d 	mov	ip, sp
21f012ac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f012b0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f012b4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f012b8:	e50b0010 	str	r0, [fp, #-16]
21f012bc:	e50b1014 	str	r1, [fp, #-20]
        pRtc->RTC_IDR = flag;
21f012c0:	e51b2010 	ldr	r2, [fp, #-16]
21f012c4:	e51b3014 	ldr	r3, [fp, #-20]
21f012c8:	e5823024 	str	r3, [r2, #36]
}
21f012cc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f012d0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f012d4 <AT91F_RTC_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_RTC_GetInterruptMaskStatus
//* \brief Return RTC Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_RTC_GetInterruptMaskStatus( // \return RTC Interrupt Mask Status
        AT91PS_RTC pRtc) // \arg  pointer to a RTC controller
{
21f012d4:	e1a0c00d 	mov	ip, sp
21f012d8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f012dc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f012e0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f012e4:	e50b0010 	str	r0, [fp, #-16]
        return pRtc->RTC_IMR;
21f012e8:	e51b3010 	ldr	r3, [fp, #-16]
21f012ec:	e5933028 	ldr	r3, [r3, #40]
}
21f012f0:	e1a00003 	mov	r0, r3
21f012f4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f012f8 <AT91F_RTC_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_RTC_IsInterruptMasked
//* \brief Test if RTC Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_RTC_IsInterruptMasked(
        AT91PS_RTC pRtc,   // \arg  pointer to a RTC controller
        unsigned int flag) // \arg  flag to be tested
{
21f012f8:	e1a0c00d 	mov	ip, sp
21f012fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01300:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01304:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01308:	e50b0010 	str	r0, [fp, #-16]
21f0130c:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_RTC_GetInterruptMaskStatus(pRtc) & flag);
21f01310:	e51b0010 	ldr	r0, [fp, #-16]
21f01314:	ebffffee 	bl	21f012d4 <AT91F_RTC_GetInterruptMaskStatus>
21f01318:	e1a02000 	mov	r2, r0
21f0131c:	e51b3014 	ldr	r3, [fp, #-20]
21f01320:	e0023003 	and	r3, r2, r3
}
21f01324:	e1a00003 	mov	r0, r3
21f01328:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0132c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01330 <AT91F_SSC_SetBaudrate>:

/* *****************************************************************************
                SOFTWARE API FOR SSC
   ***************************************************************************** */
//* Define the standard I2S mode configuration

//* Configuration to set in the SSC Transmit Clock Mode Register
//* Parameters :  nb_bit_by_slot : 8, 16 or 32 bits
//* 			  nb_slot_by_frame : number of channels
#define AT91C_I2S_ASY_MASTER_TX_SETTING(nb_bit_by_slot, nb_slot_by_frame)( +\
									   AT91C_SSC_CKS_DIV   +\
                            		   AT91C_SSC_CKO_CONTINOUS      +\
                            		   AT91C_SSC_CKG_NONE    +\
                                       AT91C_SSC_START_FALL_RF +\
                           			   AT91C_SSC_STTOUT  +\
                            		   ((1<<16) & AT91C_SSC_STTDLY) +\
                            		   ((((nb_bit_by_slot*nb_slot_by_frame)/2)-1) <<24))


//* Configuration to set in the SSC Transmit Frame Mode Register
//* Parameters : nb_bit_by_slot : 8, 16 or 32 bits
//* 			 nb_slot_by_frame : number of channels
#define AT91C_I2S_ASY_TX_FRAME_SETTING(nb_bit_by_slot, nb_slot_by_frame)( +\
									(nb_bit_by_slot-1)  +\
                            		AT91C_SSC_MSBF   +\
                            		(((nb_slot_by_frame-1)<<8) & AT91C_SSC_DATNB)  +\
                            		(((nb_bit_by_slot-1)<<16) & AT91C_SSC_FSLEN) +\
                            		AT91C_SSC_FSOS_NEGATIVE)


//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_SetBaudrate
//* \brief Set the baudrate according to the CPU clock
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_SetBaudrate (
        AT91PS_SSC pSSC,        // \arg pointer to a SSC controller
        unsigned int mainClock, // \arg peripheral clock
        unsigned int speed)     // \arg SSC baudrate
{
21f01330:	e1a0c00d 	mov	ip, sp
21f01334:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01338:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0133c:	e24dd014 	sub	sp, sp, #20	; 0x14
21f01340:	e50b0014 	str	r0, [fp, #-20]
21f01344:	e50b1018 	str	r1, [fp, #-24]
21f01348:	e50b201c 	str	r2, [fp, #-28]
        unsigned int baud_value;
        //* Define the baud rate divisor register
        if (speed == 0)
21f0134c:	e51b301c 	ldr	r3, [fp, #-28]
21f01350:	e3530000 	cmp	r3, #0	; 0x0
21f01354:	1a000002 	bne	21f01364 <AT91F_SSC_SetBaudrate+0x34>
           baud_value = 0;
21f01358:	e3a03000 	mov	r3, #0	; 0x0
21f0135c:	e50b3010 	str	r3, [fp, #-16]
21f01360:	ea000027 	b	21f01404 <AT91F_SSC_SetBaudrate+0xd4>
        else
        {
           baud_value = (unsigned int) (mainClock * 10)/(2*speed);
21f01364:	e51b2018 	ldr	r2, [fp, #-24]
21f01368:	e1a03002 	mov	r3, r2
21f0136c:	e1a03103 	mov	r3, r3, lsl #2
21f01370:	e0833002 	add	r3, r3, r2
21f01374:	e1a03083 	mov	r3, r3, lsl #1
21f01378:	e1a02003 	mov	r2, r3
21f0137c:	e51b301c 	ldr	r3, [fp, #-28]
21f01380:	e1a03083 	mov	r3, r3, lsl #1
21f01384:	e1a00002 	mov	r0, r2
21f01388:	e1a01003 	mov	r1, r3
21f0138c:	eb0011c8 	bl	21f05ab4 <__udivsi3>
21f01390:	e1a03000 	mov	r3, r0
21f01394:	e50b3010 	str	r3, [fp, #-16]
           if ((baud_value % 10) >= 5)
21f01398:	e51b2010 	ldr	r2, [fp, #-16]
21f0139c:	e59f3074 	ldr	r3, [pc, #116]	; 21f01418 <.text+0x1418>
21f013a0:	e0831392 	umull	r1, r3, r2, r3
21f013a4:	e1a031a3 	mov	r3, r3, lsr #3
21f013a8:	e50b3020 	str	r3, [fp, #-32]
21f013ac:	e51b3020 	ldr	r3, [fp, #-32]
21f013b0:	e1a03103 	mov	r3, r3, lsl #2
21f013b4:	e51b1020 	ldr	r1, [fp, #-32]
21f013b8:	e0833001 	add	r3, r3, r1
21f013bc:	e1a03083 	mov	r3, r3, lsl #1
21f013c0:	e0632002 	rsb	r2, r3, r2
21f013c4:	e50b2020 	str	r2, [fp, #-32]
21f013c8:	e51b3020 	ldr	r3, [fp, #-32]
21f013cc:	e3530004 	cmp	r3, #4	; 0x4
21f013d0:	9a000006 	bls	21f013f0 <AT91F_SSC_SetBaudrate+0xc0>
                  baud_value = (baud_value / 10) + 1;
21f013d4:	e51b2010 	ldr	r2, [fp, #-16]
21f013d8:	e59f3038 	ldr	r3, [pc, #56]	; 21f01418 <.text+0x1418>
21f013dc:	e0831392 	umull	r1, r3, r2, r3
21f013e0:	e1a031a3 	mov	r3, r3, lsr #3
21f013e4:	e2833001 	add	r3, r3, #1	; 0x1
21f013e8:	e50b3010 	str	r3, [fp, #-16]
21f013ec:	ea000004 	b	21f01404 <AT91F_SSC_SetBaudrate+0xd4>
           else
                  baud_value /= 10;
21f013f0:	e51b2010 	ldr	r2, [fp, #-16]
21f013f4:	e59f301c 	ldr	r3, [pc, #28]	; 21f01418 <.text+0x1418>
21f013f8:	e0831392 	umull	r1, r3, r2, r3
21f013fc:	e1a031a3 	mov	r3, r3, lsr #3
21f01400:	e50b3010 	str	r3, [fp, #-16]
        }

        pSSC->SSC_CMR = baud_value;
21f01404:	e51b2014 	ldr	r2, [fp, #-20]
21f01408:	e51b3010 	ldr	r3, [fp, #-16]
21f0140c:	e5823004 	str	r3, [r2, #4]
}
21f01410:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01414:	e89da800 	ldmia	sp, {fp, sp, pc}
21f01418:	cccccccd 	stcgtl	12, cr12, [ip], {205}

21f0141c <AT91F_SSC_Configure>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_Configure
//* \brief Configure SSC
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_Configure (
             AT91PS_SSC pSSC,          // \arg pointer to a SSC controller
             unsigned int syst_clock,  // \arg System Clock Frequency
             unsigned int baud_rate,   // \arg Expected Baud Rate Frequency
             unsigned int clock_rx,    // \arg Receiver Clock Parameters
             unsigned int mode_rx,     // \arg mode Register to be programmed
             unsigned int clock_tx,    // \arg Transmitter Clock Parameters
             unsigned int mode_tx)     // \arg mode Register to be programmed
{
21f0141c:	e1a0c00d 	mov	ip, sp
21f01420:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01424:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01428:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0142c:	e50b0010 	str	r0, [fp, #-16]
21f01430:	e50b1014 	str	r1, [fp, #-20]
21f01434:	e50b2018 	str	r2, [fp, #-24]
21f01438:	e50b301c 	str	r3, [fp, #-28]
    //* Disable interrupts
	pSSC->SSC_IDR = (unsigned int) -1;
21f0143c:	e51b2010 	ldr	r2, [fp, #-16]
21f01440:	e3e03000 	mvn	r3, #0	; 0x0
21f01444:	e5823048 	str	r3, [r2, #72]

    //* Reset receiver and transmitter
	pSSC->SSC_CR = AT91C_SSC_SWRST | AT91C_SSC_RXDIS | AT91C_SSC_TXDIS ;
21f01448:	e51b2010 	ldr	r2, [fp, #-16]
21f0144c:	e3a03c82 	mov	r3, #33280	; 0x8200
21f01450:	e2833002 	add	r3, r3, #2	; 0x2
21f01454:	e5823000 	str	r3, [r2]

    //* Define the Clock Mode Register
	AT91F_SSC_SetBaudrate(pSSC, syst_clock, baud_rate);
21f01458:	e51b0010 	ldr	r0, [fp, #-16]
21f0145c:	e51b1014 	ldr	r1, [fp, #-20]
21f01460:	e51b2018 	ldr	r2, [fp, #-24]
21f01464:	ebffffb1 	bl	21f01330 <AT91F_SSC_SetBaudrate>

     //* Write the Receive Clock Mode Register
	pSSC->SSC_RCMR =  clock_rx;
21f01468:	e51b2010 	ldr	r2, [fp, #-16]
21f0146c:	e51b301c 	ldr	r3, [fp, #-28]
21f01470:	e5823010 	str	r3, [r2, #16]

     //* Write the Transmit Clock Mode Register
	pSSC->SSC_TCMR =  clock_tx;
21f01474:	e51b2010 	ldr	r2, [fp, #-16]
21f01478:	e59b3008 	ldr	r3, [fp, #8]
21f0147c:	e5823018 	str	r3, [r2, #24]

     //* Write the Receive Frame Mode Register
	pSSC->SSC_RFMR =  mode_rx;
21f01480:	e51b2010 	ldr	r2, [fp, #-16]
21f01484:	e59b3004 	ldr	r3, [fp, #4]
21f01488:	e5823014 	str	r3, [r2, #20]

     //* Write the Transmit Frame Mode Register
	pSSC->SSC_TFMR =  mode_tx;
21f0148c:	e51b2010 	ldr	r2, [fp, #-16]
21f01490:	e59b300c 	ldr	r3, [fp, #12]
21f01494:	e582301c 	str	r3, [r2, #28]

    //* Clear Transmit and Receive Counters
	AT91F_PDC_Open((AT91PS_PDC) &(pSSC->SSC_RPR));
21f01498:	e51b3010 	ldr	r3, [fp, #-16]
21f0149c:	e2833c01 	add	r3, r3, #256	; 0x100
21f014a0:	e1a00003 	mov	r0, r3
21f014a4:	ebfffebb 	bl	21f00f98 <AT91F_PDC_Open>


}
21f014a8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f014ac:	e89da800 	ldmia	sp, {fp, sp, pc}

21f014b0 <AT91F_SSC_EnableRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_EnableRx
//* \brief Enable receiving datas
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_EnableRx (
	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
{
21f014b0:	e1a0c00d 	mov	ip, sp
21f014b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f014b8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f014bc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f014c0:	e50b0010 	str	r0, [fp, #-16]
    //* Enable receiver
    pSSC->SSC_CR = AT91C_SSC_RXEN;
21f014c4:	e51b2010 	ldr	r2, [fp, #-16]
21f014c8:	e3a03001 	mov	r3, #1	; 0x1
21f014cc:	e5823000 	str	r3, [r2]
}
21f014d0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f014d4 <AT91F_SSC_DisableRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_DisableRx
//* \brief Disable receiving datas
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_DisableRx (
	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
{
21f014d4:	e1a0c00d 	mov	ip, sp
21f014d8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f014dc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f014e0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f014e4:	e50b0010 	str	r0, [fp, #-16]
    //* Disable receiver
    pSSC->SSC_CR = AT91C_SSC_RXDIS;
21f014e8:	e51b2010 	ldr	r2, [fp, #-16]
21f014ec:	e3a03002 	mov	r3, #2	; 0x2
21f014f0:	e5823000 	str	r3, [r2]
}
21f014f4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f014f8 <AT91F_SSC_EnableTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_EnableTx
//* \brief Enable sending datas
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_EnableTx (
	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
{
21f014f8:	e1a0c00d 	mov	ip, sp
21f014fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01500:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01504:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01508:	e50b0010 	str	r0, [fp, #-16]
    //* Enable  transmitter
    pSSC->SSC_CR = AT91C_SSC_TXEN;
21f0150c:	e51b2010 	ldr	r2, [fp, #-16]
21f01510:	e3a03c01 	mov	r3, #256	; 0x100
21f01514:	e5823000 	str	r3, [r2]
}
21f01518:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0151c <AT91F_SSC_DisableTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_DisableTx
//* \brief Disable sending datas
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_DisableTx (
	AT91PS_SSC pSSC)     // \arg pointer to a SSC controller
{
21f0151c:	e1a0c00d 	mov	ip, sp
21f01520:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01524:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01528:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0152c:	e50b0010 	str	r0, [fp, #-16]
    //* Disable  transmitter
    pSSC->SSC_CR = AT91C_SSC_TXDIS;
21f01530:	e51b2010 	ldr	r2, [fp, #-16]
21f01534:	e3a03c02 	mov	r3, #512	; 0x200
21f01538:	e5823000 	str	r3, [r2]
}
21f0153c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01540 <AT91F_SSC_EnableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_EnableIt
//* \brief Enable SSC IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_EnableIt (
	AT91PS_SSC pSSC, // \arg pointer to a SSC controller
	unsigned int flag)   // \arg IT to be enabled
{
21f01540:	e1a0c00d 	mov	ip, sp
21f01544:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01548:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0154c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01550:	e50b0010 	str	r0, [fp, #-16]
21f01554:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IER register
	pSSC->SSC_IER = flag;
21f01558:	e51b2010 	ldr	r2, [fp, #-16]
21f0155c:	e51b3014 	ldr	r3, [fp, #-20]
21f01560:	e5823044 	str	r3, [r2, #68]
}
21f01564:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01568:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0156c <AT91F_SSC_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_DisableIt
//* \brief Disable SSC IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC_DisableIt (
	AT91PS_SSC pSSC, // \arg pointer to a SSC controller
	unsigned int flag)   // \arg IT to be disabled
{
21f0156c:	e1a0c00d 	mov	ip, sp
21f01570:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01574:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01578:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0157c:	e50b0010 	str	r0, [fp, #-16]
21f01580:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IDR register
	pSSC->SSC_IDR = flag;
21f01584:	e51b2010 	ldr	r2, [fp, #-16]
21f01588:	e51b3014 	ldr	r3, [fp, #-20]
21f0158c:	e5823048 	str	r3, [r2, #72]
}
21f01590:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01594:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01598 <AT91F_SSC_ReceiveFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_ReceiveFrame
//* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been initialized with Next Buffer, 0 if PDC is busy
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_SSC_ReceiveFrame (
	AT91PS_SSC pSSC,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f01598:	e1a0c00d 	mov	ip, sp
21f0159c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f015a0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f015a4:	e24dd014 	sub	sp, sp, #20	; 0x14
21f015a8:	e50b0010 	str	r0, [fp, #-16]
21f015ac:	e50b1014 	str	r1, [fp, #-20]
21f015b0:	e50b2018 	str	r2, [fp, #-24]
21f015b4:	e50b301c 	str	r3, [fp, #-28]
	return AT91F_PDC_ReceiveFrame(
21f015b8:	e51b3010 	ldr	r3, [fp, #-16]
21f015bc:	e2833c01 	add	r3, r3, #256	; 0x100
21f015c0:	e1a02003 	mov	r2, r3
21f015c4:	e59b3004 	ldr	r3, [fp, #4]
21f015c8:	e58d3000 	str	r3, [sp]
21f015cc:	e1a00002 	mov	r0, r2
21f015d0:	e51b1014 	ldr	r1, [fp, #-20]
21f015d4:	e51b2018 	ldr	r2, [fp, #-24]
21f015d8:	e51b301c 	ldr	r3, [fp, #-28]
21f015dc:	ebfffecf 	bl	21f01120 <AT91F_PDC_ReceiveFrame>
21f015e0:	e1a03000 	mov	r3, r0
		(AT91PS_PDC) &(pSSC->SSC_RPR),
		pBuffer,
		szBuffer,
		pNextBuffer,
		szNextBuffer);
}
21f015e4:	e1a00003 	mov	r0, r3
21f015e8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f015ec:	e89da800 	ldmia	sp, {fp, sp, pc}

21f015f0 <AT91F_SSC_SendFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_SendFrame
//* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been initialized with Next Buffer, 0 if PDC is busy
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_SSC_SendFrame(
	AT91PS_SSC pSSC,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f015f0:	e1a0c00d 	mov	ip, sp
21f015f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f015f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f015fc:	e24dd014 	sub	sp, sp, #20	; 0x14
21f01600:	e50b0010 	str	r0, [fp, #-16]
21f01604:	e50b1014 	str	r1, [fp, #-20]
21f01608:	e50b2018 	str	r2, [fp, #-24]
21f0160c:	e50b301c 	str	r3, [fp, #-28]
	return AT91F_PDC_SendFrame(
21f01610:	e51b3010 	ldr	r3, [fp, #-16]
21f01614:	e2833c01 	add	r3, r3, #256	; 0x100
21f01618:	e1a02003 	mov	r2, r3
21f0161c:	e59b3004 	ldr	r3, [fp, #4]
21f01620:	e58d3000 	str	r3, [sp]
21f01624:	e1a00002 	mov	r0, r2
21f01628:	e51b1014 	ldr	r1, [fp, #-20]
21f0162c:	e51b2018 	ldr	r2, [fp, #-24]
21f01630:	e51b301c 	ldr	r3, [fp, #-28]
21f01634:	ebfffe8f 	bl	21f01078 <AT91F_PDC_SendFrame>
21f01638:	e1a03000 	mov	r3, r0
		(AT91PS_PDC) &(pSSC->SSC_RPR),
		pBuffer,
		szBuffer,
		pNextBuffer,
		szNextBuffer);
}
21f0163c:	e1a00003 	mov	r0, r3
21f01640:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01644:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01648 <AT91F_SSC_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_GetInterruptMaskStatus
//* \brief Return SSC Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_SSC_GetInterruptMaskStatus( // \return SSC Interrupt Mask Status
        AT91PS_SSC pSsc) // \arg  pointer to a SSC controller
{
21f01648:	e1a0c00d 	mov	ip, sp
21f0164c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01650:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01654:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01658:	e50b0010 	str	r0, [fp, #-16]
        return pSsc->SSC_IMR;
21f0165c:	e51b3010 	ldr	r3, [fp, #-16]
21f01660:	e593304c 	ldr	r3, [r3, #76]
}
21f01664:	e1a00003 	mov	r0, r3
21f01668:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0166c <AT91F_SSC_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC_IsInterruptMasked
//* \brief Test if SSC Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_SSC_IsInterruptMasked(
        AT91PS_SSC pSsc,   // \arg  pointer to a SSC controller
        unsigned int flag) // \arg  flag to be tested
{
21f0166c:	e1a0c00d 	mov	ip, sp
21f01670:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01674:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01678:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0167c:	e50b0010 	str	r0, [fp, #-16]
21f01680:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_SSC_GetInterruptMaskStatus(pSsc) & flag);
21f01684:	e51b0010 	ldr	r0, [fp, #-16]
21f01688:	ebffffee 	bl	21f01648 <AT91F_SSC_GetInterruptMaskStatus>
21f0168c:	e1a02000 	mov	r2, r0
21f01690:	e51b3014 	ldr	r3, [fp, #-20]
21f01694:	e0023003 	and	r3, r2, r3
}
21f01698:	e1a00003 	mov	r0, r3
21f0169c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f016a0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f016a4 <AT91F_SPI_Open>:

/* *****************************************************************************
                SOFTWARE API FOR SPI
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Open
//* \brief Open a SPI Port
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_SPI_Open (
        const unsigned int null)  // \arg
{
21f016a4:	e1a0c00d 	mov	ip, sp
21f016a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f016ac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f016b0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f016b4:	e50b0010 	str	r0, [fp, #-16]
        /* NOT DEFINED AT THIS MOMENT */
        return ( 0 );
21f016b8:	e3a03000 	mov	r3, #0	; 0x0
}
21f016bc:	e1a00003 	mov	r0, r3
21f016c0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f016c4 <AT91F_SPI_CfgCs>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_CfgCs
//* \brief Configure SPI chip select register
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_CfgCs (
	int cs,     // SPI cs number (0 to 3)
 	int val)   //  chip select register
{
21f016c4:	e1a0c00d 	mov	ip, sp
21f016c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f016cc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f016d0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f016d4:	e50b0010 	str	r0, [fp, #-16]
21f016d8:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the CSR register
	*(AT91C_SPI_CSR + cs) = val;
21f016dc:	e51b3010 	ldr	r3, [fp, #-16]
21f016e0:	e1a03103 	mov	r3, r3, lsl #2
21f016e4:	e2433b7f 	sub	r3, r3, #130048	; 0x1fc00
21f016e8:	e2433e3d 	sub	r3, r3, #976	; 0x3d0
21f016ec:	e51b2014 	ldr	r2, [fp, #-20]
21f016f0:	e5832000 	str	r2, [r3]
}
21f016f4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f016f8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f016fc <AT91F_SPI_EnableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_EnableIt
//* \brief Enable SPI interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_EnableIt (
	AT91PS_SPI pSPI,     // pointer to a SPI controller
	unsigned int flag)   // IT to be enabled
{
21f016fc:	e1a0c00d 	mov	ip, sp
21f01700:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01704:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01708:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0170c:	e50b0010 	str	r0, [fp, #-16]
21f01710:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IER register
	pSPI->SPI_IER = flag;
21f01714:	e51b2010 	ldr	r2, [fp, #-16]
21f01718:	e51b3014 	ldr	r3, [fp, #-20]
21f0171c:	e5823014 	str	r3, [r2, #20]
}
21f01720:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01724:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01728 <AT91F_SPI_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_DisableIt
//* \brief Disable SPI interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_DisableIt (
	AT91PS_SPI pSPI, // pointer to a SPI controller
	unsigned int flag) // IT to be disabled
{
21f01728:	e1a0c00d 	mov	ip, sp
21f0172c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01730:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01734:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01738:	e50b0010 	str	r0, [fp, #-16]
21f0173c:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IDR register
	pSPI->SPI_IDR = flag;
21f01740:	e51b2010 	ldr	r2, [fp, #-16]
21f01744:	e51b3014 	ldr	r3, [fp, #-20]
21f01748:	e5823018 	str	r3, [r2, #24]
}
21f0174c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01750:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01754 <AT91F_SPI_Reset>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Reset
//* \brief Reset the SPI controller
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_Reset (
	AT91PS_SPI pSPI // pointer to a SPI controller
	)
{
21f01754:	e1a0c00d 	mov	ip, sp
21f01758:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0175c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01760:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01764:	e50b0010 	str	r0, [fp, #-16]
	//* Write to the CR register
	pSPI->SPI_CR = AT91C_SPI_SWRST;
21f01768:	e51b2010 	ldr	r2, [fp, #-16]
21f0176c:	e3a03080 	mov	r3, #128	; 0x80
21f01770:	e5823000 	str	r3, [r2]
}
21f01774:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01778 <AT91F_SPI_Enable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Enable
//* \brief Enable the SPI controller
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_Enable (
	AT91PS_SPI pSPI // pointer to a SPI controller
	)
{
21f01778:	e1a0c00d 	mov	ip, sp
21f0177c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01780:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01784:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01788:	e50b0010 	str	r0, [fp, #-16]
	//* Write to the CR register
	pSPI->SPI_CR = AT91C_SPI_SPIEN;
21f0178c:	e51b2010 	ldr	r2, [fp, #-16]
21f01790:	e3a03001 	mov	r3, #1	; 0x1
21f01794:	e5823000 	str	r3, [r2]
}
21f01798:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0179c <AT91F_SPI_Disable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Disable
//* \brief Disable the SPI controller
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_Disable (
	AT91PS_SPI pSPI // pointer to a SPI controller
	)
{
21f0179c:	e1a0c00d 	mov	ip, sp
21f017a0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f017a4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f017a8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f017ac:	e50b0010 	str	r0, [fp, #-16]
	//* Write to the CR register
	pSPI->SPI_CR = AT91C_SPI_SPIDIS;
21f017b0:	e51b2010 	ldr	r2, [fp, #-16]
21f017b4:	e3a03002 	mov	r3, #2	; 0x2
21f017b8:	e5823000 	str	r3, [r2]
}
21f017bc:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f017c0 <AT91F_SPI_CfgMode>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_CfgMode
//* \brief Enable the SPI controller
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_CfgMode (
	AT91PS_SPI pSPI, // pointer to a SPI controller
	int mode)        // mode register 
{
21f017c0:	e1a0c00d 	mov	ip, sp
21f017c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f017c8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f017cc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f017d0:	e50b0010 	str	r0, [fp, #-16]
21f017d4:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the MR register
	pSPI->SPI_MR = mode;
21f017d8:	e51b2014 	ldr	r2, [fp, #-20]
21f017dc:	e51b3010 	ldr	r3, [fp, #-16]
21f017e0:	e5832004 	str	r2, [r3, #4]
}
21f017e4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f017e8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f017ec <AT91F_SPI_CfgPCS>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_CfgPCS
//* \brief Switch to the correct PCS of SPI Mode Register : Fixed Peripheral Selected
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_CfgPCS (
	AT91PS_SPI pSPI, // pointer to a SPI controller
	char PCS_Device) // PCS of the Device
{	
21f017ec:	e1a0c00d 	mov	ip, sp
21f017f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f017f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f017f8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f017fc:	e50b0010 	str	r0, [fp, #-16]
21f01800:	e1a03001 	mov	r3, r1
21f01804:	e54b3014 	strb	r3, [fp, #-20]
 	//* Write to the MR register
	pSPI->SPI_MR &= 0xFFF0FFFF;
21f01808:	e51b3010 	ldr	r3, [fp, #-16]
21f0180c:	e5933004 	ldr	r3, [r3, #4]
21f01810:	e3c3280f 	bic	r2, r3, #983040	; 0xf0000
21f01814:	e51b3010 	ldr	r3, [fp, #-16]
21f01818:	e5832004 	str	r2, [r3, #4]
	pSPI->SPI_MR |= ( (PCS_Device<<16) & AT91C_SPI_PCS );
21f0181c:	e51b3010 	ldr	r3, [fp, #-16]
21f01820:	e5932004 	ldr	r2, [r3, #4]
21f01824:	e55b3014 	ldrb	r3, [fp, #-20]
21f01828:	e1a03803 	mov	r3, r3, lsl #16
21f0182c:	e203380f 	and	r3, r3, #983040	; 0xf0000
21f01830:	e1822003 	orr	r2, r2, r3
21f01834:	e51b3010 	ldr	r3, [fp, #-16]
21f01838:	e5832004 	str	r2, [r3, #4]
}
21f0183c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01840:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01844 <AT91F_SPI_ReceiveFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_ReceiveFrame
//* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been initializaed with Next Buffer, 0 if PDC is busy
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_SPI_ReceiveFrame (
	AT91PS_SPI pSPI,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f01844:	e1a0c00d 	mov	ip, sp
21f01848:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0184c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01850:	e24dd014 	sub	sp, sp, #20	; 0x14
21f01854:	e50b0010 	str	r0, [fp, #-16]
21f01858:	e50b1014 	str	r1, [fp, #-20]
21f0185c:	e50b2018 	str	r2, [fp, #-24]
21f01860:	e50b301c 	str	r3, [fp, #-28]
	return AT91F_PDC_ReceiveFrame(
21f01864:	e51b3010 	ldr	r3, [fp, #-16]
21f01868:	e2833c01 	add	r3, r3, #256	; 0x100
21f0186c:	e1a02003 	mov	r2, r3
21f01870:	e59b3004 	ldr	r3, [fp, #4]
21f01874:	e58d3000 	str	r3, [sp]
21f01878:	e1a00002 	mov	r0, r2
21f0187c:	e51b1014 	ldr	r1, [fp, #-20]
21f01880:	e51b2018 	ldr	r2, [fp, #-24]
21f01884:	e51b301c 	ldr	r3, [fp, #-28]
21f01888:	ebfffe24 	bl	21f01120 <AT91F_PDC_ReceiveFrame>
21f0188c:	e1a03000 	mov	r3, r0
		(AT91PS_PDC) &(pSPI->SPI_RPR),
		pBuffer,
		szBuffer,
		pNextBuffer,
		szNextBuffer);
}
21f01890:	e1a00003 	mov	r0, r3
21f01894:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01898:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0189c <AT91F_SPI_SendFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_SendFrame
//* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been initializaed with Next Buffer, 0 if PDC is bSPIy
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_SPI_SendFrame(
	AT91PS_SPI pSPI,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f0189c:	e1a0c00d 	mov	ip, sp
21f018a0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f018a4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f018a8:	e24dd014 	sub	sp, sp, #20	; 0x14
21f018ac:	e50b0010 	str	r0, [fp, #-16]
21f018b0:	e50b1014 	str	r1, [fp, #-20]
21f018b4:	e50b2018 	str	r2, [fp, #-24]
21f018b8:	e50b301c 	str	r3, [fp, #-28]
	return AT91F_PDC_SendFrame(
21f018bc:	e51b3010 	ldr	r3, [fp, #-16]
21f018c0:	e2833c01 	add	r3, r3, #256	; 0x100
21f018c4:	e1a02003 	mov	r2, r3
21f018c8:	e59b3004 	ldr	r3, [fp, #4]
21f018cc:	e58d3000 	str	r3, [sp]
21f018d0:	e1a00002 	mov	r0, r2
21f018d4:	e51b1014 	ldr	r1, [fp, #-20]
21f018d8:	e51b2018 	ldr	r2, [fp, #-24]
21f018dc:	e51b301c 	ldr	r3, [fp, #-28]
21f018e0:	ebfffde4 	bl	21f01078 <AT91F_PDC_SendFrame>
21f018e4:	e1a03000 	mov	r3, r0
		(AT91PS_PDC) &(pSPI->SPI_RPR),
		pBuffer,
		szBuffer,
		pNextBuffer,
		szNextBuffer);
}
21f018e8:	e1a00003 	mov	r0, r3
21f018ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f018f0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f018f4 <AT91F_SPI_Close>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_Close
//* \brief Close SPI: disable IT disable transfert, close PDC
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_Close (
	AT91PS_SPI pSPI)     // \arg pointer to a SPI controller
{
21f018f4:	e1a0c00d 	mov	ip, sp
21f018f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f018fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01900:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01904:	e50b0010 	str	r0, [fp, #-16]
    //* Reset all the Chip Select register
    pSPI->SPI_CSR[0] = 0 ;
21f01908:	e51b2010 	ldr	r2, [fp, #-16]
21f0190c:	e3a03000 	mov	r3, #0	; 0x0
21f01910:	e5823030 	str	r3, [r2, #48]
    pSPI->SPI_CSR[1] = 0 ;
21f01914:	e51b2010 	ldr	r2, [fp, #-16]
21f01918:	e3a03000 	mov	r3, #0	; 0x0
21f0191c:	e5823034 	str	r3, [r2, #52]
    pSPI->SPI_CSR[2] = 0 ;
21f01920:	e51b2010 	ldr	r2, [fp, #-16]
21f01924:	e3a03000 	mov	r3, #0	; 0x0
21f01928:	e5823038 	str	r3, [r2, #56]
    pSPI->SPI_CSR[3] = 0 ;
21f0192c:	e51b2010 	ldr	r2, [fp, #-16]
21f01930:	e3a03000 	mov	r3, #0	; 0x0
21f01934:	e582303c 	str	r3, [r2, #60]

    //* Reset the SPI mode
    pSPI->SPI_MR = 0  ;
21f01938:	e51b2010 	ldr	r2, [fp, #-16]
21f0193c:	e3a03000 	mov	r3, #0	; 0x0
21f01940:	e5823004 	str	r3, [r2, #4]

    //* Disable all interrupts
    pSPI->SPI_IDR = 0xFFFFFFFF ;
21f01944:	e51b2010 	ldr	r2, [fp, #-16]
21f01948:	e3e03000 	mvn	r3, #0	; 0x0
21f0194c:	e5823018 	str	r3, [r2, #24]

    //* Abort the Peripheral Data Transfers
    AT91F_PDC_Close((AT91PS_PDC) &(pSPI->SPI_RPR));
21f01950:	e51b3010 	ldr	r3, [fp, #-16]
21f01954:	e2833c01 	add	r3, r3, #256	; 0x100
21f01958:	e1a00003 	mov	r0, r3
21f0195c:	ebfffdab 	bl	21f01010 <AT91F_PDC_Close>

    //* Disable receiver and transmitter and stop any activity immediately
    pSPI->SPI_CR = AT91C_SPI_SPIDIS;
21f01960:	e51b2010 	ldr	r2, [fp, #-16]
21f01964:	e3a03002 	mov	r3, #2	; 0x2
21f01968:	e5823000 	str	r3, [r2]
}
21f0196c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01970 <AT91F_SPI_PutChar>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_PutChar
//* \brief Send a character,does not check if ready to send
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_PutChar (
	AT91PS_SPI pSPI,
	unsigned int character,
             unsigned int cs_number )
{
21f01970:	e1a0c00d 	mov	ip, sp
21f01974:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01978:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0197c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f01980:	e50b0014 	str	r0, [fp, #-20]
21f01984:	e50b1018 	str	r1, [fp, #-24]
21f01988:	e50b201c 	str	r2, [fp, #-28]
    unsigned int value_for_cs;
    value_for_cs = (~(1 << cs_number)) & 0xF;  //Place a zero among a 4 ONEs number
21f0198c:	e51b201c 	ldr	r2, [fp, #-28]
21f01990:	e3a03001 	mov	r3, #1	; 0x1
21f01994:	e1a03213 	mov	r3, r3, lsl r2
21f01998:	e1e03003 	mvn	r3, r3
21f0199c:	e203300f 	and	r3, r3, #15	; 0xf
21f019a0:	e50b3010 	str	r3, [fp, #-16]
    pSPI->SPI_TDR = (character & 0xFFFF) | (value_for_cs << 16);
21f019a4:	e51b3018 	ldr	r3, [fp, #-24]
21f019a8:	e1a03803 	mov	r3, r3, lsl #16
21f019ac:	e1a03823 	mov	r3, r3, lsr #16
21f019b0:	e51b2010 	ldr	r2, [fp, #-16]
21f019b4:	e1a02802 	mov	r2, r2, lsl #16
21f019b8:	e1832002 	orr	r2, r3, r2
21f019bc:	e51b3014 	ldr	r3, [fp, #-20]
21f019c0:	e583200c 	str	r2, [r3, #12]
}
21f019c4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f019c8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f019cc <AT91F_SPI_GetChar>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_GetChar
//* \brief Receive a character,does not check if a character is available
//*----------------------------------------------------------------------------
__inline__ int AT91F_SPI_GetChar (
	const AT91PS_SPI pSPI)
{
21f019cc:	e1a0c00d 	mov	ip, sp
21f019d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f019d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f019d8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f019dc:	e50b0010 	str	r0, [fp, #-16]
    return((pSPI->SPI_RDR) & 0xFFFF);
21f019e0:	e51b3010 	ldr	r3, [fp, #-16]
21f019e4:	e5933008 	ldr	r3, [r3, #8]
21f019e8:	e1a03803 	mov	r3, r3, lsl #16
21f019ec:	e1a03823 	mov	r3, r3, lsr #16
}
21f019f0:	e1a00003 	mov	r0, r3
21f019f4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f019f8 <AT91F_SPI_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_GetInterruptMaskStatus
//* \brief Return SPI Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_SPI_GetInterruptMaskStatus( // \return SPI Interrupt Mask Status
        AT91PS_SPI pSpi) // \arg  pointer to a SPI controller
{
21f019f8:	e1a0c00d 	mov	ip, sp
21f019fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01a00:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01a04:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01a08:	e50b0010 	str	r0, [fp, #-16]
        return pSpi->SPI_IMR;
21f01a0c:	e51b3010 	ldr	r3, [fp, #-16]
21f01a10:	e593301c 	ldr	r3, [r3, #28]
}
21f01a14:	e1a00003 	mov	r0, r3
21f01a18:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01a1c <AT91F_SPI_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_IsInterruptMasked
//* \brief Test if SPI Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_SPI_IsInterruptMasked(
        AT91PS_SPI pSpi,   // \arg  pointer to a SPI controller
        unsigned int flag) // \arg  flag to be tested
{
21f01a1c:	e1a0c00d 	mov	ip, sp
21f01a20:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01a24:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01a28:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01a2c:	e50b0010 	str	r0, [fp, #-16]
21f01a30:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_SPI_GetInterruptMaskStatus(pSpi) & flag);
21f01a34:	e51b0010 	ldr	r0, [fp, #-16]
21f01a38:	ebffffee 	bl	21f019f8 <AT91F_SPI_GetInterruptMaskStatus>
21f01a3c:	e1a02000 	mov	r2, r0
21f01a40:	e51b3014 	ldr	r3, [fp, #-20]
21f01a44:	e0023003 	and	r3, r2, r3
}
21f01a48:	e1a00003 	mov	r0, r3
21f01a4c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01a50:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01a54 <AT91F_TC_InterruptEnable>:

/* *****************************************************************************
                SOFTWARE API FOR TC
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_TC_InterruptEnable
//* \brief Enable TC Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC_InterruptEnable(
        AT91PS_TC pTc,   // \arg  pointer to a TC controller
        unsigned int flag) // \arg  TC interrupt to be enabled
{
21f01a54:	e1a0c00d 	mov	ip, sp
21f01a58:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01a5c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01a60:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01a64:	e50b0010 	str	r0, [fp, #-16]
21f01a68:	e50b1014 	str	r1, [fp, #-20]
        pTc->TC_IER = flag;
21f01a6c:	e51b2010 	ldr	r2, [fp, #-16]
21f01a70:	e51b3014 	ldr	r3, [fp, #-20]
21f01a74:	e5823024 	str	r3, [r2, #36]
}
21f01a78:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01a7c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01a80 <AT91F_TC_InterruptDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC_InterruptDisable
//* \brief Disable TC Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC_InterruptDisable(
        AT91PS_TC pTc,   // \arg  pointer to a TC controller
        unsigned int flag) // \arg  TC interrupt to be disabled
{
21f01a80:	e1a0c00d 	mov	ip, sp
21f01a84:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01a88:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01a8c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01a90:	e50b0010 	str	r0, [fp, #-16]
21f01a94:	e50b1014 	str	r1, [fp, #-20]
        pTc->TC_IDR = flag;
21f01a98:	e51b2010 	ldr	r2, [fp, #-16]
21f01a9c:	e51b3014 	ldr	r3, [fp, #-20]
21f01aa0:	e5823028 	str	r3, [r2, #40]
}
21f01aa4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01aa8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01aac <AT91F_TC_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC_GetInterruptMaskStatus
//* \brief Return TC Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_TC_GetInterruptMaskStatus( // \return TC Interrupt Mask Status
        AT91PS_TC pTc) // \arg  pointer to a TC controller
{
21f01aac:	e1a0c00d 	mov	ip, sp
21f01ab0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01ab4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01ab8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f01abc:	e50b0010 	str	r0, [fp, #-16]
        return pTc->TC_IMR;
21f01ac0:	e51b3010 	ldr	r3, [fp, #-16]
21f01ac4:	e593302c 	ldr	r3, [r3, #44]
}
21f01ac8:	e1a00003 	mov	r0, r3
21f01acc:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f01ad0 <AT91F_TC_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC_IsInterruptMasked
//* \brief Test if TC Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_TC_IsInterruptMasked(
        AT91PS_TC pTc,   // \arg  pointer to a TC controller
        unsigned int flag) // \arg  flag to be tested
{
21f01ad0:	e1a0c00d 	mov	ip, sp
21f01ad4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01ad8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01adc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01ae0:	e50b0010 	str	r0, [fp, #-16]
21f01ae4:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_TC_GetInterruptMaskStatus(pTc) & flag);
21f01ae8:	e51b0010 	ldr	r0, [fp, #-16]
21f01aec:	ebffffee 	bl	21f01aac <AT91F_TC_GetInterruptMaskStatus>
21f01af0:	e1a02000 	mov	r2, r0
21f01af4:	e51b3014 	ldr	r3, [fp, #-20]
21f01af8:	e0023003 	and	r3, r2, r3
}
21f01afc:	e1a00003 	mov	r0, r3
21f01b00:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01b04:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01b08 <AT91F_CKGR_GetMainClock>:

/* *****************************************************************************
                SOFTWARE API FOR PMC
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_CKGR_GetMainClock
//* \brief Return Main clock in Hz
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_CKGR_GetMainClock (
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int slowClock)  // \arg slowClock in Hz
{
21f01b08:	e1a0c00d 	mov	ip, sp
21f01b0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01b10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01b14:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01b18:	e50b0010 	str	r0, [fp, #-16]
21f01b1c:	e50b1014 	str	r1, [fp, #-20]
	return ((pCKGR->CKGR_MCFR  & AT91C_CKGR_MAINF) * slowClock) >> 4;
21f01b20:	e51b3010 	ldr	r3, [fp, #-16]
21f01b24:	e5933004 	ldr	r3, [r3, #4]
21f01b28:	e1a03803 	mov	r3, r3, lsl #16
21f01b2c:	e1a03823 	mov	r3, r3, lsr #16
21f01b30:	e51b2014 	ldr	r2, [fp, #-20]
21f01b34:	e0030392 	mul	r3, r2, r3
21f01b38:	e1a03223 	mov	r3, r3, lsr #4
}
21f01b3c:	e1a00003 	mov	r0, r3
21f01b40:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01b44:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01b48 <AT91F_PMC_GetProcessorClock>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_GetProcessorClock
//* \brief Return processor clock in Hz (for AT91RM3400 and AT91RM9200)
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PMC_GetProcessorClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int slowClock)  // \arg slowClock in Hz
{
21f01b48:	e1a0c00d 	mov	ip, sp
21f01b4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01b50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01b54:	e24dd020 	sub	sp, sp, #32	; 0x20
21f01b58:	e50b0020 	str	r0, [fp, #-32]
21f01b5c:	e50b1024 	str	r1, [fp, #-36]
21f01b60:	e50b2028 	str	r2, [fp, #-40]
	unsigned int reg = pPMC->PMC_MCKR;
21f01b64:	e51b3020 	ldr	r3, [fp, #-32]
21f01b68:	e5933030 	ldr	r3, [r3, #48]
21f01b6c:	e50b301c 	str	r3, [fp, #-28]
	unsigned int prescaler = (1 << ((reg & AT91C_PMC_PRES) >> 2));
21f01b70:	e51b301c 	ldr	r3, [fp, #-28]
21f01b74:	e203301c 	and	r3, r3, #28	; 0x1c
21f01b78:	e1a03123 	mov	r3, r3, lsr #2
21f01b7c:	e1a02003 	mov	r2, r3
21f01b80:	e3a03001 	mov	r3, #1	; 0x1
21f01b84:	e1a03213 	mov	r3, r3, lsl r2
21f01b88:	e50b3018 	str	r3, [fp, #-24]
	unsigned int pllDivider, pllMultiplier;

	switch (reg & AT91C_PMC_CSS) {
21f01b8c:	e51b301c 	ldr	r3, [fp, #-28]
21f01b90:	e2033003 	and	r3, r3, #3	; 0x3
21f01b94:	e3530003 	cmp	r3, #3	; 0x3
21f01b98:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f01b9c:	ea000062 	b	21f01d2c <.text+0x1d2c>
21f01ba0:	21f01bb0 	ldrcsh	r1, [r0, #176]!
21f01ba4:	21f01bc8 	mvncss	r1, r8, asr #23
21f01ba8:	21f01bf0 	ldrcssh	r1, [r0, #176]!
21f01bac:	21f01cb4 	ldrcsh	r1, [r0, #196]!
		case AT91C_PMC_CSS_SLOW_CLK: // Slow clock selected
			return slowClock / prescaler;
21f01bb0:	e51b0028 	ldr	r0, [fp, #-40]
21f01bb4:	e51b1018 	ldr	r1, [fp, #-24]
21f01bb8:	eb000fbd 	bl	21f05ab4 <__udivsi3>
21f01bbc:	e1a03000 	mov	r3, r0
21f01bc0:	e50b302c 	str	r3, [fp, #-44]
21f01bc4:	ea00005a 	b	21f01d34 <.text+0x1d34>
		case AT91C_PMC_CSS_MAIN_CLK: // Main clock is selected
			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / prescaler;
21f01bc8:	e51b0024 	ldr	r0, [fp, #-36]
21f01bcc:	e51b1028 	ldr	r1, [fp, #-40]
21f01bd0:	ebffffcc 	bl	21f01b08 <AT91F_CKGR_GetMainClock>
21f01bd4:	e1a03000 	mov	r3, r0
21f01bd8:	e1a00003 	mov	r0, r3
21f01bdc:	e51b1018 	ldr	r1, [fp, #-24]
21f01be0:	eb000fb3 	bl	21f05ab4 <__udivsi3>
21f01be4:	e1a03000 	mov	r3, r0
21f01be8:	e50b302c 	str	r3, [fp, #-44]
21f01bec:	ea000050 	b	21f01d34 <.text+0x1d34>
		case AT91C_PMC_CSS_PLLA_CLK: // PLLA clock is selected
			reg = pCKGR->CKGR_PLLAR;
21f01bf0:	e51b3024 	ldr	r3, [fp, #-36]
21f01bf4:	e5933008 	ldr	r3, [r3, #8]
21f01bf8:	e50b301c 	str	r3, [fp, #-28]
			pllDivider    = (reg  & AT91C_CKGR_DIVA);
21f01bfc:	e51b301c 	ldr	r3, [fp, #-28]
21f01c00:	e20330ff 	and	r3, r3, #255	; 0xff
21f01c04:	e50b3014 	str	r3, [fp, #-20]
			pllMultiplier = ((reg  & AT91C_CKGR_MULA) >> 16) + 1;
21f01c08:	e51b301c 	ldr	r3, [fp, #-28]
21f01c0c:	e3c3333e 	bic	r3, r3, #-134217728	; 0xf8000000
21f01c10:	e1a03823 	mov	r3, r3, lsr #16
21f01c14:	e1a03803 	mov	r3, r3, lsl #16
21f01c18:	e1a03823 	mov	r3, r3, lsr #16
21f01c1c:	e2833001 	add	r3, r3, #1	; 0x1
21f01c20:	e50b3010 	str	r3, [fp, #-16]
			if (reg & AT91C_CKGR_SRCA) // Source is Main clock
21f01c24:	e51b301c 	ldr	r3, [fp, #-28]
21f01c28:	e1a03ea3 	mov	r3, r3, lsr #29
21f01c2c:	e2033001 	and	r3, r3, #1	; 0x1
21f01c30:	e20330ff 	and	r3, r3, #255	; 0xff
21f01c34:	e3530000 	cmp	r3, #0	; 0x0
21f01c38:	0a000010 	beq	21f01c80 <.text+0x1c80>
				return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / pllDivider * pllMultiplier / prescaler;
21f01c3c:	e51b0024 	ldr	r0, [fp, #-36]
21f01c40:	e51b1028 	ldr	r1, [fp, #-40]
21f01c44:	ebffffaf 	bl	21f01b08 <AT91F_CKGR_GetMainClock>
21f01c48:	e1a03000 	mov	r3, r0
21f01c4c:	e1a00003 	mov	r0, r3
21f01c50:	e51b1014 	ldr	r1, [fp, #-20]
21f01c54:	eb000f96 	bl	21f05ab4 <__udivsi3>
21f01c58:	e1a03000 	mov	r3, r0
21f01c5c:	e1a02003 	mov	r2, r3
21f01c60:	e51b3010 	ldr	r3, [fp, #-16]
21f01c64:	e0030392 	mul	r3, r2, r3
21f01c68:	e1a00003 	mov	r0, r3
21f01c6c:	e51b1018 	ldr	r1, [fp, #-24]
21f01c70:	eb000f8f 	bl	21f05ab4 <__udivsi3>
21f01c74:	e1a03000 	mov	r3, r0
21f01c78:	e50b302c 	str	r3, [fp, #-44]
21f01c7c:	ea00002c 	b	21f01d34 <.text+0x1d34>
			else                       // Source is Slow clock
				return slowClock / pllDivider * pllMultiplier / prescaler;
21f01c80:	e51b0028 	ldr	r0, [fp, #-40]
21f01c84:	e51b1014 	ldr	r1, [fp, #-20]
21f01c88:	eb000f89 	bl	21f05ab4 <__udivsi3>
21f01c8c:	e1a03000 	mov	r3, r0
21f01c90:	e1a02003 	mov	r2, r3
21f01c94:	e51b3010 	ldr	r3, [fp, #-16]
21f01c98:	e0030392 	mul	r3, r2, r3
21f01c9c:	e1a00003 	mov	r0, r3
21f01ca0:	e51b1018 	ldr	r1, [fp, #-24]
21f01ca4:	eb000f82 	bl	21f05ab4 <__udivsi3>
21f01ca8:	e1a03000 	mov	r3, r0
21f01cac:	e50b302c 	str	r3, [fp, #-44]
21f01cb0:	ea00001f 	b	21f01d34 <.text+0x1d34>
		case AT91C_PMC_CSS_PLLB_CLK: // PLLB clock is selected
			reg = pCKGR->CKGR_PLLBR;
21f01cb4:	e51b3024 	ldr	r3, [fp, #-36]
21f01cb8:	e593300c 	ldr	r3, [r3, #12]
21f01cbc:	e50b301c 	str	r3, [fp, #-28]
			pllDivider    = (reg  & AT91C_CKGR_DIVB);
21f01cc0:	e51b301c 	ldr	r3, [fp, #-28]
21f01cc4:	e20330ff 	and	r3, r3, #255	; 0xff
21f01cc8:	e50b3014 	str	r3, [fp, #-20]
			pllMultiplier = ((reg  & AT91C_CKGR_MULB) >> 16) + 1;
21f01ccc:	e51b301c 	ldr	r3, [fp, #-28]
21f01cd0:	e3c3333e 	bic	r3, r3, #-134217728	; 0xf8000000
21f01cd4:	e1a03823 	mov	r3, r3, lsr #16
21f01cd8:	e1a03803 	mov	r3, r3, lsl #16
21f01cdc:	e1a03823 	mov	r3, r3, lsr #16
21f01ce0:	e2833001 	add	r3, r3, #1	; 0x1
21f01ce4:	e50b3010 	str	r3, [fp, #-16]
			return AT91F_CKGR_GetMainClock(pCKGR, slowClock) / pllDivider * pllMultiplier / prescaler;
21f01ce8:	e51b0024 	ldr	r0, [fp, #-36]
21f01cec:	e51b1028 	ldr	r1, [fp, #-40]
21f01cf0:	ebffff84 	bl	21f01b08 <AT91F_CKGR_GetMainClock>
21f01cf4:	e1a03000 	mov	r3, r0
21f01cf8:	e1a00003 	mov	r0, r3
21f01cfc:	e51b1014 	ldr	r1, [fp, #-20]
21f01d00:	eb000f6b 	bl	21f05ab4 <__udivsi3>
21f01d04:	e1a03000 	mov	r3, r0
21f01d08:	e1a02003 	mov	r2, r3
21f01d0c:	e51b3010 	ldr	r3, [fp, #-16]
21f01d10:	e0030392 	mul	r3, r2, r3
21f01d14:	e1a00003 	mov	r0, r3
21f01d18:	e51b1018 	ldr	r1, [fp, #-24]
21f01d1c:	eb000f64 	bl	21f05ab4 <__udivsi3>
21f01d20:	e1a03000 	mov	r3, r0
21f01d24:	e50b302c 	str	r3, [fp, #-44]
21f01d28:	ea000001 	b	21f01d34 <.text+0x1d34>
	}
	return 0;
21f01d2c:	e3a03000 	mov	r3, #0	; 0x0
21f01d30:	e50b302c 	str	r3, [fp, #-44]
21f01d34:	e51b302c 	ldr	r3, [fp, #-44]
}
21f01d38:	e1a00003 	mov	r0, r3
21f01d3c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01d40:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01d44 <AT91F_PMC_GetMasterClock>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_GetMasterClock
//* \brief Return master clock in Hz (just for AT91RM9200)
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PMC_GetMasterClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	AT91PS_CKGR pCKGR, // \arg pointer to CKGR controller
	unsigned int slowClock)  // \arg slowClock in Hz
{
21f01d44:	e1a0c00d 	mov	ip, sp
21f01d48:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01d4c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01d50:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f01d54:	e50b0010 	str	r0, [fp, #-16]
21f01d58:	e50b1014 	str	r1, [fp, #-20]
21f01d5c:	e50b2018 	str	r2, [fp, #-24]
	return AT91F_PMC_GetProcessorClock(pPMC, pCKGR, slowClock) /
21f01d60:	e51b0010 	ldr	r0, [fp, #-16]
21f01d64:	e51b1014 	ldr	r1, [fp, #-20]
21f01d68:	e51b2018 	ldr	r2, [fp, #-24]
21f01d6c:	ebffff75 	bl	21f01b48 <AT91F_PMC_GetProcessorClock>
21f01d70:	e1a02000 	mov	r2, r0
21f01d74:	e51b3010 	ldr	r3, [fp, #-16]
21f01d78:	e5933030 	ldr	r3, [r3, #48]
21f01d7c:	e2033c03 	and	r3, r3, #768	; 0x300
21f01d80:	e1a03423 	mov	r3, r3, lsr #8
21f01d84:	e2833001 	add	r3, r3, #1	; 0x1
21f01d88:	e1a00002 	mov	r0, r2
21f01d8c:	e1a01003 	mov	r1, r3
21f01d90:	eb000f47 	bl	21f05ab4 <__udivsi3>
21f01d94:	e1a03000 	mov	r3, r0
		(((pPMC->PMC_MCKR & AT91C_PMC_MDIV) >> 8)+1);
}
21f01d98:	e1a00003 	mov	r0, r3
21f01d9c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01da0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01da4 <AT91F_PMC_EnablePeriphClock>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_EnablePeriphClock
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
__inline__ void AT91F_PMC_EnablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals to enable
{
21f01da4:	e1a0c00d 	mov	ip, sp
21f01da8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01dac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01db0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01db4:	e50b0010 	str	r0, [fp, #-16]
21f01db8:	e50b1014 	str	r1, [fp, #-20]
	pPMC->PMC_PCER = periphIds;
21f01dbc:	e51b2010 	ldr	r2, [fp, #-16]
21f01dc0:	e51b3014 	ldr	r3, [fp, #-20]
21f01dc4:	e5823010 	str	r3, [r2, #16]
}
21f01dc8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01dcc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01dd0 <AT91F_PMC_DisablePeriphClock>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_DisablePeriphClock
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
__inline__ void AT91F_PMC_DisablePeriphClock (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int periphIds)  // \arg IDs of peripherals to enable
{
21f01dd0:	e1a0c00d 	mov	ip, sp
21f01dd4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01dd8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01ddc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01de0:	e50b0010 	str	r0, [fp, #-16]
21f01de4:	e50b1014 	str	r1, [fp, #-20]
	pPMC->PMC_PCDR = periphIds;
21f01de8:	e51b2010 	ldr	r2, [fp, #-16]
21f01dec:	e51b3014 	ldr	r3, [fp, #-20]
21f01df0:	e5823014 	str	r3, [r2, #20]
}
21f01df4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01df8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01dfc <AT91F_PMC_EnablePCK>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_EnablePCK
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
__inline__ void AT91F_PMC_EnablePCK (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int pck,  // \arg Peripheral clock identifier 0 .. 7
	unsigned int ccs,  // \arg clock selection: AT91C_PMC_CSS_SLOW_CLK, AT91C_PMC_CSS_MAIN_CLK, AT91C_PMC_CSS_PLLA_CLK, AT91C_PMC_CSS_PLLB_CLK
	unsigned int pres) // \arg Programmable clock prescalar AT91C_PMC_PRES_CLK, AT91C_PMC_PRES_CLK_2, ..., AT91C_PMC_PRES_CLK_64
{
21f01dfc:	e1a0c00d 	mov	ip, sp
21f01e00:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01e04:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01e08:	e24dd010 	sub	sp, sp, #16	; 0x10
21f01e0c:	e50b0010 	str	r0, [fp, #-16]
21f01e10:	e50b1014 	str	r1, [fp, #-20]
21f01e14:	e50b2018 	str	r2, [fp, #-24]
21f01e18:	e50b301c 	str	r3, [fp, #-28]
	pPMC->PMC_PCKR[pck] = ccs | pres;
21f01e1c:	e51b0014 	ldr	r0, [fp, #-20]
21f01e20:	e51b2018 	ldr	r2, [fp, #-24]
21f01e24:	e51b301c 	ldr	r3, [fp, #-28]
21f01e28:	e182c003 	orr	ip, r2, r3
21f01e2c:	e51b2010 	ldr	r2, [fp, #-16]
21f01e30:	e3a01040 	mov	r1, #64	; 0x40
21f01e34:	e1a03100 	mov	r3, r0, lsl #2
21f01e38:	e0833002 	add	r3, r3, r2
21f01e3c:	e0833001 	add	r3, r3, r1
21f01e40:	e583c000 	str	ip, [r3]
	pPMC->PMC_SCER = (1 << pck) << 8;
21f01e44:	e51b2014 	ldr	r2, [fp, #-20]
21f01e48:	e3a03001 	mov	r3, #1	; 0x1
21f01e4c:	e1a03213 	mov	r3, r3, lsl r2
21f01e50:	e1a03403 	mov	r3, r3, lsl #8
21f01e54:	e1a02003 	mov	r2, r3
21f01e58:	e51b3010 	ldr	r3, [fp, #-16]
21f01e5c:	e5832000 	str	r2, [r3]
}
21f01e60:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01e64:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01e68 <AT91F_PMC_DisablePCK>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_DisablePCK
//* \brief Enable peripheral clock
//*----------------------------------------------------------------------------
__inline__ void AT91F_PMC_DisablePCK (
	AT91PS_PMC pPMC, // \arg pointer to PMC controller
	unsigned int pck)  // \arg Peripheral clock identifier 0 .. 7
{
21f01e68:	e1a0c00d 	mov	ip, sp
21f01e6c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01e70:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01e74:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01e78:	e50b0010 	str	r0, [fp, #-16]
21f01e7c:	e50b1014 	str	r1, [fp, #-20]
	pPMC->PMC_SCDR = (1 << pck) << 8;
21f01e80:	e51b2014 	ldr	r2, [fp, #-20]
21f01e84:	e3a03001 	mov	r3, #1	; 0x1
21f01e88:	e1a03213 	mov	r3, r3, lsl r2
21f01e8c:	e1a03403 	mov	r3, r3, lsl #8
21f01e90:	e1a02003 	mov	r2, r3
21f01e94:	e51b3010 	ldr	r3, [fp, #-16]
21f01e98:	e5832004 	str	r2, [r3, #4]
}
21f01e9c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01ea0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01ea4 <AT91F_PIO_CfgPeriph>:

/* *****************************************************************************
                SOFTWARE API FOR PIO
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgPeriph
//* \brief Enable pins to be drived by peripheral
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_CfgPeriph(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int periphAEnable,  // \arg PERIPH A to enable
	unsigned int periphBEnable)  // \arg PERIPH B to enable

{
21f01ea4:	e1a0c00d 	mov	ip, sp
21f01ea8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01eac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01eb0:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f01eb4:	e50b0010 	str	r0, [fp, #-16]
21f01eb8:	e50b1014 	str	r1, [fp, #-20]
21f01ebc:	e50b2018 	str	r2, [fp, #-24]
	pPio->PIO_ASR = periphAEnable;
21f01ec0:	e51b2010 	ldr	r2, [fp, #-16]
21f01ec4:	e51b3014 	ldr	r3, [fp, #-20]
21f01ec8:	e5823070 	str	r3, [r2, #112]
	pPio->PIO_BSR = periphBEnable;
21f01ecc:	e51b2010 	ldr	r2, [fp, #-16]
21f01ed0:	e51b3018 	ldr	r3, [fp, #-24]
21f01ed4:	e5823074 	str	r3, [r2, #116]
	pPio->PIO_PDR = (periphAEnable | periphBEnable); // Set in Periph mode
21f01ed8:	e51b2014 	ldr	r2, [fp, #-20]
21f01edc:	e51b3018 	ldr	r3, [fp, #-24]
21f01ee0:	e1822003 	orr	r2, r2, r3
21f01ee4:	e51b3010 	ldr	r3, [fp, #-16]
21f01ee8:	e5832004 	str	r2, [r3, #4]
}
21f01eec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01ef0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01ef4 <AT91F_PIO_CfgOutput>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgOutput
//* \brief Enable PIO in output mode
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_CfgOutput(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int pioEnable)      // \arg PIO to be enabled
{
21f01ef4:	e1a0c00d 	mov	ip, sp
21f01ef8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01efc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01f00:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01f04:	e50b0010 	str	r0, [fp, #-16]
21f01f08:	e50b1014 	str	r1, [fp, #-20]
	pPio->PIO_PER = pioEnable; // Set in PIO mode
21f01f0c:	e51b2010 	ldr	r2, [fp, #-16]
21f01f10:	e51b3014 	ldr	r3, [fp, #-20]
21f01f14:	e5823000 	str	r3, [r2]
	pPio->PIO_OER = pioEnable; // Configure in Output
21f01f18:	e51b2010 	ldr	r2, [fp, #-16]
21f01f1c:	e51b3014 	ldr	r3, [fp, #-20]
21f01f20:	e5823010 	str	r3, [r2, #16]
}
21f01f24:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01f28:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01f2c <AT91F_PIO_CfgInput>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgInput
//* \brief Enable PIO in input mode
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_CfgInput(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int inputEnable)      // \arg PIO to be enabled
{
21f01f2c:	e1a0c00d 	mov	ip, sp
21f01f30:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01f34:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01f38:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01f3c:	e50b0010 	str	r0, [fp, #-16]
21f01f40:	e50b1014 	str	r1, [fp, #-20]
	// Disable output
	pPio->PIO_ODR  = inputEnable;
21f01f44:	e51b2010 	ldr	r2, [fp, #-16]
21f01f48:	e51b3014 	ldr	r3, [fp, #-20]
21f01f4c:	e5823014 	str	r3, [r2, #20]
	pPio->PIO_PER  = inputEnable;
21f01f50:	e51b2010 	ldr	r2, [fp, #-16]
21f01f54:	e51b3014 	ldr	r3, [fp, #-20]
21f01f58:	e5823000 	str	r3, [r2]
}
21f01f5c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01f60:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01f64 <AT91F_PIO_CfgOpendrain>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgOpendrain
//* \brief Configure PIO in open drain
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_CfgOpendrain(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int multiDrvEnable) // \arg pio to be configured in open drain
{
21f01f64:	e1a0c00d 	mov	ip, sp
21f01f68:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01f6c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01f70:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01f74:	e50b0010 	str	r0, [fp, #-16]
21f01f78:	e50b1014 	str	r1, [fp, #-20]
	// Configure the multi-drive option
	pPio->PIO_MDDR = ~multiDrvEnable;
21f01f7c:	e51b3014 	ldr	r3, [fp, #-20]
21f01f80:	e1e02003 	mvn	r2, r3
21f01f84:	e51b3010 	ldr	r3, [fp, #-16]
21f01f88:	e5832054 	str	r2, [r3, #84]
	pPio->PIO_MDER = multiDrvEnable;
21f01f8c:	e51b2010 	ldr	r2, [fp, #-16]
21f01f90:	e51b3014 	ldr	r3, [fp, #-20]
21f01f94:	e5823050 	str	r3, [r2, #80]
}
21f01f98:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01f9c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01fa0 <AT91F_PIO_CfgPullup>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgPullup
//* \brief Enable pullup on PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_CfgPullup(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int pullupEnable)   // \arg enable pullup on PIO
{
21f01fa0:	e1a0c00d 	mov	ip, sp
21f01fa4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01fa8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01fac:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01fb0:	e50b0010 	str	r0, [fp, #-16]
21f01fb4:	e50b1014 	str	r1, [fp, #-20]
		// Connect or not Pullup
	pPio->PIO_PPUDR = ~pullupEnable;
21f01fb8:	e51b3014 	ldr	r3, [fp, #-20]
21f01fbc:	e1e02003 	mvn	r2, r3
21f01fc0:	e51b3010 	ldr	r3, [fp, #-16]
21f01fc4:	e5832060 	str	r2, [r3, #96]
	pPio->PIO_PPUER = pullupEnable;
21f01fc8:	e51b2010 	ldr	r2, [fp, #-16]
21f01fcc:	e51b3014 	ldr	r3, [fp, #-20]
21f01fd0:	e5823064 	str	r3, [r2, #100]
}
21f01fd4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f01fd8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f01fdc <AT91F_PIO_CfgDirectDrive>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgDirectDrive
//* \brief Enable direct drive on PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_CfgDirectDrive(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int directDrive)    // \arg PIO to be configured with direct drive

{
21f01fdc:	e1a0c00d 	mov	ip, sp
21f01fe0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f01fe4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f01fe8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f01fec:	e50b0010 	str	r0, [fp, #-16]
21f01ff0:	e50b1014 	str	r1, [fp, #-20]
	// Configure the Direct Drive
	pPio->PIO_OWDR  = ~directDrive;
21f01ff4:	e51b3014 	ldr	r3, [fp, #-20]
21f01ff8:	e1e02003 	mvn	r2, r3
21f01ffc:	e51b3010 	ldr	r3, [fp, #-16]
21f02000:	e58320a4 	str	r2, [r3, #164]
	pPio->PIO_OWER  = directDrive;
21f02004:	e51b2010 	ldr	r2, [fp, #-16]
21f02008:	e51b3014 	ldr	r3, [fp, #-20]
21f0200c:	e58230a0 	str	r3, [r2, #160]
}
21f02010:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02014:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02018 <AT91F_PIO_CfgInputFilter>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_CfgInputFilter
//* \brief Enable input filter on input PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_CfgInputFilter(
	AT91PS_PIO pPio,             // \arg pointer to a PIO controller
	unsigned int inputFilter)    // \arg PIO to be configured with input filter

{
21f02018:	e1a0c00d 	mov	ip, sp
21f0201c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02020:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02024:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02028:	e50b0010 	str	r0, [fp, #-16]
21f0202c:	e50b1014 	str	r1, [fp, #-20]
	// Configure the Direct Drive
	pPio->PIO_IFDR  = ~inputFilter;
21f02030:	e51b3014 	ldr	r3, [fp, #-20]
21f02034:	e1e02003 	mvn	r2, r3
21f02038:	e51b3010 	ldr	r3, [fp, #-16]
21f0203c:	e5832024 	str	r2, [r3, #36]
	pPio->PIO_IFER  = inputFilter;
21f02040:	e51b2010 	ldr	r2, [fp, #-16]
21f02044:	e51b3014 	ldr	r3, [fp, #-20]
21f02048:	e5823020 	str	r3, [r2, #32]
}
21f0204c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02050:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02054 <AT91F_PIO_GetInput>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetInput
//* \brief Return PIO input value
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetInput( // \return PIO input
	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f02054:	e1a0c00d 	mov	ip, sp
21f02058:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0205c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02060:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02064:	e50b0010 	str	r0, [fp, #-16]
	return pPio->PIO_PDSR;
21f02068:	e51b3010 	ldr	r3, [fp, #-16]
21f0206c:	e593303c 	ldr	r3, [r3, #60]
}
21f02070:	e1a00003 	mov	r0, r3
21f02074:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02078 <AT91F_PIO_IsInputSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsInputSet
//* \brief Test if PIO is input flag is active
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsInputSet(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  flag to be tested
{
21f02078:	e1a0c00d 	mov	ip, sp
21f0207c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02080:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02084:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02088:	e50b0010 	str	r0, [fp, #-16]
21f0208c:	e50b1014 	str	r1, [fp, #-20]
	return (AT91F_PIO_GetInput(pPio) & flag);
21f02090:	e51b0010 	ldr	r0, [fp, #-16]
21f02094:	ebffffee 	bl	21f02054 <AT91F_PIO_GetInput>
21f02098:	e1a02000 	mov	r2, r0
21f0209c:	e51b3014 	ldr	r3, [fp, #-20]
21f020a0:	e0023003 	and	r3, r2, r3
}
21f020a4:	e1a00003 	mov	r0, r3
21f020a8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f020ac:	e89da800 	ldmia	sp, {fp, sp, pc}

21f020b0 <AT91F_PIO_SetOutput>:


//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_SetOutput
//* \brief Set to 1 output PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_SetOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be set
{
21f020b0:	e1a0c00d 	mov	ip, sp
21f020b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f020b8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f020bc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f020c0:	e50b0010 	str	r0, [fp, #-16]
21f020c4:	e50b1014 	str	r1, [fp, #-20]
	pPio->PIO_SODR = flag;
21f020c8:	e51b2010 	ldr	r2, [fp, #-16]
21f020cc:	e51b3014 	ldr	r3, [fp, #-20]
21f020d0:	e5823030 	str	r3, [r2, #48]
}
21f020d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f020d8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f020dc <AT91F_PIO_ClearOutput>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_ClearOutput
//* \brief Set to 0 output PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_ClearOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be cleared
{
21f020dc:	e1a0c00d 	mov	ip, sp
21f020e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f020e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f020e8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f020ec:	e50b0010 	str	r0, [fp, #-16]
21f020f0:	e50b1014 	str	r1, [fp, #-20]
	pPio->PIO_CODR = flag;
21f020f4:	e51b2010 	ldr	r2, [fp, #-16]
21f020f8:	e51b3014 	ldr	r3, [fp, #-20]
21f020fc:	e5823034 	str	r3, [r2, #52]
}
21f02100:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02104:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02108 <AT91F_PIO_ForceOutput>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_ForceOutput
//* \brief Force output when Direct drive option is enabled
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_ForceOutput(
	AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
	unsigned int flag) // \arg  output to be forced
{
21f02108:	e1a0c00d 	mov	ip, sp
21f0210c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02110:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02114:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02118:	e50b0010 	str	r0, [fp, #-16]
21f0211c:	e50b1014 	str	r1, [fp, #-20]
	pPio->PIO_ODSR = flag;
21f02120:	e51b2010 	ldr	r2, [fp, #-16]
21f02124:	e51b3014 	ldr	r3, [fp, #-20]
21f02128:	e5823038 	str	r3, [r2, #56]
}
21f0212c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02130:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02134 <AT91F_PIO_Enable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_Enable
//* \brief Enable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_Enable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio to be enabled 
{
21f02134:	e1a0c00d 	mov	ip, sp
21f02138:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0213c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02140:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02144:	e50b0010 	str	r0, [fp, #-16]
21f02148:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_PER = flag;
21f0214c:	e51b2010 	ldr	r2, [fp, #-16]
21f02150:	e51b3014 	ldr	r3, [fp, #-20]
21f02154:	e5823000 	str	r3, [r2]
}
21f02158:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0215c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02160 <AT91F_PIO_Disable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_Disable
//* \brief Disable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_Disable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio to be disabled 
{
21f02160:	e1a0c00d 	mov	ip, sp
21f02164:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02168:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0216c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02170:	e50b0010 	str	r0, [fp, #-16]
21f02174:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_PDR = flag;
21f02178:	e51b2010 	ldr	r2, [fp, #-16]
21f0217c:	e51b3014 	ldr	r3, [fp, #-20]
21f02180:	e5823004 	str	r3, [r2, #4]
}
21f02184:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02188:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0218c <AT91F_PIO_GetStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetStatus
//* \brief Return PIO Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetStatus( // \return PIO Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f0218c:	e1a0c00d 	mov	ip, sp
21f02190:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02194:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02198:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0219c:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_PSR;
21f021a0:	e51b3010 	ldr	r3, [fp, #-16]
21f021a4:	e5933008 	ldr	r3, [r3, #8]
}
21f021a8:	e1a00003 	mov	r0, r3
21f021ac:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f021b0 <AT91F_PIO_IsSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsSet
//* \brief Test if PIO is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f021b0:	e1a0c00d 	mov	ip, sp
21f021b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f021b8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f021bc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f021c0:	e50b0010 	str	r0, [fp, #-16]
21f021c4:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetStatus(pPio) & flag);
21f021c8:	e51b0010 	ldr	r0, [fp, #-16]
21f021cc:	ebffffee 	bl	21f0218c <AT91F_PIO_GetStatus>
21f021d0:	e1a02000 	mov	r2, r0
21f021d4:	e51b3014 	ldr	r3, [fp, #-20]
21f021d8:	e0023003 	and	r3, r2, r3
}
21f021dc:	e1a00003 	mov	r0, r3
21f021e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f021e4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f021e8 <AT91F_PIO_OutputEnable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_OutputEnable
//* \brief Output Enable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_OutputEnable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio output to be enabled
{
21f021e8:	e1a0c00d 	mov	ip, sp
21f021ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f021f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f021f4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f021f8:	e50b0010 	str	r0, [fp, #-16]
21f021fc:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_OER = flag;
21f02200:	e51b2010 	ldr	r2, [fp, #-16]
21f02204:	e51b3014 	ldr	r3, [fp, #-20]
21f02208:	e5823010 	str	r3, [r2, #16]
}
21f0220c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02210:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02214 <AT91F_PIO_OutputDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_OutputDisable
//* \brief Output Enable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_OutputDisable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio output to be disabled
{
21f02214:	e1a0c00d 	mov	ip, sp
21f02218:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0221c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02220:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02224:	e50b0010 	str	r0, [fp, #-16]
21f02228:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_ODR = flag;
21f0222c:	e51b2010 	ldr	r2, [fp, #-16]
21f02230:	e51b3014 	ldr	r3, [fp, #-20]
21f02234:	e5823014 	str	r3, [r2, #20]
}
21f02238:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0223c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02240 <AT91F_PIO_GetOutputStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetOutputStatus
//* \brief Return PIO Output Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetOutputStatus( // \return PIO Output Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f02240:	e1a0c00d 	mov	ip, sp
21f02244:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02248:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0224c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02250:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_OSR;
21f02254:	e51b3010 	ldr	r3, [fp, #-16]
21f02258:	e5933018 	ldr	r3, [r3, #24]
}
21f0225c:	e1a00003 	mov	r0, r3
21f02260:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02264 <AT91F_PIO_IsOutputSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsOuputSet
//* \brief Test if PIO Output is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsOutputSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f02264:	e1a0c00d 	mov	ip, sp
21f02268:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0226c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02270:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02274:	e50b0010 	str	r0, [fp, #-16]
21f02278:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetOutputStatus(pPio) & flag);
21f0227c:	e51b0010 	ldr	r0, [fp, #-16]
21f02280:	ebffffee 	bl	21f02240 <AT91F_PIO_GetOutputStatus>
21f02284:	e1a02000 	mov	r2, r0
21f02288:	e51b3014 	ldr	r3, [fp, #-20]
21f0228c:	e0023003 	and	r3, r2, r3
}
21f02290:	e1a00003 	mov	r0, r3
21f02294:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02298:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0229c <AT91F_PIO_InputFilterEnable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_InputFilterEnable
//* \brief Input Filter Enable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_InputFilterEnable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio input filter to be enabled
{
21f0229c:	e1a0c00d 	mov	ip, sp
21f022a0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f022a4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f022a8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f022ac:	e50b0010 	str	r0, [fp, #-16]
21f022b0:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_IFER = flag;
21f022b4:	e51b2010 	ldr	r2, [fp, #-16]
21f022b8:	e51b3014 	ldr	r3, [fp, #-20]
21f022bc:	e5823020 	str	r3, [r2, #32]
}
21f022c0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f022c4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f022c8 <AT91F_PIO_InputFilterDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_InputFilterDisable
//* \brief Input Filter Disable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_InputFilterDisable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio input filter to be disabled
{
21f022c8:	e1a0c00d 	mov	ip, sp
21f022cc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f022d0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f022d4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f022d8:	e50b0010 	str	r0, [fp, #-16]
21f022dc:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_IFDR = flag;
21f022e0:	e51b2010 	ldr	r2, [fp, #-16]
21f022e4:	e51b3014 	ldr	r3, [fp, #-20]
21f022e8:	e5823024 	str	r3, [r2, #36]
}
21f022ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f022f0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f022f4 <AT91F_PIO_GetInputFilterStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetInputFilterStatus
//* \brief Return PIO Input Filter Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetInputFilterStatus( // \return PIO Input Filter Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f022f4:	e1a0c00d 	mov	ip, sp
21f022f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f022fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02300:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02304:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_IFSR;
21f02308:	e51b3010 	ldr	r3, [fp, #-16]
21f0230c:	e5933028 	ldr	r3, [r3, #40]
}
21f02310:	e1a00003 	mov	r0, r3
21f02314:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02318 <AT91F_PIO_IsInputFilterSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsInputFilterSet
//* \brief Test if PIO Input filter is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsInputFilterSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f02318:	e1a0c00d 	mov	ip, sp
21f0231c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02320:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02324:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02328:	e50b0010 	str	r0, [fp, #-16]
21f0232c:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetInputFilterStatus(pPio) & flag);
21f02330:	e51b0010 	ldr	r0, [fp, #-16]
21f02334:	ebffffee 	bl	21f022f4 <AT91F_PIO_GetInputFilterStatus>
21f02338:	e1a02000 	mov	r2, r0
21f0233c:	e51b3014 	ldr	r3, [fp, #-20]
21f02340:	e0023003 	and	r3, r2, r3
}
21f02344:	e1a00003 	mov	r0, r3
21f02348:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0234c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02350 <AT91F_PIO_GetOutputDataStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetOutputDataStatus
//* \brief Return PIO Output Data Status 
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetOutputDataStatus( // \return PIO Output Data Status 
	AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f02350:	e1a0c00d 	mov	ip, sp
21f02354:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02358:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0235c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02360:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_ODSR;
21f02364:	e51b3010 	ldr	r3, [fp, #-16]
21f02368:	e5933038 	ldr	r3, [r3, #56]
}
21f0236c:	e1a00003 	mov	r0, r3
21f02370:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02374 <AT91F_PIO_InterruptEnable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_InterruptEnable
//* \brief Enable PIO Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_InterruptEnable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio interrupt to be enabled
{
21f02374:	e1a0c00d 	mov	ip, sp
21f02378:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0237c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02380:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02384:	e50b0010 	str	r0, [fp, #-16]
21f02388:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_IER = flag;
21f0238c:	e51b2010 	ldr	r2, [fp, #-16]
21f02390:	e51b3014 	ldr	r3, [fp, #-20]
21f02394:	e5823040 	str	r3, [r2, #64]
}
21f02398:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0239c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f023a0 <AT91F_PIO_InterruptDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_InterruptDisable
//* \brief Disable PIO Interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_InterruptDisable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio interrupt to be disabled
{
21f023a0:	e1a0c00d 	mov	ip, sp
21f023a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f023a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f023ac:	e24dd008 	sub	sp, sp, #8	; 0x8
21f023b0:	e50b0010 	str	r0, [fp, #-16]
21f023b4:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_IDR = flag;
21f023b8:	e51b2010 	ldr	r2, [fp, #-16]
21f023bc:	e51b3014 	ldr	r3, [fp, #-20]
21f023c0:	e5823044 	str	r3, [r2, #68]
}
21f023c4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f023c8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f023cc <AT91F_PIO_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetInterruptMaskStatus
//* \brief Return PIO Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetInterruptMaskStatus( // \return PIO Interrupt Mask Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f023cc:	e1a0c00d 	mov	ip, sp
21f023d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f023d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f023d8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f023dc:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_IMR;
21f023e0:	e51b3010 	ldr	r3, [fp, #-16]
21f023e4:	e5933048 	ldr	r3, [r3, #72]
}
21f023e8:	e1a00003 	mov	r0, r3
21f023ec:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f023f0 <AT91F_PIO_GetInterruptStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetInterruptStatus
//* \brief Return PIO Interrupt Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetInterruptStatus( // \return PIO Interrupt Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f023f0:	e1a0c00d 	mov	ip, sp
21f023f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f023f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f023fc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02400:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_ISR;
21f02404:	e51b3010 	ldr	r3, [fp, #-16]
21f02408:	e593304c 	ldr	r3, [r3, #76]
}
21f0240c:	e1a00003 	mov	r0, r3
21f02410:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02414 <AT91F_PIO_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsInterruptMasked
//* \brief Test if PIO Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsInterruptMasked(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f02414:	e1a0c00d 	mov	ip, sp
21f02418:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0241c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02420:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02424:	e50b0010 	str	r0, [fp, #-16]
21f02428:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetInterruptMaskStatus(pPio) & flag);
21f0242c:	e51b0010 	ldr	r0, [fp, #-16]
21f02430:	ebffffe5 	bl	21f023cc <AT91F_PIO_GetInterruptMaskStatus>
21f02434:	e1a02000 	mov	r2, r0
21f02438:	e51b3014 	ldr	r3, [fp, #-20]
21f0243c:	e0023003 	and	r3, r2, r3
}
21f02440:	e1a00003 	mov	r0, r3
21f02444:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02448:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0244c <AT91F_PIO_IsInterruptSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsInterruptSet
//* \brief Test if PIO Interrupt is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsInterruptSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f0244c:	e1a0c00d 	mov	ip, sp
21f02450:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02454:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02458:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0245c:	e50b0010 	str	r0, [fp, #-16]
21f02460:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetInterruptStatus(pPio) & flag);
21f02464:	e51b0010 	ldr	r0, [fp, #-16]
21f02468:	ebffffe0 	bl	21f023f0 <AT91F_PIO_GetInterruptStatus>
21f0246c:	e1a02000 	mov	r2, r0
21f02470:	e51b3014 	ldr	r3, [fp, #-20]
21f02474:	e0023003 	and	r3, r2, r3
}
21f02478:	e1a00003 	mov	r0, r3
21f0247c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02480:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02484 <AT91F_PIO_MultiDriverEnable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_MultiDriverEnable
//* \brief Multi Driver Enable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_MultiDriverEnable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio to be enabled
{
21f02484:	e1a0c00d 	mov	ip, sp
21f02488:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0248c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02490:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02494:	e50b0010 	str	r0, [fp, #-16]
21f02498:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_MDER = flag;
21f0249c:	e51b2010 	ldr	r2, [fp, #-16]
21f024a0:	e51b3014 	ldr	r3, [fp, #-20]
21f024a4:	e5823050 	str	r3, [r2, #80]
}
21f024a8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f024ac:	e89da800 	ldmia	sp, {fp, sp, pc}

21f024b0 <AT91F_PIO_MultiDriverDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_MultiDriverDisable
//* \brief Multi Driver Disable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_MultiDriverDisable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio to be disabled
{
21f024b0:	e1a0c00d 	mov	ip, sp
21f024b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f024b8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f024bc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f024c0:	e50b0010 	str	r0, [fp, #-16]
21f024c4:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_MDDR = flag;
21f024c8:	e51b2010 	ldr	r2, [fp, #-16]
21f024cc:	e51b3014 	ldr	r3, [fp, #-20]
21f024d0:	e5823054 	str	r3, [r2, #84]
}
21f024d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f024d8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f024dc <AT91F_PIO_GetMultiDriverStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetMultiDriverStatus
//* \brief Return PIO Multi Driver Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetMultiDriverStatus( // \return PIO Multi Driver Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f024dc:	e1a0c00d 	mov	ip, sp
21f024e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f024e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f024e8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f024ec:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_MDSR;
21f024f0:	e51b3010 	ldr	r3, [fp, #-16]
21f024f4:	e5933058 	ldr	r3, [r3, #88]
}
21f024f8:	e1a00003 	mov	r0, r3
21f024fc:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02500 <AT91F_PIO_IsMultiDriverSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsMultiDriverSet
//* \brief Test if PIO MultiDriver is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsMultiDriverSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f02500:	e1a0c00d 	mov	ip, sp
21f02504:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02508:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0250c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02510:	e50b0010 	str	r0, [fp, #-16]
21f02514:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetMultiDriverStatus(pPio) & flag);
21f02518:	e51b0010 	ldr	r0, [fp, #-16]
21f0251c:	ebffffee 	bl	21f024dc <AT91F_PIO_GetMultiDriverStatus>
21f02520:	e1a02000 	mov	r2, r0
21f02524:	e51b3014 	ldr	r3, [fp, #-20]
21f02528:	e0023003 	and	r3, r2, r3
}
21f0252c:	e1a00003 	mov	r0, r3
21f02530:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02534:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02538 <AT91F_PIO_A_RegisterSelection>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_A_RegisterSelection
//* \brief PIO A Register Selection 
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_A_RegisterSelection(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio A register selection
{
21f02538:	e1a0c00d 	mov	ip, sp
21f0253c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02540:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02544:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02548:	e50b0010 	str	r0, [fp, #-16]
21f0254c:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_ASR = flag;
21f02550:	e51b2010 	ldr	r2, [fp, #-16]
21f02554:	e51b3014 	ldr	r3, [fp, #-20]
21f02558:	e5823070 	str	r3, [r2, #112]
}
21f0255c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02560:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02564 <AT91F_PIO_B_RegisterSelection>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_B_RegisterSelection
//* \brief PIO B Register Selection 
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_B_RegisterSelection(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio B register selection 
{
21f02564:	e1a0c00d 	mov	ip, sp
21f02568:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0256c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02570:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02574:	e50b0010 	str	r0, [fp, #-16]
21f02578:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_BSR = flag;
21f0257c:	e51b2010 	ldr	r2, [fp, #-16]
21f02580:	e51b3014 	ldr	r3, [fp, #-20]
21f02584:	e5823074 	str	r3, [r2, #116]
}
21f02588:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0258c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02590 <AT91F_PIO_Get_AB_RegisterStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_Get_AB_RegisterStatus
//* \brief Return PIO Interrupt Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_Get_AB_RegisterStatus( // \return PIO AB Register Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f02590:	e1a0c00d 	mov	ip, sp
21f02594:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02598:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0259c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f025a0:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_ABSR;
21f025a4:	e51b3010 	ldr	r3, [fp, #-16]
21f025a8:	e5933078 	ldr	r3, [r3, #120]
}
21f025ac:	e1a00003 	mov	r0, r3
21f025b0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f025b4 <AT91F_PIO_IsAB_RegisterSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsAB_RegisterSet
//* \brief Test if PIO AB Register is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsAB_RegisterSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f025b4:	e1a0c00d 	mov	ip, sp
21f025b8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f025bc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f025c0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f025c4:	e50b0010 	str	r0, [fp, #-16]
21f025c8:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_Get_AB_RegisterStatus(pPio) & flag);
21f025cc:	e51b0010 	ldr	r0, [fp, #-16]
21f025d0:	ebffffee 	bl	21f02590 <AT91F_PIO_Get_AB_RegisterStatus>
21f025d4:	e1a02000 	mov	r2, r0
21f025d8:	e51b3014 	ldr	r3, [fp, #-20]
21f025dc:	e0023003 	and	r3, r2, r3
}
21f025e0:	e1a00003 	mov	r0, r3
21f025e4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f025e8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f025ec <AT91F_PIO_OutputWriteEnable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_OutputWriteEnable
//* \brief Output Write Enable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_OutputWriteEnable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio output write to be enabled
{
21f025ec:	e1a0c00d 	mov	ip, sp
21f025f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f025f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f025f8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f025fc:	e50b0010 	str	r0, [fp, #-16]
21f02600:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_OWER = flag;
21f02604:	e51b2010 	ldr	r2, [fp, #-16]
21f02608:	e51b3014 	ldr	r3, [fp, #-20]
21f0260c:	e58230a0 	str	r3, [r2, #160]
}
21f02610:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02614:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02618 <AT91F_PIO_OutputWriteDisable>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_OutputWriteDisable
//* \brief Output Write Disable PIO
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIO_OutputWriteDisable(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  pio output write to be disabled
{
21f02618:	e1a0c00d 	mov	ip, sp
21f0261c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02620:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02624:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02628:	e50b0010 	str	r0, [fp, #-16]
21f0262c:	e50b1014 	str	r1, [fp, #-20]
        pPio->PIO_OWDR = flag;
21f02630:	e51b2010 	ldr	r2, [fp, #-16]
21f02634:	e51b3014 	ldr	r3, [fp, #-20]
21f02638:	e58230a4 	str	r3, [r2, #164]
}
21f0263c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02640:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02644 <AT91F_PIO_GetOutputWriteStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetOutputWriteStatus
//* \brief Return PIO Output Write Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetOutputWriteStatus( // \return PIO Output Write Status
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f02644:	e1a0c00d 	mov	ip, sp
21f02648:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0264c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02650:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02654:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_OWSR;
21f02658:	e51b3010 	ldr	r3, [fp, #-16]
21f0265c:	e59330a8 	ldr	r3, [r3, #168]
}
21f02660:	e1a00003 	mov	r0, r3
21f02664:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02668 <AT91F_PIO_IsOutputWriteSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsOutputWriteSet
//* \brief Test if PIO OutputWrite is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsOutputWriteSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f02668:	e1a0c00d 	mov	ip, sp
21f0266c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02670:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02674:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02678:	e50b0010 	str	r0, [fp, #-16]
21f0267c:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetOutputWriteStatus(pPio) & flag);
21f02680:	e51b0010 	ldr	r0, [fp, #-16]
21f02684:	ebffffee 	bl	21f02644 <AT91F_PIO_GetOutputWriteStatus>
21f02688:	e1a02000 	mov	r2, r0
21f0268c:	e51b3014 	ldr	r3, [fp, #-20]
21f02690:	e0023003 	and	r3, r2, r3
}
21f02694:	e1a00003 	mov	r0, r3
21f02698:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0269c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f026a0 <AT91F_PIO_GetCfgPullup>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_GetCfgPullup
//* \brief Return PIO Configuration Pullup
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_PIO_GetCfgPullup( // \return PIO Configuration Pullup 
        AT91PS_PIO pPio) // \arg  pointer to a PIO controller
{
21f026a0:	e1a0c00d 	mov	ip, sp
21f026a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f026a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f026ac:	e24dd004 	sub	sp, sp, #4	; 0x4
21f026b0:	e50b0010 	str	r0, [fp, #-16]
        return pPio->PIO_PPUSR;
21f026b4:	e51b3010 	ldr	r3, [fp, #-16]
21f026b8:	e5933068 	ldr	r3, [r3, #104]
}
21f026bc:	e1a00003 	mov	r0, r3
21f026c0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f026c4 <AT91F_PIO_IsOutputDataStatusSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsOutputDataStatusSet
//* \brief Test if PIO Output Data Status is Set 
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsOutputDataStatusSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f026c4:	e1a0c00d 	mov	ip, sp
21f026c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f026cc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f026d0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f026d4:	e50b0010 	str	r0, [fp, #-16]
21f026d8:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_PIO_GetOutputDataStatus(pPio) & flag);
21f026dc:	e51b0010 	ldr	r0, [fp, #-16]
21f026e0:	ebffff1a 	bl	21f02350 <AT91F_PIO_GetOutputDataStatus>
21f026e4:	e1a02000 	mov	r2, r0
21f026e8:	e51b3014 	ldr	r3, [fp, #-20]
21f026ec:	e0023003 	and	r3, r2, r3
}
21f026f0:	e1a00003 	mov	r0, r3
21f026f4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f026f8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f026fc <AT91F_PIO_IsCfgPullupStatusSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIO_IsCfgPullupStatusSet
//* \brief Test if PIO Configuration Pullup Status is Set
//*----------------------------------------------------------------------------
__inline__ int AT91F_PIO_IsCfgPullupStatusSet(
        AT91PS_PIO pPio,   // \arg  pointer to a PIO controller
        unsigned int flag) // \arg  flag to be tested
{
21f026fc:	e1a0c00d 	mov	ip, sp
21f02700:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02704:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02708:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0270c:	e50b0010 	str	r0, [fp, #-16]
21f02710:	e50b1014 	str	r1, [fp, #-20]
        return (~AT91F_PIO_GetCfgPullup(pPio) & flag);
21f02714:	e51b0010 	ldr	r0, [fp, #-16]
21f02718:	ebffffe0 	bl	21f026a0 <AT91F_PIO_GetCfgPullup>
21f0271c:	e1a03000 	mov	r3, r0
21f02720:	e1e02003 	mvn	r2, r3
21f02724:	e51b3014 	ldr	r3, [fp, #-20]
21f02728:	e0023003 	and	r3, r2, r3
}
21f0272c:	e1a00003 	mov	r0, r3
21f02730:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02734:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02738 <AT91F_TWI_EnableIt>:

/* *****************************************************************************
                SOFTWARE API FOR TWI
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_TWI_EnableIt
//* \brief Enable TWI IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_TWI_EnableIt (
	AT91PS_TWI pTWI, // \arg pointer to a TWI controller
	unsigned int flag)   // \arg IT to be enabled
{
21f02738:	e1a0c00d 	mov	ip, sp
21f0273c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02740:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02744:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02748:	e50b0010 	str	r0, [fp, #-16]
21f0274c:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IER register
	pTWI->TWI_IER = flag;
21f02750:	e51b2010 	ldr	r2, [fp, #-16]
21f02754:	e51b3014 	ldr	r3, [fp, #-20]
21f02758:	e5823024 	str	r3, [r2, #36]
}
21f0275c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02760:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02764 <AT91F_TWI_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TWI_DisableIt
//* \brief Disable TWI IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_TWI_DisableIt (
	AT91PS_TWI pTWI, // \arg pointer to a TWI controller
	unsigned int flag)   // \arg IT to be disabled
{
21f02764:	e1a0c00d 	mov	ip, sp
21f02768:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0276c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02770:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02774:	e50b0010 	str	r0, [fp, #-16]
21f02778:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IDR register
	pTWI->TWI_IDR = flag;
21f0277c:	e51b2010 	ldr	r2, [fp, #-16]
21f02780:	e51b3014 	ldr	r3, [fp, #-20]
21f02784:	e5823028 	str	r3, [r2, #40]
}
21f02788:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0278c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02790 <AT91F_TWI_Configure>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TWI_Configure
//* \brief Configure TWI in master mode
//*----------------------------------------------------------------------------
__inline__ void AT91F_TWI_Configure ( AT91PS_TWI pTWI )          // \arg pointer to a TWI controller
{
21f02790:	e1a0c00d 	mov	ip, sp
21f02794:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02798:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0279c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f027a0:	e50b0010 	str	r0, [fp, #-16]
    //* Disable interrupts
	pTWI->TWI_IDR = (unsigned int) -1;
21f027a4:	e51b2010 	ldr	r2, [fp, #-16]
21f027a8:	e3e03000 	mvn	r3, #0	; 0x0
21f027ac:	e5823028 	str	r3, [r2, #40]

    //* Reset peripheral
	pTWI->TWI_CR = AT91C_TWI_SWRST;
21f027b0:	e51b2010 	ldr	r2, [fp, #-16]
21f027b4:	e3a03080 	mov	r3, #128	; 0x80
21f027b8:	e5823000 	str	r3, [r2]

	//* Set Master mode
	pTWI->TWI_CR = AT91C_TWI_MSEN | AT91C_TWI_SVDIS;
21f027bc:	e51b2010 	ldr	r2, [fp, #-16]
21f027c0:	e3a03024 	mov	r3, #36	; 0x24
21f027c4:	e5823000 	str	r3, [r2]

}
21f027c8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f027cc <AT91F_TWI_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TWI_GetInterruptMaskStatus
//* \brief Return TWI Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_TWI_GetInterruptMaskStatus( // \return TWI Interrupt Mask Status
        AT91PS_TWI pTwi) // \arg  pointer to a TWI controller
{
21f027cc:	e1a0c00d 	mov	ip, sp
21f027d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f027d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f027d8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f027dc:	e50b0010 	str	r0, [fp, #-16]
        return pTwi->TWI_IMR;
21f027e0:	e51b3010 	ldr	r3, [fp, #-16]
21f027e4:	e593302c 	ldr	r3, [r3, #44]
}
21f027e8:	e1a00003 	mov	r0, r3
21f027ec:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f027f0 <AT91F_TWI_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TWI_IsInterruptMasked
//* \brief Test if TWI Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_TWI_IsInterruptMasked(
        AT91PS_TWI pTwi,   // \arg  pointer to a TWI controller
        unsigned int flag) // \arg  flag to be tested
{
21f027f0:	e1a0c00d 	mov	ip, sp
21f027f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f027f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f027fc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02800:	e50b0010 	str	r0, [fp, #-16]
21f02804:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_TWI_GetInterruptMaskStatus(pTwi) & flag);
21f02808:	e51b0010 	ldr	r0, [fp, #-16]
21f0280c:	ebffffee 	bl	21f027cc <AT91F_TWI_GetInterruptMaskStatus>
21f02810:	e1a02000 	mov	r2, r0
21f02814:	e51b3014 	ldr	r3, [fp, #-20]
21f02818:	e0023003 	and	r3, r2, r3
}
21f0281c:	e1a00003 	mov	r0, r3
21f02820:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02824:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02828 <AT91F_US_Baudrate>:

/* *****************************************************************************
                SOFTWARE API FOR USART
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_US_Baudrate
//* \brief Calculate the baudrate
//* Standard Asynchronous Mode : 8 bits , 1 stop , no parity
#define AT91C_US_ASYNC_MODE ( AT91C_US_USMODE_NORMAL + \
                        AT91C_US_NBSTOP_1_BIT + \
                        AT91C_US_PAR_NONE + \
                        AT91C_US_CHRL_8_BITS + \
                        AT91C_US_CLKS_CLOCK )

//* Standard External Asynchronous Mode : 8 bits , 1 stop , no parity
#define AT91C_US_ASYNC_SCK_MODE ( AT91C_US_USMODE_NORMAL + \
                            AT91C_US_NBSTOP_1_BIT + \
                            AT91C_US_PAR_NONE + \
                            AT91C_US_CHRL_8_BITS + \
                            AT91C_US_CLKS_EXT )

//* Standard Synchronous Mode : 8 bits , 1 stop , no parity
#define AT91C_US_SYNC_MODE ( AT91C_US_SYNC + \
                       AT91C_US_USMODE_NORMAL + \
                       AT91C_US_NBSTOP_1_BIT + \
                       AT91C_US_PAR_NONE + \
                       AT91C_US_CHRL_8_BITS + \
                       AT91C_US_CLKS_CLOCK )

//* SCK used Label
#define AT91C_US_SCK_USED (AT91C_US_CKLO | AT91C_US_CLKS_EXT)

//* Standard ISO T=0 Mode : 8 bits , 1 stop , parity
#define AT91C_US_ISO_READER_MODE ( AT91C_US_USMODE_ISO7816_0 + \
					   		 AT91C_US_CLKS_CLOCK +\
                       		 AT91C_US_NBSTOP_1_BIT + \
                       		 AT91C_US_PAR_EVEN + \
                       		 AT91C_US_CHRL_8_BITS + \
                       		 AT91C_US_CKLO +\
                       		 AT91C_US_OVER)

//* Standard IRDA mode
#define AT91C_US_ASYNC_IRDA_MODE (  AT91C_US_USMODE_IRDA + \
                            AT91C_US_NBSTOP_1_BIT + \
                            AT91C_US_PAR_NONE + \
                            AT91C_US_CHRL_8_BITS + \
                            AT91C_US_CLKS_CLOCK )

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_Baudrate
//* \brief Caluculate baud_value according to the main clock and the baud rate
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_US_Baudrate (
	const unsigned int main_clock, // \arg peripheral clock
	const unsigned int baud_rate)  // \arg UART baudrate
{
21f02828:	e1a0c00d 	mov	ip, sp
21f0282c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02830:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02834:	e24dd010 	sub	sp, sp, #16	; 0x10
21f02838:	e50b0014 	str	r0, [fp, #-20]
21f0283c:	e50b1018 	str	r1, [fp, #-24]
	unsigned int baud_value = ((main_clock*10)/(baud_rate * 16));
21f02840:	e51b2014 	ldr	r2, [fp, #-20]
21f02844:	e1a03002 	mov	r3, r2
21f02848:	e1a03103 	mov	r3, r3, lsl #2
21f0284c:	e0833002 	add	r3, r3, r2
21f02850:	e1a03083 	mov	r3, r3, lsl #1
21f02854:	e1a02003 	mov	r2, r3
21f02858:	e51b3018 	ldr	r3, [fp, #-24]
21f0285c:	e1a03203 	mov	r3, r3, lsl #4
21f02860:	e1a00002 	mov	r0, r2
21f02864:	e1a01003 	mov	r1, r3
21f02868:	eb000c91 	bl	21f05ab4 <__udivsi3>
21f0286c:	e1a03000 	mov	r3, r0
21f02870:	e50b3010 	str	r3, [fp, #-16]
	if ((baud_value % 10) >= 5)
21f02874:	e51b2010 	ldr	r2, [fp, #-16]
21f02878:	e59f3070 	ldr	r3, [pc, #112]	; 21f028f0 <.text+0x28f0>
21f0287c:	e0831392 	umull	r1, r3, r2, r3
21f02880:	e1a031a3 	mov	r3, r3, lsr #3
21f02884:	e50b301c 	str	r3, [fp, #-28]
21f02888:	e51b301c 	ldr	r3, [fp, #-28]
21f0288c:	e1a03103 	mov	r3, r3, lsl #2
21f02890:	e51b101c 	ldr	r1, [fp, #-28]
21f02894:	e0833001 	add	r3, r3, r1
21f02898:	e1a03083 	mov	r3, r3, lsl #1
21f0289c:	e0632002 	rsb	r2, r3, r2
21f028a0:	e50b201c 	str	r2, [fp, #-28]
21f028a4:	e51b301c 	ldr	r3, [fp, #-28]
21f028a8:	e3530004 	cmp	r3, #4	; 0x4
21f028ac:	9a000006 	bls	21f028cc <AT91F_US_Baudrate+0xa4>
		baud_value = (baud_value / 10) + 1;
21f028b0:	e51b2010 	ldr	r2, [fp, #-16]
21f028b4:	e59f3034 	ldr	r3, [pc, #52]	; 21f028f0 <.text+0x28f0>
21f028b8:	e0831392 	umull	r1, r3, r2, r3
21f028bc:	e1a031a3 	mov	r3, r3, lsr #3
21f028c0:	e2833001 	add	r3, r3, #1	; 0x1
21f028c4:	e50b3010 	str	r3, [fp, #-16]
21f028c8:	ea000004 	b	21f028e0 <AT91F_US_Baudrate+0xb8>
	else
		baud_value /= 10;
21f028cc:	e51b2010 	ldr	r2, [fp, #-16]
21f028d0:	e59f3018 	ldr	r3, [pc, #24]	; 21f028f0 <.text+0x28f0>
21f028d4:	e0831392 	umull	r1, r3, r2, r3
21f028d8:	e1a031a3 	mov	r3, r3, lsr #3
21f028dc:	e50b3010 	str	r3, [fp, #-16]
	return baud_value;
21f028e0:	e51b3010 	ldr	r3, [fp, #-16]
}
21f028e4:	e1a00003 	mov	r0, r3
21f028e8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f028ec:	e89da800 	ldmia	sp, {fp, sp, pc}
21f028f0:	cccccccd 	stcgtl	12, cr12, [ip], {205}

21f028f4 <AT91F_US_SetBaudrate>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_SetBaudrate
//* \brief Set the baudrate according to the CPU clock
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_SetBaudrate (
	AT91PS_USART pUSART,    // \arg pointer to a USART controller
	unsigned int mainClock, // \arg peripheral clock
	unsigned int speed)     // \arg UART baudrate
{
21f028f4:	e1a0c00d 	mov	ip, sp
21f028f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f028fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02900:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f02904:	e50b0010 	str	r0, [fp, #-16]
21f02908:	e50b1014 	str	r1, [fp, #-20]
21f0290c:	e50b2018 	str	r2, [fp, #-24]
	//* Define the baud rate divisor register
	pUSART->US_BRGR = AT91F_US_Baudrate(mainClock, speed);
21f02910:	e51b0014 	ldr	r0, [fp, #-20]
21f02914:	e51b1018 	ldr	r1, [fp, #-24]
21f02918:	ebffffc2 	bl	21f02828 <AT91F_US_Baudrate>
21f0291c:	e1a02000 	mov	r2, r0
21f02920:	e51b3010 	ldr	r3, [fp, #-16]
21f02924:	e5832020 	str	r2, [r3, #32]
}
21f02928:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0292c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02930 <AT91F_US_SetTimeguard>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_SetTimeguard
//* \brief Set USART timeguard
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_SetTimeguard (
	AT91PS_USART pUSART,    // \arg pointer to a USART controller
	unsigned int timeguard) // \arg timeguard value
{
21f02930:	e1a0c00d 	mov	ip, sp
21f02934:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02938:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0293c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02940:	e50b0010 	str	r0, [fp, #-16]
21f02944:	e50b1014 	str	r1, [fp, #-20]
	//* Write the Timeguard Register
	pUSART->US_TTGR = timeguard ;
21f02948:	e51b2010 	ldr	r2, [fp, #-16]
21f0294c:	e51b3014 	ldr	r3, [fp, #-20]
21f02950:	e5823028 	str	r3, [r2, #40]
}
21f02954:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02958:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0295c <AT91F_US_EnableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_EnableIt
//* \brief Enable USART IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_EnableIt (
	AT91PS_USART pUSART, // \arg pointer to a USART controller
	unsigned int flag)   // \arg IT to be enabled
{
21f0295c:	e1a0c00d 	mov	ip, sp
21f02960:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02964:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02968:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0296c:	e50b0010 	str	r0, [fp, #-16]
21f02970:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IER register
	pUSART->US_IER = flag;
21f02974:	e51b2010 	ldr	r2, [fp, #-16]
21f02978:	e51b3014 	ldr	r3, [fp, #-20]
21f0297c:	e5823008 	str	r3, [r2, #8]
}
21f02980:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02984:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02988 <AT91F_US_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_DisableIt
//* \brief Disable USART IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_DisableIt (
	AT91PS_USART pUSART, // \arg pointer to a USART controller
	unsigned int flag)   // \arg IT to be disabled
{
21f02988:	e1a0c00d 	mov	ip, sp
21f0298c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02990:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02994:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02998:	e50b0010 	str	r0, [fp, #-16]
21f0299c:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IER register
	pUSART->US_IDR = flag;
21f029a0:	e51b2010 	ldr	r2, [fp, #-16]
21f029a4:	e51b3014 	ldr	r3, [fp, #-20]
21f029a8:	e582300c 	str	r3, [r2, #12]
}
21f029ac:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f029b0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f029b4 <AT91F_US_Configure>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_Configure
//* \brief Configure USART
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_Configure (
	AT91PS_USART pUSART,     // \arg pointer to a USART controller
	unsigned int mainClock,  // \arg peripheral clock
	unsigned int mode ,      // \arg mode Register to be programmed
	unsigned int baudRate ,  // \arg baudrate to be programmed
	unsigned int timeguard ) // \arg timeguard to be programmed
{
21f029b4:	e1a0c00d 	mov	ip, sp
21f029b8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f029bc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f029c0:	e24dd010 	sub	sp, sp, #16	; 0x10
21f029c4:	e50b0010 	str	r0, [fp, #-16]
21f029c8:	e50b1014 	str	r1, [fp, #-20]
21f029cc:	e50b2018 	str	r2, [fp, #-24]
21f029d0:	e50b301c 	str	r3, [fp, #-28]
    //* Disable interrupts
    pUSART->US_IDR = (unsigned int) -1;
21f029d4:	e51b2010 	ldr	r2, [fp, #-16]
21f029d8:	e3e03000 	mvn	r3, #0	; 0x0
21f029dc:	e582300c 	str	r3, [r2, #12]

    //* Reset receiver and transmitter
    pUSART->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX | AT91C_US_RXDIS | AT91C_US_TXDIS ;
21f029e0:	e51b2010 	ldr	r2, [fp, #-16]
21f029e4:	e3a030ac 	mov	r3, #172	; 0xac
21f029e8:	e5823000 	str	r3, [r2]

	//* Define the baud rate divisor register
	AT91F_US_SetBaudrate(pUSART, mainClock, baudRate);
21f029ec:	e51b0010 	ldr	r0, [fp, #-16]
21f029f0:	e51b1014 	ldr	r1, [fp, #-20]
21f029f4:	e51b201c 	ldr	r2, [fp, #-28]
21f029f8:	ebffffbd 	bl	21f028f4 <AT91F_US_SetBaudrate>

	//* Write the Timeguard Register
	AT91F_US_SetTimeguard(pUSART, timeguard);
21f029fc:	e51b0010 	ldr	r0, [fp, #-16]
21f02a00:	e59b1004 	ldr	r1, [fp, #4]
21f02a04:	ebffffc9 	bl	21f02930 <AT91F_US_SetTimeguard>

    //* Clear Transmit and Receive Counters
    AT91F_PDC_Open((AT91PS_PDC) &(pUSART->US_RPR));
21f02a08:	e51b3010 	ldr	r3, [fp, #-16]
21f02a0c:	e2833c01 	add	r3, r3, #256	; 0x100
21f02a10:	e1a00003 	mov	r0, r3
21f02a14:	ebfff95f 	bl	21f00f98 <AT91F_PDC_Open>

    //* Define the USART mode
    pUSART->US_MR = mode  ;
21f02a18:	e51b2010 	ldr	r2, [fp, #-16]
21f02a1c:	e51b3018 	ldr	r3, [fp, #-24]
21f02a20:	e5823004 	str	r3, [r2, #4]

}
21f02a24:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02a28:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02a2c <AT91F_US_EnableRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_EnableRx
//* \brief Enable receiving characters
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_EnableRx (
	AT91PS_USART pUSART)     // \arg pointer to a USART controller
{
21f02a2c:	e1a0c00d 	mov	ip, sp
21f02a30:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02a34:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02a38:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02a3c:	e50b0010 	str	r0, [fp, #-16]
    //* Enable receiver
    pUSART->US_CR = AT91C_US_RXEN;
21f02a40:	e51b2010 	ldr	r2, [fp, #-16]
21f02a44:	e3a03010 	mov	r3, #16	; 0x10
21f02a48:	e5823000 	str	r3, [r2]
}
21f02a4c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02a50 <AT91F_US_EnableTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_EnableTx
//* \brief Enable sending characters
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_EnableTx (
	AT91PS_USART pUSART)     // \arg pointer to a USART controller
{
21f02a50:	e1a0c00d 	mov	ip, sp
21f02a54:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02a58:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02a5c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02a60:	e50b0010 	str	r0, [fp, #-16]
    //* Enable  transmitter
    pUSART->US_CR = AT91C_US_TXEN;
21f02a64:	e51b2010 	ldr	r2, [fp, #-16]
21f02a68:	e3a03040 	mov	r3, #64	; 0x40
21f02a6c:	e5823000 	str	r3, [r2]
}
21f02a70:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02a74 <AT91F_US_ResetRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_ResetRx
//* \brief Reset Receiver and re-enable it
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_ResetRx (
	AT91PS_USART pUSART)     // \arg pointer to a USART controller
{
21f02a74:	e1a0c00d 	mov	ip, sp
21f02a78:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02a7c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02a80:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02a84:	e50b0010 	str	r0, [fp, #-16]
	//* Reset receiver
	pUSART->US_CR = AT91C_US_RSTRX;
21f02a88:	e51b2010 	ldr	r2, [fp, #-16]
21f02a8c:	e3a03004 	mov	r3, #4	; 0x4
21f02a90:	e5823000 	str	r3, [r2]
    //* Re-Enable receiver
    pUSART->US_CR = AT91C_US_RXEN;
21f02a94:	e51b2010 	ldr	r2, [fp, #-16]
21f02a98:	e3a03010 	mov	r3, #16	; 0x10
21f02a9c:	e5823000 	str	r3, [r2]
}
21f02aa0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02aa4 <AT91F_US_ResetTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_ResetTx
//* \brief Reset Transmitter and re-enable it
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_ResetTx (
	AT91PS_USART pUSART)     // \arg pointer to a USART controller
{
21f02aa4:	e1a0c00d 	mov	ip, sp
21f02aa8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02aac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02ab0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02ab4:	e50b0010 	str	r0, [fp, #-16]
	//* Reset transmitter
	pUSART->US_CR = AT91C_US_RSTTX;
21f02ab8:	e51b2010 	ldr	r2, [fp, #-16]
21f02abc:	e3a03008 	mov	r3, #8	; 0x8
21f02ac0:	e5823000 	str	r3, [r2]
    //* Enable transmitter
    pUSART->US_CR = AT91C_US_TXEN;
21f02ac4:	e51b2010 	ldr	r2, [fp, #-16]
21f02ac8:	e3a03040 	mov	r3, #64	; 0x40
21f02acc:	e5823000 	str	r3, [r2]
}
21f02ad0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02ad4 <AT91F_US_DisableRx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_DisableRx
//* \brief Disable Receiver
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_DisableRx (
	AT91PS_USART pUSART)     // \arg pointer to a USART controller
{
21f02ad4:	e1a0c00d 	mov	ip, sp
21f02ad8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02adc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02ae0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02ae4:	e50b0010 	str	r0, [fp, #-16]
    //* Disable receiver
    pUSART->US_CR = AT91C_US_RXDIS;
21f02ae8:	e51b2010 	ldr	r2, [fp, #-16]
21f02aec:	e3a03020 	mov	r3, #32	; 0x20
21f02af0:	e5823000 	str	r3, [r2]
}
21f02af4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02af8 <AT91F_US_DisableTx>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_DisableTx
//* \brief Disable Transmitter
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_DisableTx (
	AT91PS_USART pUSART)     // \arg pointer to a USART controller
{
21f02af8:	e1a0c00d 	mov	ip, sp
21f02afc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02b00:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02b04:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02b08:	e50b0010 	str	r0, [fp, #-16]
    //* Disable transmitter
    pUSART->US_CR = AT91C_US_TXDIS;
21f02b0c:	e51b2010 	ldr	r2, [fp, #-16]
21f02b10:	e3a03080 	mov	r3, #128	; 0x80
21f02b14:	e5823000 	str	r3, [r2]
}
21f02b18:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02b1c <AT91F_US_Close>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_Close
//* \brief Close USART: disable IT disable receiver and transmitter, close PDC
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_Close (
	AT91PS_USART pUSART)     // \arg pointer to a USART controller
{
21f02b1c:	e1a0c00d 	mov	ip, sp
21f02b20:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02b24:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02b28:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02b2c:	e50b0010 	str	r0, [fp, #-16]
    //* Reset the baud rate divisor register
    pUSART->US_BRGR = 0 ;
21f02b30:	e51b2010 	ldr	r2, [fp, #-16]
21f02b34:	e3a03000 	mov	r3, #0	; 0x0
21f02b38:	e5823020 	str	r3, [r2, #32]

    //* Reset the USART mode
    pUSART->US_MR = 0  ;
21f02b3c:	e51b2010 	ldr	r2, [fp, #-16]
21f02b40:	e3a03000 	mov	r3, #0	; 0x0
21f02b44:	e5823004 	str	r3, [r2, #4]

    //* Reset the Timeguard Register
    pUSART->US_TTGR = 0;
21f02b48:	e51b2010 	ldr	r2, [fp, #-16]
21f02b4c:	e3a03000 	mov	r3, #0	; 0x0
21f02b50:	e5823028 	str	r3, [r2, #40]

    //* Disable all interrupts
    pUSART->US_IDR = 0xFFFFFFFF ;
21f02b54:	e51b2010 	ldr	r2, [fp, #-16]
21f02b58:	e3e03000 	mvn	r3, #0	; 0x0
21f02b5c:	e582300c 	str	r3, [r2, #12]

    //* Abort the Peripheral Data Transfers
    AT91F_PDC_Close((AT91PS_PDC) &(pUSART->US_RPR));
21f02b60:	e51b3010 	ldr	r3, [fp, #-16]
21f02b64:	e2833c01 	add	r3, r3, #256	; 0x100
21f02b68:	e1a00003 	mov	r0, r3
21f02b6c:	ebfff927 	bl	21f01010 <AT91F_PDC_Close>

    //* Disable receiver and transmitter and stop any activity immediately
    pUSART->US_CR = AT91C_US_TXDIS | AT91C_US_RXDIS | AT91C_US_RSTTX | AT91C_US_RSTRX ;
21f02b70:	e51b2010 	ldr	r2, [fp, #-16]
21f02b74:	e3a030ac 	mov	r3, #172	; 0xac
21f02b78:	e5823000 	str	r3, [r2]
}
21f02b7c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02b80 <AT91F_US_TxReady>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_TxReady
//* \brief Return 1 if a character can be written in US_THR
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_US_TxReady (
	AT91PS_USART pUSART )     // \arg pointer to a USART controller
{
21f02b80:	e1a0c00d 	mov	ip, sp
21f02b84:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02b88:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02b8c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02b90:	e50b0010 	str	r0, [fp, #-16]
    return (pUSART->US_CSR & AT91C_US_TXRDY);
21f02b94:	e51b3010 	ldr	r3, [fp, #-16]
21f02b98:	e5933014 	ldr	r3, [r3, #20]
21f02b9c:	e2033002 	and	r3, r3, #2	; 0x2
}
21f02ba0:	e1a00003 	mov	r0, r3
21f02ba4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02ba8 <AT91F_US_RxReady>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_RxReady
//* \brief Return 1 if a character can be read in US_RHR
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_US_RxReady (
	AT91PS_USART pUSART )     // \arg pointer to a USART controller
{
21f02ba8:	e1a0c00d 	mov	ip, sp
21f02bac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02bb0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02bb4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02bb8:	e50b0010 	str	r0, [fp, #-16]
    return (pUSART->US_CSR & AT91C_US_RXRDY);
21f02bbc:	e51b3010 	ldr	r3, [fp, #-16]
21f02bc0:	e5933014 	ldr	r3, [r3, #20]
21f02bc4:	e2033001 	and	r3, r3, #1	; 0x1
}
21f02bc8:	e1a00003 	mov	r0, r3
21f02bcc:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02bd0 <AT91F_US_Error>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_Error
//* \brief Return the error flag
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_US_Error (
	AT91PS_USART pUSART )     // \arg pointer to a USART controller
{
21f02bd0:	e1a0c00d 	mov	ip, sp
21f02bd4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02bd8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02bdc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02be0:	e50b0010 	str	r0, [fp, #-16]
    return (pUSART->US_CSR &
21f02be4:	e51b3010 	ldr	r3, [fp, #-16]
21f02be8:	e5933014 	ldr	r3, [r3, #20]
21f02bec:	e20330e0 	and	r3, r3, #224	; 0xe0
    	(AT91C_US_OVRE |  // Overrun error
    	 AT91C_US_FRAME | // Framing error
    	 AT91C_US_PARE));  // Parity error
}
21f02bf0:	e1a00003 	mov	r0, r3
21f02bf4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02bf8 <AT91F_US_PutChar>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_PutChar
//* \brief Send a character,does not check if ready to send
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_PutChar (
	AT91PS_USART pUSART,
	int character )
{
21f02bf8:	e1a0c00d 	mov	ip, sp
21f02bfc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02c00:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02c04:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02c08:	e50b0010 	str	r0, [fp, #-16]
21f02c0c:	e50b1014 	str	r1, [fp, #-20]
    pUSART->US_THR = (character & 0x1FF);
21f02c10:	e51b3014 	ldr	r3, [fp, #-20]
21f02c14:	e1a03b83 	mov	r3, r3, lsl #23
21f02c18:	e1a03ba3 	mov	r3, r3, lsr #23
21f02c1c:	e51b2010 	ldr	r2, [fp, #-16]
21f02c20:	e582301c 	str	r3, [r2, #28]
}
21f02c24:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02c28:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02c2c <AT91F_US_GetChar>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_GetChar
//* \brief Receive a character,does not check if a character is available
//*----------------------------------------------------------------------------
__inline__ int AT91F_US_GetChar (
	const AT91PS_USART pUSART)
{
21f02c2c:	e1a0c00d 	mov	ip, sp
21f02c30:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02c34:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02c38:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02c3c:	e50b0010 	str	r0, [fp, #-16]
    return((pUSART->US_RHR) & 0x1FF);
21f02c40:	e51b3010 	ldr	r3, [fp, #-16]
21f02c44:	e5933018 	ldr	r3, [r3, #24]
21f02c48:	e1a03b83 	mov	r3, r3, lsl #23
21f02c4c:	e1a03ba3 	mov	r3, r3, lsr #23
}
21f02c50:	e1a00003 	mov	r0, r3
21f02c54:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02c58 <AT91F_US_SendFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_SendFrame
//* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been initializaed with Next Buffer, 0 if PDC is busy
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_US_SendFrame(
	AT91PS_USART pUSART,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f02c58:	e1a0c00d 	mov	ip, sp
21f02c5c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02c60:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02c64:	e24dd014 	sub	sp, sp, #20	; 0x14
21f02c68:	e50b0010 	str	r0, [fp, #-16]
21f02c6c:	e50b1014 	str	r1, [fp, #-20]
21f02c70:	e50b2018 	str	r2, [fp, #-24]
21f02c74:	e50b301c 	str	r3, [fp, #-28]
	return AT91F_PDC_SendFrame(
21f02c78:	e51b3010 	ldr	r3, [fp, #-16]
21f02c7c:	e2833c01 	add	r3, r3, #256	; 0x100
21f02c80:	e1a02003 	mov	r2, r3
21f02c84:	e59b3004 	ldr	r3, [fp, #4]
21f02c88:	e58d3000 	str	r3, [sp]
21f02c8c:	e1a00002 	mov	r0, r2
21f02c90:	e51b1014 	ldr	r1, [fp, #-20]
21f02c94:	e51b2018 	ldr	r2, [fp, #-24]
21f02c98:	e51b301c 	ldr	r3, [fp, #-28]
21f02c9c:	ebfff8f5 	bl	21f01078 <AT91F_PDC_SendFrame>
21f02ca0:	e1a03000 	mov	r3, r0
		(AT91PS_PDC) &(pUSART->US_RPR),
		pBuffer,
		szBuffer,
		pNextBuffer,
		szNextBuffer);
}
21f02ca4:	e1a00003 	mov	r0, r3
21f02ca8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02cac:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02cb0 <AT91F_US_ReceiveFrame>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_ReceiveFrame
//* \brief Return 2 if PDC has been initialized with Buffer and Next Buffer, 1 if PDC has been initializaed with Next Buffer, 0 if PDC is busy
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_US_ReceiveFrame (
	AT91PS_USART pUSART,
	char *pBuffer,
	unsigned int szBuffer,
	char *pNextBuffer,
	unsigned int szNextBuffer )
{
21f02cb0:	e1a0c00d 	mov	ip, sp
21f02cb4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02cb8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02cbc:	e24dd014 	sub	sp, sp, #20	; 0x14
21f02cc0:	e50b0010 	str	r0, [fp, #-16]
21f02cc4:	e50b1014 	str	r1, [fp, #-20]
21f02cc8:	e50b2018 	str	r2, [fp, #-24]
21f02ccc:	e50b301c 	str	r3, [fp, #-28]
	return AT91F_PDC_ReceiveFrame(
21f02cd0:	e51b3010 	ldr	r3, [fp, #-16]
21f02cd4:	e2833c01 	add	r3, r3, #256	; 0x100
21f02cd8:	e1a02003 	mov	r2, r3
21f02cdc:	e59b3004 	ldr	r3, [fp, #4]
21f02ce0:	e58d3000 	str	r3, [sp]
21f02ce4:	e1a00002 	mov	r0, r2
21f02ce8:	e51b1014 	ldr	r1, [fp, #-20]
21f02cec:	e51b2018 	ldr	r2, [fp, #-24]
21f02cf0:	e51b301c 	ldr	r3, [fp, #-28]
21f02cf4:	ebfff909 	bl	21f01120 <AT91F_PDC_ReceiveFrame>
21f02cf8:	e1a03000 	mov	r3, r0
		(AT91PS_PDC) &(pUSART->US_RPR),
		pBuffer,
		szBuffer,
		pNextBuffer,
		szNextBuffer);
}
21f02cfc:	e1a00003 	mov	r0, r3
21f02d00:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02d04:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02d08 <AT91F_US_SetIrdaFilter>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US_SetIrdaFilter
//* \brief Set the value of IrDa filter tregister
//*----------------------------------------------------------------------------
__inline__ void AT91F_US_SetIrdaFilter (
	AT91PS_USART pUSART,
	unsigned char value
)
{
21f02d08:	e1a0c00d 	mov	ip, sp
21f02d0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02d10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02d14:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02d18:	e50b0010 	str	r0, [fp, #-16]
21f02d1c:	e1a03001 	mov	r3, r1
21f02d20:	e54b3014 	strb	r3, [fp, #-20]
	pUSART->US_IF = value;
21f02d24:	e55b2014 	ldrb	r2, [fp, #-20]
21f02d28:	e51b3010 	ldr	r3, [fp, #-16]
21f02d2c:	e583204c 	str	r2, [r3, #76]
}
21f02d30:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02d34:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02d38 <AT91F_MCI_Configure>:

/* *****************************************************************************
                SOFTWARE API FOR MCI
   ***************************************************************************** */
//* Classic MCI Mode Register Configuration with PDC mode enabled and MCK = MCI Clock
#define AT91C_MCI_MR_PDCMODE	(AT91C_MCI_CLKDIV |\
                                AT91C_MCI_PWSDIV |\
                                (AT91C_MCI_PWSDIV<<1) |\
                                AT91C_MCI_PDCMODE)

//* Classic MCI Data Timeout Register Configuration with 1048576 MCK cycles between 2 data transfer
#define AT91C_MCI_DTOR_1MEGA_CYCLES	(AT91C_MCI_DTOCYC | AT91C_MCI_DTOMUL)

//* Classic MCI SDCard Register Configuration with 1-bit data bus on slot A
#define AT91C_MCI_MMC_SLOTA	(AT91C_MCI_SCDSEL & 0x0)

//* Classic MCI SDCard Register Configuration with 1-bit data bus on slot B
#define AT91C_MCI_MMC_SLOTB	(AT91C_MCI_SCDSEL)

//* Classic MCI SDCard Register Configuration with 4-bit data bus on slot A
#define AT91C_MCI_SDCARD_4BITS_SLOTA	( (AT91C_MCI_SCDSEL & 0x0) | AT91C_MCI_SCDBUS )

//* Classic MCI SDCard Register Configuration with 4-bit data bus on slot B
#define AT91C_MCI_SDCARD_4BITS_SLOTB	(AT91C_MCI_SCDSEL | AT91C_MCI_SCDBUS)



//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_Configure
//* \brief Configure the MCI
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_Configure (
        AT91PS_MCI pMCI,  			 // \arg pointer to a MCI controller
        unsigned int DTOR_register,  // \arg Data Timeout Register to be programmed
        unsigned int MR_register,  	 // \arg Mode Register to be programmed
        unsigned int SDCR_register)  // \arg SDCard Register to be programmed
{
21f02d38:	e1a0c00d 	mov	ip, sp
21f02d3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02d40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02d44:	e24dd010 	sub	sp, sp, #16	; 0x10
21f02d48:	e50b0010 	str	r0, [fp, #-16]
21f02d4c:	e50b1014 	str	r1, [fp, #-20]
21f02d50:	e50b2018 	str	r2, [fp, #-24]
21f02d54:	e50b301c 	str	r3, [fp, #-28]
    //* Reset the MCI
    pMCI->MCI_CR = AT91C_MCI_MCIEN | AT91C_MCI_PWSEN;
21f02d58:	e51b2010 	ldr	r2, [fp, #-16]
21f02d5c:	e3a03005 	mov	r3, #5	; 0x5
21f02d60:	e5823000 	str	r3, [r2]

    //* Disable all the interrupts
    pMCI->MCI_IDR = 0xFFFFFFFF;
21f02d64:	e51b2010 	ldr	r2, [fp, #-16]
21f02d68:	e3e03000 	mvn	r3, #0	; 0x0
21f02d6c:	e5823048 	str	r3, [r2, #72]

    //* Set the Data Timeout Register
    pMCI->MCI_DTOR = DTOR_register;
21f02d70:	e51b2010 	ldr	r2, [fp, #-16]
21f02d74:	e51b3014 	ldr	r3, [fp, #-20]
21f02d78:	e5823008 	str	r3, [r2, #8]

    //* Set the Mode Register
    pMCI->MCI_MR = MR_register;
21f02d7c:	e51b2010 	ldr	r2, [fp, #-16]
21f02d80:	e51b3018 	ldr	r3, [fp, #-24]
21f02d84:	e5823004 	str	r3, [r2, #4]

    //* Set the SDCard Register
    pMCI->MCI_SDCR = SDCR_register;
21f02d88:	e51b2010 	ldr	r2, [fp, #-16]
21f02d8c:	e51b301c 	ldr	r3, [fp, #-28]
21f02d90:	e582300c 	str	r3, [r2, #12]
}
21f02d94:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02d98:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02d9c <AT91F_MCI_EnableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_EnableIt
//* \brief Enable MCI IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_EnableIt (
        AT91PS_MCI pMCI, // \arg pointer to a MCI controller
        unsigned int flag)   // \arg IT to be enabled
{
21f02d9c:	e1a0c00d 	mov	ip, sp
21f02da0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02da4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02da8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02dac:	e50b0010 	str	r0, [fp, #-16]
21f02db0:	e50b1014 	str	r1, [fp, #-20]
    //* Write to the IER register
    pMCI->MCI_IER = flag;
21f02db4:	e51b2010 	ldr	r2, [fp, #-16]
21f02db8:	e51b3014 	ldr	r3, [fp, #-20]
21f02dbc:	e5823044 	str	r3, [r2, #68]
}
21f02dc0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02dc4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02dc8 <AT91F_MCI_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_DisableIt
//* \brief Disable MCI IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_DisableIt (
        AT91PS_MCI pMCI, // \arg pointer to a MCI controller
        unsigned int flag)   // \arg IT to be disabled
{
21f02dc8:	e1a0c00d 	mov	ip, sp
21f02dcc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02dd0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02dd4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02dd8:	e50b0010 	str	r0, [fp, #-16]
21f02ddc:	e50b1014 	str	r1, [fp, #-20]
    //* Write to the IDR register
    pMCI->MCI_IDR = flag;
21f02de0:	e51b2010 	ldr	r2, [fp, #-16]
21f02de4:	e51b3014 	ldr	r3, [fp, #-20]
21f02de8:	e5823048 	str	r3, [r2, #72]
}
21f02dec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02df0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02df4 <AT91F_MCI_Enable_Interface>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_Enable_Interface
//* \brief Enable the MCI Interface
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_Enable_Interface (
        AT91PS_MCI pMCI)     // \arg pointer to a MCI controller
{
21f02df4:	e1a0c00d 	mov	ip, sp
21f02df8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02dfc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02e00:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02e04:	e50b0010 	str	r0, [fp, #-16]
    //* Enable the MCI
    pMCI->MCI_CR = AT91C_MCI_MCIEN;
21f02e08:	e51b2010 	ldr	r2, [fp, #-16]
21f02e0c:	e3a03001 	mov	r3, #1	; 0x1
21f02e10:	e5823000 	str	r3, [r2]
}
21f02e14:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02e18 <AT91F_MCI_Disable_Interface>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_Disable_Interface
//* \brief Disable the MCI Interface
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_Disable_Interface (
        AT91PS_MCI pMCI)     // \arg pointer to a MCI controller
{
21f02e18:	e1a0c00d 	mov	ip, sp
21f02e1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02e20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02e24:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02e28:	e50b0010 	str	r0, [fp, #-16]
    //* Disable the MCI
    pMCI->MCI_CR = AT91C_MCI_MCIDIS;
21f02e2c:	e51b2010 	ldr	r2, [fp, #-16]
21f02e30:	e3a03002 	mov	r3, #2	; 0x2
21f02e34:	e5823000 	str	r3, [r2]
}
21f02e38:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02e3c <AT91F_MCI_Cfg_ModeRegister>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_Cfg_ModeRegister
//* \brief Configure the MCI Mode Register
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_Cfg_ModeRegister (
        AT91PS_MCI pMCI, // \arg pointer to a MCI controller
        unsigned int mode_register)   // \arg value to set in the mode register
{
21f02e3c:	e1a0c00d 	mov	ip, sp
21f02e40:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02e44:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02e48:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02e4c:	e50b0010 	str	r0, [fp, #-16]
21f02e50:	e50b1014 	str	r1, [fp, #-20]
    //* Configure the MCI MR
    pMCI->MCI_MR = mode_register;
21f02e54:	e51b2010 	ldr	r2, [fp, #-16]
21f02e58:	e51b3014 	ldr	r3, [fp, #-20]
21f02e5c:	e5823004 	str	r3, [r2, #4]
}
21f02e60:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02e64:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02e68 <AT91F_AIC_ConfigureIt>:
/* *****************************************************************************
                SOFTWARE API FOR AIC
   ***************************************************************************** */
#define AT91C_AIC_BRANCH_OPCODE ((void (*) ()) 0xE51FFF20) // ldr, pc, [pc, #-&F20]

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_ConfigureIt
//* \brief Interrupt Handler Initialization
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_AIC_ConfigureIt (
	AT91PS_AIC pAic,  // \arg pointer to the AIC registers
	unsigned int irq_id,     // \arg interrupt number to initialize
	unsigned int priority,   // \arg priority to give to the interrupt
	unsigned int src_type,   // \arg activation and sense of activation
	void (*newHandler) (void) ) // \arg address of the interrupt handler
{
21f02e68:	e1a0c00d 	mov	ip, sp
21f02e6c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02e70:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02e74:	e24dd018 	sub	sp, sp, #24	; 0x18
21f02e78:	e50b0018 	str	r0, [fp, #-24]
21f02e7c:	e50b101c 	str	r1, [fp, #-28]
21f02e80:	e50b2020 	str	r2, [fp, #-32]
21f02e84:	e50b3024 	str	r3, [fp, #-36]
	unsigned int oldHandler;
    unsigned int mask ;

    oldHandler = pAic->AIC_SVR[irq_id];
21f02e88:	e51b301c 	ldr	r3, [fp, #-28]
21f02e8c:	e51b2018 	ldr	r2, [fp, #-24]
21f02e90:	e3a01080 	mov	r1, #128	; 0x80
21f02e94:	e1a03103 	mov	r3, r3, lsl #2
21f02e98:	e0833002 	add	r3, r3, r2
21f02e9c:	e0833001 	add	r3, r3, r1
21f02ea0:	e5933000 	ldr	r3, [r3]
21f02ea4:	e50b3014 	str	r3, [fp, #-20]

    mask = 0x1 << irq_id ;
21f02ea8:	e51b201c 	ldr	r2, [fp, #-28]
21f02eac:	e3a03001 	mov	r3, #1	; 0x1
21f02eb0:	e1a03213 	mov	r3, r3, lsl r2
21f02eb4:	e50b3010 	str	r3, [fp, #-16]
    //* Disable the interrupt on the interrupt controller
    pAic->AIC_IDCR = mask ;
21f02eb8:	e51b2018 	ldr	r2, [fp, #-24]
21f02ebc:	e51b3010 	ldr	r3, [fp, #-16]
21f02ec0:	e5823124 	str	r3, [r2, #292]
    //* Save the interrupt handler routine pointer and the interrupt priority
    pAic->AIC_SVR[irq_id] = (unsigned int) newHandler ;
21f02ec4:	e51b001c 	ldr	r0, [fp, #-28]
21f02ec8:	e59b3004 	ldr	r3, [fp, #4]
21f02ecc:	e1a0c003 	mov	ip, r3
21f02ed0:	e51b2018 	ldr	r2, [fp, #-24]
21f02ed4:	e3a01080 	mov	r1, #128	; 0x80
21f02ed8:	e1a03100 	mov	r3, r0, lsl #2
21f02edc:	e0833002 	add	r3, r3, r2
21f02ee0:	e0833001 	add	r3, r3, r1
21f02ee4:	e583c000 	str	ip, [r3]
    //* Store the Source Mode Register
    pAic->AIC_SMR[irq_id] = src_type | priority  ;
21f02ee8:	e51b101c 	ldr	r1, [fp, #-28]
21f02eec:	e51b2024 	ldr	r2, [fp, #-36]
21f02ef0:	e51b3020 	ldr	r3, [fp, #-32]
21f02ef4:	e1822003 	orr	r2, r2, r3
21f02ef8:	e51b3018 	ldr	r3, [fp, #-24]
21f02efc:	e7832101 	str	r2, [r3, r1, lsl #2]
    //* Clear the interrupt on the interrupt controller
    pAic->AIC_ICCR = mask ;
21f02f00:	e51b2018 	ldr	r2, [fp, #-24]
21f02f04:	e51b3010 	ldr	r3, [fp, #-16]
21f02f08:	e5823128 	str	r3, [r2, #296]

	return oldHandler;
21f02f0c:	e51b3014 	ldr	r3, [fp, #-20]
}
21f02f10:	e1a00003 	mov	r0, r3
21f02f14:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02f18:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02f1c <AT91F_AIC_EnableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_EnableIt
//* \brief Enable corresponding IT number
//*----------------------------------------------------------------------------
__inline__ void AT91F_AIC_EnableIt (
	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
	unsigned int irq_id ) // \arg interrupt number to initialize
{
21f02f1c:	e1a0c00d 	mov	ip, sp
21f02f20:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02f24:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02f28:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02f2c:	e50b0010 	str	r0, [fp, #-16]
21f02f30:	e50b1014 	str	r1, [fp, #-20]
    //* Enable the interrupt on the interrupt controller
    pAic->AIC_IECR = 0x1 << irq_id ;
21f02f34:	e51b2014 	ldr	r2, [fp, #-20]
21f02f38:	e3a03001 	mov	r3, #1	; 0x1
21f02f3c:	e1a03213 	mov	r3, r3, lsl r2
21f02f40:	e1a02003 	mov	r2, r3
21f02f44:	e51b3010 	ldr	r3, [fp, #-16]
21f02f48:	e5832120 	str	r2, [r3, #288]
}
21f02f4c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02f50:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02f54 <AT91F_AIC_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_DisableIt
//* \brief Disable corresponding IT number
//*----------------------------------------------------------------------------
__inline__ void AT91F_AIC_DisableIt (
	AT91PS_AIC pAic,      // \arg pointer to the AIC registers
	unsigned int irq_id ) // \arg interrupt number to initialize
{
21f02f54:	e1a0c00d 	mov	ip, sp
21f02f58:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02f5c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02f60:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f02f64:	e50b0014 	str	r0, [fp, #-20]
21f02f68:	e50b1018 	str	r1, [fp, #-24]
    unsigned int mask = 0x1 << irq_id;
21f02f6c:	e51b2018 	ldr	r2, [fp, #-24]
21f02f70:	e3a03001 	mov	r3, #1	; 0x1
21f02f74:	e1a03213 	mov	r3, r3, lsl r2
21f02f78:	e50b3010 	str	r3, [fp, #-16]
    //* Disable the interrupt on the interrupt controller
    pAic->AIC_IDCR = mask ;
21f02f7c:	e51b2014 	ldr	r2, [fp, #-20]
21f02f80:	e51b3010 	ldr	r3, [fp, #-16]
21f02f84:	e5823124 	str	r3, [r2, #292]
    //* Clear the interrupt on the Interrupt Controller ( if one is pending )
    pAic->AIC_ICCR = mask ;
21f02f88:	e51b2014 	ldr	r2, [fp, #-20]
21f02f8c:	e51b3010 	ldr	r3, [fp, #-16]
21f02f90:	e5823128 	str	r3, [r2, #296]
}
21f02f94:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02f98:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02f9c <AT91F_AIC_ClearIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_ClearIt
//* \brief Clear corresponding IT number
//*----------------------------------------------------------------------------
__inline__ void AT91F_AIC_ClearIt (
	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
	unsigned int irq_id) // \arg interrupt number to initialize
{
21f02f9c:	e1a0c00d 	mov	ip, sp
21f02fa0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02fa4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02fa8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f02fac:	e50b0010 	str	r0, [fp, #-16]
21f02fb0:	e50b1014 	str	r1, [fp, #-20]
    //* Clear the interrupt on the Interrupt Controller ( if one is pending )
    pAic->AIC_ICCR = (0x1 << irq_id);
21f02fb4:	e51b2014 	ldr	r2, [fp, #-20]
21f02fb8:	e3a03001 	mov	r3, #1	; 0x1
21f02fbc:	e1a03213 	mov	r3, r3, lsl r2
21f02fc0:	e1a02003 	mov	r2, r3
21f02fc4:	e51b3010 	ldr	r3, [fp, #-16]
21f02fc8:	e5832128 	str	r2, [r3, #296]
}
21f02fcc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f02fd0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f02fd4 <AT91F_AIC_AcknowledgeIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_AcknowledgeIt
//* \brief Acknowledge corresponding IT number
//*----------------------------------------------------------------------------
__inline__ void AT91F_AIC_AcknowledgeIt (
	AT91PS_AIC pAic)     // \arg pointer to the AIC registers
{
21f02fd4:	e1a0c00d 	mov	ip, sp
21f02fd8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f02fdc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f02fe0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f02fe4:	e50b0010 	str	r0, [fp, #-16]
    pAic->AIC_EOICR = pAic->AIC_EOICR;
21f02fe8:	e51b3010 	ldr	r3, [fp, #-16]
21f02fec:	e5932130 	ldr	r2, [r3, #304]
21f02ff0:	e51b3010 	ldr	r3, [fp, #-16]
21f02ff4:	e5832130 	str	r2, [r3, #304]
}
21f02ff8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f02ffc <AT91F_AIC_SetExceptionVector>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_SetExceptionVector
//* \brief Configure vector handler
//*----------------------------------------------------------------------------
__inline__ unsigned int  AT91F_AIC_SetExceptionVector (
	unsigned int *pVector, // \arg pointer to the AIC registers
	void (*Handler) () )   // \arg Interrupt Handler
{
21f02ffc:	e1a0c00d 	mov	ip, sp
21f03000:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03004:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03008:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0300c:	e50b0014 	str	r0, [fp, #-20]
21f03010:	e50b1018 	str	r1, [fp, #-24]
	unsigned int oldVector = *pVector;
21f03014:	e51b3014 	ldr	r3, [fp, #-20]
21f03018:	e5933000 	ldr	r3, [r3]
21f0301c:	e50b3010 	str	r3, [fp, #-16]

	if ((unsigned int) Handler == (unsigned int) AT91C_AIC_BRANCH_OPCODE)
21f03020:	e51b2018 	ldr	r2, [fp, #-24]
21f03024:	e3e0356b 	mvn	r3, #448790528	; 0x1ac00000
21f03028:	e2433602 	sub	r3, r3, #2097152	; 0x200000
21f0302c:	e24330df 	sub	r3, r3, #223	; 0xdf
21f03030:	e1520003 	cmp	r2, r3
21f03034:	1a000005 	bne	21f03050 <AT91F_AIC_SetExceptionVector+0x54>
		*pVector = (unsigned int) AT91C_AIC_BRANCH_OPCODE;
21f03038:	e51b2014 	ldr	r2, [fp, #-20]
21f0303c:	e3e0356b 	mvn	r3, #448790528	; 0x1ac00000
21f03040:	e2433602 	sub	r3, r3, #2097152	; 0x200000
21f03044:	e24330df 	sub	r3, r3, #223	; 0xdf
21f03048:	e5823000 	str	r3, [r2]
21f0304c:	ea000009 	b	21f03078 <AT91F_AIC_SetExceptionVector+0x7c>
	else
		*pVector = (((((unsigned int) Handler) - ((unsigned int) pVector) - 0x8) >> 2) & 0x00FFFFFF) | 0xEA000000;
21f03050:	e51b3018 	ldr	r3, [fp, #-24]
21f03054:	e1a02003 	mov	r2, r3
21f03058:	e51b3014 	ldr	r3, [fp, #-20]
21f0305c:	e0633002 	rsb	r3, r3, r2
21f03060:	e2433008 	sub	r3, r3, #8	; 0x8
21f03064:	e1a03123 	mov	r3, r3, lsr #2
21f03068:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
21f0306c:	e38324ea 	orr	r2, r3, #-369098752	; 0xea000000
21f03070:	e51b3014 	ldr	r3, [fp, #-20]
21f03074:	e5832000 	str	r2, [r3]

	return oldVector;
21f03078:	e51b3010 	ldr	r3, [fp, #-16]
}
21f0307c:	e1a00003 	mov	r0, r3
21f03080:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03084:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03088 <AT91F_AIC_Trig>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_Trig
//* \brief Trig an IT
//*----------------------------------------------------------------------------
__inline__ void  AT91F_AIC_Trig (
	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
	unsigned int irq_id) // \arg interrupt number
{
21f03088:	e1a0c00d 	mov	ip, sp
21f0308c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03090:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03094:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03098:	e50b0010 	str	r0, [fp, #-16]
21f0309c:	e50b1014 	str	r1, [fp, #-20]
	pAic->AIC_ISCR = (0x1 << irq_id) ;
21f030a0:	e51b2014 	ldr	r2, [fp, #-20]
21f030a4:	e3a03001 	mov	r3, #1	; 0x1
21f030a8:	e1a03213 	mov	r3, r3, lsl r2
21f030ac:	e1a02003 	mov	r2, r3
21f030b0:	e51b3010 	ldr	r3, [fp, #-16]
21f030b4:	e583212c 	str	r2, [r3, #300]
}
21f030b8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f030bc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f030c0 <AT91F_AIC_IsActive>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_IsActive
//* \brief Test if an IT is active
//*----------------------------------------------------------------------------
__inline__ unsigned int  AT91F_AIC_IsActive (
	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
	unsigned int irq_id) // \arg Interrupt Number
{
21f030c0:	e1a0c00d 	mov	ip, sp
21f030c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f030c8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f030cc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f030d0:	e50b0010 	str	r0, [fp, #-16]
21f030d4:	e50b1014 	str	r1, [fp, #-20]
	return (pAic->AIC_ISR & (0x1 << irq_id));
21f030d8:	e51b3010 	ldr	r3, [fp, #-16]
21f030dc:	e5931108 	ldr	r1, [r3, #264]
21f030e0:	e51b2014 	ldr	r2, [fp, #-20]
21f030e4:	e3a03001 	mov	r3, #1	; 0x1
21f030e8:	e1a03213 	mov	r3, r3, lsl r2
21f030ec:	e0013003 	and	r3, r1, r3
}
21f030f0:	e1a00003 	mov	r0, r3
21f030f4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f030f8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f030fc <AT91F_AIC_IsPending>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_IsPending
//* \brief Test if an IT is pending
//*----------------------------------------------------------------------------
__inline__ unsigned int  AT91F_AIC_IsPending (
	AT91PS_AIC pAic,     // \arg pointer to the AIC registers
	unsigned int irq_id) // \arg Interrupt Number
{
21f030fc:	e1a0c00d 	mov	ip, sp
21f03100:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03104:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03108:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0310c:	e50b0010 	str	r0, [fp, #-16]
21f03110:	e50b1014 	str	r1, [fp, #-20]
	return (pAic->AIC_IPR & (0x1 << irq_id));
21f03114:	e51b3010 	ldr	r3, [fp, #-16]
21f03118:	e593110c 	ldr	r1, [r3, #268]
21f0311c:	e51b2014 	ldr	r2, [fp, #-20]
21f03120:	e3a03001 	mov	r3, #1	; 0x1
21f03124:	e1a03213 	mov	r3, r3, lsl r2
21f03128:	e0013003 	and	r3, r1, r3
}
21f0312c:	e1a00003 	mov	r0, r3
21f03130:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03134:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03138 <AT91F_AIC_Open>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_Open
//* \brief Set exception vectors and AIC registers to default values
//*----------------------------------------------------------------------------
__inline__ void AT91F_AIC_Open(
	AT91PS_AIC pAic,        // \arg pointer to the AIC registers
	void (*IrqHandler) (),  // \arg Default IRQ vector exception
	void (*FiqHandler) (),  // \arg Default FIQ vector exception
	void (*DefaultHandler)  (), // \arg Default Handler set in ISR
	void (*SpuriousHandler) (), // \arg Default Spurious Handler
	unsigned int protectMode)   // \arg Debug Control Register
{
21f03138:	e1a0c00d 	mov	ip, sp
21f0313c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03140:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03144:	e24dd018 	sub	sp, sp, #24	; 0x18
21f03148:	e50b0014 	str	r0, [fp, #-20]
21f0314c:	e50b1018 	str	r1, [fp, #-24]
21f03150:	e50b201c 	str	r2, [fp, #-28]
21f03154:	e50b3020 	str	r3, [fp, #-32]
	int i;

	// Disable all interrupts and set IVR to the default handler
	for (i = 0; i < 32; ++i) {
21f03158:	e3a03000 	mov	r3, #0	; 0x0
21f0315c:	e50b3010 	str	r3, [fp, #-16]
21f03160:	ea00000e 	b	21f031a0 <AT91F_AIC_Open+0x68>
		AT91F_AIC_DisableIt(pAic, i);
21f03164:	e51b3010 	ldr	r3, [fp, #-16]
21f03168:	e51b0014 	ldr	r0, [fp, #-20]
21f0316c:	e1a01003 	mov	r1, r3
21f03170:	ebffff77 	bl	21f02f54 <AT91F_AIC_DisableIt>
		AT91F_AIC_ConfigureIt(pAic, i, AT91C_AIC_PRIOR_LOWEST, AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE, DefaultHandler);
21f03174:	e51b2010 	ldr	r2, [fp, #-16]
21f03178:	e51b3020 	ldr	r3, [fp, #-32]
21f0317c:	e58d3000 	str	r3, [sp]
21f03180:	e51b0014 	ldr	r0, [fp, #-20]
21f03184:	e1a01002 	mov	r1, r2
21f03188:	e3a02000 	mov	r2, #0	; 0x0
21f0318c:	e3a03000 	mov	r3, #0	; 0x0
21f03190:	ebffff34 	bl	21f02e68 <AT91F_AIC_ConfigureIt>
21f03194:	e51b3010 	ldr	r3, [fp, #-16]
21f03198:	e2833001 	add	r3, r3, #1	; 0x1
21f0319c:	e50b3010 	str	r3, [fp, #-16]
21f031a0:	e51b3010 	ldr	r3, [fp, #-16]
21f031a4:	e353001f 	cmp	r3, #31	; 0x1f
21f031a8:	daffffed 	ble	21f03164 <AT91F_AIC_Open+0x2c>
	}

	// Set the IRQ exception vector
	AT91F_AIC_SetExceptionVector((unsigned int *) 0x18, IrqHandler);
21f031ac:	e3a00018 	mov	r0, #24	; 0x18
21f031b0:	e51b1018 	ldr	r1, [fp, #-24]
21f031b4:	ebffff90 	bl	21f02ffc <AT91F_AIC_SetExceptionVector>
	// Set the Fast Interrupt exception vector
	AT91F_AIC_SetExceptionVector((unsigned int *) 0x1C, FiqHandler);
21f031b8:	e3a0001c 	mov	r0, #28	; 0x1c
21f031bc:	e51b101c 	ldr	r1, [fp, #-28]
21f031c0:	ebffff8d 	bl	21f02ffc <AT91F_AIC_SetExceptionVector>

	pAic->AIC_SPU = (unsigned int) SpuriousHandler;
21f031c4:	e59b3004 	ldr	r3, [fp, #4]
21f031c8:	e1a02003 	mov	r2, r3
21f031cc:	e51b3014 	ldr	r3, [fp, #-20]
21f031d0:	e5832134 	str	r2, [r3, #308]
	pAic->AIC_DCR = protectMode;
21f031d4:	e51b2014 	ldr	r2, [fp, #-20]
21f031d8:	e59b3008 	ldr	r3, [fp, #8]
21f031dc:	e5823138 	str	r3, [r2, #312]
}
21f031e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f031e4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f031e8 <AT91F_UDP_EnableIt>:
/* *****************************************************************************
                SOFTWARE API FOR UDP
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EnableIt
//* \brief Enable UDP IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_EnableIt (
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned int flag)   // \arg IT to be enabled
{
21f031e8:	e1a0c00d 	mov	ip, sp
21f031ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f031f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f031f4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f031f8:	e50b0010 	str	r0, [fp, #-16]
21f031fc:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IER register
	pUDP->UDP_IER = flag;
21f03200:	e51b2010 	ldr	r2, [fp, #-16]
21f03204:	e51b3014 	ldr	r3, [fp, #-20]
21f03208:	e5823010 	str	r3, [r2, #16]
}
21f0320c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03210:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03214 <AT91F_UDP_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_DisableIt
//* \brief Disable UDP IT
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_DisableIt (
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned int flag)   // \arg IT to be disabled
{
21f03214:	e1a0c00d 	mov	ip, sp
21f03218:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0321c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03220:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03224:	e50b0010 	str	r0, [fp, #-16]
21f03228:	e50b1014 	str	r1, [fp, #-20]
	//* Write to the IDR register
	pUDP->UDP_IDR = flag;
21f0322c:	e51b2010 	ldr	r2, [fp, #-16]
21f03230:	e51b3014 	ldr	r3, [fp, #-20]
21f03234:	e5823014 	str	r3, [r2, #20]
}
21f03238:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0323c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03240 <AT91F_UDP_SetAddress>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_SetAddress
//* \brief Set UDP functional address
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_SetAddress (
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned char address)   // \arg new UDP address
{
21f03240:	e1a0c00d 	mov	ip, sp
21f03244:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03248:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0324c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03250:	e50b0010 	str	r0, [fp, #-16]
21f03254:	e1a03001 	mov	r3, r1
21f03258:	e54b3014 	strb	r3, [fp, #-20]
	pUDP->UDP_FADDR = (AT91C_UDP_FEN | address);
21f0325c:	e55b3014 	ldrb	r3, [fp, #-20]
21f03260:	e3832c01 	orr	r2, r3, #256	; 0x100
21f03264:	e51b3010 	ldr	r3, [fp, #-16]
21f03268:	e5832008 	str	r2, [r3, #8]
}
21f0326c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03270:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03274 <AT91F_UDP_EnableEp>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EnableEp
//* \brief Enable Endpoint
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_EnableEp (
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned int flag)   // \arg endpoints to be enabled
{
21f03274:	e1a0c00d 	mov	ip, sp
21f03278:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0327c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03280:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03284:	e50b0010 	str	r0, [fp, #-16]
21f03288:	e50b1014 	str	r1, [fp, #-20]
	pUDP->UDP_GLBSTATE  |= flag;
21f0328c:	e51b3010 	ldr	r3, [fp, #-16]
21f03290:	e5932004 	ldr	r2, [r3, #4]
21f03294:	e51b3014 	ldr	r3, [fp, #-20]
21f03298:	e1822003 	orr	r2, r2, r3
21f0329c:	e51b3010 	ldr	r3, [fp, #-16]
21f032a0:	e5832004 	str	r2, [r3, #4]
}
21f032a4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f032a8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f032ac <AT91F_UDP_DisableEp>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_DisableEp
//* \brief Enable Endpoint
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_DisableEp (
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned int flag)   // \arg endpoints to be enabled
{
21f032ac:	e1a0c00d 	mov	ip, sp
21f032b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f032b4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f032b8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f032bc:	e50b0010 	str	r0, [fp, #-16]
21f032c0:	e50b1014 	str	r1, [fp, #-20]
	pUDP->UDP_GLBSTATE  &= ~(flag);
21f032c4:	e51b3010 	ldr	r3, [fp, #-16]
21f032c8:	e5932004 	ldr	r2, [r3, #4]
21f032cc:	e51b3014 	ldr	r3, [fp, #-20]
21f032d0:	e1e03003 	mvn	r3, r3
21f032d4:	e0022003 	and	r2, r2, r3
21f032d8:	e51b3010 	ldr	r3, [fp, #-16]
21f032dc:	e5832004 	str	r2, [r3, #4]
}
21f032e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f032e4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f032e8 <AT91F_UDP_SetState>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_SetState
//* \brief Set UDP Device state
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_SetState (
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned int flag)   // \arg new UDP address
{
21f032e8:	e1a0c00d 	mov	ip, sp
21f032ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f032f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f032f4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f032f8:	e50b0010 	str	r0, [fp, #-16]
21f032fc:	e50b1014 	str	r1, [fp, #-20]
	pUDP->UDP_GLBSTATE  &= ~(AT91C_UDP_FADDEN | AT91C_UDP_CONFG);
21f03300:	e51b3010 	ldr	r3, [fp, #-16]
21f03304:	e5933004 	ldr	r3, [r3, #4]
21f03308:	e3c32003 	bic	r2, r3, #3	; 0x3
21f0330c:	e51b3010 	ldr	r3, [fp, #-16]
21f03310:	e5832004 	str	r2, [r3, #4]
	pUDP->UDP_GLBSTATE  |= flag;
21f03314:	e51b3010 	ldr	r3, [fp, #-16]
21f03318:	e5932004 	ldr	r2, [r3, #4]
21f0331c:	e51b3014 	ldr	r3, [fp, #-20]
21f03320:	e1822003 	orr	r2, r2, r3
21f03324:	e51b3010 	ldr	r3, [fp, #-16]
21f03328:	e5832004 	str	r2, [r3, #4]
}
21f0332c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03330:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03334 <AT91F_UDP_GetState>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_GetState
//* \brief return UDP Device state
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_UDP_GetState ( // \return the UDP device state
	AT91PS_UDP pUDP)     // \arg pointer to a UDP controller
{
21f03334:	e1a0c00d 	mov	ip, sp
21f03338:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0333c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03340:	e24dd004 	sub	sp, sp, #4	; 0x4
21f03344:	e50b0010 	str	r0, [fp, #-16]
	return (pUDP->UDP_GLBSTATE  & (AT91C_UDP_FADDEN | AT91C_UDP_CONFG));
21f03348:	e51b3010 	ldr	r3, [fp, #-16]
21f0334c:	e5933004 	ldr	r3, [r3, #4]
21f03350:	e2033003 	and	r3, r3, #3	; 0x3
}
21f03354:	e1a00003 	mov	r0, r3
21f03358:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0335c <AT91F_UDP_ResetEp>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_ResetEp
//* \brief Reset UDP endpoint
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_ResetEp ( // \return the UDP device state
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned int flag)   // \arg Endpoints to be reset
{
21f0335c:	e1a0c00d 	mov	ip, sp
21f03360:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03364:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03368:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0336c:	e50b0010 	str	r0, [fp, #-16]
21f03370:	e50b1014 	str	r1, [fp, #-20]
	pUDP->UDP_RSTEP = flag;
21f03374:	e51b2010 	ldr	r2, [fp, #-16]
21f03378:	e51b3014 	ldr	r3, [fp, #-20]
21f0337c:	e5823028 	str	r3, [r2, #40]
}
21f03380:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03384:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03388 <AT91F_UDP_EpStall>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EpStall
//* \brief Endpoint will STALL requests
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_EpStall(
	AT91PS_UDP pUDP,     // \arg pointer to a UDP controller
	unsigned char endpoint)   // \arg endpoint number
{
21f03388:	e1a0c00d 	mov	ip, sp
21f0338c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03390:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03394:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03398:	e50b0010 	str	r0, [fp, #-16]
21f0339c:	e1a03001 	mov	r3, r1
21f033a0:	e54b3014 	strb	r3, [fp, #-20]
	pUDP->UDP_CSR[endpoint] |= AT91C_UDP_FORCESTALL;
21f033a4:	e55bc014 	ldrb	ip, [fp, #-20]
21f033a8:	e55b3014 	ldrb	r3, [fp, #-20]
21f033ac:	e51b2010 	ldr	r2, [fp, #-16]
21f033b0:	e3a01030 	mov	r1, #48	; 0x30
21f033b4:	e1a03103 	mov	r3, r3, lsl #2
21f033b8:	e0833002 	add	r3, r3, r2
21f033bc:	e0833001 	add	r3, r3, r1
21f033c0:	e5933000 	ldr	r3, [r3]
21f033c4:	e3830020 	orr	r0, r3, #32	; 0x20
21f033c8:	e51b2010 	ldr	r2, [fp, #-16]
21f033cc:	e3a01030 	mov	r1, #48	; 0x30
21f033d0:	e1a0310c 	mov	r3, ip, lsl #2
21f033d4:	e0833002 	add	r3, r3, r2
21f033d8:	e0833001 	add	r3, r3, r1
21f033dc:	e5830000 	str	r0, [r3]
}
21f033e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f033e4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f033e8 <AT91F_UDP_EpWrite>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EpWrite
//* \brief Write value in the DPR
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_EpWrite(
	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
	unsigned char endpoint,  // \arg endpoint number
	unsigned char value)     // \arg value to be written in the DPR
{
21f033e8:	e1a0c00d 	mov	ip, sp
21f033ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f033f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f033f4:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f033f8:	e50b0010 	str	r0, [fp, #-16]
21f033fc:	e1a03001 	mov	r3, r1
21f03400:	e54b3014 	strb	r3, [fp, #-20]
21f03404:	e1a03002 	mov	r3, r2
21f03408:	e54b3018 	strb	r3, [fp, #-24]
	pUDP->UDP_FDR[endpoint] = value;
21f0340c:	e55b3014 	ldrb	r3, [fp, #-20]
21f03410:	e55b0018 	ldrb	r0, [fp, #-24]
21f03414:	e51b2010 	ldr	r2, [fp, #-16]
21f03418:	e3a01050 	mov	r1, #80	; 0x50
21f0341c:	e1a03103 	mov	r3, r3, lsl #2
21f03420:	e0833002 	add	r3, r3, r2
21f03424:	e0833001 	add	r3, r3, r1
21f03428:	e5830000 	str	r0, [r3]
}
21f0342c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03430:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03434 <AT91F_UDP_EpRead>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EpRead
//* \brief Return value from the DPR
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_UDP_EpRead(
	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
	unsigned char endpoint)  // \arg endpoint number
{
21f03434:	e1a0c00d 	mov	ip, sp
21f03438:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0343c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03440:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03444:	e50b0010 	str	r0, [fp, #-16]
21f03448:	e1a03001 	mov	r3, r1
21f0344c:	e54b3014 	strb	r3, [fp, #-20]
	return pUDP->UDP_FDR[endpoint];
21f03450:	e55b3014 	ldrb	r3, [fp, #-20]
21f03454:	e51b2010 	ldr	r2, [fp, #-16]
21f03458:	e3a01050 	mov	r1, #80	; 0x50
21f0345c:	e1a03103 	mov	r3, r3, lsl #2
21f03460:	e0833002 	add	r3, r3, r2
21f03464:	e0833001 	add	r3, r3, r1
21f03468:	e5933000 	ldr	r3, [r3]
}
21f0346c:	e1a00003 	mov	r0, r3
21f03470:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03474:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03478 <AT91F_UDP_EpEndOfWr>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EpEndOfWr
//* \brief Notify the UDP that values in DPR are ready to be sent
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_EpEndOfWr(
	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
	unsigned char endpoint)  // \arg endpoint number
{
21f03478:	e1a0c00d 	mov	ip, sp
21f0347c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03480:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03484:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03488:	e50b0010 	str	r0, [fp, #-16]
21f0348c:	e1a03001 	mov	r3, r1
21f03490:	e54b3014 	strb	r3, [fp, #-20]
	pUDP->UDP_CSR[endpoint] |= AT91C_UDP_TXPKTRDY;
21f03494:	e55bc014 	ldrb	ip, [fp, #-20]
21f03498:	e55b3014 	ldrb	r3, [fp, #-20]
21f0349c:	e51b2010 	ldr	r2, [fp, #-16]
21f034a0:	e3a01030 	mov	r1, #48	; 0x30
21f034a4:	e1a03103 	mov	r3, r3, lsl #2
21f034a8:	e0833002 	add	r3, r3, r2
21f034ac:	e0833001 	add	r3, r3, r1
21f034b0:	e5933000 	ldr	r3, [r3]
21f034b4:	e3830010 	orr	r0, r3, #16	; 0x10
21f034b8:	e51b2010 	ldr	r2, [fp, #-16]
21f034bc:	e3a01030 	mov	r1, #48	; 0x30
21f034c0:	e1a0310c 	mov	r3, ip, lsl #2
21f034c4:	e0833002 	add	r3, r3, r2
21f034c8:	e0833001 	add	r3, r3, r1
21f034cc:	e5830000 	str	r0, [r3]
}
21f034d0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f034d4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f034d8 <AT91F_UDP_EpClear>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EpClear
//* \brief Clear flag in the endpoint CSR register
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_EpClear(
	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
	unsigned char endpoint,  // \arg endpoint number
	unsigned int flag)       // \arg flag to be cleared
{
21f034d8:	e1a0c00d 	mov	ip, sp
21f034dc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f034e0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f034e4:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f034e8:	e50b0010 	str	r0, [fp, #-16]
21f034ec:	e1a03001 	mov	r3, r1
21f034f0:	e50b2018 	str	r2, [fp, #-24]
21f034f4:	e54b3014 	strb	r3, [fp, #-20]
	pUDP->UDP_CSR[endpoint] &= ~(flag);
21f034f8:	e55bc014 	ldrb	ip, [fp, #-20]
21f034fc:	e55b3014 	ldrb	r3, [fp, #-20]
21f03500:	e51b2010 	ldr	r2, [fp, #-16]
21f03504:	e3a01030 	mov	r1, #48	; 0x30
21f03508:	e1a03103 	mov	r3, r3, lsl #2
21f0350c:	e0833002 	add	r3, r3, r2
21f03510:	e0833001 	add	r3, r3, r1
21f03514:	e5932000 	ldr	r2, [r3]
21f03518:	e51b3018 	ldr	r3, [fp, #-24]
21f0351c:	e1e03003 	mvn	r3, r3
21f03520:	e0020003 	and	r0, r2, r3
21f03524:	e51b2010 	ldr	r2, [fp, #-16]
21f03528:	e3a01030 	mov	r1, #48	; 0x30
21f0352c:	e1a0310c 	mov	r3, ip, lsl #2
21f03530:	e0833002 	add	r3, r3, r2
21f03534:	e0833001 	add	r3, r3, r1
21f03538:	e5830000 	str	r0, [r3]
}
21f0353c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03540:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03544 <AT91F_UDP_EpSet>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EpSet
//* \brief Set flag in the endpoint CSR register
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_EpSet(
	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
	unsigned char endpoint,  // \arg endpoint number
	unsigned int flag)       // \arg flag to be cleared
{
21f03544:	e1a0c00d 	mov	ip, sp
21f03548:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0354c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03550:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f03554:	e50b0010 	str	r0, [fp, #-16]
21f03558:	e1a03001 	mov	r3, r1
21f0355c:	e50b2018 	str	r2, [fp, #-24]
21f03560:	e54b3014 	strb	r3, [fp, #-20]
	pUDP->UDP_CSR[endpoint] |= flag;
21f03564:	e55bc014 	ldrb	ip, [fp, #-20]
21f03568:	e55b3014 	ldrb	r3, [fp, #-20]
21f0356c:	e51b2010 	ldr	r2, [fp, #-16]
21f03570:	e3a01030 	mov	r1, #48	; 0x30
21f03574:	e1a03103 	mov	r3, r3, lsl #2
21f03578:	e0833002 	add	r3, r3, r2
21f0357c:	e0833001 	add	r3, r3, r1
21f03580:	e5932000 	ldr	r2, [r3]
21f03584:	e51b3018 	ldr	r3, [fp, #-24]
21f03588:	e1820003 	orr	r0, r2, r3
21f0358c:	e51b2010 	ldr	r2, [fp, #-16]
21f03590:	e3a01030 	mov	r1, #48	; 0x30
21f03594:	e1a0310c 	mov	r3, ip, lsl #2
21f03598:	e0833002 	add	r3, r3, r2
21f0359c:	e0833001 	add	r3, r3, r1
21f035a0:	e5830000 	str	r0, [r3]
}
21f035a4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f035a8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f035ac <AT91F_UDP_EpStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_EpStatus
//* \brief Return the endpoint CSR register
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_UDP_EpStatus(
	AT91PS_UDP pUDP,         // \arg pointer to a UDP controller
	unsigned char endpoint)  // \arg endpoint number
{
21f035ac:	e1a0c00d 	mov	ip, sp
21f035b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f035b4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f035b8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f035bc:	e50b0010 	str	r0, [fp, #-16]
21f035c0:	e1a03001 	mov	r3, r1
21f035c4:	e54b3014 	strb	r3, [fp, #-20]
	return pUDP->UDP_CSR[endpoint];
21f035c8:	e55b3014 	ldrb	r3, [fp, #-20]
21f035cc:	e51b2010 	ldr	r2, [fp, #-16]
21f035d0:	e3a01030 	mov	r1, #48	; 0x30
21f035d4:	e1a03103 	mov	r3, r3, lsl #2
21f035d8:	e0833002 	add	r3, r3, r2
21f035dc:	e0833001 	add	r3, r3, r1
21f035e0:	e5933000 	ldr	r3, [r3]
}
21f035e4:	e1a00003 	mov	r0, r3
21f035e8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f035ec:	e89da800 	ldmia	sp, {fp, sp, pc}

21f035f0 <AT91F_UDP_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_GetInterruptMaskStatus
//* \brief Return UDP Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_UDP_GetInterruptMaskStatus( // \return UDP Interrupt Mask Status
        AT91PS_UDP pUdp) // \arg  pointer to a UDP controller
{
21f035f0:	e1a0c00d 	mov	ip, sp
21f035f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f035f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f035fc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f03600:	e50b0010 	str	r0, [fp, #-16]
        return pUdp->UDP_IMR;
21f03604:	e51b3010 	ldr	r3, [fp, #-16]
21f03608:	e5933018 	ldr	r3, [r3, #24]
}
21f0360c:	e1a00003 	mov	r0, r3
21f03610:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f03614 <AT91F_UDP_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_IsInterruptMasked
//* \brief Test if UDP Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_UDP_IsInterruptMasked(
        AT91PS_UDP pUdp,   // \arg  pointer to a UDP controller
        unsigned int flag) // \arg  flag to be tested
{
21f03614:	e1a0c00d 	mov	ip, sp
21f03618:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0361c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03620:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03624:	e50b0010 	str	r0, [fp, #-16]
21f03628:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_UDP_GetInterruptMaskStatus(pUdp) & flag);
21f0362c:	e51b0010 	ldr	r0, [fp, #-16]
21f03630:	ebffffee 	bl	21f035f0 <AT91F_UDP_GetInterruptMaskStatus>
21f03634:	e1a02000 	mov	r2, r0
21f03638:	e51b3014 	ldr	r3, [fp, #-20]
21f0363c:	e0023003 	and	r3, r2, r3
}
21f03640:	e1a00003 	mov	r0, r3
21f03644:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03648:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0364c <AT91F_ST_SetPeriodInterval>:

/* *****************************************************************************
                SOFTWARE API FOR ST
   ***************************************************************************** */
//*----------------------------------------------------------------------------
//* \fn    AT91F_ST_SetPeriodInterval
//* \brief Set Periodic Interval Interrupt (period in ms)
//*----------------------------------------------------------------------------
__inline__ void AT91F_ST_SetPeriodInterval(
	AT91PS_ST pSt,
	unsigned int period)
{
21f0364c:	e1a0c00d 	mov	ip, sp
21f03650:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03654:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03658:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0365c:	e50b0014 	str	r0, [fp, #-20]
21f03660:	e50b1018 	str	r1, [fp, #-24]
	volatile int status;
	pSt->ST_IDR = AT91C_ST_PITS;			/* Interrupt disable Register */
21f03664:	e51b2014 	ldr	r2, [fp, #-20]
21f03668:	e3a03001 	mov	r3, #1	; 0x1
21f0366c:	e5823018 	str	r3, [r2, #24]

	status = pSt->ST_SR;
21f03670:	e51b3014 	ldr	r3, [fp, #-20]
21f03674:	e5933010 	ldr	r3, [r3, #16]
21f03678:	e50b3010 	str	r3, [fp, #-16]
    pSt->ST_PIMR = period << 5;   			/* Period Interval Mode Register == timer interval = 1ms*/
21f0367c:	e51b3018 	ldr	r3, [fp, #-24]
21f03680:	e1a02283 	mov	r2, r3, lsl #5
21f03684:	e51b3014 	ldr	r3, [fp, #-20]
21f03688:	e5832004 	str	r2, [r3, #4]
}
21f0368c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03690:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03694 <AT91F_ST_EnableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_ST_EnableIt
//* \brief Enable system timer interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_ST_EnableIt(
	AT91PS_ST pSt,
	unsigned int flag)
{
21f03694:	e1a0c00d 	mov	ip, sp
21f03698:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0369c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f036a0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f036a4:	e50b0010 	str	r0, [fp, #-16]
21f036a8:	e50b1014 	str	r1, [fp, #-20]
	pSt->ST_IER = flag;
21f036ac:	e51b2010 	ldr	r2, [fp, #-16]
21f036b0:	e51b3014 	ldr	r3, [fp, #-20]
21f036b4:	e5823014 	str	r3, [r2, #20]
}
21f036b8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f036bc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f036c0 <AT91F_ST_DisableIt>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_ST_DisableIt
//* \brief Disable system timer interrupt
//*----------------------------------------------------------------------------
__inline__ void AT91F_ST_DisableIt(
	AT91PS_ST pSt,
	unsigned int flag)
{
21f036c0:	e1a0c00d 	mov	ip, sp
21f036c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f036c8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f036cc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f036d0:	e50b0010 	str	r0, [fp, #-16]
21f036d4:	e50b1014 	str	r1, [fp, #-20]
	pSt->ST_IDR = flag;
21f036d8:	e51b2010 	ldr	r2, [fp, #-16]
21f036dc:	e51b3014 	ldr	r3, [fp, #-20]
21f036e0:	e5823018 	str	r3, [r2, #24]
}
21f036e4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f036e8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f036ec <AT91F_ST_GetInterruptMaskStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_ST_GetInterruptMaskStatus
//* \brief Return ST Interrupt Mask Status
//*----------------------------------------------------------------------------
__inline__ unsigned int AT91F_ST_GetInterruptMaskStatus( // \return ST Interrupt Mask Status
        AT91PS_ST pSt) // \arg  pointer to a ST controller
{
21f036ec:	e1a0c00d 	mov	ip, sp
21f036f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f036f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f036f8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f036fc:	e50b0010 	str	r0, [fp, #-16]
        return pSt->ST_IMR;
21f03700:	e51b3010 	ldr	r3, [fp, #-16]
21f03704:	e593301c 	ldr	r3, [r3, #28]
}
21f03708:	e1a00003 	mov	r0, r3
21f0370c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f03710 <AT91F_ST_IsInterruptMasked>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_ST_IsInterruptMasked
//* \brief Test if ST Interrupt is Masked 
//*----------------------------------------------------------------------------
__inline__ int AT91F_ST_IsInterruptMasked(
        AT91PS_ST pSt,   // \arg  pointer to a ST controller
        unsigned int flag) // \arg  flag to be tested
{
21f03710:	e1a0c00d 	mov	ip, sp
21f03714:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03718:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0371c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03720:	e50b0010 	str	r0, [fp, #-16]
21f03724:	e50b1014 	str	r1, [fp, #-20]
        return (AT91F_ST_GetInterruptMaskStatus(pSt) & flag);
21f03728:	e51b0010 	ldr	r0, [fp, #-16]
21f0372c:	ebffffee 	bl	21f036ec <AT91F_ST_GetInterruptMaskStatus>
21f03730:	e1a02000 	mov	r2, r0
21f03734:	e51b3014 	ldr	r3, [fp, #-20]
21f03738:	e0023003 	and	r3, r2, r3
}
21f0373c:	e1a00003 	mov	r0, r3
21f03740:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03744:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03748 <AT91F_EBI_CfgPIO>:
//*----------------------------------------------------------------------------
//* \fn    AT91F_EBI_CfgPIO
//* \brief Configure PIO controllers to drive EBI signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_EBI_CfgPIO (void)
{
21f03748:	e1a0c00d 	mov	ip, sp
21f0374c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03750:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03754:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03758:	e1a00a40 	mov	r0, r0, asr #20
21f0375c:	e3a01d06 	mov	r1, #384	; 0x180
21f03760:	e3a02000 	mov	r2, #0	; 0x0
21f03764:	ebfff9ce 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOC, // PIO controller base address
		((unsigned int) AT91C_PC8_A24     ) |
		((unsigned int) AT91C_PC7_A23     ), // Peripheral A
		0); // Peripheral B
}
21f03768:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0376c <AT91F_DBGU_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_DBGU_CfgPMC
//* \brief Enable Peripheral clock in PMC for  DBGU
//*----------------------------------------------------------------------------
__inline__ void AT91F_DBGU_CfgPMC (void)
{
21f0376c:	e1a0c00d 	mov	ip, sp
21f03770:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03774:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03778:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f0377c:	e1a00ac0 	mov	r0, r0, asr #21
21f03780:	e3a01002 	mov	r1, #2	; 0x2
21f03784:	ebfff986 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SYS));
}
21f03788:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0378c <AT91F_DBGU_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_DBGU_CfgPIO
//* \brief Configure PIO controllers to drive DBGU signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_DBGU_CfgPIO (void)
{
21f0378c:	e1a0c00d 	mov	ip, sp
21f03790:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03794:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03798:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f0379c:	e1a009c0 	mov	r0, r0, asr #19
21f037a0:	e3a01103 	mov	r1, #-1073741824	; 0xc0000000
21f037a4:	e3a02000 	mov	r2, #0	; 0x0
21f037a8:	ebfff9bd 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		((unsigned int) AT91C_PA31_DTXD    ) |
		((unsigned int) AT91C_PA30_DRXD    ), // Peripheral A
		0); // Peripheral B
}
21f037ac:	e89da800 	ldmia	sp, {fp, sp, pc}

21f037b0 <AT91F_SYS_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SYS_CfgPMC
//* \brief Enable Peripheral clock in PMC for  SYS
//*----------------------------------------------------------------------------
__inline__ void AT91F_SYS_CfgPMC (void)
{
21f037b0:	e1a0c00d 	mov	ip, sp
21f037b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f037b8:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f037bc:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f037c0:	e1a00ac0 	mov	r0, r0, asr #21
21f037c4:	e3a01002 	mov	r1, #2	; 0x2
21f037c8:	ebfff975 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SYS));
}
21f037cc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f037d0 <AT91F_UHP_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UHP_CfgPMC
//* \brief Enable Peripheral clock in PMC for  UHP
//*----------------------------------------------------------------------------
__inline__ void AT91F_UHP_CfgPMC (void)
{
21f037d0:	e1a0c00d 	mov	ip, sp
21f037d4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f037d8:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f037dc:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f037e0:	e1a00ac0 	mov	r0, r0, asr #21
21f037e4:	e3a01502 	mov	r1, #8388608	; 0x800000
21f037e8:	ebfff96d 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_UHP));
}
21f037ec:	e89da800 	ldmia	sp, {fp, sp, pc}

21f037f0 <AT91F_SDRC_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SDRC_CfgPIO
//* \brief Configure PIO controllers to drive SDRC signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_SDRC_CfgPIO (void)
{
21f037f0:	e1a0c00d 	mov	ip, sp
21f037f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f037f8:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f037fc:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03800:	e1a00a40 	mov	r0, r0, asr #20
21f03804:	e3a01102 	mov	r1, #-2147483648	; 0x80000000
21f03808:	e1a017c1 	mov	r1, r1, asr #15
21f0380c:	e3a02000 	mov	r2, #0	; 0x0
21f03810:	ebfff9a3 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOC, // PIO controller base address
		((unsigned int) AT91C_PC20_D20     ) |
		((unsigned int) AT91C_PC21_D21     ) |
		((unsigned int) AT91C_PC30_D30     ) |
		((unsigned int) AT91C_PC22_D22     ) |
		((unsigned int) AT91C_PC31_D31     ) |
		((unsigned int) AT91C_PC23_D23     ) |
		((unsigned int) AT91C_PC16_D16     ) |
		((unsigned int) AT91C_PC24_D24     ) |
		((unsigned int) AT91C_PC17_D17     ) |
		((unsigned int) AT91C_PC25_D25     ) |
		((unsigned int) AT91C_PC18_D18     ) |
		((unsigned int) AT91C_PC26_D26     ) |
		((unsigned int) AT91C_PC19_D19     ) |
		((unsigned int) AT91C_PC27_D27     ) |
		((unsigned int) AT91C_PC28_D28     ) |
		((unsigned int) AT91C_PC29_D29     ), // Peripheral A
		0); // Peripheral B
}
21f03814:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03818 <AT91F_EMAC_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_EMAC_CfgPMC
//* \brief Enable Peripheral clock in PMC for  EMAC
//*----------------------------------------------------------------------------
__inline__ void AT91F_EMAC_CfgPMC (void)
{
21f03818:	e1a0c00d 	mov	ip, sp
21f0381c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03820:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03824:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03828:	e1a00ac0 	mov	r0, r0, asr #21
21f0382c:	e3a01401 	mov	r1, #16777216	; 0x1000000
21f03830:	ebfff95b 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_EMAC));
}
21f03834:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03838 <AT91F_EMAC_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_EMAC_CfgPIO
//* \brief Configure PIO controllers to drive EMAC signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_EMAC_CfgPIO (void)
{
21f03838:	e1a0c00d 	mov	ip, sp
21f0383c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03840:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03844:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f03848:	e1a009c0 	mov	r0, r0, asr #19
21f0384c:	e3a01b7f 	mov	r1, #130048	; 0x1fc00
21f03850:	e2811d0e 	add	r1, r1, #896	; 0x380
21f03854:	e3a02000 	mov	r2, #0	; 0x0
21f03858:	ebfff991 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		((unsigned int) AT91C_PA14_ERXER   ) |
		((unsigned int) AT91C_PA12_ERX0    ) |
		((unsigned int) AT91C_PA13_ERX1    ) |
		((unsigned int) AT91C_PA8_ETXEN   ) |
		((unsigned int) AT91C_PA16_EMDIO   ) |
		((unsigned int) AT91C_PA9_ETX0    ) |
		((unsigned int) AT91C_PA10_ETX1    ) |
		((unsigned int) AT91C_PA11_ECRS_ECRSDV) |
		((unsigned int) AT91C_PA15_EMDC    ) |
		((unsigned int) AT91C_PA7_ETXCK_EREFCK), // Peripheral A
		0); // Peripheral B
}
21f0385c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03860 <AT91F_RTC_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_RTC_CfgPMC
//* \brief Enable Peripheral clock in PMC for  RTC
//*----------------------------------------------------------------------------
__inline__ void AT91F_RTC_CfgPMC (void)
{
21f03860:	e1a0c00d 	mov	ip, sp
21f03864:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03868:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f0386c:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03870:	e1a00ac0 	mov	r0, r0, asr #21
21f03874:	e3a01002 	mov	r1, #2	; 0x2
21f03878:	ebfff949 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SYS));
}
21f0387c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03880 <AT91F_SSC2_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC2_CfgPMC
//* \brief Enable Peripheral clock in PMC for  SSC2
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC2_CfgPMC (void)
{
21f03880:	e1a0c00d 	mov	ip, sp
21f03884:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03888:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f0388c:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03890:	e1a00ac0 	mov	r0, r0, asr #21
21f03894:	e3a01801 	mov	r1, #65536	; 0x10000
21f03898:	ebfff941 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SSC2));
}
21f0389c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f038a0 <AT91F_SSC2_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC2_CfgPIO
//* \brief Configure PIO controllers to drive SSC2 signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC2_CfgPIO (void)
{
21f038a0:	e1a0c00d 	mov	ip, sp
21f038a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f038a8:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f038ac:	e3a0020b 	mov	r0, #-1342177280	; 0xb0000000
21f038b0:	e1a009c0 	mov	r0, r0, asr #19
21f038b4:	e3a01a3f 	mov	r1, #258048	; 0x3f000
21f038b8:	e3a02000 	mov	r2, #0	; 0x0
21f038bc:	ebfff978 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOB, // PIO controller base address
		((unsigned int) AT91C_PB12_TF2     ) |
		((unsigned int) AT91C_PB17_RF2     ) |
		((unsigned int) AT91C_PB13_TK2     ) |
		((unsigned int) AT91C_PB16_RK2     ) |
		((unsigned int) AT91C_PB14_TD2     ) |
		((unsigned int) AT91C_PB15_RD2     ), // Peripheral A
		0); // Peripheral B
}
21f038c0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f038c4 <AT91F_SSC1_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC1_CfgPMC
//* \brief Enable Peripheral clock in PMC for  SSC1
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC1_CfgPMC (void)
{
21f038c4:	e1a0c00d 	mov	ip, sp
21f038c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f038cc:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f038d0:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f038d4:	e1a00ac0 	mov	r0, r0, asr #21
21f038d8:	e3a01902 	mov	r1, #32768	; 0x8000
21f038dc:	ebfff930 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SSC1));
}
21f038e0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f038e4 <AT91F_SSC1_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC1_CfgPIO
//* \brief Configure PIO controllers to drive SSC1 signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC1_CfgPIO (void)
{
21f038e4:	e1a0c00d 	mov	ip, sp
21f038e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f038ec:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f038f0:	e3a0020b 	mov	r0, #-1342177280	; 0xb0000000
21f038f4:	e1a009c0 	mov	r0, r0, asr #19
21f038f8:	e3a01c0f 	mov	r1, #3840	; 0xf00
21f038fc:	e3a02000 	mov	r2, #0	; 0x0
21f03900:	ebfff967 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOB, // PIO controller base address
		((unsigned int) AT91C_PB11_RF1     ) |
		((unsigned int) AT91C_PB10_RK1     ) |
		((unsigned int) AT91C_PB8_TD1     ) |
		((unsigned int) AT91C_PB9_RD1     ), // Peripheral A
		0); // Peripheral B
}
21f03904:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03908 <AT91F_SSC0_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SSC0_CfgPMC
//* \brief Enable Peripheral clock in PMC for  SSC0
//*----------------------------------------------------------------------------
__inline__ void AT91F_SSC0_CfgPMC (void)
{
21f03908:	e1a0c00d 	mov	ip, sp
21f0390c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03910:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03914:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03918:	e1a00ac0 	mov	r0, r0, asr #21
21f0391c:	e3a01901 	mov	r1, #16384	; 0x4000
21f03920:	ebfff91f 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SSC0));
}
21f03924:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03928 <AT91F_SPI_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_CfgPMC
//* \brief Enable Peripheral clock in PMC for  SPI
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_CfgPMC (void)
{
21f03928:	e1a0c00d 	mov	ip, sp
21f0392c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03930:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03934:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03938:	e1a00ac0 	mov	r0, r0, asr #21
21f0393c:	e3a01a02 	mov	r1, #8192	; 0x2000
21f03940:	ebfff917 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SPI));
}
21f03944:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03948 <AT91F_SPI_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SPI_CfgPIO
//* \brief Configure PIO controllers to drive SPI signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_SPI_CfgPIO (void)
{
21f03948:	e1a0c00d 	mov	ip, sp
21f0394c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03950:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03954:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f03958:	e1a009c0 	mov	r0, r0, asr #19
21f0395c:	e3a0107f 	mov	r1, #127	; 0x7f
21f03960:	e3a02000 	mov	r2, #0	; 0x0
21f03964:	ebfff94e 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		((unsigned int) AT91C_PA3_NPCS0   ) |
		((unsigned int) AT91C_PA4_NPCS1   ) |
		((unsigned int) AT91C_PA1_MOSI    ) |
		((unsigned int) AT91C_PA5_NPCS2   ) |
		((unsigned int) AT91C_PA6_NPCS3   ) |
		((unsigned int) AT91C_PA0_MISO    ) |
		((unsigned int) AT91C_PA2_SPCK    ), // Peripheral A
		0); // Peripheral B
}
21f03968:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0396c <AT91F_TC5_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC5_CfgPMC
//* \brief Enable Peripheral clock in PMC for  TC5
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC5_CfgPMC (void)
{
21f0396c:	e1a0c00d 	mov	ip, sp
21f03970:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03974:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03978:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f0397c:	e1a00ac0 	mov	r0, r0, asr #21
21f03980:	e3a01501 	mov	r1, #4194304	; 0x400000
21f03984:	ebfff906 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_TC5));
}
21f03988:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0398c <AT91F_TC4_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC4_CfgPMC
//* \brief Enable Peripheral clock in PMC for  TC4
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC4_CfgPMC (void)
{
21f0398c:	e1a0c00d 	mov	ip, sp
21f03990:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03994:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03998:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f0399c:	e1a00ac0 	mov	r0, r0, asr #21
21f039a0:	e3a01602 	mov	r1, #2097152	; 0x200000
21f039a4:	ebfff8fe 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_TC4));
}
21f039a8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f039ac <AT91F_TC3_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC3_CfgPMC
//* \brief Enable Peripheral clock in PMC for  TC3
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC3_CfgPMC (void)
{
21f039ac:	e1a0c00d 	mov	ip, sp
21f039b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f039b4:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f039b8:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f039bc:	e1a00ac0 	mov	r0, r0, asr #21
21f039c0:	e3a01601 	mov	r1, #1048576	; 0x100000
21f039c4:	ebfff8f6 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_TC3));
}
21f039c8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f039cc <AT91F_TC2_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC2_CfgPMC
//* \brief Enable Peripheral clock in PMC for  TC2
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC2_CfgPMC (void)
{
21f039cc:	e1a0c00d 	mov	ip, sp
21f039d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f039d4:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f039d8:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f039dc:	e1a00ac0 	mov	r0, r0, asr #21
21f039e0:	e3a01702 	mov	r1, #524288	; 0x80000
21f039e4:	ebfff8ee 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_TC2));
}
21f039e8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f039ec <AT91F_TC1_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC1_CfgPMC
//* \brief Enable Peripheral clock in PMC for  TC1
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC1_CfgPMC (void)
{
21f039ec:	e1a0c00d 	mov	ip, sp
21f039f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f039f4:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f039f8:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f039fc:	e1a00ac0 	mov	r0, r0, asr #21
21f03a00:	e3a01701 	mov	r1, #262144	; 0x40000
21f03a04:	ebfff8e6 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_TC1));
}
21f03a08:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03a0c <AT91F_TC0_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TC0_CfgPMC
//* \brief Enable Peripheral clock in PMC for  TC0
//*----------------------------------------------------------------------------
__inline__ void AT91F_TC0_CfgPMC (void)
{
21f03a0c:	e1a0c00d 	mov	ip, sp
21f03a10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03a14:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03a18:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03a1c:	e1a00ac0 	mov	r0, r0, asr #21
21f03a20:	e3a01802 	mov	r1, #131072	; 0x20000
21f03a24:	ebfff8de 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_TC0));
}
21f03a28:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03a2c <AT91F_SMC2_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_SMC2_CfgPIO
//* \brief Configure PIO controllers to drive SMC2 signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_SMC2_CfgPIO (void)
{
21f03a2c:	e1a0c00d 	mov	ip, sp
21f03a30:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03a34:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03a38:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03a3c:	e1a00a40 	mov	r0, r0, asr #20
21f03a40:	e3a01c1e 	mov	r1, #7680	; 0x1e00
21f03a44:	e3a02000 	mov	r2, #0	; 0x0
21f03a48:	ebfff915 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOC, // PIO controller base address
		((unsigned int) AT91C_PC10_NCS4_CFCS) |
		((unsigned int) AT91C_PC9_A25_CFRNW) |
		((unsigned int) AT91C_PC12_NCS6_CFCE2) |
		((unsigned int) AT91C_PC11_NCS5_CFCE1), // Peripheral A
		0); // Peripheral B
}
21f03a4c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03a50 <AT91F_PMC_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_CfgPMC
//* \brief Enable Peripheral clock in PMC for  PMC
//*----------------------------------------------------------------------------
__inline__ void AT91F_PMC_CfgPMC (void)
{
21f03a50:	e1a0c00d 	mov	ip, sp
21f03a54:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03a58:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03a5c:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03a60:	e1a00ac0 	mov	r0, r0, asr #21
21f03a64:	e3a01002 	mov	r1, #2	; 0x2
21f03a68:	ebfff8cd 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SYS));
}
21f03a6c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03a70 <AT91F_PMC_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PMC_CfgPIO
//* \brief Configure PIO controllers to drive PMC signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_PMC_CfgPIO (void)
{
21f03a70:	e1a0c00d 	mov	ip, sp
21f03a74:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03a78:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03a7c:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f03a80:	e1a009c0 	mov	r0, r0, asr #19
21f03a84:	e3a01000 	mov	r1, #0	; 0x0
21f03a88:	e3a02401 	mov	r2, #16777216	; 0x1000000
21f03a8c:	ebfff904 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		0, // Peripheral A
		((unsigned int) AT91C_PA24_PCK1    )); // Peripheral B
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03a90:	e3a0020b 	mov	r0, #-1342177280	; 0xb0000000
21f03a94:	e1a009c0 	mov	r0, r0, asr #19
21f03a98:	e3a01302 	mov	r1, #134217728	; 0x8000000
21f03a9c:	e3a02000 	mov	r2, #0	; 0x0
21f03aa0:	ebfff8ff 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOB, // PIO controller base address
		((unsigned int) AT91C_PB27_PCK0    ), // Peripheral A
		0); // Peripheral B
}
21f03aa4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03aa8 <AT91F_PIOD_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIOD_CfgPMC
//* \brief Enable Peripheral clock in PMC for  PIOD
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIOD_CfgPMC (void)
{
21f03aa8:	e1a0c00d 	mov	ip, sp
21f03aac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03ab0:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03ab4:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03ab8:	e1a00ac0 	mov	r0, r0, asr #21
21f03abc:	e3a01020 	mov	r1, #32	; 0x20
21f03ac0:	ebfff8b7 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_PIOD));
}
21f03ac4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03ac8 <AT91F_PIOC_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIOC_CfgPMC
//* \brief Enable Peripheral clock in PMC for  PIOC
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIOC_CfgPMC (void)
{
21f03ac8:	e1a0c00d 	mov	ip, sp
21f03acc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03ad0:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03ad4:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03ad8:	e1a00ac0 	mov	r0, r0, asr #21
21f03adc:	e3a01010 	mov	r1, #16	; 0x10
21f03ae0:	ebfff8af 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_PIOC));
}
21f03ae4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03ae8 <AT91F_PIOB_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIOB_CfgPMC
//* \brief Enable Peripheral clock in PMC for  PIOB
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIOB_CfgPMC (void)
{
21f03ae8:	e1a0c00d 	mov	ip, sp
21f03aec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03af0:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03af4:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03af8:	e1a00ac0 	mov	r0, r0, asr #21
21f03afc:	e3a01008 	mov	r1, #8	; 0x8
21f03b00:	ebfff8a7 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_PIOB));
}
21f03b04:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03b08 <AT91F_PIOA_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_PIOA_CfgPMC
//* \brief Enable Peripheral clock in PMC for  PIOA
//*----------------------------------------------------------------------------
__inline__ void AT91F_PIOA_CfgPMC (void)
{
21f03b08:	e1a0c00d 	mov	ip, sp
21f03b0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03b10:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03b14:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03b18:	e1a00ac0 	mov	r0, r0, asr #21
21f03b1c:	e3a01004 	mov	r1, #4	; 0x4
21f03b20:	ebfff89f 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_PIOA));
}
21f03b24:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03b28 <AT91F_TWI_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TWI_CfgPMC
//* \brief Enable Peripheral clock in PMC for  TWI
//*----------------------------------------------------------------------------
__inline__ void AT91F_TWI_CfgPMC (void)
{
21f03b28:	e1a0c00d 	mov	ip, sp
21f03b2c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03b30:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03b34:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03b38:	e1a00ac0 	mov	r0, r0, asr #21
21f03b3c:	e3a01a01 	mov	r1, #4096	; 0x1000
21f03b40:	ebfff897 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_TWI));
}
21f03b44:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03b48 <AT91F_TWI_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_TWI_CfgPIO
//* \brief Configure PIO controllers to drive TWI signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_TWI_CfgPIO (void)
{
21f03b48:	e1a0c00d 	mov	ip, sp
21f03b4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03b50:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03b54:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f03b58:	e1a009c0 	mov	r0, r0, asr #19
21f03b5c:	e3a01406 	mov	r1, #100663296	; 0x6000000
21f03b60:	e3a02000 	mov	r2, #0	; 0x0
21f03b64:	ebfff8ce 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		((unsigned int) AT91C_PA25_TWD     ) |
		((unsigned int) AT91C_PA26_TWCK    ), // Peripheral A
		0); // Peripheral B
}
21f03b68:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03b6c <AT91F_US3_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US3_CfgPMC
//* \brief Enable Peripheral clock in PMC for  US3
//*----------------------------------------------------------------------------
__inline__ void AT91F_US3_CfgPMC (void)
{
21f03b6c:	e1a0c00d 	mov	ip, sp
21f03b70:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03b74:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03b78:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03b7c:	e1a00ac0 	mov	r0, r0, asr #21
21f03b80:	e3a01c02 	mov	r1, #512	; 0x200
21f03b84:	ebfff886 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_US3));
}
21f03b88:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03b8c <AT91F_US2_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US2_CfgPMC
//* \brief Enable Peripheral clock in PMC for  US2
//*----------------------------------------------------------------------------
__inline__ void AT91F_US2_CfgPMC (void)
{
21f03b8c:	e1a0c00d 	mov	ip, sp
21f03b90:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03b94:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03b98:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03b9c:	e1a00ac0 	mov	r0, r0, asr #21
21f03ba0:	e3a01c01 	mov	r1, #256	; 0x100
21f03ba4:	ebfff87e 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_US2));
}
21f03ba8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03bac <AT91F_US2_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US2_CfgPIO
//* \brief Configure PIO controllers to drive US2 signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_US2_CfgPIO (void)
{
21f03bac:	e1a0c00d 	mov	ip, sp
21f03bb0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03bb4:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03bb8:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f03bbc:	e1a009c0 	mov	r0, r0, asr #19
21f03bc0:	e3a01503 	mov	r1, #12582912	; 0xc00000
21f03bc4:	e3a02000 	mov	r2, #0	; 0x0
21f03bc8:	ebfff8b5 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		((unsigned int) AT91C_PA23_TXD2    ) |
		((unsigned int) AT91C_PA22_RXD2    ), // Peripheral A
		0); // Peripheral B
}
21f03bcc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03bd0 <AT91F_US1_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US1_CfgPMC
//* \brief Enable Peripheral clock in PMC for  US1
//*----------------------------------------------------------------------------
__inline__ void AT91F_US1_CfgPMC (void)
{
21f03bd0:	e1a0c00d 	mov	ip, sp
21f03bd4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03bd8:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03bdc:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03be0:	e1a00ac0 	mov	r0, r0, asr #21
21f03be4:	e3a01080 	mov	r1, #128	; 0x80
21f03be8:	ebfff86d 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_US1));
}
21f03bec:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03bf0 <AT91F_US1_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US1_CfgPIO
//* \brief Configure PIO controllers to drive US1 signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_US1_CfgPIO (void)
{
21f03bf0:	e1a0c00d 	mov	ip, sp
21f03bf4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03bf8:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03bfc:	e3a0020b 	mov	r0, #-1342177280	; 0xb0000000
21f03c00:	e1a009c0 	mov	r0, r0, asr #19
21f03c04:	e3a0167b 	mov	r1, #128974848	; 0x7b00000
21f03c08:	e2811703 	add	r1, r1, #786432	; 0xc0000
21f03c0c:	e3a02000 	mov	r2, #0	; 0x0
21f03c10:	ebfff8a3 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOB, // PIO controller base address
		((unsigned int) AT91C_PB21_RXD1    ) |
		((unsigned int) AT91C_PB26_RTS1    ) |
		((unsigned int) AT91C_PB25_DSR1    ) |
		((unsigned int) AT91C_PB24_CTS1    ) |
		((unsigned int) AT91C_PB19_DTR1    ) |
		((unsigned int) AT91C_PB23_DCD1    ) |
		((unsigned int) AT91C_PB20_TXD1    ) |
		((unsigned int) AT91C_PB18_RI1     ), // Peripheral A
		0); // Peripheral B
}
21f03c14:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03c18 <AT91F_US0_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US0_CfgPMC
//* \brief Enable Peripheral clock in PMC for  US0
//*----------------------------------------------------------------------------
__inline__ void AT91F_US0_CfgPMC (void)
{
21f03c18:	e1a0c00d 	mov	ip, sp
21f03c1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03c20:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03c24:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03c28:	e1a00ac0 	mov	r0, r0, asr #21
21f03c2c:	e3a01040 	mov	r1, #64	; 0x40
21f03c30:	ebfff85b 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_US0));
}
21f03c34:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03c38 <AT91F_US0_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_US0_CfgPIO
//* \brief Configure PIO controllers to drive US0 signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_US0_CfgPIO (void)
{
21f03c38:	e1a0c00d 	mov	ip, sp
21f03c3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03c40:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03c44:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f03c48:	e1a009c0 	mov	r0, r0, asr #19
21f03c4c:	e3a0183a 	mov	r1, #3801088	; 0x3a0000
21f03c50:	e3a02000 	mov	r2, #0	; 0x0
21f03c54:	ebfff892 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		((unsigned int) AT91C_PA17_TXD0    ) |
		((unsigned int) AT91C_PA21_RTS0    ) |
		((unsigned int) AT91C_PA19_SCK0    ) |
		((unsigned int) AT91C_PA20_CTS0    ), // Peripheral A
		0); // Peripheral B
}
21f03c58:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03c5c <AT91F_MCI_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_CfgPMC
//* \brief Enable Peripheral clock in PMC for  MCI
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_CfgPMC (void)
{
21f03c5c:	e1a0c00d 	mov	ip, sp
21f03c60:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03c64:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03c68:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03c6c:	e1a00ac0 	mov	r0, r0, asr #21
21f03c70:	e3a01b01 	mov	r1, #1024	; 0x400
21f03c74:	ebfff84a 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_MCI));
}
21f03c78:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03c7c <AT91F_MCI_CfgPIO>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_CfgPIO
//* \brief Configure PIO controllers to drive MCI signals
//*----------------------------------------------------------------------------
__inline__ void AT91F_MCI_CfgPIO (void)
{
21f03c7c:	e1a0c00d 	mov	ip, sp
21f03c80:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03c84:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03c88:	e3a0020a 	mov	r0, #-1610612736	; 0xa0000000
21f03c8c:	e1a009c0 	mov	r0, r0, asr #19
21f03c90:	e3a0130e 	mov	r1, #939524096	; 0x38000000
21f03c94:	e3a02000 	mov	r2, #0	; 0x0
21f03c98:	ebfff881 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOA, // PIO controller base address
		((unsigned int) AT91C_PA28_MCCDA   ) |
		((unsigned int) AT91C_PA29_MCDA0   ) |
		((unsigned int) AT91C_PA27_MCCK    ), // Peripheral A
		0); // Peripheral B
	// Configure PIO controllers to periph mode
	AT91F_PIO_CfgPeriph(
21f03c9c:	e3a0020b 	mov	r0, #-1342177280	; 0xb0000000
21f03ca0:	e1a009c0 	mov	r0, r0, asr #19
21f03ca4:	e3a01000 	mov	r1, #0	; 0x0
21f03ca8:	e3a02038 	mov	r2, #56	; 0x38
21f03cac:	ebfff87c 	bl	21f01ea4 <AT91F_PIO_CfgPeriph>
		AT91C_BASE_PIOB, // PIO controller base address
		0, // Peripheral A
		((unsigned int) AT91C_PB5_MCDA3   ) |
		((unsigned int) AT91C_PB3_MCDA1   ) |
		((unsigned int) AT91C_PB4_MCDA2   )); // Peripheral B
}
21f03cb0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03cb4 <AT91F_AIC_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_AIC_CfgPMC
//* \brief Enable Peripheral clock in PMC for  AIC
//*----------------------------------------------------------------------------
__inline__ void AT91F_AIC_CfgPMC (void)
{
21f03cb4:	e1a0c00d 	mov	ip, sp
21f03cb8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03cbc:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03cc0:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03cc4:	e1a00ac0 	mov	r0, r0, asr #21
21f03cc8:	e3a014fe 	mov	r1, #-33554432	; 0xfe000000
21f03ccc:	e2811001 	add	r1, r1, #1	; 0x1
21f03cd0:	ebfff833 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_IRQ4) |
		((unsigned int) 1 << AT91C_ID_FIQ) |
		((unsigned int) 1 << AT91C_ID_IRQ5) |
		((unsigned int) 1 << AT91C_ID_IRQ6) |
		((unsigned int) 1 << AT91C_ID_IRQ0) |
		((unsigned int) 1 << AT91C_ID_IRQ1) |
		((unsigned int) 1 << AT91C_ID_IRQ2) |
		((unsigned int) 1 << AT91C_ID_IRQ3));
}
21f03cd4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03cd8 <AT91F_UDP_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_UDP_CfgPMC
//* \brief Enable Peripheral clock in PMC for  UDP
//*----------------------------------------------------------------------------
__inline__ void AT91F_UDP_CfgPMC (void)
{
21f03cd8:	e1a0c00d 	mov	ip, sp
21f03cdc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03ce0:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03ce4:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03ce8:	e1a00ac0 	mov	r0, r0, asr #21
21f03cec:	e3a01b02 	mov	r1, #2048	; 0x800
21f03cf0:	ebfff82b 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_UDP));
}
21f03cf4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03cf8 <AT91F_ST_CfgPMC>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_ST_CfgPMC
//* \brief Enable Peripheral clock in PMC for  ST
//*----------------------------------------------------------------------------
__inline__ void AT91F_ST_CfgPMC (void)
{
21f03cf8:	e1a0c00d 	mov	ip, sp
21f03cfc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03d00:	e24cb004 	sub	fp, ip, #4	; 0x4
	AT91F_PMC_EnablePeriphClock(
21f03d04:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f03d08:	e1a00ac0 	mov	r0, r0, asr #21
21f03d0c:	e3a01002 	mov	r1, #2	; 0x2
21f03d10:	ebfff823 	bl	21f01da4 <AT91F_PMC_EnablePeriphClock>
		AT91C_BASE_PMC, // PIO controller base address
		((unsigned int) 1 << AT91C_ID_SYS));
}
21f03d14:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03d18 <AT91F_MCI_SendCommand>:
AT91S_MCIDeviceStatus AT91F_MCI_SendCommand (
	AT91PS_MciDevice pMCI_Device,
	unsigned int Cmd,
	unsigned int Arg)
{
21f03d18:	e1a0c00d 	mov	ip, sp
21f03d1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03d20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03d24:	e24dd018 	sub	sp, sp, #24	; 0x18
21f03d28:	e50b0018 	str	r0, [fp, #-24]
21f03d2c:	e50b101c 	str	r1, [fp, #-28]
21f03d30:	e50b2020 	str	r2, [fp, #-32]
	unsigned int	error,status;
	//unsigned int	tick=0;

    // Send the command
    AT91C_BASE_MCI->MCI_ARGR = Arg;
21f03d34:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03d38:	e1a03643 	mov	r3, r3, asr #12
21f03d3c:	e51b2020 	ldr	r2, [fp, #-32]
21f03d40:	e5832010 	str	r2, [r3, #16]
    AT91C_BASE_MCI->MCI_CMDR = Cmd;
21f03d44:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03d48:	e1a03643 	mov	r3, r3, asr #12
21f03d4c:	e51b201c 	ldr	r2, [fp, #-28]
21f03d50:	e5832014 	str	r2, [r3, #20]

	// wait for CMDRDY Status flag to read the response
	do
	{
		status = AT91C_BASE_MCI->MCI_SR;
21f03d54:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03d58:	e1a03643 	mov	r3, r3, asr #12
21f03d5c:	e5933040 	ldr	r3, [r3, #64]
21f03d60:	e50b3010 	str	r3, [fp, #-16]
		//tick++;
	}
	while( !(status & AT91C_MCI_CMDRDY) );//&& (tick<100) );
21f03d64:	e51b3010 	ldr	r3, [fp, #-16]
21f03d68:	e2033001 	and	r3, r3, #1	; 0x1
21f03d6c:	e3530000 	cmp	r3, #0	; 0x0
21f03d70:	0afffff7 	beq	21f03d54 <AT91F_MCI_SendCommand+0x3c>

    // Test error  ==> if crc error and response R3 ==> don't check error
    error = (AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR;
21f03d74:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03d78:	e1a03643 	mov	r3, r3, asr #12
21f03d7c:	e5933040 	ldr	r3, [r3, #64]
21f03d80:	e3c335fe 	bic	r3, r3, #1065353216	; 0x3f800000
21f03d84:	e1a03823 	mov	r3, r3, lsr #16
21f03d88:	e1a03803 	mov	r3, r3, lsl #16
21f03d8c:	e50b3014 	str	r3, [fp, #-20]
	if(error != 0 )
21f03d90:	e51b3014 	ldr	r3, [fp, #-20]
21f03d94:	e3530000 	cmp	r3, #0	; 0x0
21f03d98:	0a000022 	beq	21f03e28 <AT91F_MCI_SendCommand+0x110>
	{
		// if the command is SEND_OP_COND the CRC error flag is always present (cf : R3 response)
		if ( (Cmd != AT91C_SDCARD_APP_OP_COND_CMD) && (Cmd != AT91C_MMC_SEND_OP_COND_CMD) )
21f03d9c:	e51b301c 	ldr	r3, [fp, #-28]
21f03da0:	e3530069 	cmp	r3, #105	; 0x69
21f03da4:	0a000010 	beq	21f03dec <AT91F_MCI_SendCommand+0xd4>
21f03da8:	e51b201c 	ldr	r2, [fp, #-28]
21f03dac:	e3a03d21 	mov	r3, #2112	; 0x840
21f03db0:	e2833001 	add	r3, r3, #1	; 0x1
21f03db4:	e1520003 	cmp	r2, r3
21f03db8:	0a00000b 	beq	21f03dec <AT91F_MCI_SendCommand+0xd4>
			return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);
21f03dbc:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03dc0:	e1a03643 	mov	r3, r3, asr #12
21f03dc4:	e5933040 	ldr	r3, [r3, #64]
21f03dc8:	e3c335fe 	bic	r3, r3, #1065353216	; 0x3f800000
21f03dcc:	e50b3024 	str	r3, [fp, #-36]
21f03dd0:	e51b3024 	ldr	r3, [fp, #-36]
21f03dd4:	e1a03823 	mov	r3, r3, lsr #16
21f03dd8:	e50b3024 	str	r3, [fp, #-36]
21f03ddc:	e51b3024 	ldr	r3, [fp, #-36]
21f03de0:	e1a03803 	mov	r3, r3, lsl #16
21f03de4:	e50b3024 	str	r3, [fp, #-36]
21f03de8:	ea000010 	b	21f03e30 <AT91F_MCI_SendCommand+0x118>
		else
		{
			if (error != AT91C_MCI_RCRCE)
21f03dec:	e51b3014 	ldr	r3, [fp, #-20]
21f03df0:	e3530701 	cmp	r3, #262144	; 0x40000
21f03df4:	0a00000b 	beq	21f03e28 <AT91F_MCI_SendCommand+0x110>
				return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);
21f03df8:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03dfc:	e1a03643 	mov	r3, r3, asr #12
21f03e00:	e5933040 	ldr	r3, [r3, #64]
21f03e04:	e3c335fe 	bic	r3, r3, #1065353216	; 0x3f800000
21f03e08:	e50b3024 	str	r3, [fp, #-36]
21f03e0c:	e51b3024 	ldr	r3, [fp, #-36]
21f03e10:	e1a03823 	mov	r3, r3, lsr #16
21f03e14:	e50b3024 	str	r3, [fp, #-36]
21f03e18:	e51b3024 	ldr	r3, [fp, #-36]
21f03e1c:	e1a03803 	mov	r3, r3, lsl #16
21f03e20:	e50b3024 	str	r3, [fp, #-36]
21f03e24:	ea000001 	b	21f03e30 <AT91F_MCI_SendCommand+0x118>
		}
	}
    return AT91C_CMD_SEND_OK;
21f03e28:	e3a03000 	mov	r3, #0	; 0x0
21f03e2c:	e50b3024 	str	r3, [fp, #-36]
21f03e30:	e51b3024 	ldr	r3, [fp, #-36]
}
21f03e34:	e1a00003 	mov	r0, r3
21f03e38:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03e3c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03e40 <AT91F_MCI_SDCard_SendAppCommand>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_SDCard_SendAppCommand
//* \brief Specific function to send a specific command to the SDCard
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_SDCard_SendAppCommand (
	AT91PS_MciDevice pMCI_Device,
	unsigned int Cmd_App,
	unsigned int Arg	)
{
21f03e40:	e1a0c00d 	mov	ip, sp
21f03e44:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03e48:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03e4c:	e24dd014 	sub	sp, sp, #20	; 0x14
21f03e50:	e50b0014 	str	r0, [fp, #-20]
21f03e54:	e50b1018 	str	r1, [fp, #-24]
21f03e58:	e50b201c 	str	r2, [fp, #-28]
	unsigned int status;
	//unsigned int	tick=0;

	// Send the CMD55 for application specific command
    AT91C_BASE_MCI->MCI_ARGR = (pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address << 16 );
21f03e5c:	e3a0232d 	mov	r2, #-1275068416	; 0xb4000000
21f03e60:	e1a02642 	mov	r2, r2, asr #12
21f03e64:	e51b3014 	ldr	r3, [fp, #-20]
21f03e68:	e5933004 	ldr	r3, [r3, #4]
21f03e6c:	e5933004 	ldr	r3, [r3, #4]
21f03e70:	e1a03803 	mov	r3, r3, lsl #16
21f03e74:	e5823010 	str	r3, [r2, #16]
    AT91C_BASE_MCI->MCI_CMDR = AT91C_APP_CMD;
21f03e78:	e3a0232d 	mov	r2, #-1275068416	; 0xb4000000
21f03e7c:	e1a02642 	mov	r2, r2, asr #12
21f03e80:	e3a03d41 	mov	r3, #4160	; 0x1040
21f03e84:	e2833037 	add	r3, r3, #55	; 0x37
21f03e88:	e5823014 	str	r3, [r2, #20]

	// wait for CMDRDY Status flag to read the response
	do
	{
		status = AT91C_BASE_MCI->MCI_SR;
21f03e8c:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03e90:	e1a03643 	mov	r3, r3, asr #12
21f03e94:	e5933040 	ldr	r3, [r3, #64]
21f03e98:	e50b3010 	str	r3, [fp, #-16]
		//tick++;
	}
	while( !(status & AT91C_MCI_CMDRDY) );//&& (tick<100) );	
21f03e9c:	e51b3010 	ldr	r3, [fp, #-16]
21f03ea0:	e2033001 	and	r3, r3, #1	; 0x1
21f03ea4:	e3530000 	cmp	r3, #0	; 0x0
21f03ea8:	0afffff7 	beq	21f03e8c <AT91F_MCI_SDCard_SendAppCommand+0x4c>

    // if an error occurs
    if (((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR) != 0 )
21f03eac:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03eb0:	e1a03643 	mov	r3, r3, asr #12
21f03eb4:	e5933040 	ldr	r3, [r3, #64]
21f03eb8:	e3c335fe 	bic	r3, r3, #1065353216	; 0x3f800000
21f03ebc:	e1a03823 	mov	r3, r3, lsr #16
21f03ec0:	e1a03803 	mov	r3, r3, lsl #16
21f03ec4:	e3530000 	cmp	r3, #0	; 0x0
21f03ec8:	0a00000b 	beq	21f03efc <AT91F_MCI_SDCard_SendAppCommand+0xbc>
		return ((AT91C_BASE_MCI->MCI_SR) & AT91C_MCI_SR_ERROR);
21f03ecc:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03ed0:	e1a03643 	mov	r3, r3, asr #12
21f03ed4:	e5933040 	ldr	r3, [r3, #64]
21f03ed8:	e3c335fe 	bic	r3, r3, #1065353216	; 0x3f800000
21f03edc:	e50b3020 	str	r3, [fp, #-32]
21f03ee0:	e51b3020 	ldr	r3, [fp, #-32]
21f03ee4:	e1a03823 	mov	r3, r3, lsr #16
21f03ee8:	e50b3020 	str	r3, [fp, #-32]
21f03eec:	e51b3020 	ldr	r3, [fp, #-32]
21f03ef0:	e1a03803 	mov	r3, r3, lsl #16
21f03ef4:	e50b3020 	str	r3, [fp, #-32]
21f03ef8:	ea00000b 	b	21f03f2c <AT91F_MCI_SDCard_SendAppCommand+0xec>

    // check if it is a specific command and then send the command
	if ( (Cmd_App && AT91C_SDCARD_APP_ALL_CMD) == 0)
21f03efc:	e51b3018 	ldr	r3, [fp, #-24]
21f03f00:	e3530000 	cmp	r3, #0	; 0x0
21f03f04:	1a000002 	bne	21f03f14 <AT91F_MCI_SDCard_SendAppCommand+0xd4>
		return AT91C_CMD_SEND_ERROR;
21f03f08:	e3e03000 	mvn	r3, #0	; 0x0
21f03f0c:	e50b3020 	str	r3, [fp, #-32]
21f03f10:	ea000005 	b	21f03f2c <AT91F_MCI_SDCard_SendAppCommand+0xec>

   return( AT91F_MCI_SendCommand(pMCI_Device,Cmd_App,Arg) );
21f03f14:	e51b0014 	ldr	r0, [fp, #-20]
21f03f18:	e51b1018 	ldr	r1, [fp, #-24]
21f03f1c:	e51b201c 	ldr	r2, [fp, #-28]
21f03f20:	ebffff7c 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f03f24:	e1a03000 	mov	r3, r0
21f03f28:	e50b3020 	str	r3, [fp, #-32]
21f03f2c:	e51b3020 	ldr	r3, [fp, #-32]
}
21f03f30:	e1a00003 	mov	r0, r3
21f03f34:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03f38:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03f3c <AT91F_MCI_GetStatus>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_GetStatus
//* \brief Addressed card sends its status register
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_GetStatus(AT91PS_MciDevice pMCI_Device,unsigned int relative_card_address)
{
21f03f3c:	e1a0c00d 	mov	ip, sp
21f03f40:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03f44:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03f48:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f03f4c:	e50b0010 	str	r0, [fp, #-16]
21f03f50:	e50b1014 	str	r1, [fp, #-20]
	if (AT91F_MCI_SendCommand(pMCI_Device,
21f03f54:	e51b3014 	ldr	r3, [fp, #-20]
21f03f58:	e1a03803 	mov	r3, r3, lsl #16
21f03f5c:	e51b0010 	ldr	r0, [fp, #-16]
21f03f60:	e3a01d41 	mov	r1, #4160	; 0x1040
21f03f64:	e281100d 	add	r1, r1, #13	; 0xd
21f03f68:	e1a02003 	mov	r2, r3
21f03f6c:	ebffff69 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f03f70:	e1a03000 	mov	r3, r0
21f03f74:	e3530000 	cmp	r3, #0	; 0x0
21f03f78:	1a000004 	bne	21f03f90 <AT91F_MCI_GetStatus+0x54>
								AT91C_SEND_STATUS_CMD,
								relative_card_address <<16) == AT91C_CMD_SEND_OK)
    	return (AT91C_BASE_MCI->MCI_RSPR[0]);
21f03f7c:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03f80:	e1a03643 	mov	r3, r3, asr #12
21f03f84:	e5933020 	ldr	r3, [r3, #32]
21f03f88:	e50b3018 	str	r3, [fp, #-24]
21f03f8c:	ea000001 	b	21f03f98 <AT91F_MCI_GetStatus+0x5c>

    return AT91C_CMD_SEND_ERROR;
21f03f90:	e3e03000 	mvn	r3, #0	; 0x0
21f03f94:	e50b3018 	str	r3, [fp, #-24]
21f03f98:	e51b3018 	ldr	r3, [fp, #-24]
}
21f03f9c:	e1a00003 	mov	r0, r3
21f03fa0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f03fa4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f03fa8 <AT91F_MCI_Device_Handler>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_Device_Handler
//* \brief MCI C interrupt handler
//*----------------------------------------------------------------------------
void AT91F_MCI_Device_Handler(
	AT91PS_MciDevice pMCI_Device,
	unsigned int status)
{
21f03fa8:	e1a0c00d 	mov	ip, sp
21f03fac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f03fb0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f03fb4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f03fb8:	e50b0010 	str	r0, [fp, #-16]
21f03fbc:	e50b1014 	str	r1, [fp, #-20]
	// If End of Tx Buffer Empty interrupt occurred
	if ( status & AT91C_MCI_TXBUFE )
21f03fc0:	e51b3014 	ldr	r3, [fp, #-20]
21f03fc4:	e1a037a3 	mov	r3, r3, lsr #15
21f03fc8:	e2033001 	and	r3, r3, #1	; 0x1
21f03fcc:	e20330ff 	and	r3, r3, #255	; 0xff
21f03fd0:	e3530000 	cmp	r3, #0	; 0x0
21f03fd4:	0a00000c 	beq	21f0400c <AT91F_MCI_Device_Handler+0x64>
    {
		AT91C_BASE_MCI->MCI_IDR = AT91C_MCI_TXBUFE;
21f03fd8:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f03fdc:	e1a03643 	mov	r3, r3, asr #12
21f03fe0:	e3a02902 	mov	r2, #32768	; 0x8000
21f03fe4:	e5832048 	str	r2, [r3, #72]
 		AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_TXTDIS;
21f03fe8:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f03fec:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f03ff0:	e243300f 	sub	r3, r3, #15	; 0xf
21f03ff4:	e3a02c02 	mov	r2, #512	; 0x200
21f03ff8:	e5832020 	str	r2, [r3, #32]
        	
		pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_IDLE;
21f03ffc:	e51b3010 	ldr	r3, [fp, #-16]
21f04000:	e5932000 	ldr	r2, [r3]
21f04004:	e3a03000 	mov	r3, #0	; 0x0
21f04008:	e5c23000 	strb	r3, [r2]
	}	// End of if AT91C_MCI_TXBUFF		
	
    // If End of Rx Buffer Full interrupt occurred
    if ( status & AT91C_MCI_RXBUFF )
21f0400c:	e51b3014 	ldr	r3, [fp, #-20]
21f04010:	e1a03723 	mov	r3, r3, lsr #14
21f04014:	e2033001 	and	r3, r3, #1	; 0x1
21f04018:	e20330ff 	and	r3, r3, #255	; 0xff
21f0401c:	e3530000 	cmp	r3, #0	; 0x0
21f04020:	0a00000c 	beq	21f04058 <AT91F_MCI_Device_Handler+0xb0>
    {        
       	AT91C_BASE_MCI->MCI_IDR = AT91C_MCI_RXBUFF;
21f04024:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04028:	e1a03643 	mov	r3, r3, asr #12
21f0402c:	e3a02901 	mov	r2, #16384	; 0x4000
21f04030:	e5832048 	str	r2, [r3, #72]
 		AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTDIS;
21f04034:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f04038:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f0403c:	e243300f 	sub	r3, r3, #15	; 0xf
21f04040:	e3a02002 	mov	r2, #2	; 0x2
21f04044:	e5832020 	str	r2, [r3, #32]
	
		pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_IDLE;
21f04048:	e51b3010 	ldr	r3, [fp, #-16]
21f0404c:	e5932000 	ldr	r2, [r3]
21f04050:	e3a03000 	mov	r3, #0	; 0x0
21f04054:	e5c23000 	strb	r3, [r2]
	}	// End of if AT91C_MCI_RXBUFF

}
21f04058:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0405c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04060 <AT91F_MCI_ReadBlock>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_ReadBlock
//* \brief Read an ENTIRE block or PARTIAL block
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_ReadBlock(
	AT91PS_MciDevice pMCI_Device,
	int src,
	unsigned int *dataBuffer,
	int sizeToRead )
{
21f04060:	e1a0c00d 	mov	ip, sp
21f04064:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04068:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0406c:	e24dd014 	sub	sp, sp, #20	; 0x14
21f04070:	e50b0010 	str	r0, [fp, #-16]
21f04074:	e50b1014 	str	r1, [fp, #-20]
21f04078:	e50b2018 	str	r2, [fp, #-24]
21f0407c:	e50b301c 	str	r3, [fp, #-28]
    ////////////////////////////////////////////////////////////////////////////////////////////
    if(pMCI_Device->pMCI_DeviceDesc->state != AT91C_MCI_IDLE)
21f04080:	e51b3010 	ldr	r3, [fp, #-16]
21f04084:	e5933000 	ldr	r3, [r3]
21f04088:	e5d33000 	ldrb	r3, [r3]
21f0408c:	e20330ff 	and	r3, r3, #255	; 0xff
21f04090:	e3530000 	cmp	r3, #0	; 0x0
21f04094:	0a000002 	beq	21f040a4 <AT91F_MCI_ReadBlock+0x44>
    	return AT91C_READ_ERROR;
21f04098:	e3a03005 	mov	r3, #5	; 0x5
21f0409c:	e50b3020 	str	r3, [fp, #-32]
21f040a0:	ea000088 	b	21f042c8 <AT91F_MCI_ReadBlock+0x268>
    
    if( (AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address) & AT91C_SR_READY_FOR_DATA) != AT91C_SR_READY_FOR_DATA)
21f040a4:	e51b3010 	ldr	r3, [fp, #-16]
21f040a8:	e5933004 	ldr	r3, [r3, #4]
21f040ac:	e5933004 	ldr	r3, [r3, #4]
21f040b0:	e51b0010 	ldr	r0, [fp, #-16]
21f040b4:	e1a01003 	mov	r1, r3
21f040b8:	ebffff9f 	bl	21f03f3c <AT91F_MCI_GetStatus>
21f040bc:	e1a03000 	mov	r3, r0
21f040c0:	e1a03423 	mov	r3, r3, lsr #8
21f040c4:	e2233001 	eor	r3, r3, #1	; 0x1
21f040c8:	e2033001 	and	r3, r3, #1	; 0x1
21f040cc:	e20330ff 	and	r3, r3, #255	; 0xff
21f040d0:	e3530000 	cmp	r3, #0	; 0x0
21f040d4:	0a000002 	beq	21f040e4 <AT91F_MCI_ReadBlock+0x84>
    	return AT91C_READ_ERROR;
21f040d8:	e3a03005 	mov	r3, #5	; 0x5
21f040dc:	e50b3020 	str	r3, [fp, #-32]
21f040e0:	ea000078 	b	21f042c8 <AT91F_MCI_ReadBlock+0x268>
    	
    if ( (src + sizeToRead) > pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity )
21f040e4:	e51b2014 	ldr	r2, [fp, #-20]
21f040e8:	e51b301c 	ldr	r3, [fp, #-28]
21f040ec:	e0823003 	add	r3, r2, r3
21f040f0:	e1a02003 	mov	r2, r3
21f040f4:	e51b3010 	ldr	r3, [fp, #-16]
21f040f8:	e5933004 	ldr	r3, [r3, #4]
21f040fc:	e5933018 	ldr	r3, [r3, #24]
21f04100:	e1520003 	cmp	r2, r3
21f04104:	9a000002 	bls	21f04114 <AT91F_MCI_ReadBlock+0xb4>
		return AT91C_READ_ERROR;
21f04108:	e3a03005 	mov	r3, #5	; 0x5
21f0410c:	e50b3020 	str	r3, [fp, #-32]
21f04110:	ea00006c 	b	21f042c8 <AT91F_MCI_ReadBlock+0x268>

    // If source does not fit a begin of a block
	if ( (src % pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) != 0 )
21f04114:	e51b2014 	ldr	r2, [fp, #-20]
21f04118:	e51b3010 	ldr	r3, [fp, #-16]
21f0411c:	e5933004 	ldr	r3, [r3, #4]
21f04120:	e5933008 	ldr	r3, [r3, #8]
21f04124:	e1a00002 	mov	r0, r2
21f04128:	e1a01003 	mov	r1, r3
21f0412c:	eb000686 	bl	21f05b4c <__umodsi3>
21f04130:	e1a03000 	mov	r3, r0
21f04134:	e3530000 	cmp	r3, #0	; 0x0
21f04138:	0a000002 	beq	21f04148 <AT91F_MCI_ReadBlock+0xe8>
		return AT91C_READ_ERROR;
21f0413c:	e3a03005 	mov	r3, #5	; 0x5
21f04140:	e50b3020 	str	r3, [fp, #-32]
21f04144:	ea00005f 	b	21f042c8 <AT91F_MCI_ReadBlock+0x268>
   
     // Test if the MMC supports Partial Read Block
     // ALWAYS SUPPORTED IN SD Memory Card
     if( (sizeToRead < pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) 
21f04148:	e51b201c 	ldr	r2, [fp, #-28]
21f0414c:	e51b3010 	ldr	r3, [fp, #-16]
21f04150:	e5933004 	ldr	r3, [r3, #4]
21f04154:	e5933008 	ldr	r3, [r3, #8]
21f04158:	e1520003 	cmp	r2, r3
21f0415c:	2a000007 	bcs	21f04180 <AT91F_MCI_ReadBlock+0x120>
21f04160:	e51b3010 	ldr	r3, [fp, #-16]
21f04164:	e5933004 	ldr	r3, [r3, #4]
21f04168:	e5d33010 	ldrb	r3, [r3, #16]
21f0416c:	e3530000 	cmp	r3, #0	; 0x0
21f04170:	1a000002 	bne	21f04180 <AT91F_MCI_ReadBlock+0x120>
    	&& (pMCI_Device->pMCI_DeviceFeatures->Read_Partial == 0x00) )
   		return AT91C_READ_ERROR;
21f04174:	e3a03005 	mov	r3, #5	; 0x5
21f04178:	e50b3020 	str	r3, [fp, #-32]
21f0417c:	ea000051 	b	21f042c8 <AT91F_MCI_ReadBlock+0x268>
   		
    if( sizeToRead > pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length)
21f04180:	e51b201c 	ldr	r2, [fp, #-28]
21f04184:	e51b3010 	ldr	r3, [fp, #-16]
21f04188:	e5933004 	ldr	r3, [r3, #4]
21f0418c:	e5933008 	ldr	r3, [r3, #8]
21f04190:	e1520003 	cmp	r2, r3
21f04194:	9a000002 	bls	21f041a4 <AT91F_MCI_ReadBlock+0x144>
   		return AT91C_READ_ERROR;
21f04198:	e3a03005 	mov	r3, #5	; 0x5
21f0419c:	e50b3020 	str	r3, [fp, #-32]
21f041a0:	ea000048 	b	21f042c8 <AT91F_MCI_ReadBlock+0x268>
    ////////////////////////////////////////////////////////////////////////////////////////////
      
    // Init Mode Register
	AT91C_BASE_MCI->MCI_MR |= ((pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length << 16) | AT91C_MCI_PDCMODE);
21f041a4:	e3a0232d 	mov	r2, #-1275068416	; 0xb4000000
21f041a8:	e1a02642 	mov	r2, r2, asr #12
21f041ac:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f041b0:	e1a03643 	mov	r3, r3, asr #12
21f041b4:	e5931004 	ldr	r1, [r3, #4]
21f041b8:	e51b3010 	ldr	r3, [fp, #-16]
21f041bc:	e5933004 	ldr	r3, [r3, #4]
21f041c0:	e5933008 	ldr	r3, [r3, #8]
21f041c4:	e1a03803 	mov	r3, r3, lsl #16
21f041c8:	e1813003 	orr	r3, r1, r3
21f041cc:	e3833902 	orr	r3, r3, #32768	; 0x8000
21f041d0:	e5823004 	str	r3, [r2, #4]
	 
    if (sizeToRead %4)
21f041d4:	e51b301c 	ldr	r3, [fp, #-28]
21f041d8:	e2033003 	and	r3, r3, #3	; 0x3
21f041dc:	e3530000 	cmp	r3, #0	; 0x0
21f041e0:	0a000007 	beq	21f04204 <AT91F_MCI_ReadBlock+0x1a4>
		sizeToRead = (sizeToRead /4)+1;
21f041e4:	e51b301c 	ldr	r3, [fp, #-28]
21f041e8:	e2832003 	add	r2, r3, #3	; 0x3
21f041ec:	e3530000 	cmp	r3, #0	; 0x0
21f041f0:	b1a03002 	movlt	r3, r2
21f041f4:	e1a03143 	mov	r3, r3, asr #2
21f041f8:	e2833001 	add	r3, r3, #1	; 0x1
21f041fc:	e50b301c 	str	r3, [fp, #-28]
21f04200:	ea000005 	b	21f0421c <AT91F_MCI_ReadBlock+0x1bc>
	else
		sizeToRead = sizeToRead/4;
21f04204:	e51b301c 	ldr	r3, [fp, #-28]
21f04208:	e2832003 	add	r2, r3, #3	; 0x3
21f0420c:	e3530000 	cmp	r3, #0	; 0x0
21f04210:	b1a03002 	movlt	r3, r2
21f04214:	e1a03143 	mov	r3, r3, asr #2
21f04218:	e50b301c 	str	r3, [fp, #-28]

	AT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);
21f0421c:	e3e02a4b 	mvn	r2, #307200	; 0x4b000
21f04220:	e2422eef 	sub	r2, r2, #3824	; 0xef0
21f04224:	e242200f 	sub	r2, r2, #15	; 0xf
21f04228:	e3a03c02 	mov	r3, #512	; 0x200
21f0422c:	e2833002 	add	r3, r3, #2	; 0x2
21f04230:	e5823020 	str	r3, [r2, #32]
    AT91C_BASE_PDC_MCI->PDC_RPR  = (unsigned int)dataBuffer;
21f04234:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f04238:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f0423c:	e243300f 	sub	r3, r3, #15	; 0xf
21f04240:	e51b2018 	ldr	r2, [fp, #-24]
21f04244:	e5832000 	str	r2, [r3]
    AT91C_BASE_PDC_MCI->PDC_RCR  = sizeToRead;
21f04248:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f0424c:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f04250:	e243300f 	sub	r3, r3, #15	; 0xf
21f04254:	e51b201c 	ldr	r2, [fp, #-28]
21f04258:	e5832004 	str	r2, [r3, #4]

	// Send the Read single block command
    if ( AT91F_MCI_SendCommand(pMCI_Device, AT91C_READ_SINGLE_BLOCK_CMD, src) != AT91C_CMD_SEND_OK )
21f0425c:	e51b3014 	ldr	r3, [fp, #-20]
21f04260:	e51b0010 	ldr	r0, [fp, #-16]
21f04264:	e3a01a51 	mov	r1, #331776	; 0x51000
21f04268:	e2811051 	add	r1, r1, #81	; 0x51
21f0426c:	e1a02003 	mov	r2, r3
21f04270:	ebfffea8 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f04274:	e1a03000 	mov	r3, r0
21f04278:	e3530000 	cmp	r3, #0	; 0x0
21f0427c:	0a000002 	beq	21f0428c <AT91F_MCI_ReadBlock+0x22c>
    	return AT91C_READ_ERROR;
21f04280:	e3a03005 	mov	r3, #5	; 0x5
21f04284:	e50b3020 	str	r3, [fp, #-32]
21f04288:	ea00000e 	b	21f042c8 <AT91F_MCI_ReadBlock+0x268>

	pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_RX_SINGLE_BLOCK;
21f0428c:	e51b3010 	ldr	r3, [fp, #-16]
21f04290:	e5932000 	ldr	r2, [r3]
21f04294:	e3a03002 	mov	r3, #2	; 0x2
21f04298:	e5c23000 	strb	r3, [r2]

	// Enable AT91C_MCI_RXBUFF Interrupt
    AT91C_BASE_MCI->MCI_IER = AT91C_MCI_RXBUFF;
21f0429c:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f042a0:	e1a03643 	mov	r3, r3, asr #12
21f042a4:	e3a02901 	mov	r2, #16384	; 0x4000
21f042a8:	e5832044 	str	r2, [r3, #68]

	// (PDC) Receiver Transfer Enable
	AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_RXTEN;
21f042ac:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f042b0:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f042b4:	e243300f 	sub	r3, r3, #15	; 0xf
21f042b8:	e3a02001 	mov	r2, #1	; 0x1
21f042bc:	e5832020 	str	r2, [r3, #32]
	
	return AT91C_READ_OK;
21f042c0:	e3a03004 	mov	r3, #4	; 0x4
21f042c4:	e50b3020 	str	r3, [fp, #-32]
21f042c8:	e51b3020 	ldr	r3, [fp, #-32]
}
21f042cc:	e1a00003 	mov	r0, r3
21f042d0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f042d4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f042d8 <AT91F_MCI_WriteBlock>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_WriteBlock
//* \brief  Write an ENTIRE block but not always PARTIAL block !!!
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_WriteBlock(
	AT91PS_MciDevice pMCI_Device,
	int dest,
	unsigned int *dataBuffer,
	int sizeToWrite )
{
21f042d8:	e1a0c00d 	mov	ip, sp
21f042dc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f042e0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f042e4:	e24dd014 	sub	sp, sp, #20	; 0x14
21f042e8:	e50b0010 	str	r0, [fp, #-16]
21f042ec:	e50b1014 	str	r1, [fp, #-20]
21f042f0:	e50b2018 	str	r2, [fp, #-24]
21f042f4:	e50b301c 	str	r3, [fp, #-28]
    ////////////////////////////////////////////////////////////////////////////////////////////
	if( pMCI_Device->pMCI_DeviceDesc->state != AT91C_MCI_IDLE)
21f042f8:	e51b3010 	ldr	r3, [fp, #-16]
21f042fc:	e5933000 	ldr	r3, [r3]
21f04300:	e5d33000 	ldrb	r3, [r3]
21f04304:	e20330ff 	and	r3, r3, #255	; 0xff
21f04308:	e3530000 	cmp	r3, #0	; 0x0
21f0430c:	0a000002 	beq	21f0431c <AT91F_MCI_WriteBlock+0x44>
    	return AT91C_WRITE_ERROR;
21f04310:	e3a03007 	mov	r3, #7	; 0x7
21f04314:	e50b3020 	str	r3, [fp, #-32]
21f04318:	ea000088 	b	21f04540 <AT91F_MCI_WriteBlock+0x268>
    
    if( (AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address) & AT91C_SR_READY_FOR_DATA) != AT91C_SR_READY_FOR_DATA)
21f0431c:	e51b3010 	ldr	r3, [fp, #-16]
21f04320:	e5933004 	ldr	r3, [r3, #4]
21f04324:	e5933004 	ldr	r3, [r3, #4]
21f04328:	e51b0010 	ldr	r0, [fp, #-16]
21f0432c:	e1a01003 	mov	r1, r3
21f04330:	ebffff01 	bl	21f03f3c <AT91F_MCI_GetStatus>
21f04334:	e1a03000 	mov	r3, r0
21f04338:	e1a03423 	mov	r3, r3, lsr #8
21f0433c:	e2233001 	eor	r3, r3, #1	; 0x1
21f04340:	e2033001 	and	r3, r3, #1	; 0x1
21f04344:	e20330ff 	and	r3, r3, #255	; 0xff
21f04348:	e3530000 	cmp	r3, #0	; 0x0
21f0434c:	0a000002 	beq	21f0435c <AT91F_MCI_WriteBlock+0x84>
    	return AT91C_WRITE_ERROR;
21f04350:	e3a03007 	mov	r3, #7	; 0x7
21f04354:	e50b3020 	str	r3, [fp, #-32]
21f04358:	ea000078 	b	21f04540 <AT91F_MCI_WriteBlock+0x268>
    	
    if ( (dest + sizeToWrite) > pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity )
21f0435c:	e51b2014 	ldr	r2, [fp, #-20]
21f04360:	e51b301c 	ldr	r3, [fp, #-28]
21f04364:	e0823003 	add	r3, r2, r3
21f04368:	e1a02003 	mov	r2, r3
21f0436c:	e51b3010 	ldr	r3, [fp, #-16]
21f04370:	e5933004 	ldr	r3, [r3, #4]
21f04374:	e5933018 	ldr	r3, [r3, #24]
21f04378:	e1520003 	cmp	r2, r3
21f0437c:	9a000002 	bls	21f0438c <AT91F_MCI_WriteBlock+0xb4>
		return AT91C_WRITE_ERROR;
21f04380:	e3a03007 	mov	r3, #7	; 0x7
21f04384:	e50b3020 	str	r3, [fp, #-32]
21f04388:	ea00006c 	b	21f04540 <AT91F_MCI_WriteBlock+0x268>

    // If source does not fit a begin of a block
	if ( (dest % pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) != 0 )
21f0438c:	e51b2014 	ldr	r2, [fp, #-20]
21f04390:	e51b3010 	ldr	r3, [fp, #-16]
21f04394:	e5933004 	ldr	r3, [r3, #4]
21f04398:	e5933008 	ldr	r3, [r3, #8]
21f0439c:	e1a00002 	mov	r0, r2
21f043a0:	e1a01003 	mov	r1, r3
21f043a4:	eb0005e8 	bl	21f05b4c <__umodsi3>
21f043a8:	e1a03000 	mov	r3, r0
21f043ac:	e3530000 	cmp	r3, #0	; 0x0
21f043b0:	0a000002 	beq	21f043c0 <AT91F_MCI_WriteBlock+0xe8>
		return AT91C_WRITE_ERROR;
21f043b4:	e3a03007 	mov	r3, #7	; 0x7
21f043b8:	e50b3020 	str	r3, [fp, #-32]
21f043bc:	ea00005f 	b	21f04540 <AT91F_MCI_WriteBlock+0x268>
   
    // Test if the MMC supports Partial Write Block 
    if( (sizeToWrite < pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length) 
21f043c0:	e51b201c 	ldr	r2, [fp, #-28]
21f043c4:	e51b3010 	ldr	r3, [fp, #-16]
21f043c8:	e5933004 	ldr	r3, [r3, #4]
21f043cc:	e593300c 	ldr	r3, [r3, #12]
21f043d0:	e1520003 	cmp	r2, r3
21f043d4:	2a000007 	bcs	21f043f8 <AT91F_MCI_WriteBlock+0x120>
21f043d8:	e51b3010 	ldr	r3, [fp, #-16]
21f043dc:	e5933004 	ldr	r3, [r3, #4]
21f043e0:	e5d33011 	ldrb	r3, [r3, #17]
21f043e4:	e3530000 	cmp	r3, #0	; 0x0
21f043e8:	1a000002 	bne	21f043f8 <AT91F_MCI_WriteBlock+0x120>
    	&& (pMCI_Device->pMCI_DeviceFeatures->Write_Partial == 0x00) )
   		return AT91C_WRITE_ERROR;
21f043ec:	e3a03007 	mov	r3, #7	; 0x7
21f043f0:	e50b3020 	str	r3, [fp, #-32]
21f043f4:	ea000051 	b	21f04540 <AT91F_MCI_WriteBlock+0x268>
   		
   	if( sizeToWrite > pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length )
21f043f8:	e51b201c 	ldr	r2, [fp, #-28]
21f043fc:	e51b3010 	ldr	r3, [fp, #-16]
21f04400:	e5933004 	ldr	r3, [r3, #4]
21f04404:	e593300c 	ldr	r3, [r3, #12]
21f04408:	e1520003 	cmp	r2, r3
21f0440c:	9a000002 	bls	21f0441c <AT91F_MCI_WriteBlock+0x144>
   		return AT91C_WRITE_ERROR;
21f04410:	e3a03007 	mov	r3, #7	; 0x7
21f04414:	e50b3020 	str	r3, [fp, #-32]
21f04418:	ea000048 	b	21f04540 <AT91F_MCI_WriteBlock+0x268>
    ////////////////////////////////////////////////////////////////////////////////////////////
  
    // Init Mode Register
	AT91C_BASE_MCI->MCI_MR |= ((pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length << 16) | AT91C_MCI_PDCMODE);
21f0441c:	e3a0232d 	mov	r2, #-1275068416	; 0xb4000000
21f04420:	e1a02642 	mov	r2, r2, asr #12
21f04424:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04428:	e1a03643 	mov	r3, r3, asr #12
21f0442c:	e5931004 	ldr	r1, [r3, #4]
21f04430:	e51b3010 	ldr	r3, [fp, #-16]
21f04434:	e5933004 	ldr	r3, [r3, #4]
21f04438:	e593300c 	ldr	r3, [r3, #12]
21f0443c:	e1a03803 	mov	r3, r3, lsl #16
21f04440:	e1813003 	orr	r3, r1, r3
21f04444:	e3833902 	orr	r3, r3, #32768	; 0x8000
21f04448:	e5823004 	str	r3, [r2, #4]
	
	if (sizeToWrite %4)
21f0444c:	e51b301c 	ldr	r3, [fp, #-28]
21f04450:	e2033003 	and	r3, r3, #3	; 0x3
21f04454:	e3530000 	cmp	r3, #0	; 0x0
21f04458:	0a000007 	beq	21f0447c <AT91F_MCI_WriteBlock+0x1a4>
		sizeToWrite = (sizeToWrite /4)+1;
21f0445c:	e51b301c 	ldr	r3, [fp, #-28]
21f04460:	e2832003 	add	r2, r3, #3	; 0x3
21f04464:	e3530000 	cmp	r3, #0	; 0x0
21f04468:	b1a03002 	movlt	r3, r2
21f0446c:	e1a03143 	mov	r3, r3, asr #2
21f04470:	e2833001 	add	r3, r3, #1	; 0x1
21f04474:	e50b301c 	str	r3, [fp, #-28]
21f04478:	ea000005 	b	21f04494 <AT91F_MCI_WriteBlock+0x1bc>
	else
		sizeToWrite = sizeToWrite/4;
21f0447c:	e51b301c 	ldr	r3, [fp, #-28]
21f04480:	e2832003 	add	r2, r3, #3	; 0x3
21f04484:	e3530000 	cmp	r3, #0	; 0x0
21f04488:	b1a03002 	movlt	r3, r2
21f0448c:	e1a03143 	mov	r3, r3, asr #2
21f04490:	e50b301c 	str	r3, [fp, #-28]

	// Init PDC for write sequence
    AT91C_BASE_PDC_MCI->PDC_PTCR = (AT91C_PDC_TXTDIS | AT91C_PDC_RXTDIS);
21f04494:	e3e02a4b 	mvn	r2, #307200	; 0x4b000
21f04498:	e2422eef 	sub	r2, r2, #3824	; 0xef0
21f0449c:	e242200f 	sub	r2, r2, #15	; 0xf
21f044a0:	e3a03c02 	mov	r3, #512	; 0x200
21f044a4:	e2833002 	add	r3, r3, #2	; 0x2
21f044a8:	e5823020 	str	r3, [r2, #32]
    AT91C_BASE_PDC_MCI->PDC_TPR = (unsigned int) dataBuffer;
21f044ac:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f044b0:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f044b4:	e243300f 	sub	r3, r3, #15	; 0xf
21f044b8:	e51b2018 	ldr	r2, [fp, #-24]
21f044bc:	e5832008 	str	r2, [r3, #8]
    AT91C_BASE_PDC_MCI->PDC_TCR = sizeToWrite;
21f044c0:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f044c4:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f044c8:	e243300f 	sub	r3, r3, #15	; 0xf
21f044cc:	e51b201c 	ldr	r2, [fp, #-28]
21f044d0:	e583200c 	str	r2, [r3, #12]

	// Send the write single block command
    if ( AT91F_MCI_SendCommand(pMCI_Device, AT91C_WRITE_BLOCK_CMD, dest) != AT91C_CMD_SEND_OK)
21f044d4:	e51b3014 	ldr	r3, [fp, #-20]
21f044d8:	e51b0010 	ldr	r0, [fp, #-16]
21f044dc:	e3a01a11 	mov	r1, #69632	; 0x11000
21f044e0:	e2811058 	add	r1, r1, #88	; 0x58
21f044e4:	e1a02003 	mov	r2, r3
21f044e8:	ebfffe0a 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f044ec:	e1a03000 	mov	r3, r0
21f044f0:	e3530000 	cmp	r3, #0	; 0x0
21f044f4:	0a000002 	beq	21f04504 <AT91F_MCI_WriteBlock+0x22c>
    	return AT91C_WRITE_ERROR;
21f044f8:	e3a03007 	mov	r3, #7	; 0x7
21f044fc:	e50b3020 	str	r3, [fp, #-32]
21f04500:	ea00000e 	b	21f04540 <AT91F_MCI_WriteBlock+0x268>

	pMCI_Device->pMCI_DeviceDesc->state = AT91C_MCI_TX_SINGLE_BLOCK;
21f04504:	e51b3010 	ldr	r3, [fp, #-16]
21f04508:	e5932000 	ldr	r2, [r3]
21f0450c:	e3a03005 	mov	r3, #5	; 0x5
21f04510:	e5c23000 	strb	r3, [r2]

	// Enable AT91C_MCI_TXBUFE Interrupt
    AT91C_BASE_MCI->MCI_IER = AT91C_MCI_TXBUFE;
21f04514:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04518:	e1a03643 	mov	r3, r3, asr #12
21f0451c:	e3a02902 	mov	r2, #32768	; 0x8000
21f04520:	e5832044 	str	r2, [r3, #68]
  
  	// Enables TX for PDC transfert requests
    AT91C_BASE_PDC_MCI->PDC_PTCR = AT91C_PDC_TXTEN;
21f04524:	e3e03a4b 	mvn	r3, #307200	; 0x4b000
21f04528:	e2433eef 	sub	r3, r3, #3824	; 0xef0
21f0452c:	e243300f 	sub	r3, r3, #15	; 0xf
21f04530:	e3a02c01 	mov	r2, #256	; 0x100
21f04534:	e5832020 	str	r2, [r3, #32]
  
	return AT91C_WRITE_OK;
21f04538:	e3a03006 	mov	r3, #6	; 0x6
21f0453c:	e50b3020 	str	r3, [fp, #-32]
21f04540:	e51b3020 	ldr	r3, [fp, #-32]
}
21f04544:	e1a00003 	mov	r0, r3
21f04548:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0454c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04550 <AT91F_MCI_MMC_SelectCard>:

//*------------------------------------------------------------------------------------------------------------
//* \fn    AT91F_MCI_MMC_SelectCard
//* \brief Toggles a card between the Stand_by and Transfer states or between Programming and Disconnect states
//*------------------------------------------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_MMC_SelectCard(AT91PS_MciDevice pMCI_Device, unsigned int relative_card_address)
{
21f04550:	e1a0c00d 	mov	ip, sp
21f04554:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04558:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0455c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f04560:	e50b0014 	str	r0, [fp, #-20]
21f04564:	e50b1018 	str	r1, [fp, #-24]
    int status;
	
	//* Check if the MMC card chosen is already the selected one
	status = AT91F_MCI_GetStatus(pMCI_Device,relative_card_address);
21f04568:	e51b0014 	ldr	r0, [fp, #-20]
21f0456c:	e51b1018 	ldr	r1, [fp, #-24]
21f04570:	ebfffe71 	bl	21f03f3c <AT91F_MCI_GetStatus>
21f04574:	e1a03000 	mov	r3, r0
21f04578:	e50b3010 	str	r3, [fp, #-16]

	if (status < 0)
21f0457c:	e51b3010 	ldr	r3, [fp, #-16]
21f04580:	e3530000 	cmp	r3, #0	; 0x0
21f04584:	aa000002 	bge	21f04594 <AT91F_MCI_MMC_SelectCard+0x44>
		return AT91C_CARD_SELECTED_ERROR;
21f04588:	e3a0300b 	mov	r3, #11	; 0xb
21f0458c:	e50b301c 	str	r3, [fp, #-28]
21f04590:	ea000038 	b	21f04678 <AT91F_MCI_MMC_SelectCard+0x128>

	if ((status & AT91C_SR_CARD_SELECTED) == AT91C_SR_CARD_SELECTED)
21f04594:	e51b3010 	ldr	r3, [fp, #-16]
21f04598:	e2033c09 	and	r3, r3, #2304	; 0x900
21f0459c:	e3530c09 	cmp	r3, #2304	; 0x900
21f045a0:	1a000002 	bne	21f045b0 <AT91F_MCI_MMC_SelectCard+0x60>
		return AT91C_CARD_SELECTED_OK;
21f045a4:	e3a0300a 	mov	r3, #10	; 0xa
21f045a8:	e50b301c 	str	r3, [fp, #-28]
21f045ac:	ea000031 	b	21f04678 <AT91F_MCI_MMC_SelectCard+0x128>

	//* Search for the MMC Card to be selected, status = the Corresponding Device Number
	status = 0;
21f045b0:	e3a03000 	mov	r3, #0	; 0x0
21f045b4:	e50b3010 	str	r3, [fp, #-16]
	while( (pMCI_Device->pMCI_DeviceFeatures[status].Relative_Card_Address != relative_card_address)
21f045b8:	ea000002 	b	21f045c8 <AT91F_MCI_MMC_SelectCard+0x78>
		   && (status < AT91C_MAX_MCI_CARDS) )
		status++;
21f045bc:	e51b3010 	ldr	r3, [fp, #-16]
21f045c0:	e2833001 	add	r3, r3, #1	; 0x1
21f045c4:	e50b3010 	str	r3, [fp, #-16]
21f045c8:	e51b3014 	ldr	r3, [fp, #-20]
21f045cc:	e5931004 	ldr	r1, [r3, #4]
21f045d0:	e51b2010 	ldr	r2, [fp, #-16]
21f045d4:	e1a03002 	mov	r3, r2
21f045d8:	e1a03183 	mov	r3, r3, lsl #3
21f045dc:	e0623003 	rsb	r3, r2, r3
21f045e0:	e1a03103 	mov	r3, r3, lsl #2
21f045e4:	e0813003 	add	r3, r1, r3
21f045e8:	e5932004 	ldr	r2, [r3, #4]
21f045ec:	e51b3018 	ldr	r3, [fp, #-24]
21f045f0:	e1520003 	cmp	r2, r3
21f045f4:	0a000002 	beq	21f04604 <AT91F_MCI_MMC_SelectCard+0xb4>
21f045f8:	e51b3010 	ldr	r3, [fp, #-16]
21f045fc:	e3530009 	cmp	r3, #9	; 0x9
21f04600:	daffffed 	ble	21f045bc <AT91F_MCI_MMC_SelectCard+0x6c>

	if (status > AT91C_MAX_MCI_CARDS)
21f04604:	e51b3010 	ldr	r3, [fp, #-16]
21f04608:	e353000a 	cmp	r3, #10	; 0xa
21f0460c:	da000002 	ble	21f0461c <AT91F_MCI_MMC_SelectCard+0xcc>
    	return AT91C_CARD_SELECTED_ERROR;
21f04610:	e3a0300b 	mov	r3, #11	; 0xb
21f04614:	e50b301c 	str	r3, [fp, #-28]
21f04618:	ea000016 	b	21f04678 <AT91F_MCI_MMC_SelectCard+0x128>

    if (AT91F_MCI_SendCommand( pMCI_Device,
21f0461c:	e51b3014 	ldr	r3, [fp, #-20]
21f04620:	e5931004 	ldr	r1, [r3, #4]
21f04624:	e51b2010 	ldr	r2, [fp, #-16]
21f04628:	e1a03002 	mov	r3, r2
21f0462c:	e1a03183 	mov	r3, r3, lsl #3
21f04630:	e0623003 	rsb	r3, r2, r3
21f04634:	e1a03103 	mov	r3, r3, lsl #2
21f04638:	e0813003 	add	r3, r1, r3
21f0463c:	e5933004 	ldr	r3, [r3, #4]
21f04640:	e1a03803 	mov	r3, r3, lsl #16
21f04644:	e51b0014 	ldr	r0, [fp, #-20]
21f04648:	e3a01d41 	mov	r1, #4160	; 0x1040
21f0464c:	e2811007 	add	r1, r1, #7	; 0x7
21f04650:	e1a02003 	mov	r2, r3
21f04654:	ebfffdaf 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f04658:	e1a03000 	mov	r3, r0
21f0465c:	e3530000 	cmp	r3, #0	; 0x0
21f04660:	1a000002 	bne	21f04670 <AT91F_MCI_MMC_SelectCard+0x120>
    								   AT91C_SEL_DESEL_CARD_CMD,
    								   pMCI_Device->pMCI_DeviceFeatures[status].Relative_Card_Address << 16) == AT91C_CMD_SEND_OK)
    	return AT91C_CARD_SELECTED_OK;
21f04664:	e3a0300a 	mov	r3, #10	; 0xa
21f04668:	e50b301c 	str	r3, [fp, #-28]
21f0466c:	ea000001 	b	21f04678 <AT91F_MCI_MMC_SelectCard+0x128>
    return AT91C_CARD_SELECTED_ERROR;
21f04670:	e3a0300b 	mov	r3, #11	; 0xb
21f04674:	e50b301c 	str	r3, [fp, #-28]
21f04678:	e51b301c 	ldr	r3, [fp, #-28]
}
21f0467c:	e1a00003 	mov	r0, r3
21f04680:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04684:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04688 <AT91F_MCI_GetCSD>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_GetCSD
//* \brief Asks to the specified card to send its CSD
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_GetCSD (AT91PS_MciDevice pMCI_Device, unsigned int relative_card_address , unsigned int * response)
{
21f04688:	e1a0c00d 	mov	ip, sp
21f0468c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04690:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04694:	e24dd010 	sub	sp, sp, #16	; 0x10
21f04698:	e50b0010 	str	r0, [fp, #-16]
21f0469c:	e50b1014 	str	r1, [fp, #-20]
21f046a0:	e50b2018 	str	r2, [fp, #-24]
 	
 	if(AT91F_MCI_SendCommand(pMCI_Device,
21f046a4:	e51b3014 	ldr	r3, [fp, #-20]
21f046a8:	e1a03803 	mov	r3, r3, lsl #16
21f046ac:	e51b0010 	ldr	r0, [fp, #-16]
21f046b0:	e3a01d42 	mov	r1, #4224	; 0x1080
21f046b4:	e2811009 	add	r1, r1, #9	; 0x9
21f046b8:	e1a02003 	mov	r2, r3
21f046bc:	ebfffd95 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f046c0:	e1a03000 	mov	r3, r0
21f046c4:	e3530000 	cmp	r3, #0	; 0x0
21f046c8:	0a000002 	beq	21f046d8 <AT91F_MCI_GetCSD+0x50>
								  AT91C_SEND_CSD_CMD,
								  (relative_card_address << 16)) != AT91C_CMD_SEND_OK)
		return AT91C_CMD_SEND_ERROR;
21f046cc:	e3e03000 	mvn	r3, #0	; 0x0
21f046d0:	e50b301c 	str	r3, [fp, #-28]
21f046d4:	ea000018 	b	21f0473c <AT91F_MCI_GetCSD+0xb4>
	
    response[0] = AT91C_BASE_MCI->MCI_RSPR[0];
21f046d8:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f046dc:	e1a03643 	mov	r3, r3, asr #12
21f046e0:	e5932020 	ldr	r2, [r3, #32]
21f046e4:	e51b3018 	ldr	r3, [fp, #-24]
21f046e8:	e5832000 	str	r2, [r3]
   	response[1] = AT91C_BASE_MCI->MCI_RSPR[1];
21f046ec:	e51b3018 	ldr	r3, [fp, #-24]
21f046f0:	e2832004 	add	r2, r3, #4	; 0x4
21f046f4:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f046f8:	e1a03643 	mov	r3, r3, asr #12
21f046fc:	e5933024 	ldr	r3, [r3, #36]
21f04700:	e5823000 	str	r3, [r2]
    response[2] = AT91C_BASE_MCI->MCI_RSPR[2];
21f04704:	e51b3018 	ldr	r3, [fp, #-24]
21f04708:	e2832008 	add	r2, r3, #8	; 0x8
21f0470c:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04710:	e1a03643 	mov	r3, r3, asr #12
21f04714:	e5933028 	ldr	r3, [r3, #40]
21f04718:	e5823000 	str	r3, [r2]
    response[3] = AT91C_BASE_MCI->MCI_RSPR[3];
21f0471c:	e51b3018 	ldr	r3, [fp, #-24]
21f04720:	e283200c 	add	r2, r3, #12	; 0xc
21f04724:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04728:	e1a03643 	mov	r3, r3, asr #12
21f0472c:	e593302c 	ldr	r3, [r3, #44]
21f04730:	e5823000 	str	r3, [r2]
    
    return AT91C_CMD_SEND_OK;
21f04734:	e3a03000 	mov	r3, #0	; 0x0
21f04738:	e50b301c 	str	r3, [fp, #-28]
21f0473c:	e51b301c 	ldr	r3, [fp, #-28]
}
21f04740:	e1a00003 	mov	r0, r3
21f04744:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04748:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0474c <AT91F_MCI_SetBlocklength>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_SetBlocklength
//* \brief Select a block length for all following block commands (R/W)
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_SetBlocklength(AT91PS_MciDevice pMCI_Device,unsigned int length)
{
21f0474c:	e1a0c00d 	mov	ip, sp
21f04750:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04754:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04758:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0475c:	e50b0010 	str	r0, [fp, #-16]
21f04760:	e50b1014 	str	r1, [fp, #-20]
    return( AT91F_MCI_SendCommand(pMCI_Device, AT91C_SET_BLOCKLEN_CMD, length) );
21f04764:	e51b0010 	ldr	r0, [fp, #-16]
21f04768:	e3a01d41 	mov	r1, #4160	; 0x1040
21f0476c:	e2811010 	add	r1, r1, #16	; 0x10
21f04770:	e51b2014 	ldr	r2, [fp, #-20]
21f04774:	ebfffd67 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f04778:	e1a03000 	mov	r3, r0
}
21f0477c:	e1a00003 	mov	r0, r3
21f04780:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04784:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04788 <AT91F_MCI_MMC_GetAllOCR>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_MMC_GetAllOCR
//* \brief Asks to all cards to send their operations conditions
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_MMC_GetAllOCR (AT91PS_MciDevice pMCI_Device)
{
21f04788:	e1a0c00d 	mov	ip, sp
21f0478c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04790:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04794:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f04798:	e50b0014 	str	r0, [fp, #-20]
	unsigned int	response =0x0;
21f0479c:	e3a03000 	mov	r3, #0	; 0x0
21f047a0:	e50b3010 	str	r3, [fp, #-16]
 	
 	while(1)
    {
    	response = AT91F_MCI_SendCommand(pMCI_Device,
21f047a4:	e51b0014 	ldr	r0, [fp, #-20]
21f047a8:	e3a01d21 	mov	r1, #2112	; 0x840
21f047ac:	e2811001 	add	r1, r1, #1	; 0x1
21f047b0:	e3a0297e 	mov	r2, #2064384	; 0x1f8000
21f047b4:	ebfffd57 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f047b8:	e1a03000 	mov	r3, r0
21f047bc:	e50b3010 	str	r3, [fp, #-16]
  										AT91C_MMC_SEND_OP_COND_CMD,
  										AT91C_MMC_HOST_VOLTAGE_RANGE);
		if (response != AT91C_CMD_SEND_OK)
21f047c0:	e51b3010 	ldr	r3, [fp, #-16]
21f047c4:	e3530000 	cmp	r3, #0	; 0x0
21f047c8:	0a000002 	beq	21f047d8 <AT91F_MCI_MMC_GetAllOCR+0x50>
			return AT91C_INIT_ERROR;
21f047cc:	e3a03003 	mov	r3, #3	; 0x3
21f047d0:	e50b3018 	str	r3, [fp, #-24]
21f047d4:	ea000008 	b	21f047fc <AT91F_MCI_MMC_GetAllOCR+0x74>
		
		response = AT91C_BASE_MCI->MCI_RSPR[0];
21f047d8:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f047dc:	e1a03643 	mov	r3, r3, asr #12
21f047e0:	e5933020 	ldr	r3, [r3, #32]
21f047e4:	e50b3010 	str	r3, [fp, #-16]
		
		if ( (response & AT91C_CARD_POWER_UP_BUSY) == AT91C_CARD_POWER_UP_BUSY)
21f047e8:	e51b3010 	ldr	r3, [fp, #-16]
21f047ec:	e3530000 	cmp	r3, #0	; 0x0
21f047f0:	aaffffeb 	bge	21f047a4 <AT91F_MCI_MMC_GetAllOCR+0x1c>
			return(response);	
21f047f4:	e51b3010 	ldr	r3, [fp, #-16]
21f047f8:	e50b3018 	str	r3, [fp, #-24]
21f047fc:	e51b3018 	ldr	r3, [fp, #-24]
	}
}
21f04800:	e1a00003 	mov	r0, r3
21f04804:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04808:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0480c <AT91F_MCI_MMC_GetAllCID>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_MMC_GetAllCID
//* \brief Asks to the MMC on the chosen slot to send its CID
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_MMC_GetAllCID (AT91PS_MciDevice pMCI_Device, unsigned int *response)
{
21f0480c:	e1a0c00d 	mov	ip, sp
21f04810:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04814:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04818:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0481c:	e50b0014 	str	r0, [fp, #-20]
21f04820:	e50b1018 	str	r1, [fp, #-24]
	int Nb_Cards_Found=-1;
21f04824:	e3e03000 	mvn	r3, #0	; 0x0
21f04828:	e50b3010 	str	r3, [fp, #-16]
  
	while(1)
	{
	 	if(AT91F_MCI_SendCommand(pMCI_Device,
21f0482c:	e51b0014 	ldr	r0, [fp, #-20]
21f04830:	e3a01d22 	mov	r1, #2176	; 0x880
21f04834:	e2811002 	add	r1, r1, #2	; 0x2
21f04838:	e3a02000 	mov	r2, #0	; 0x0
21f0483c:	ebfffd35 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f04840:	e1a03000 	mov	r3, r0
21f04844:	e3530000 	cmp	r3, #0	; 0x0
21f04848:	0a000002 	beq	21f04858 <AT91F_MCI_MMC_GetAllCID+0x4c>
								AT91C_MMC_ALL_SEND_CID_CMD,
								AT91C_NO_ARGUMENT) != AT91C_CMD_SEND_OK)
			return Nb_Cards_Found;
21f0484c:	e51b3010 	ldr	r3, [fp, #-16]
21f04850:	e50b301c 	str	r3, [fp, #-28]
21f04854:	ea00002a 	b	21f04904 <AT91F_MCI_MMC_GetAllCID+0xf8>
		else
		{		
			Nb_Cards_Found = 0;
21f04858:	e3a03000 	mov	r3, #0	; 0x0
21f0485c:	e50b3010 	str	r3, [fp, #-16]
			//* Assignation of the relative address to the MMC CARD
			pMCI_Device->pMCI_DeviceFeatures[Nb_Cards_Found].Relative_Card_Address = Nb_Cards_Found + AT91C_FIRST_RCA;
21f04860:	e51b3014 	ldr	r3, [fp, #-20]
21f04864:	e5931004 	ldr	r1, [r3, #4]
21f04868:	e51b2010 	ldr	r2, [fp, #-16]
21f0486c:	e1a03002 	mov	r3, r2
21f04870:	e1a03183 	mov	r3, r3, lsl #3
21f04874:	e0623003 	rsb	r3, r2, r3
21f04878:	e1a03103 	mov	r3, r3, lsl #2
21f0487c:	e0812003 	add	r2, r1, r3
21f04880:	e51b3010 	ldr	r3, [fp, #-16]
21f04884:	e2833cca 	add	r3, r3, #51712	; 0xca00
21f04888:	e28330fe 	add	r3, r3, #254	; 0xfe
21f0488c:	e5823004 	str	r3, [r2, #4]
			//* Set the insert flag
			pMCI_Device->pMCI_DeviceFeatures[Nb_Cards_Found].Card_Inserted = AT91C_MMC_CARD_INSERTED;
21f04890:	e51b3014 	ldr	r3, [fp, #-20]
21f04894:	e5931004 	ldr	r1, [r3, #4]
21f04898:	e51b2010 	ldr	r2, [fp, #-16]
21f0489c:	e1a03002 	mov	r3, r2
21f048a0:	e1a03183 	mov	r3, r3, lsl #3
21f048a4:	e0623003 	rsb	r3, r2, r3
21f048a8:	e1a03103 	mov	r3, r3, lsl #2
21f048ac:	e0812003 	add	r2, r1, r3
21f048b0:	e3a03001 	mov	r3, #1	; 0x1
21f048b4:	e5c23000 	strb	r3, [r2]
	
			if (AT91F_MCI_SendCommand(pMCI_Device,
21f048b8:	e51b3010 	ldr	r3, [fp, #-16]
21f048bc:	e2833cca 	add	r3, r3, #51712	; 0xca00
21f048c0:	e28330fe 	add	r3, r3, #254	; 0xfe
21f048c4:	e1a03803 	mov	r3, r3, lsl #16
21f048c8:	e51b0014 	ldr	r0, [fp, #-20]
21f048cc:	e3a01d61 	mov	r1, #6208	; 0x1840
21f048d0:	e2811003 	add	r1, r1, #3	; 0x3
21f048d4:	e1a02003 	mov	r2, r3
21f048d8:	ebfffd0e 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f048dc:	e1a03000 	mov	r3, r0
21f048e0:	e3530000 	cmp	r3, #0	; 0x0
21f048e4:	0a000002 	beq	21f048f4 <AT91F_MCI_MMC_GetAllCID+0xe8>
									 AT91C_MMC_SET_RELATIVE_ADDR_CMD,
									 (Nb_Cards_Found + AT91C_FIRST_RCA) << 16) != AT91C_CMD_SEND_OK)
				return AT91C_CMD_SEND_ERROR;
21f048e8:	e3e03000 	mvn	r3, #0	; 0x0
21f048ec:	e50b301c 	str	r3, [fp, #-28]
21f048f0:	ea000003 	b	21f04904 <AT91F_MCI_MMC_GetAllCID+0xf8>
				 
			//* If no error during assignation address ==> Increment Nb_cards_Found
			Nb_Cards_Found++ ;
21f048f4:	e51b3010 	ldr	r3, [fp, #-16]
21f048f8:	e2833001 	add	r3, r3, #1	; 0x1
21f048fc:	e50b3010 	str	r3, [fp, #-16]
		}
	}
21f04900:	eaffffc9 	b	21f0482c <AT91F_MCI_MMC_GetAllCID+0x20>
21f04904:	e51b301c 	ldr	r3, [fp, #-28]
}
21f04908:	e1a00003 	mov	r0, r3
21f0490c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04910:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04914 <AT91F_MCI_MMC_Init>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_MMC_Init
//* \brief Return the MMC initialisation status
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_MMC_Init (AT91PS_MciDevice pMCI_Device)
{
21f04914:	e1a0c00d 	mov	ip, sp
21f04918:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0491c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04920:	e24dd028 	sub	sp, sp, #40	; 0x28
21f04924:	e50b0030 	str	r0, [fp, #-48]
    unsigned int	tab_response[4];
	unsigned int	mult,blocknr;
	unsigned int 	i,Nb_Cards_Found=0;
21f04928:	e3a03000 	mov	r3, #0	; 0x0
21f0492c:	e50b3010 	str	r3, [fp, #-16]

	//* Resets all MMC Cards in Idle state
	AT91F_MCI_SendCommand(pMCI_Device, AT91C_MMC_GO_IDLE_STATE_CMD, AT91C_NO_ARGUMENT);
21f04930:	e51b0030 	ldr	r0, [fp, #-48]
21f04934:	e3a01b02 	mov	r1, #2048	; 0x800
21f04938:	e3a02000 	mov	r2, #0	; 0x0
21f0493c:	ebfffcf5 	bl	21f03d18 <AT91F_MCI_SendCommand>

    if(AT91F_MCI_MMC_GetAllOCR(pMCI_Device) == AT91C_INIT_ERROR)
21f04940:	e51b0030 	ldr	r0, [fp, #-48]
21f04944:	ebffff8f 	bl	21f04788 <AT91F_MCI_MMC_GetAllOCR>
21f04948:	e1a03000 	mov	r3, r0
21f0494c:	e3530003 	cmp	r3, #3	; 0x3
21f04950:	1a000002 	bne	21f04960 <AT91F_MCI_MMC_Init+0x4c>
    	return AT91C_INIT_ERROR;
21f04954:	e3a03003 	mov	r3, #3	; 0x3
21f04958:	e50b3034 	str	r3, [fp, #-52]
21f0495c:	ea0000ca 	b	21f04c8c <AT91F_MCI_MMC_Init+0x378>

	Nb_Cards_Found = AT91F_MCI_MMC_GetAllCID(pMCI_Device,tab_response);
21f04960:	e24b302c 	sub	r3, fp, #44	; 0x2c
21f04964:	e51b0030 	ldr	r0, [fp, #-48]
21f04968:	e1a01003 	mov	r1, r3
21f0496c:	ebffffa6 	bl	21f0480c <AT91F_MCI_MMC_GetAllCID>
21f04970:	e1a03000 	mov	r3, r0
21f04974:	e50b3010 	str	r3, [fp, #-16]
	if (Nb_Cards_Found != AT91C_CMD_SEND_ERROR)
21f04978:	e51b3010 	ldr	r3, [fp, #-16]
21f0497c:	e3730001 	cmn	r3, #1	; 0x1
21f04980:	0a0000bf 	beq	21f04c84 <AT91F_MCI_MMC_Init+0x370>
	{
	    //* Set the Mode Register
    	AT91C_BASE_MCI->MCI_MR = AT91C_MCI_MR_PDCMODE;
21f04984:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04988:	e1a03643 	mov	r3, r3, asr #12
21f0498c:	e3a02c83 	mov	r2, #33536	; 0x8300
21f04990:	e2822001 	add	r2, r2, #1	; 0x1
21f04994:	e5832004 	str	r2, [r3, #4]

		for(i = 0; i < Nb_Cards_Found; i++)
21f04998:	e3a03000 	mov	r3, #0	; 0x0
21f0499c:	e50b3014 	str	r3, [fp, #-20]
21f049a0:	ea0000b0 	b	21f04c68 <AT91F_MCI_MMC_Init+0x354>
		{
			if (AT91F_MCI_GetCSD(pMCI_Device,
21f049a4:	e51b3030 	ldr	r3, [fp, #-48]
21f049a8:	e5931004 	ldr	r1, [r3, #4]
21f049ac:	e51b2014 	ldr	r2, [fp, #-20]
21f049b0:	e1a03002 	mov	r3, r2
21f049b4:	e1a03183 	mov	r3, r3, lsl #3
21f049b8:	e0623003 	rsb	r3, r2, r3
21f049bc:	e1a03103 	mov	r3, r3, lsl #2
21f049c0:	e0813003 	add	r3, r1, r3
21f049c4:	e5933004 	ldr	r3, [r3, #4]
21f049c8:	e24b202c 	sub	r2, fp, #44	; 0x2c
21f049cc:	e51b0030 	ldr	r0, [fp, #-48]
21f049d0:	e1a01003 	mov	r1, r3
21f049d4:	ebffff2b 	bl	21f04688 <AT91F_MCI_GetCSD>
21f049d8:	e1a03000 	mov	r3, r0
21f049dc:	e3530000 	cmp	r3, #0	; 0x0
21f049e0:	0a00000a 	beq	21f04a10 <AT91F_MCI_MMC_Init+0xfc>
									  pMCI_Device->pMCI_DeviceFeatures[i].Relative_Card_Address,
									  tab_response) != AT91C_CMD_SEND_OK)
				pMCI_Device->pMCI_DeviceFeatures[i].Relative_Card_Address = 0;					  
21f049e4:	e51b3030 	ldr	r3, [fp, #-48]
21f049e8:	e5931004 	ldr	r1, [r3, #4]
21f049ec:	e51b2014 	ldr	r2, [fp, #-20]
21f049f0:	e1a03002 	mov	r3, r2
21f049f4:	e1a03183 	mov	r3, r3, lsl #3
21f049f8:	e0623003 	rsb	r3, r2, r3
21f049fc:	e1a03103 	mov	r3, r3, lsl #2
21f04a00:	e0812003 	add	r2, r1, r3
21f04a04:	e3a03000 	mov	r3, #0	; 0x0
21f04a08:	e5823004 	str	r3, [r2, #4]
21f04a0c:	ea000092 	b	21f04c5c <AT91F_MCI_MMC_Init+0x348>
			else
			{
				pMCI_Device->pMCI_DeviceFeatures[i].Max_Read_DataBlock_Length = 1 << ((tab_response[1] >> AT91C_CSD_RD_B_LEN_S) & AT91C_CSD_RD_B_LEN_M );
21f04a10:	e51b3030 	ldr	r3, [fp, #-48]
21f04a14:	e5931004 	ldr	r1, [r3, #4]
21f04a18:	e51b2014 	ldr	r2, [fp, #-20]
21f04a1c:	e1a03002 	mov	r3, r2
21f04a20:	e1a03183 	mov	r3, r3, lsl #3
21f04a24:	e0623003 	rsb	r3, r2, r3
21f04a28:	e1a03103 	mov	r3, r3, lsl #2
21f04a2c:	e0811003 	add	r1, r1, r3
21f04a30:	e51b3028 	ldr	r3, [fp, #-40]
21f04a34:	e1a03823 	mov	r3, r3, lsr #16
21f04a38:	e203200f 	and	r2, r3, #15	; 0xf
21f04a3c:	e3a03001 	mov	r3, #1	; 0x1
21f04a40:	e1a03213 	mov	r3, r3, lsl r2
21f04a44:	e5813008 	str	r3, [r1, #8]
	 			pMCI_Device->pMCI_DeviceFeatures[i].Max_Write_DataBlock_Length =	1 << ((tab_response[3] >> AT91C_CSD_WBLEN_S) & AT91C_CSD_WBLEN_M );
21f04a48:	e51b3030 	ldr	r3, [fp, #-48]
21f04a4c:	e5931004 	ldr	r1, [r3, #4]
21f04a50:	e51b2014 	ldr	r2, [fp, #-20]
21f04a54:	e1a03002 	mov	r3, r2
21f04a58:	e1a03183 	mov	r3, r3, lsl #3
21f04a5c:	e0623003 	rsb	r3, r2, r3
21f04a60:	e1a03103 	mov	r3, r3, lsl #2
21f04a64:	e0811003 	add	r1, r1, r3
21f04a68:	e51b3020 	ldr	r3, [fp, #-32]
21f04a6c:	e1a03b23 	mov	r3, r3, lsr #22
21f04a70:	e203200f 	and	r2, r3, #15	; 0xf
21f04a74:	e3a03001 	mov	r3, #1	; 0x1
21f04a78:	e1a03213 	mov	r3, r3, lsl r2
21f04a7c:	e581300c 	str	r3, [r1, #12]
				pMCI_Device->pMCI_DeviceFeatures[i].Sector_Size = 1 + ((tab_response[2] >> AT91C_CSD_v22_SECT_SIZE_S) & AT91C_CSD_v22_SECT_SIZE_M );
21f04a80:	e51b3030 	ldr	r3, [fp, #-48]
21f04a84:	e5931004 	ldr	r1, [r3, #4]
21f04a88:	e51b2014 	ldr	r2, [fp, #-20]
21f04a8c:	e1a03002 	mov	r3, r2
21f04a90:	e1a03183 	mov	r3, r3, lsl #3
21f04a94:	e0623003 	rsb	r3, r2, r3
21f04a98:	e1a03103 	mov	r3, r3, lsl #2
21f04a9c:	e0812003 	add	r2, r1, r3
21f04aa0:	e51b3024 	ldr	r3, [fp, #-36]
21f04aa4:	e1a03523 	mov	r3, r3, lsr #10
21f04aa8:	e20330ff 	and	r3, r3, #255	; 0xff
21f04aac:	e203301f 	and	r3, r3, #31	; 0x1f
21f04ab0:	e2833001 	add	r3, r3, #1	; 0x1
21f04ab4:	e20330ff 	and	r3, r3, #255	; 0xff
21f04ab8:	e5c23015 	strb	r3, [r2, #21]
		  		pMCI_Device->pMCI_DeviceFeatures[i].Read_Partial = (tab_response[1] >> AT91C_CSD_RD_B_PAR_S) & AT91C_CSD_RD_B_PAR_M;
21f04abc:	e51b3030 	ldr	r3, [fp, #-48]
21f04ac0:	e5931004 	ldr	r1, [r3, #4]
21f04ac4:	e51b2014 	ldr	r2, [fp, #-20]
21f04ac8:	e1a03002 	mov	r3, r2
21f04acc:	e1a03183 	mov	r3, r3, lsl #3
21f04ad0:	e0623003 	rsb	r3, r2, r3
21f04ad4:	e1a03103 	mov	r3, r3, lsl #2
21f04ad8:	e0812003 	add	r2, r1, r3
21f04adc:	e51b3028 	ldr	r3, [fp, #-40]
21f04ae0:	e1a037a3 	mov	r3, r3, lsr #15
21f04ae4:	e20330ff 	and	r3, r3, #255	; 0xff
21f04ae8:	e2033001 	and	r3, r3, #1	; 0x1
21f04aec:	e5c23010 	strb	r3, [r2, #16]
				pMCI_Device->pMCI_DeviceFeatures[i].Write_Partial = (tab_response[3] >> AT91C_CSD_WBLOCK_P_S) & AT91C_CSD_WBLOCK_P_M;
21f04af0:	e51b3030 	ldr	r3, [fp, #-48]
21f04af4:	e5931004 	ldr	r1, [r3, #4]
21f04af8:	e51b2014 	ldr	r2, [fp, #-20]
21f04afc:	e1a03002 	mov	r3, r2
21f04b00:	e1a03183 	mov	r3, r3, lsl #3
21f04b04:	e0623003 	rsb	r3, r2, r3
21f04b08:	e1a03103 	mov	r3, r3, lsl #2
21f04b0c:	e0812003 	add	r2, r1, r3
21f04b10:	e51b3020 	ldr	r3, [fp, #-32]
21f04b14:	e1a03aa3 	mov	r3, r3, lsr #21
21f04b18:	e20330ff 	and	r3, r3, #255	; 0xff
21f04b1c:	e2033001 	and	r3, r3, #1	; 0x1
21f04b20:	e5c23011 	strb	r3, [r2, #17]
				
				// None in MMC specification version 2.2
				pMCI_Device->pMCI_DeviceFeatures[i].Erase_Block_Enable = 0;
21f04b24:	e51b3030 	ldr	r3, [fp, #-48]
21f04b28:	e5931004 	ldr	r1, [r3, #4]
21f04b2c:	e51b2014 	ldr	r2, [fp, #-20]
21f04b30:	e1a03002 	mov	r3, r2
21f04b34:	e1a03183 	mov	r3, r3, lsl #3
21f04b38:	e0623003 	rsb	r3, r2, r3
21f04b3c:	e1a03103 	mov	r3, r3, lsl #2
21f04b40:	e0812003 	add	r2, r1, r3
21f04b44:	e3a03000 	mov	r3, #0	; 0x0
21f04b48:	e5c23012 	strb	r3, [r2, #18]
				
				pMCI_Device->pMCI_DeviceFeatures[i].Read_Block_Misalignment = (tab_response[1] >> AT91C_CSD_RD_B_MIS_S) & AT91C_CSD_RD_B_MIS_M;
21f04b4c:	e51b3030 	ldr	r3, [fp, #-48]
21f04b50:	e5931004 	ldr	r1, [r3, #4]
21f04b54:	e51b2014 	ldr	r2, [fp, #-20]
21f04b58:	e1a03002 	mov	r3, r2
21f04b5c:	e1a03183 	mov	r3, r3, lsl #3
21f04b60:	e0623003 	rsb	r3, r2, r3
21f04b64:	e1a03103 	mov	r3, r3, lsl #2
21f04b68:	e0812003 	add	r2, r1, r3
21f04b6c:	e51b3028 	ldr	r3, [fp, #-40]
21f04b70:	e1a036a3 	mov	r3, r3, lsr #13
21f04b74:	e20330ff 	and	r3, r3, #255	; 0xff
21f04b78:	e2033001 	and	r3, r3, #1	; 0x1
21f04b7c:	e5c23013 	strb	r3, [r2, #19]
				pMCI_Device->pMCI_DeviceFeatures[i].Write_Block_Misalignment = (tab_response[1] >> AT91C_CSD_WR_B_MIS_S) & AT91C_CSD_WR_B_MIS_M;
21f04b80:	e51b3030 	ldr	r3, [fp, #-48]
21f04b84:	e5931004 	ldr	r1, [r3, #4]
21f04b88:	e51b2014 	ldr	r2, [fp, #-20]
21f04b8c:	e1a03002 	mov	r3, r2
21f04b90:	e1a03183 	mov	r3, r3, lsl #3
21f04b94:	e0623003 	rsb	r3, r2, r3
21f04b98:	e1a03103 	mov	r3, r3, lsl #2
21f04b9c:	e0812003 	add	r2, r1, r3
21f04ba0:	e51b3028 	ldr	r3, [fp, #-40]
21f04ba4:	e1a03723 	mov	r3, r3, lsr #14
21f04ba8:	e20330ff 	and	r3, r3, #255	; 0xff
21f04bac:	e2033001 	and	r3, r3, #1	; 0x1
21f04bb0:	e5c23014 	strb	r3, [r2, #20]

				//// Compute Memory Capacity
				// compute MULT
				mult = 1 << ( ((tab_response[2] >> AT91C_CSD_C_SIZE_M_S) & AT91C_CSD_C_SIZE_M_M) + 2 );
21f04bb4:	e51b3024 	ldr	r3, [fp, #-36]
21f04bb8:	e1a037a3 	mov	r3, r3, lsr #15
21f04bbc:	e2033007 	and	r3, r3, #7	; 0x7
21f04bc0:	e2833002 	add	r3, r3, #2	; 0x2
21f04bc4:	e1a02003 	mov	r2, r3
21f04bc8:	e3a03001 	mov	r3, #1	; 0x1
21f04bcc:	e1a03213 	mov	r3, r3, lsl r2
21f04bd0:	e50b301c 	str	r3, [fp, #-28]
				// compute MSB of C_SIZE
				blocknr = ((tab_response[1] >> AT91C_CSD_CSIZE_H_S) & AT91C_CSD_CSIZE_H_M) << 2;
21f04bd4:	e51b3028 	ldr	r3, [fp, #-40]
21f04bd8:	e1a03b03 	mov	r3, r3, lsl #22
21f04bdc:	e1a03b23 	mov	r3, r3, lsr #22
21f04be0:	e1a03103 	mov	r3, r3, lsl #2
21f04be4:	e50b3018 	str	r3, [fp, #-24]
				// compute MULT * (LSB of C-SIZE + MSB already computed + 1) = BLOCKNR
				blocknr = mult * ( ( blocknr + ( (tab_response[2] >> AT91C_CSD_CSIZE_L_S) & AT91C_CSD_CSIZE_L_M) ) + 1 );
21f04be8:	e51b3024 	ldr	r3, [fp, #-36]
21f04bec:	e1a03f23 	mov	r3, r3, lsr #30
21f04bf0:	e2032003 	and	r2, r3, #3	; 0x3
21f04bf4:	e51b3018 	ldr	r3, [fp, #-24]
21f04bf8:	e0823003 	add	r3, r2, r3
21f04bfc:	e2832001 	add	r2, r3, #1	; 0x1
21f04c00:	e51b301c 	ldr	r3, [fp, #-28]
21f04c04:	e0030392 	mul	r3, r2, r3
21f04c08:	e50b3018 	str	r3, [fp, #-24]

				pMCI_Device->pMCI_DeviceFeatures[i].Memory_Capacity =  pMCI_Device->pMCI_DeviceFeatures[i].Max_Read_DataBlock_Length * blocknr;
21f04c0c:	e51b3030 	ldr	r3, [fp, #-48]
21f04c10:	e5931004 	ldr	r1, [r3, #4]
21f04c14:	e51b2014 	ldr	r2, [fp, #-20]
21f04c18:	e1a03002 	mov	r3, r2
21f04c1c:	e1a03183 	mov	r3, r3, lsl #3
21f04c20:	e0623003 	rsb	r3, r2, r3
21f04c24:	e1a03103 	mov	r3, r3, lsl #2
21f04c28:	e0810003 	add	r0, r1, r3
21f04c2c:	e51b3030 	ldr	r3, [fp, #-48]
21f04c30:	e5931004 	ldr	r1, [r3, #4]
21f04c34:	e51b2014 	ldr	r2, [fp, #-20]
21f04c38:	e1a03002 	mov	r3, r2
21f04c3c:	e1a03183 	mov	r3, r3, lsl #3
21f04c40:	e0623003 	rsb	r3, r2, r3
21f04c44:	e1a03103 	mov	r3, r3, lsl #2
21f04c48:	e0813003 	add	r3, r1, r3
21f04c4c:	e5932008 	ldr	r2, [r3, #8]
21f04c50:	e51b3018 	ldr	r3, [fp, #-24]
21f04c54:	e0030392 	mul	r3, r2, r3
21f04c58:	e5803018 	str	r3, [r0, #24]
21f04c5c:	e51b3014 	ldr	r3, [fp, #-20]
21f04c60:	e2833001 	add	r3, r3, #1	; 0x1
21f04c64:	e50b3014 	str	r3, [fp, #-20]
21f04c68:	e51b2014 	ldr	r2, [fp, #-20]
21f04c6c:	e51b3010 	ldr	r3, [fp, #-16]
21f04c70:	e1520003 	cmp	r2, r3
21f04c74:	3affff4a 	bcc	21f049a4 <AT91F_MCI_MMC_Init+0x90>
		  		//// End of Compute Memory Capacity
		  		
			}	// end of else			  
		}	// end of for
		
		return AT91C_INIT_OK;
21f04c78:	e3a03002 	mov	r3, #2	; 0x2
21f04c7c:	e50b3034 	str	r3, [fp, #-52]
21f04c80:	ea000001 	b	21f04c8c <AT91F_MCI_MMC_Init+0x378>
	}	// end of if

    return AT91C_INIT_ERROR;
21f04c84:	e3a03003 	mov	r3, #3	; 0x3
21f04c88:	e50b3034 	str	r3, [fp, #-52]
21f04c8c:	e51b3034 	ldr	r3, [fp, #-52]
}
21f04c90:	e1a00003 	mov	r0, r3
21f04c94:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04c98:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04c9c <AT91F_MCI_SDCard_GetOCR>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_SDCard_GetOCR
//* \brief Asks to all cards to send their operations conditions
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_SDCard_GetOCR (AT91PS_MciDevice pMCI_Device)
{
21f04c9c:	e1a0c00d 	mov	ip, sp
21f04ca0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04ca4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04ca8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f04cac:	e50b0014 	str	r0, [fp, #-20]
	unsigned int	response =0x0;
21f04cb0:	e3a03000 	mov	r3, #0	; 0x0
21f04cb4:	e50b3010 	str	r3, [fp, #-16]

	// The RCA to be used for CMD55 in Idle state shall be the card's default RCA=0x0000.
	pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address = 0x0;
21f04cb8:	e51b3014 	ldr	r3, [fp, #-20]
21f04cbc:	e5932004 	ldr	r2, [r3, #4]
21f04cc0:	e3a03000 	mov	r3, #0	; 0x0
21f04cc4:	e5823004 	str	r3, [r2, #4]
 	
 	while( (response & AT91C_CARD_POWER_UP_BUSY) != AT91C_CARD_POWER_UP_BUSY )
21f04cc8:	ea00000f 	b	21f04d0c <AT91F_MCI_SDCard_GetOCR+0x70>
    {
    	response = AT91F_MCI_SDCard_SendAppCommand(pMCI_Device,
21f04ccc:	e51b0014 	ldr	r0, [fp, #-20]
21f04cd0:	e3a01069 	mov	r1, #105	; 0x69
21f04cd4:	e3a0297e 	mov	r2, #2064384	; 0x1f8000
21f04cd8:	ebfffc58 	bl	21f03e40 <AT91F_MCI_SDCard_SendAppCommand>
21f04cdc:	e1a03000 	mov	r3, r0
21f04ce0:	e50b3010 	str	r3, [fp, #-16]
  										AT91C_SDCARD_APP_OP_COND_CMD,
  										AT91C_MMC_HOST_VOLTAGE_RANGE);
		if (response != AT91C_CMD_SEND_OK)
21f04ce4:	e51b3010 	ldr	r3, [fp, #-16]
21f04ce8:	e3530000 	cmp	r3, #0	; 0x0
21f04cec:	0a000002 	beq	21f04cfc <AT91F_MCI_SDCard_GetOCR+0x60>
			return AT91C_INIT_ERROR;
21f04cf0:	e3a03003 	mov	r3, #3	; 0x3
21f04cf4:	e50b3018 	str	r3, [fp, #-24]
21f04cf8:	ea00000a 	b	21f04d28 <AT91F_MCI_SDCard_GetOCR+0x8c>
		
		response = AT91C_BASE_MCI->MCI_RSPR[0];
21f04cfc:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04d00:	e1a03643 	mov	r3, r3, asr #12
21f04d04:	e5933020 	ldr	r3, [r3, #32]
21f04d08:	e50b3010 	str	r3, [fp, #-16]
21f04d0c:	e51b3010 	ldr	r3, [fp, #-16]
21f04d10:	e3530000 	cmp	r3, #0	; 0x0
21f04d14:	aaffffec 	bge	21f04ccc <AT91F_MCI_SDCard_GetOCR+0x30>
	}
	
	return(AT91C_BASE_MCI->MCI_RSPR[0]);
21f04d18:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04d1c:	e1a03643 	mov	r3, r3, asr #12
21f04d20:	e5933020 	ldr	r3, [r3, #32]
21f04d24:	e50b3018 	str	r3, [fp, #-24]
21f04d28:	e51b3018 	ldr	r3, [fp, #-24]
}
21f04d2c:	e1a00003 	mov	r0, r3
21f04d30:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04d34:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04d38 <AT91F_MCI_SDCard_GetCID>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_SDCard_GetCID
//* \brief Asks to the SDCard on the chosen slot to send its CID
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_SDCard_GetCID (AT91PS_MciDevice pMCI_Device, unsigned int *response)
{
21f04d38:	e1a0c00d 	mov	ip, sp
21f04d3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04d40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04d44:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f04d48:	e50b0010 	str	r0, [fp, #-16]
21f04d4c:	e50b1014 	str	r1, [fp, #-20]
 	if(AT91F_MCI_SendCommand(pMCI_Device,
21f04d50:	e51b0010 	ldr	r0, [fp, #-16]
21f04d54:	e3a01082 	mov	r1, #130	; 0x82
21f04d58:	e3a02000 	mov	r2, #0	; 0x0
21f04d5c:	ebfffbed 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f04d60:	e1a03000 	mov	r3, r0
21f04d64:	e3530000 	cmp	r3, #0	; 0x0
21f04d68:	0a000002 	beq	21f04d78 <AT91F_MCI_SDCard_GetCID+0x40>
							AT91C_ALL_SEND_CID_CMD,
							AT91C_NO_ARGUMENT) != AT91C_CMD_SEND_OK)
		return AT91C_CMD_SEND_ERROR;
21f04d6c:	e3e03000 	mvn	r3, #0	; 0x0
21f04d70:	e50b3018 	str	r3, [fp, #-24]
21f04d74:	ea000018 	b	21f04ddc <AT91F_MCI_SDCard_GetCID+0xa4>
	
    response[0] = AT91C_BASE_MCI->MCI_RSPR[0];
21f04d78:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04d7c:	e1a03643 	mov	r3, r3, asr #12
21f04d80:	e5932020 	ldr	r2, [r3, #32]
21f04d84:	e51b3014 	ldr	r3, [fp, #-20]
21f04d88:	e5832000 	str	r2, [r3]
   	response[1] = AT91C_BASE_MCI->MCI_RSPR[1];
21f04d8c:	e51b3014 	ldr	r3, [fp, #-20]
21f04d90:	e2832004 	add	r2, r3, #4	; 0x4
21f04d94:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04d98:	e1a03643 	mov	r3, r3, asr #12
21f04d9c:	e5933024 	ldr	r3, [r3, #36]
21f04da0:	e5823000 	str	r3, [r2]
    response[2] = AT91C_BASE_MCI->MCI_RSPR[2];
21f04da4:	e51b3014 	ldr	r3, [fp, #-20]
21f04da8:	e2832008 	add	r2, r3, #8	; 0x8
21f04dac:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04db0:	e1a03643 	mov	r3, r3, asr #12
21f04db4:	e5933028 	ldr	r3, [r3, #40]
21f04db8:	e5823000 	str	r3, [r2]
    response[3] = AT91C_BASE_MCI->MCI_RSPR[3];
21f04dbc:	e51b3014 	ldr	r3, [fp, #-20]
21f04dc0:	e283200c 	add	r2, r3, #12	; 0xc
21f04dc4:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04dc8:	e1a03643 	mov	r3, r3, asr #12
21f04dcc:	e593302c 	ldr	r3, [r3, #44]
21f04dd0:	e5823000 	str	r3, [r2]
    
    return AT91C_CMD_SEND_OK;
21f04dd4:	e3a03000 	mov	r3, #0	; 0x0
21f04dd8:	e50b3018 	str	r3, [fp, #-24]
21f04ddc:	e51b3018 	ldr	r3, [fp, #-24]
}
21f04de0:	e1a00003 	mov	r0, r3
21f04de4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04de8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04dec <AT91F_MCI_SDCard_SetBusWidth>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_SDCard_SetBusWidth
//* \brief  Set bus width for SDCard
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_SDCard_SetBusWidth(AT91PS_MciDevice pMCI_Device)
{
21f04dec:	e1a0c00d 	mov	ip, sp
21f04df0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04df4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04df8:	e24dd010 	sub	sp, sp, #16	; 0x10
21f04dfc:	e50b0018 	str	r0, [fp, #-24]
	volatile int	ret_value;
	char			bus_width;

	do
	{
		ret_value =AT91F_MCI_GetStatus(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address);
21f04e00:	e51b3018 	ldr	r3, [fp, #-24]
21f04e04:	e5933004 	ldr	r3, [r3, #4]
21f04e08:	e5933004 	ldr	r3, [r3, #4]
21f04e0c:	e51b0018 	ldr	r0, [fp, #-24]
21f04e10:	e1a01003 	mov	r1, r3
21f04e14:	ebfffc48 	bl	21f03f3c <AT91F_MCI_GetStatus>
21f04e18:	e1a03000 	mov	r3, r0
21f04e1c:	e50b3014 	str	r3, [fp, #-20]
	}
	while((ret_value > 0) && ((ret_value & AT91C_SR_READY_FOR_DATA) == 0));
21f04e20:	e51b3014 	ldr	r3, [fp, #-20]
21f04e24:	e3530000 	cmp	r3, #0	; 0x0
21f04e28:	da000006 	ble	21f04e48 <AT91F_MCI_SDCard_SetBusWidth+0x5c>
21f04e2c:	e51b3014 	ldr	r3, [fp, #-20]
21f04e30:	e1a03423 	mov	r3, r3, lsr #8
21f04e34:	e2233001 	eor	r3, r3, #1	; 0x1
21f04e38:	e2033001 	and	r3, r3, #1	; 0x1
21f04e3c:	e20330ff 	and	r3, r3, #255	; 0xff
21f04e40:	e3530000 	cmp	r3, #0	; 0x0
21f04e44:	1affffed 	bne	21f04e00 <AT91F_MCI_SDCard_SetBusWidth+0x14>

	// Select Card
    AT91F_MCI_SendCommand(pMCI_Device,
21f04e48:	e51b3018 	ldr	r3, [fp, #-24]
21f04e4c:	e5933004 	ldr	r3, [r3, #4]
21f04e50:	e5933004 	ldr	r3, [r3, #4]
21f04e54:	e1a03803 	mov	r3, r3, lsl #16
21f04e58:	e51b0018 	ldr	r0, [fp, #-24]
21f04e5c:	e3a01d41 	mov	r1, #4160	; 0x1040
21f04e60:	e2811007 	add	r1, r1, #7	; 0x7
21f04e64:	e1a02003 	mov	r2, r3
21f04e68:	ebfffbaa 	bl	21f03d18 <AT91F_MCI_SendCommand>
    						AT91C_SEL_DESEL_CARD_CMD,
    						(pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address)<<16);

	// Set bus width for Sdcard
	if(pMCI_Device->pMCI_DeviceDesc->SDCard_bus_width == AT91C_MCI_SCDBUS)
21f04e6c:	e51b3018 	ldr	r3, [fp, #-24]
21f04e70:	e5933000 	ldr	r3, [r3]
21f04e74:	e5d33001 	ldrb	r3, [r3, #1]
21f04e78:	e3530080 	cmp	r3, #128	; 0x80
21f04e7c:	1a000002 	bne	21f04e8c <AT91F_MCI_SDCard_SetBusWidth+0xa0>
		 	bus_width = AT91C_BUS_WIDTH_4BITS;
21f04e80:	e3a03002 	mov	r3, #2	; 0x2
21f04e84:	e54b300d 	strb	r3, [fp, #-13]
21f04e88:	ea000001 	b	21f04e94 <AT91F_MCI_SDCard_SetBusWidth+0xa8>
	else	bus_width = AT91C_BUS_WIDTH_1BIT;
21f04e8c:	e3a03000 	mov	r3, #0	; 0x0
21f04e90:	e54b300d 	strb	r3, [fp, #-13]

	if (AT91F_MCI_SDCard_SendAppCommand(pMCI_Device,AT91C_SDCARD_SET_BUS_WIDTH_CMD,bus_width) != AT91C_CMD_SEND_OK)
21f04e94:	e55b300d 	ldrb	r3, [fp, #-13]
21f04e98:	e51b0018 	ldr	r0, [fp, #-24]
21f04e9c:	e3a01d41 	mov	r1, #4160	; 0x1040
21f04ea0:	e2811006 	add	r1, r1, #6	; 0x6
21f04ea4:	e1a02003 	mov	r2, r3
21f04ea8:	ebfffbe4 	bl	21f03e40 <AT91F_MCI_SDCard_SendAppCommand>
21f04eac:	e1a03000 	mov	r3, r0
21f04eb0:	e3530000 	cmp	r3, #0	; 0x0
21f04eb4:	0a000002 	beq	21f04ec4 <AT91F_MCI_SDCard_SetBusWidth+0xd8>
		return AT91C_CMD_SEND_ERROR;
21f04eb8:	e3e03000 	mvn	r3, #0	; 0x0
21f04ebc:	e50b301c 	str	r3, [fp, #-28]
21f04ec0:	ea000001 	b	21f04ecc <AT91F_MCI_SDCard_SetBusWidth+0xe0>

	return AT91C_CMD_SEND_OK;
21f04ec4:	e3a03000 	mov	r3, #0	; 0x0
21f04ec8:	e50b301c 	str	r3, [fp, #-28]
21f04ecc:	e51b301c 	ldr	r3, [fp, #-28]
}
21f04ed0:	e1a00003 	mov	r0, r3
21f04ed4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f04ed8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f04edc <AT91F_MCI_SDCard_Init>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_SDCard_Init
//* \brief Return the SDCard initialisation status
//*----------------------------------------------------------------------------
AT91S_MCIDeviceStatus AT91F_MCI_SDCard_Init (AT91PS_MciDevice pMCI_Device)
{
21f04edc:	e1a0c00d 	mov	ip, sp
21f04ee0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f04ee4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f04ee8:	e24dd020 	sub	sp, sp, #32	; 0x20
21f04eec:	e50b0028 	str	r0, [fp, #-40]
    unsigned int	tab_response[4];
	unsigned int	mult,blocknr;

	AT91F_MCI_SendCommand(pMCI_Device, AT91C_GO_IDLE_STATE_CMD, AT91C_NO_ARGUMENT);
21f04ef0:	e51b0028 	ldr	r0, [fp, #-40]
21f04ef4:	e3a01000 	mov	r1, #0	; 0x0
21f04ef8:	e3a02000 	mov	r2, #0	; 0x0
21f04efc:	ebfffb85 	bl	21f03d18 <AT91F_MCI_SendCommand>

    if(AT91F_MCI_SDCard_GetOCR(pMCI_Device) == AT91C_INIT_ERROR)
21f04f00:	e51b0028 	ldr	r0, [fp, #-40]
21f04f04:	ebffff64 	bl	21f04c9c <AT91F_MCI_SDCard_GetOCR>
21f04f08:	e1a03000 	mov	r3, r0
21f04f0c:	e3530003 	cmp	r3, #3	; 0x3
21f04f10:	1a000002 	bne	21f04f20 <AT91F_MCI_SDCard_Init+0x44>
    	return AT91C_INIT_ERROR;
21f04f14:	e3a03003 	mov	r3, #3	; 0x3
21f04f18:	e50b302c 	str	r3, [fp, #-44]
21f04f1c:	ea000090 	b	21f05164 <AT91F_MCI_SDCard_Init+0x288>

	if (AT91F_MCI_SDCard_GetCID(pMCI_Device,tab_response) == AT91C_CMD_SEND_OK)
21f04f20:	e24b3024 	sub	r3, fp, #36	; 0x24
21f04f24:	e51b0028 	ldr	r0, [fp, #-40]
21f04f28:	e1a01003 	mov	r1, r3
21f04f2c:	ebffff81 	bl	21f04d38 <AT91F_MCI_SDCard_GetCID>
21f04f30:	e1a03000 	mov	r3, r0
21f04f34:	e3530000 	cmp	r3, #0	; 0x0
21f04f38:	1a000087 	bne	21f0515c <AT91F_MCI_SDCard_Init+0x280>
	{
	    pMCI_Device->pMCI_DeviceFeatures->Card_Inserted = AT91C_SD_CARD_INSERTED;
21f04f3c:	e51b3028 	ldr	r3, [fp, #-40]
21f04f40:	e5932004 	ldr	r2, [r3, #4]
21f04f44:	e3a03002 	mov	r3, #2	; 0x2
21f04f48:	e5c23000 	strb	r3, [r2]

	    if (AT91F_MCI_SendCommand(pMCI_Device, AT91C_SET_RELATIVE_ADDR_CMD, 0) == AT91C_CMD_SEND_OK)
21f04f4c:	e51b0028 	ldr	r0, [fp, #-40]
21f04f50:	e3a01d41 	mov	r1, #4160	; 0x1040
21f04f54:	e2811003 	add	r1, r1, #3	; 0x3
21f04f58:	e3a02000 	mov	r2, #0	; 0x0
21f04f5c:	ebfffb6d 	bl	21f03d18 <AT91F_MCI_SendCommand>
21f04f60:	e1a03000 	mov	r3, r0
21f04f64:	e3530000 	cmp	r3, #0	; 0x0
21f04f68:	1a00007b 	bne	21f0515c <AT91F_MCI_SDCard_Init+0x280>
		{
			pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address = (AT91C_BASE_MCI->MCI_RSPR[0] >> 16);
21f04f6c:	e51b3028 	ldr	r3, [fp, #-40]
21f04f70:	e5932004 	ldr	r2, [r3, #4]
21f04f74:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f04f78:	e1a03643 	mov	r3, r3, asr #12
21f04f7c:	e5933020 	ldr	r3, [r3, #32]
21f04f80:	e1a03823 	mov	r3, r3, lsr #16
21f04f84:	e5823004 	str	r3, [r2, #4]
			if (AT91F_MCI_GetCSD(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Relative_Card_Address,tab_response) == AT91C_CMD_SEND_OK)
21f04f88:	e51b3028 	ldr	r3, [fp, #-40]
21f04f8c:	e5933004 	ldr	r3, [r3, #4]
21f04f90:	e5933004 	ldr	r3, [r3, #4]
21f04f94:	e24b2024 	sub	r2, fp, #36	; 0x24
21f04f98:	e51b0028 	ldr	r0, [fp, #-40]
21f04f9c:	e1a01003 	mov	r1, r3
21f04fa0:	ebfffdb8 	bl	21f04688 <AT91F_MCI_GetCSD>
21f04fa4:	e1a03000 	mov	r3, r0
21f04fa8:	e3530000 	cmp	r3, #0	; 0x0
21f04fac:	1a00006a 	bne	21f0515c <AT91F_MCI_SDCard_Init+0x280>
			{
		  		pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length = 1 << ((tab_response[1] >> AT91C_CSD_RD_B_LEN_S) & AT91C_CSD_RD_B_LEN_M );
21f04fb0:	e51b3028 	ldr	r3, [fp, #-40]
21f04fb4:	e5931004 	ldr	r1, [r3, #4]
21f04fb8:	e51b3020 	ldr	r3, [fp, #-32]
21f04fbc:	e1a03823 	mov	r3, r3, lsr #16
21f04fc0:	e203200f 	and	r2, r3, #15	; 0xf
21f04fc4:	e3a03001 	mov	r3, #1	; 0x1
21f04fc8:	e1a03213 	mov	r3, r3, lsl r2
21f04fcc:	e5813008 	str	r3, [r1, #8]
	 			pMCI_Device->pMCI_DeviceFeatures->Max_Write_DataBlock_Length =	1 << ((tab_response[3] >> AT91C_CSD_WBLEN_S) & AT91C_CSD_WBLEN_M );
21f04fd0:	e51b3028 	ldr	r3, [fp, #-40]
21f04fd4:	e5931004 	ldr	r1, [r3, #4]
21f04fd8:	e51b3018 	ldr	r3, [fp, #-24]
21f04fdc:	e1a03b23 	mov	r3, r3, lsr #22
21f04fe0:	e203200f 	and	r2, r3, #15	; 0xf
21f04fe4:	e3a03001 	mov	r3, #1	; 0x1
21f04fe8:	e1a03213 	mov	r3, r3, lsl r2
21f04fec:	e581300c 	str	r3, [r1, #12]
				pMCI_Device->pMCI_DeviceFeatures->Sector_Size = 1 + ((tab_response[2] >> AT91C_CSD_v21_SECT_SIZE_S) & AT91C_CSD_v21_SECT_SIZE_M );
21f04ff0:	e51b3028 	ldr	r3, [fp, #-40]
21f04ff4:	e5932004 	ldr	r2, [r3, #4]
21f04ff8:	e51b301c 	ldr	r3, [fp, #-28]
21f04ffc:	e1a033a3 	mov	r3, r3, lsr #7
21f05000:	e20330ff 	and	r3, r3, #255	; 0xff
21f05004:	e203307f 	and	r3, r3, #127	; 0x7f
21f05008:	e2833001 	add	r3, r3, #1	; 0x1
21f0500c:	e20330ff 	and	r3, r3, #255	; 0xff
21f05010:	e5c23015 	strb	r3, [r2, #21]
		  		pMCI_Device->pMCI_DeviceFeatures->Read_Partial = (tab_response[1] >> AT91C_CSD_RD_B_PAR_S) & AT91C_CSD_RD_B_PAR_M;
21f05014:	e51b3028 	ldr	r3, [fp, #-40]
21f05018:	e5932004 	ldr	r2, [r3, #4]
21f0501c:	e51b3020 	ldr	r3, [fp, #-32]
21f05020:	e1a037a3 	mov	r3, r3, lsr #15
21f05024:	e20330ff 	and	r3, r3, #255	; 0xff
21f05028:	e2033001 	and	r3, r3, #1	; 0x1
21f0502c:	e5c23010 	strb	r3, [r2, #16]
				pMCI_Device->pMCI_DeviceFeatures->Write_Partial = (tab_response[3] >> AT91C_CSD_WBLOCK_P_S) & AT91C_CSD_WBLOCK_P_M;
21f05030:	e51b3028 	ldr	r3, [fp, #-40]
21f05034:	e5932004 	ldr	r2, [r3, #4]
21f05038:	e51b3018 	ldr	r3, [fp, #-24]
21f0503c:	e1a03aa3 	mov	r3, r3, lsr #21
21f05040:	e20330ff 	and	r3, r3, #255	; 0xff
21f05044:	e2033001 	and	r3, r3, #1	; 0x1
21f05048:	e5c23011 	strb	r3, [r2, #17]
				pMCI_Device->pMCI_DeviceFeatures->Erase_Block_Enable = (tab_response[3] >> AT91C_CSD_v21_ER_BLEN_EN_S) & AT91C_CSD_v21_ER_BLEN_EN_M;
21f0504c:	e51b3028 	ldr	r3, [fp, #-40]
21f05050:	e5932004 	ldr	r2, [r3, #4]
21f05054:	e51b3018 	ldr	r3, [fp, #-24]
21f05058:	e1a03723 	mov	r3, r3, lsr #14
21f0505c:	e20330ff 	and	r3, r3, #255	; 0xff
21f05060:	e2033001 	and	r3, r3, #1	; 0x1
21f05064:	e5c23012 	strb	r3, [r2, #18]
				pMCI_Device->pMCI_DeviceFeatures->Read_Block_Misalignment = (tab_response[1] >> AT91C_CSD_RD_B_MIS_S) & AT91C_CSD_RD_B_MIS_M;
21f05068:	e51b3028 	ldr	r3, [fp, #-40]
21f0506c:	e5932004 	ldr	r2, [r3, #4]
21f05070:	e51b3020 	ldr	r3, [fp, #-32]
21f05074:	e1a036a3 	mov	r3, r3, lsr #13
21f05078:	e20330ff 	and	r3, r3, #255	; 0xff
21f0507c:	e2033001 	and	r3, r3, #1	; 0x1
21f05080:	e5c23013 	strb	r3, [r2, #19]
				pMCI_Device->pMCI_DeviceFeatures->Write_Block_Misalignment = (tab_response[1] >> AT91C_CSD_WR_B_MIS_S) & AT91C_CSD_WR_B_MIS_M;
21f05084:	e51b3028 	ldr	r3, [fp, #-40]
21f05088:	e5932004 	ldr	r2, [r3, #4]
21f0508c:	e51b3020 	ldr	r3, [fp, #-32]
21f05090:	e1a03723 	mov	r3, r3, lsr #14
21f05094:	e20330ff 	and	r3, r3, #255	; 0xff
21f05098:	e2033001 	and	r3, r3, #1	; 0x1
21f0509c:	e5c23014 	strb	r3, [r2, #20]

				//// Compute Memory Capacity
					// compute MULT
					mult = 1 << ( ((tab_response[2] >> AT91C_CSD_C_SIZE_M_S) & AT91C_CSD_C_SIZE_M_M) + 2 );
21f050a0:	e51b301c 	ldr	r3, [fp, #-28]
21f050a4:	e1a037a3 	mov	r3, r3, lsr #15
21f050a8:	e2033007 	and	r3, r3, #7	; 0x7
21f050ac:	e2833002 	add	r3, r3, #2	; 0x2
21f050b0:	e1a02003 	mov	r2, r3
21f050b4:	e3a03001 	mov	r3, #1	; 0x1
21f050b8:	e1a03213 	mov	r3, r3, lsl r2
21f050bc:	e50b3014 	str	r3, [fp, #-20]
					// compute MSB of C_SIZE
					blocknr = ((tab_response[1] >> AT91C_CSD_CSIZE_H_S) & AT91C_CSD_CSIZE_H_M) << 2;
21f050c0:	e51b3020 	ldr	r3, [fp, #-32]
21f050c4:	e1a03b03 	mov	r3, r3, lsl #22
21f050c8:	e1a03b23 	mov	r3, r3, lsr #22
21f050cc:	e1a03103 	mov	r3, r3, lsl #2
21f050d0:	e50b3010 	str	r3, [fp, #-16]
					// compute MULT * (LSB of C-SIZE + MSB already computed + 1) = BLOCKNR
					blocknr = mult * ( ( blocknr + ( (tab_response[2] >> AT91C_CSD_CSIZE_L_S) & AT91C_CSD_CSIZE_L_M) ) + 1 );
21f050d4:	e51b301c 	ldr	r3, [fp, #-28]
21f050d8:	e1a03f23 	mov	r3, r3, lsr #30
21f050dc:	e2032003 	and	r2, r3, #3	; 0x3
21f050e0:	e51b3010 	ldr	r3, [fp, #-16]
21f050e4:	e0823003 	add	r3, r2, r3
21f050e8:	e2832001 	add	r2, r3, #1	; 0x1
21f050ec:	e51b3014 	ldr	r3, [fp, #-20]
21f050f0:	e0030392 	mul	r3, r2, r3
21f050f4:	e50b3010 	str	r3, [fp, #-16]

					pMCI_Device->pMCI_DeviceFeatures->Memory_Capacity =  pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length * blocknr;
21f050f8:	e51b3028 	ldr	r3, [fp, #-40]
21f050fc:	e5931004 	ldr	r1, [r3, #4]
21f05100:	e51b3028 	ldr	r3, [fp, #-40]
21f05104:	e5933004 	ldr	r3, [r3, #4]
21f05108:	e5932008 	ldr	r2, [r3, #8]
21f0510c:	e51b3010 	ldr	r3, [fp, #-16]
21f05110:	e0030392 	mul	r3, r2, r3
21f05114:	e5813018 	str	r3, [r1, #24]
			  	//// End of Compute Memory Capacity

		  		if( AT91F_MCI_SDCard_SetBusWidth(pMCI_Device) == AT91C_CMD_SEND_OK )
21f05118:	e51b0028 	ldr	r0, [fp, #-40]
21f0511c:	ebffff32 	bl	21f04dec <AT91F_MCI_SDCard_SetBusWidth>
21f05120:	e1a03000 	mov	r3, r0
21f05124:	e3530000 	cmp	r3, #0	; 0x0
21f05128:	1a00000b 	bne	21f0515c <AT91F_MCI_SDCard_Init+0x280>
				{	
					 if (AT91F_MCI_SetBlocklength(pMCI_Device,pMCI_Device->pMCI_DeviceFeatures->Max_Read_DataBlock_Length) == AT91C_CMD_SEND_OK)
21f0512c:	e51b3028 	ldr	r3, [fp, #-40]
21f05130:	e5933004 	ldr	r3, [r3, #4]
21f05134:	e5933008 	ldr	r3, [r3, #8]
21f05138:	e51b0028 	ldr	r0, [fp, #-40]
21f0513c:	e1a01003 	mov	r1, r3
21f05140:	ebfffd81 	bl	21f0474c <AT91F_MCI_SetBlocklength>
21f05144:	e1a03000 	mov	r3, r0
21f05148:	e3530000 	cmp	r3, #0	; 0x0
21f0514c:	1a000002 	bne	21f0515c <AT91F_MCI_SDCard_Init+0x280>
					return AT91C_INIT_OK;
21f05150:	e3a03002 	mov	r3, #2	; 0x2
21f05154:	e50b302c 	str	r3, [fp, #-44]
21f05158:	ea000001 	b	21f05164 <AT91F_MCI_SDCard_Init+0x288>
				}
			}
		}
	}
    return AT91C_INIT_ERROR;
21f0515c:	e3a03003 	mov	r3, #3	; 0x3
21f05160:	e50b302c 	str	r3, [fp, #-44]
21f05164:	e51b302c 	ldr	r3, [fp, #-44]
}
21f05168:	e1a00003 	mov	r0, r3
21f0516c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05170:	e89da800 	ldmia	sp, {fp, sp, pc}

21f05174 <mmc_get_dev>:
/* Local variables */
static block_dev_desc_t mmc_dev;
										
block_dev_desc_t * mmc_get_dev(int dev)
{
21f05174:	e1a0c00d 	mov	ip, sp
21f05178:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0517c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05180:	e24dd004 	sub	sp, sp, #4	; 0x4
21f05184:	e50b0010 	str	r0, [fp, #-16]
	return ((block_dev_desc_t *)&mmc_dev);
21f05188:	e59f3004 	ldr	r3, [pc, #4]	; 21f05194 <.text+0x5194>
}
21f0518c:	e1a00003 	mov	r0, r3
21f05190:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f05194:	21f34234 	mvncss	r4, r4, lsr r2

21f05198 <mmc_block_read>:

#define AT91C_MCI_TIMEOUT			1000000   /* For AT91F_MCIDeviceWaitReady */
#define FALSE						-1
#define TRUE						1

/* External Functions  in mci_device.c*/
extern void AT91F_ASM_MCI_Handler(void);
extern void AT91F_MCI_Device_Handler(AT91PS_MciDevice,unsigned int);

extern AT91S_MCIDeviceStatus 	AT91F_MCI_SDCard_Init (AT91PS_MciDevice);
extern AT91S_MCIDeviceStatus	AT91F_MCI_MMC_Init(AT91PS_MciDevice);
extern AT91S_MCIDeviceStatus 	AT91F_MCI_SetBlocklength(AT91PS_MciDevice,unsigned int);
extern AT91S_MCIDeviceStatus 	AT91F_MCI_MMC_SelectCard(AT91PS_MciDevice,unsigned int);
extern AT91S_MCIDeviceStatus 	AT91F_MCI_ReadBlock(AT91PS_MciDevice,int,unsigned int *,int);
extern AT91S_MCIDeviceStatus 	AT91F_MCI_WriteBlock(AT91PS_MciDevice,int,unsigned int *,int);

/* Local Functions */
void AT91F_MCIDeviceWaitReady	(unsigned int timeout);
void AT91F_MCI_CorrectByteOrder(uchar *pBuffer, int len);

//* Global Variables
AT91S_MciDeviceFeatures			MCI_Device_Features;
AT91S_MciDeviceDesc				MCI_Device_Desc;
AT91S_MciDevice					MCI_Device;
//Targetbuffer for DMA transfers
static uchar					mmc_buf[CFG_MMC_BLOCKSIZE];

static int at91sdcard_init(void);
static ulong mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst);

int
/****************************************************/
mmc_block_read(uchar *dst, ulong src, ulong len)
/****************************************************/
{
21f05198:	e1a0c00d 	mov	ip, sp
21f0519c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f051a0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f051a4:	e24dd014 	sub	sp, sp, #20	; 0x14
21f051a8:	e50b0014 	str	r0, [fp, #-20]
21f051ac:	e50b1018 	str	r1, [fp, #-24]
21f051b0:	e50b201c 	str	r2, [fp, #-28]
	
	AT91S_MCIDeviceStatus status;
	if (len > CFG_MMC_BLOCKSIZE) {
21f051b4:	e51b301c 	ldr	r3, [fp, #-28]
21f051b8:	e3530c02 	cmp	r3, #512	; 0x200
21f051bc:	9a000005 	bls	21f051d8 <mmc_block_read+0x40>
		printf ("mmc_block_read: Error len (%x) > Blocksize \n",len);
21f051c0:	e59f00ac 	ldr	r0, [pc, #172]	; 21f05274 <.text+0x5274>
21f051c4:	e51b101c 	ldr	r1, [fp, #-28]
21f051c8:	eb005a2f 	bl	21f1ba8c <printf>
		return -1;
21f051cc:	e3e03000 	mvn	r3, #0	; 0x0
21f051d0:	e50b3020 	str	r3, [fp, #-32]
21f051d4:	ea000022 	b	21f05264 <mmc_block_read+0xcc>
	}
	
	status = AT91F_MCI_ReadBlock(&MCI_Device, src, mmc_buf,len);
21f051d8:	e51b3018 	ldr	r3, [fp, #-24]
21f051dc:	e59f2094 	ldr	r2, [pc, #148]	; 21f05278 <.text+0x5278>
21f051e0:	e51bc01c 	ldr	ip, [fp, #-28]
21f051e4:	e59f0090 	ldr	r0, [pc, #144]	; 21f0527c <.text+0x527c>
21f051e8:	e1a01003 	mov	r1, r3
21f051ec:	e1a0300c 	mov	r3, ip
21f051f0:	ebfffb9a 	bl	21f04060 <AT91F_MCI_ReadBlock>
21f051f4:	e1a03000 	mov	r3, r0
21f051f8:	e50b3010 	str	r3, [fp, #-16]
	if (status != AT91C_READ_OK) {
21f051fc:	e51b3010 	ldr	r3, [fp, #-16]
21f05200:	e3530004 	cmp	r3, #4	; 0x4
21f05204:	0a000005 	beq	21f05220 <mmc_block_read+0x88>
		printf ("mmc_block_read: Error read %d to dst\n", status);
21f05208:	e59f0070 	ldr	r0, [pc, #112]	; 21f05280 <.text+0x5280>
21f0520c:	e51b1010 	ldr	r1, [fp, #-16]
21f05210:	eb005a1d 	bl	21f1ba8c <printf>
		return -1;
21f05214:	e3e03000 	mvn	r3, #0	; 0x0
21f05218:	e50b3020 	str	r3, [fp, #-32]
21f0521c:	ea000010 	b	21f05264 <mmc_block_read+0xcc>
	}
	//* Wait end of Read
	AT91F_MCIDeviceWaitReady(AT91C_MCI_TIMEOUT);
21f05220:	e3a0093d 	mov	r0, #999424	; 0xf4000
21f05224:	e2800d09 	add	r0, r0, #576	; 0x240
21f05228:	eb000182 	bl	21f05838 <AT91F_MCIDeviceWaitReady>

	if (dst != mmc_buf) {
21f0522c:	e51b2014 	ldr	r2, [fp, #-20]
21f05230:	e59f3040 	ldr	r3, [pc, #64]	; 21f05278 <.text+0x5278>
21f05234:	e1520003 	cmp	r2, r3
21f05238:	0a000003 	beq	21f0524c <mmc_block_read+0xb4>
		memcpy(dst,mmc_buf,len);
21f0523c:	e51b0014 	ldr	r0, [fp, #-20]
21f05240:	e59f1030 	ldr	r1, [pc, #48]	; 21f05278 <.text+0x5278>
21f05244:	e51b201c 	ldr	r2, [fp, #-28]
21f05248:	eb0077df 	bl	21f231cc <memcpy>
	}
	
	AT91F_MCI_CorrectByteOrder(dst,len);
21f0524c:	e51b301c 	ldr	r3, [fp, #-28]
21f05250:	e51b0014 	ldr	r0, [fp, #-20]
21f05254:	e1a01003 	mov	r1, r3
21f05258:	eb000108 	bl	21f05680 <AT91F_MCI_CorrectByteOrder>
	
	return 0;
21f0525c:	e3a03000 	mov	r3, #0	; 0x0
21f05260:	e50b3020 	str	r3, [fp, #-32]
21f05264:	e51b3020 	ldr	r3, [fp, #-32]
}
21f05268:	e1a00003 	mov	r0, r3
21f0526c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05270:	e89da800 	ldmia	sp, {fp, sp, pc}
21f05274:	21f2f0d8 	ldrcssb	pc, [r2, #8]!
21f05278:	21f34298 	ldrcsb	r4, [r3, #40]!
21f0527c:	21f3422c 	mvncss	r4, ip, lsr #4
21f05280:	21f2f108 	mvncss	pc, r8, lsl #2

21f05284 <mmc_read>:

int
/****************************************************/
mmc_read(ulong src, uchar *dst, int size)
/****************************************************/
{
21f05284:	e1a0c00d 	mov	ip, sp
21f05288:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0528c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05290:	e24dd030 	sub	sp, sp, #48	; 0x30
21f05294:	e50b0030 	str	r0, [fp, #-48]
21f05298:	e50b1034 	str	r1, [fp, #-52]
21f0529c:	e50b2038 	str	r2, [fp, #-56]
	ulong end, part_start, part_end, part_len, aligned_start, aligned_end;
	ulong mmc_block_size, mmc_block_address;

	if (size == 0) {
21f052a0:	e51b3038 	ldr	r3, [fp, #-56]
21f052a4:	e3530000 	cmp	r3, #0	; 0x0
21f052a8:	1a000002 	bne	21f052b8 <mmc_read+0x34>
		return 0;
21f052ac:	e3a03000 	mov	r3, #0	; 0x0
21f052b0:	e50b303c 	str	r3, [fp, #-60]
21f052b4:	ea000075 	b	21f05490 <mmc_read+0x20c>
	}

	if (!MCI_Device.pMCI_DeviceFeatures->Max_Read_DataBlock_Length) {
21f052b8:	e59f31e0 	ldr	r3, [pc, #480]	; 21f054a0 <.text+0x54a0>
21f052bc:	e5933004 	ldr	r3, [r3, #4]
21f052c0:	e5933008 	ldr	r3, [r3, #8]
21f052c4:	e3530000 	cmp	r3, #0	; 0x0
21f052c8:	1a000004 	bne	21f052e0 <mmc_read+0x5c>
		printf("Please initial the MMC first\n");
21f052cc:	e59f01d0 	ldr	r0, [pc, #464]	; 21f054a4 <.text+0x54a4>
21f052d0:	eb0059ed 	bl	21f1ba8c <printf>
		return -1;
21f052d4:	e3e03000 	mvn	r3, #0	; 0x0
21f052d8:	e50b303c 	str	r3, [fp, #-60]
21f052dc:	ea00006b 	b	21f05490 <mmc_read+0x20c>
	}

	mmc_block_size = CFG_MMC_BLOCKSIZE;
21f052e0:	e3a03c02 	mov	r3, #512	; 0x200
21f052e4:	e50b3014 	str	r3, [fp, #-20]
	mmc_block_address = ~(mmc_block_size - 1);
21f052e8:	e51b3014 	ldr	r3, [fp, #-20]
21f052ec:	e2633000 	rsb	r3, r3, #0	; 0x0
21f052f0:	e50b3010 	str	r3, [fp, #-16]

	src -= CFG_MMC_BASE;
21f052f4:	e51b3030 	ldr	r3, [fp, #-48]
21f052f8:	e2833913 	add	r3, r3, #311296	; 0x4c000
21f052fc:	e50b3030 	str	r3, [fp, #-48]
	end = src + size;
21f05300:	e51b2038 	ldr	r2, [fp, #-56]
21f05304:	e51b3030 	ldr	r3, [fp, #-48]
21f05308:	e0833002 	add	r3, r3, r2
21f0530c:	e50b302c 	str	r3, [fp, #-44]
	part_start = ~mmc_block_address & src;
21f05310:	e51b3010 	ldr	r3, [fp, #-16]
21f05314:	e1e02003 	mvn	r2, r3
21f05318:	e51b3030 	ldr	r3, [fp, #-48]
21f0531c:	e0023003 	and	r3, r2, r3
21f05320:	e50b3028 	str	r3, [fp, #-40]
	part_end = ~mmc_block_address & end;
21f05324:	e51b3010 	ldr	r3, [fp, #-16]
21f05328:	e1e02003 	mvn	r2, r3
21f0532c:	e51b302c 	ldr	r3, [fp, #-44]
21f05330:	e0023003 	and	r3, r2, r3
21f05334:	e50b3024 	str	r3, [fp, #-36]
	aligned_start = mmc_block_address & src;
21f05338:	e51b2010 	ldr	r2, [fp, #-16]
21f0533c:	e51b3030 	ldr	r3, [fp, #-48]
21f05340:	e0023003 	and	r3, r2, r3
21f05344:	e50b301c 	str	r3, [fp, #-28]
	aligned_end = mmc_block_address & end;
21f05348:	e51b2010 	ldr	r2, [fp, #-16]
21f0534c:	e51b302c 	ldr	r3, [fp, #-44]
21f05350:	e0023003 	and	r3, r2, r3
21f05354:	e50b3018 	str	r3, [fp, #-24]

	/* all block aligned accesses */
	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
	if (part_start) {
21f05358:	e51b3028 	ldr	r3, [fp, #-40]
21f0535c:	e3530000 	cmp	r3, #0	; 0x0
21f05360:	0a00002f 	beq	21f05424 <mmc_read+0x1a0>
		part_len = mmc_block_size - part_start;
21f05364:	e51b2014 	ldr	r2, [fp, #-20]
21f05368:	e51b3028 	ldr	r3, [fp, #-40]
21f0536c:	e0633002 	rsb	r3, r3, r2
21f05370:	e50b3020 	str	r3, [fp, #-32]
		debug("ps src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
		if ((mmc_block_read(mmc_buf, aligned_start, mmc_block_size)) < 0) {
21f05374:	e59f012c 	ldr	r0, [pc, #300]	; 21f054a8 <.text+0x54a8>
21f05378:	e51b101c 	ldr	r1, [fp, #-28]
21f0537c:	e51b2014 	ldr	r2, [fp, #-20]
21f05380:	ebffff84 	bl	21f05198 <mmc_block_read>
21f05384:	e1a03000 	mov	r3, r0
21f05388:	e3530000 	cmp	r3, #0	; 0x0
21f0538c:	aa000002 	bge	21f0539c <mmc_read+0x118>
			return -1;
21f05390:	e3e03000 	mvn	r3, #0	; 0x0
21f05394:	e50b303c 	str	r3, [fp, #-60]
21f05398:	ea00003c 	b	21f05490 <mmc_read+0x20c>
		}
		memcpy(dst, mmc_buf+part_start, part_len);
21f0539c:	e51b2028 	ldr	r2, [fp, #-40]
21f053a0:	e59f3100 	ldr	r3, [pc, #256]	; 21f054a8 <.text+0x54a8>
21f053a4:	e0823003 	add	r3, r2, r3
21f053a8:	e51b0034 	ldr	r0, [fp, #-52]
21f053ac:	e1a01003 	mov	r1, r3
21f053b0:	e51b2020 	ldr	r2, [fp, #-32]
21f053b4:	eb007784 	bl	21f231cc <memcpy>
		dst += part_len;
21f053b8:	e51b2020 	ldr	r2, [fp, #-32]
21f053bc:	e51b3034 	ldr	r3, [fp, #-52]
21f053c0:	e0833002 	add	r3, r3, r2
21f053c4:	e50b3034 	str	r3, [fp, #-52]
		src += part_len;
21f053c8:	e51b2030 	ldr	r2, [fp, #-48]
21f053cc:	e51b3020 	ldr	r3, [fp, #-32]
21f053d0:	e0823003 	add	r3, r2, r3
21f053d4:	e50b3030 	str	r3, [fp, #-48]
21f053d8:	ea000011 	b	21f05424 <mmc_read+0x1a0>
	}
	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
	for (; src < aligned_end; src += mmc_block_size, dst += mmc_block_size) {
		debug("al src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
		if ((mmc_block_read((uchar *)(dst), src, mmc_block_size)) < 0) {
21f053dc:	e51b0034 	ldr	r0, [fp, #-52]
21f053e0:	e51b1030 	ldr	r1, [fp, #-48]
21f053e4:	e51b2014 	ldr	r2, [fp, #-20]
21f053e8:	ebffff6a 	bl	21f05198 <mmc_block_read>
21f053ec:	e1a03000 	mov	r3, r0
21f053f0:	e3530000 	cmp	r3, #0	; 0x0
21f053f4:	aa000002 	bge	21f05404 <mmc_read+0x180>
			return -1;
21f053f8:	e3e03000 	mvn	r3, #0	; 0x0
21f053fc:	e50b303c 	str	r3, [fp, #-60]
21f05400:	ea000022 	b	21f05490 <mmc_read+0x20c>
21f05404:	e51b2030 	ldr	r2, [fp, #-48]
21f05408:	e51b3014 	ldr	r3, [fp, #-20]
21f0540c:	e0823003 	add	r3, r2, r3
21f05410:	e50b3030 	str	r3, [fp, #-48]
21f05414:	e51b2014 	ldr	r2, [fp, #-20]
21f05418:	e51b3034 	ldr	r3, [fp, #-52]
21f0541c:	e0833002 	add	r3, r3, r2
21f05420:	e50b3034 	str	r3, [fp, #-52]
21f05424:	e51b2030 	ldr	r2, [fp, #-48]
21f05428:	e51b3018 	ldr	r3, [fp, #-24]
21f0542c:	e1520003 	cmp	r2, r3
21f05430:	3affffe9 	bcc	21f053dc <mmc_read+0x158>
		}
	}
	debug("src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
	src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
	if (part_end && src < end) {
21f05434:	e51b3024 	ldr	r3, [fp, #-36]
21f05438:	e3530000 	cmp	r3, #0	; 0x0
21f0543c:	0a000011 	beq	21f05488 <mmc_read+0x204>
21f05440:	e51b2030 	ldr	r2, [fp, #-48]
21f05444:	e51b302c 	ldr	r3, [fp, #-44]
21f05448:	e1520003 	cmp	r2, r3
21f0544c:	2a00000d 	bcs	21f05488 <mmc_read+0x204>
		debug("pe src %lx dst %lx end %lx pstart %lx pend %lx astart %lx aend %lx\n",
		src, (ulong)dst, end, part_start, part_end, aligned_start, aligned_end);
		if ((mmc_block_read(mmc_buf, aligned_end, mmc_block_size)) < 0) {
21f05450:	e59f0050 	ldr	r0, [pc, #80]	; 21f054a8 <.text+0x54a8>
21f05454:	e51b1018 	ldr	r1, [fp, #-24]
21f05458:	e51b2014 	ldr	r2, [fp, #-20]
21f0545c:	ebffff4d 	bl	21f05198 <mmc_block_read>
21f05460:	e1a03000 	mov	r3, r0
21f05464:	e3530000 	cmp	r3, #0	; 0x0
21f05468:	aa000002 	bge	21f05478 <mmc_read+0x1f4>
			return -1;
21f0546c:	e3e03000 	mvn	r3, #0	; 0x0
21f05470:	e50b303c 	str	r3, [fp, #-60]
21f05474:	ea000005 	b	21f05490 <mmc_read+0x20c>
		}
		memcpy(dst, mmc_buf, part_end);
21f05478:	e51b0034 	ldr	r0, [fp, #-52]
21f0547c:	e59f1024 	ldr	r1, [pc, #36]	; 21f054a8 <.text+0x54a8>
21f05480:	e51b2024 	ldr	r2, [fp, #-36]
21f05484:	eb007750 	bl	21f231cc <memcpy>
	}
	return 0;
21f05488:	e3a03000 	mov	r3, #0	; 0x0
21f0548c:	e50b303c 	str	r3, [fp, #-60]
21f05490:	e51b303c 	ldr	r3, [fp, #-60]
}
21f05494:	e1a00003 	mov	r0, r3
21f05498:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0549c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f054a0:	21f3422c 	mvncss	r4, ip, lsr #4
21f054a4:	21f2f130 	mvncss	pc, r0, lsr r1
21f054a8:	21f34298 	ldrcsb	r4, [r3, #40]!

21f054ac <mmc_init>:
/****************************************************/
int mmc_init(int verbose)
/****************************************************/
{
21f054ac:	e1a0c00d 	mov	ip, sp
21f054b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f054b4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f054b8:	e24dd014 	sub	sp, sp, #20	; 0x14
21f054bc:	e50b0010 	str	r0, [fp, #-16]
	at91sdcard_init();
21f054c0:	eb00014b 	bl	21f059f4 <at91sdcard_init>
	printf ("Card found with %u MB size\r\n",MCI_Device.pMCI_DeviceFeatures[0].Memory_Capacity>>20);
21f054c4:	e59f3114 	ldr	r3, [pc, #276]	; 21f055e0 <.text+0x55e0>
21f054c8:	e5933004 	ldr	r3, [r3, #4]
21f054cc:	e5933018 	ldr	r3, [r3, #24]
21f054d0:	e1a03a23 	mov	r3, r3, lsr #20
21f054d4:	e59f0108 	ldr	r0, [pc, #264]	; 21f055e4 <.text+0x55e4>
21f054d8:	e1a01003 	mov	r1, r3
21f054dc:	eb00596a 	bl	21f1ba8c <printf>
	/* fill in device description */
	mmc_dev.if_type = IF_TYPE_MMC;
21f054e0:	e59f2100 	ldr	r2, [pc, #256]	; 21f055e8 <.text+0x55e8>
21f054e4:	e3a03006 	mov	r3, #6	; 0x6
21f054e8:	e5823000 	str	r3, [r2]
	mmc_dev.part_type = PART_TYPE_DOS;
21f054ec:	e59f20f4 	ldr	r2, [pc, #244]	; 21f055e8 <.text+0x55e8>
21f054f0:	e3a03002 	mov	r3, #2	; 0x2
21f054f4:	e5c23008 	strb	r3, [r2, #8]
	mmc_dev.dev = 0;
21f054f8:	e59f20e8 	ldr	r2, [pc, #232]	; 21f055e8 <.text+0x55e8>
21f054fc:	e3a03000 	mov	r3, #0	; 0x0
21f05500:	e5823004 	str	r3, [r2, #4]
	mmc_dev.lun = 0;
21f05504:	e59f20dc 	ldr	r2, [pc, #220]	; 21f055e8 <.text+0x55e8>
21f05508:	e3a03000 	mov	r3, #0	; 0x0
21f0550c:	e5c2300a 	strb	r3, [r2, #10]
	mmc_dev.type = 0;
21f05510:	e59f20d0 	ldr	r2, [pc, #208]	; 21f055e8 <.text+0x55e8>
21f05514:	e3a03000 	mov	r3, #0	; 0x0
21f05518:	e5c2300b 	strb	r3, [r2, #11]
	mmc_dev.blksz = MCI_Device.pMCI_DeviceFeatures[0].Max_Read_DataBlock_Length;
21f0551c:	e59f30bc 	ldr	r3, [pc, #188]	; 21f055e0 <.text+0x55e0>
21f05520:	e5933004 	ldr	r3, [r3, #4]
21f05524:	e5932008 	ldr	r2, [r3, #8]
21f05528:	e59f30b8 	ldr	r3, [pc, #184]	; 21f055e8 <.text+0x55e8>
21f0552c:	e5832014 	str	r2, [r3, #20]
	mmc_dev.lba = MCI_Device.pMCI_DeviceFeatures[0].Memory_Capacity >> 9;
21f05530:	e59f30a8 	ldr	r3, [pc, #168]	; 21f055e0 <.text+0x55e0>
21f05534:	e5933004 	ldr	r3, [r3, #4]
21f05538:	e5933018 	ldr	r3, [r3, #24]
21f0553c:	e1a024a3 	mov	r2, r3, lsr #9
21f05540:	e59f30a0 	ldr	r3, [pc, #160]	; 21f055e8 <.text+0x55e8>
21f05544:	e5832010 	str	r2, [r3, #16]
	sprintf(mmc_dev.vendor,"Man %02x%02x%02x Snr %02x%02x%02x", 0, 0,0,0,0,0);
21f05548:	e59f209c 	ldr	r2, [pc, #156]	; 21f055ec <.text+0x55ec>
21f0554c:	e3a03000 	mov	r3, #0	; 0x0
21f05550:	e58d3000 	str	r3, [sp]
21f05554:	e3a03000 	mov	r3, #0	; 0x0
21f05558:	e58d3004 	str	r3, [sp, #4]
21f0555c:	e3a03000 	mov	r3, #0	; 0x0
21f05560:	e58d3008 	str	r3, [sp, #8]
21f05564:	e3a03000 	mov	r3, #0	; 0x0
21f05568:	e58d300c 	str	r3, [sp, #12]
21f0556c:	e1a00002 	mov	r0, r2
21f05570:	e59f1078 	ldr	r1, [pc, #120]	; 21f055f0 <.text+0x55f0>
21f05574:	e3a02000 	mov	r2, #0	; 0x0
21f05578:	e3a03000 	mov	r3, #0	; 0x0
21f0557c:	eb007c51 	bl	21f246c8 <sprintf>
	sprintf(mmc_dev.product,"%s","unknown");
21f05580:	e59f306c 	ldr	r3, [pc, #108]	; 21f055f4 <.text+0x55f4>
21f05584:	e1a00003 	mov	r0, r3
21f05588:	e59f1068 	ldr	r1, [pc, #104]	; 21f055f8 <.text+0x55f8>
21f0558c:	e59f2068 	ldr	r2, [pc, #104]	; 21f055fc <.text+0x55fc>
21f05590:	eb007c4c 	bl	21f246c8 <sprintf>
	sprintf(mmc_dev.revision,"%x %x",0, 0);
21f05594:	e59f3064 	ldr	r3, [pc, #100]	; 21f05600 <.text+0x5600>
21f05598:	e1a00003 	mov	r0, r3
21f0559c:	e59f1060 	ldr	r1, [pc, #96]	; 21f05604 <.text+0x5604>
21f055a0:	e3a02000 	mov	r2, #0	; 0x0
21f055a4:	e3a03000 	mov	r3, #0	; 0x0
21f055a8:	eb007c46 	bl	21f246c8 <sprintf>
	mmc_dev.removable = 0;
21f055ac:	e59f2034 	ldr	r2, [pc, #52]	; 21f055e8 <.text+0x55e8>
21f055b0:	e3a03000 	mov	r3, #0	; 0x0
21f055b4:	e5c2300c 	strb	r3, [r2, #12]
	mmc_dev.block_read = mmc_bread;
21f055b8:	e59f2028 	ldr	r2, [pc, #40]	; 21f055e8 <.text+0x55e8>
21f055bc:	e59f3044 	ldr	r3, [pc, #68]	; 21f05608 <.text+0x5608>
21f055c0:	e5823060 	str	r3, [r2, #96]

	fat_register_device(&mmc_dev,1);
21f055c4:	e59f001c 	ldr	r0, [pc, #28]	; 21f055e8 <.text+0x55e8>
21f055c8:	e3a01001 	mov	r1, #1	; 0x1
21f055cc:	eb000347 	bl	21f062f0 <fat_register_device>
	return 0;
21f055d0:	e3a03000 	mov	r3, #0	; 0x0
}
21f055d4:	e1a00003 	mov	r0, r3
21f055d8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f055dc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f055e0:	21f3422c 	mvncss	r4, ip, lsr #4
21f055e4:	21f2f150 	mvncss	pc, r0, asr r1
21f055e8:	21f34234 	mvncss	r4, r4, lsr r2
21f055ec:	21f3424c 	mvncss	r4, ip, asr #4
21f055f0:	21f2f170 	mvncss	pc, r0, ror r1
21f055f4:	21f34275 	mvncss	r4, r5, ror r2
21f055f8:	21f2f194 	ldrcsb	pc, [r2, #20]!
21f055fc:	21f2f198 	ldrcsb	pc, [r2, #24]!
21f05600:	21f3428a 	mvncss	r4, sl, lsl #5
21f05604:	21f2f1a0 	mvncss	pc, r0, lsr #3
21f05608:	21f0570c 	mvncss	r5, ip, lsl #14

21f0560c <mmc_write>:

/****************************************************/
int mmc_write(uchar *src, ulong dst, int size)
/****************************************************/
{
21f0560c:	e1a0c00d 	mov	ip, sp
21f05610:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05614:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05618:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0561c:	e50b0010 	str	r0, [fp, #-16]
21f05620:	e50b1014 	str	r1, [fp, #-20]
21f05624:	e50b2018 	str	r2, [fp, #-24]
	return 0;
21f05628:	e3a03000 	mov	r3, #0	; 0x0
}
21f0562c:	e1a00003 	mov	r0, r3
21f05630:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05634:	e89da800 	ldmia	sp, {fp, sp, pc}

21f05638 <doswap>:

/****************************************************/
/* This function is used to correct ATMEL errata: big endian read/write on MCI*/
inline void doswap(unsigned char *x, unsigned char *y)
{
21f05638:	e1a0c00d 	mov	ip, sp
21f0563c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05640:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05644:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f05648:	e50b0014 	str	r0, [fp, #-20]
21f0564c:	e50b1018 	str	r1, [fp, #-24]
   /* Exchanging values with xor
	* Here's some weird code I ran across once. 
	* It uses xor to exchange two values (x and y). 
	* Never use it; ;-) this is just a curiosity from the museum of bizarre code.
	*/
		/**x = *x ^ *y;
		*y = *x ^ *y;
		*x = *x ^ *y;*/
	unsigned char t=*y;
21f05650:	e51b3018 	ldr	r3, [fp, #-24]
21f05654:	e5d33000 	ldrb	r3, [r3]
21f05658:	e54b300d 	strb	r3, [fp, #-13]
	*y=*x;
21f0565c:	e51b3014 	ldr	r3, [fp, #-20]
21f05660:	e5d33000 	ldrb	r3, [r3]
21f05664:	e51b2018 	ldr	r2, [fp, #-24]
21f05668:	e5c23000 	strb	r3, [r2]
	*x=t;
21f0566c:	e51b2014 	ldr	r2, [fp, #-20]
21f05670:	e55b300d 	ldrb	r3, [fp, #-13]
21f05674:	e5c23000 	strb	r3, [r2]
}
21f05678:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0567c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f05680 <AT91F_MCI_CorrectByteOrder>:
void AT91F_MCI_CorrectByteOrder(uchar *pBuffer, int len)
{
21f05680:	e1a0c00d 	mov	ip, sp
21f05684:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05688:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0568c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f05690:	e50b0018 	str	r0, [fp, #-24]
21f05694:	e50b101c 	str	r1, [fp, #-28]
	unsigned char *pEnd = pBuffer + len;
21f05698:	e51b301c 	ldr	r3, [fp, #-28]
21f0569c:	e1a02003 	mov	r2, r3
21f056a0:	e51b3018 	ldr	r3, [fp, #-24]
21f056a4:	e0833002 	add	r3, r3, r2
21f056a8:	e50b3014 	str	r3, [fp, #-20]
	unsigned char *p;

	for(p=pBuffer;p<pEnd;p+=4) {
21f056ac:	e51b3018 	ldr	r3, [fp, #-24]
21f056b0:	e50b3010 	str	r3, [fp, #-16]
21f056b4:	ea00000e 	b	21f056f4 <AT91F_MCI_CorrectByteOrder+0x74>
		doswap(p+0,p+3);
21f056b8:	e51b3010 	ldr	r3, [fp, #-16]
21f056bc:	e2833003 	add	r3, r3, #3	; 0x3
21f056c0:	e51b0010 	ldr	r0, [fp, #-16]
21f056c4:	e1a01003 	mov	r1, r3
21f056c8:	ebffffda 	bl	21f05638 <doswap>
		doswap(p+1,p+2);
21f056cc:	e51b3010 	ldr	r3, [fp, #-16]
21f056d0:	e2832001 	add	r2, r3, #1	; 0x1
21f056d4:	e51b3010 	ldr	r3, [fp, #-16]
21f056d8:	e2833002 	add	r3, r3, #2	; 0x2
21f056dc:	e1a00002 	mov	r0, r2
21f056e0:	e1a01003 	mov	r1, r3
21f056e4:	ebffffd3 	bl	21f05638 <doswap>
21f056e8:	e51b3010 	ldr	r3, [fp, #-16]
21f056ec:	e2833004 	add	r3, r3, #4	; 0x4
21f056f0:	e50b3010 	str	r3, [fp, #-16]
21f056f4:	e51b2010 	ldr	r2, [fp, #-16]
21f056f8:	e51b3014 	ldr	r3, [fp, #-20]
21f056fc:	e1520003 	cmp	r2, r3
21f05700:	3affffec 	bcc	21f056b8 <AT91F_MCI_CorrectByteOrder+0x38>
	}
}
21f05704:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05708:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0570c <mmc_bread>:
ulong
/****************************************************/
mmc_bread(int dev_num, ulong blknr, ulong blkcnt, ulong *dst)
/****************************************************/
{
21f0570c:	e1a0c00d 	mov	ip, sp
21f05710:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05714:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05718:	e24dd018 	sub	sp, sp, #24	; 0x18
21f0571c:	e50b0018 	str	r0, [fp, #-24]
21f05720:	e50b101c 	str	r1, [fp, #-28]
21f05724:	e50b2020 	str	r2, [fp, #-32]
21f05728:	e50b3024 	str	r3, [fp, #-36]
	int mmc_block_size = CFG_MMC_BLOCKSIZE;
21f0572c:	e3a03c02 	mov	r3, #512	; 0x200
21f05730:	e50b3014 	str	r3, [fp, #-20]
	ulong src = blknr * mmc_block_size + CFG_MMC_BASE;
21f05734:	e51b2014 	ldr	r2, [fp, #-20]
21f05738:	e51b301c 	ldr	r3, [fp, #-28]
21f0573c:	e0030392 	mul	r3, r2, r3
21f05740:	e2433913 	sub	r3, r3, #311296	; 0x4c000
21f05744:	e50b3010 	str	r3, [fp, #-16]

	mmc_read(src, (uchar *)dst, blkcnt*mmc_block_size);
21f05748:	e51b1024 	ldr	r1, [fp, #-36]
21f0574c:	e51b2014 	ldr	r2, [fp, #-20]
21f05750:	e51b3020 	ldr	r3, [fp, #-32]
21f05754:	e0030392 	mul	r3, r2, r3
21f05758:	e51b0010 	ldr	r0, [fp, #-16]
21f0575c:	e1a02003 	mov	r2, r3
21f05760:	ebfffec7 	bl	21f05284 <mmc_read>
	return blkcnt;
21f05764:	e51b3020 	ldr	r3, [fp, #-32]
}
21f05768:	e1a00003 	mov	r0, r3
21f0576c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05770:	e89da800 	ldmia	sp, {fp, sp, pc}

21f05774 <mmc_ident>:


int mmc_ident(block_dev_desc_t *dev)
{
21f05774:	e1a0c00d 	mov	ip, sp
21f05778:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0577c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05780:	e24dd004 	sub	sp, sp, #4	; 0x4
21f05784:	e50b0010 	str	r0, [fp, #-16]
	return 0;
21f05788:	e3a03000 	mov	r3, #0	; 0x0
}
21f0578c:	e1a00003 	mov	r0, r3
21f05790:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f05794 <mmc2info>:

int mmc2info(ulong addr)
{
21f05794:	e1a0c00d 	mov	ip, sp
21f05798:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0579c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f057a0:	e24dd010 	sub	sp, sp, #16	; 0x10
21f057a4:	e50b0018 	str	r0, [fp, #-24]
	
	ulong capacity = MCI_Device.pMCI_DeviceFeatures[0].Memory_Capacity;
21f057a8:	e59f3078 	ldr	r3, [pc, #120]	; 21f05828 <.text+0x5828>
21f057ac:	e5933004 	ldr	r3, [r3, #4]
21f057b0:	e5933018 	ldr	r3, [r3, #24]
21f057b4:	e50b3014 	str	r3, [fp, #-20]
	long laddr;

	laddr = addr - (long)AT91C_BASE_MCI;
21f057b8:	e51b3018 	ldr	r3, [fp, #-24]
21f057bc:	e2833913 	add	r3, r3, #311296	; 0x4c000
21f057c0:	e50b3010 	str	r3, [fp, #-16]
	if (laddr < 0) {
21f057c4:	e51b3010 	ldr	r3, [fp, #-16]
21f057c8:	e3530000 	cmp	r3, #0	; 0x0
21f057cc:	aa000004 	bge	21f057e4 <mmc2info+0x50>
		printf (" addr lower than AT91C_BASE_MCI\n");
21f057d0:	e59f0054 	ldr	r0, [pc, #84]	; 21f0582c <.text+0x582c>
21f057d4:	eb0058ac 	bl	21f1ba8c <printf>
		return 0;
21f057d8:	e3a03000 	mov	r3, #0	; 0x0
21f057dc:	e50b301c 	str	r3, [fp, #-28]
21f057e0:	ea00000c 	b	21f05818 <mmc2info+0x84>
	}
	if (laddr > capacity) {
21f057e4:	e51b2010 	ldr	r2, [fp, #-16]
21f057e8:	e51b3014 	ldr	r3, [fp, #-20]
21f057ec:	e1520003 	cmp	r2, r3
21f057f0:	9a000004 	bls	21f05808 <mmc2info+0x74>
		printf (" addr higher than AT91C_BASE_MCI + capacity\n");
21f057f4:	e59f0034 	ldr	r0, [pc, #52]	; 21f05830 <.text+0x5830>
21f057f8:	eb0058a3 	bl	21f1ba8c <printf>
		return 0;
21f057fc:	e3a03000 	mov	r3, #0	; 0x0
21f05800:	e50b301c 	str	r3, [fp, #-28]
21f05804:	ea000003 	b	21f05818 <mmc2info+0x84>
	}
	printf ("Ok\n");
21f05808:	e59f0024 	ldr	r0, [pc, #36]	; 21f05834 <.text+0x5834>
21f0580c:	eb00589e 	bl	21f1ba8c <printf>
	return 1;
21f05810:	e3a03001 	mov	r3, #1	; 0x1
21f05814:	e50b301c 	str	r3, [fp, #-28]
21f05818:	e51b301c 	ldr	r3, [fp, #-28]
	
}
21f0581c:	e1a00003 	mov	r0, r3
21f05820:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05824:	e89da800 	ldmia	sp, {fp, sp, pc}
21f05828:	21f3422c 	mvncss	r4, ip, lsr #4
21f0582c:	21f2f1a8 	mvncss	pc, r8, lsr #3
21f05830:	21f2f1cc 	mvncss	pc, ip, asr #3
21f05834:	21f2f1fc 	ldrcssh	pc, [r2, #28]!

21f05838 <AT91F_MCIDeviceWaitReady>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCIDeviceWaitReady
//* \brief Wait for MCI Device ready
//*----------------------------------------------------------------------------
void AT91F_MCIDeviceWaitReady(unsigned int timeout)
{
21f05838:	e1a0c00d 	mov	ip, sp
21f0583c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05840:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05844:	e24dd008 	sub	sp, sp, #8	; 0x8
21f05848:	e50b0014 	str	r0, [fp, #-20]
	volatile int status;
	
	do
	{
		status = AT91C_BASE_MCI->MCI_SR;
21f0584c:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f05850:	e1a03643 	mov	r3, r3, asr #12
21f05854:	e5933040 	ldr	r3, [r3, #64]
21f05858:	e50b3010 	str	r3, [fp, #-16]
		timeout--;
21f0585c:	e51b3014 	ldr	r3, [fp, #-20]
21f05860:	e2433001 	sub	r3, r3, #1	; 0x1
21f05864:	e50b3014 	str	r3, [fp, #-20]
	}
	while( !(status & AT91C_MCI_NOTBUSY)  && (timeout>0) );	
21f05868:	e51b3010 	ldr	r3, [fp, #-16]
21f0586c:	e1a032a3 	mov	r3, r3, lsr #5
21f05870:	e2033001 	and	r3, r3, #1	; 0x1
21f05874:	e3530000 	cmp	r3, #0	; 0x0
21f05878:	1a000002 	bne	21f05888 <AT91F_MCIDeviceWaitReady+0x50>
21f0587c:	e51b3014 	ldr	r3, [fp, #-20]
21f05880:	e3530000 	cmp	r3, #0	; 0x0
21f05884:	1afffff0 	bne	21f0584c <AT91F_MCIDeviceWaitReady+0x14>
}
21f05888:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0588c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f05890 <AT91F_CfgDevice>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_CfgDevice
//* \brief This function is used to initialise MMC or SDCard Features
//*----------------------------------------------------------------------------
void AT91F_CfgDevice(void)
{
21f05890:	e1a0c00d 	mov	ip, sp
21f05894:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05898:	e24cb004 	sub	fp, ip, #4	; 0x4
	// Init Device Structure

	MCI_Device_Features.Relative_Card_Address 		= 0;
21f0589c:	e59f2098 	ldr	r2, [pc, #152]	; 21f0593c <.text+0x593c>
21f058a0:	e3a03000 	mov	r3, #0	; 0x0
21f058a4:	e5823004 	str	r3, [r2, #4]
	MCI_Device_Features.Card_Inserted 				= AT91C_CARD_REMOVED;
21f058a8:	e59f208c 	ldr	r2, [pc, #140]	; 21f0593c <.text+0x593c>
21f058ac:	e3a03000 	mov	r3, #0	; 0x0
21f058b0:	e5c23000 	strb	r3, [r2]
	MCI_Device_Features.Max_Read_DataBlock_Length	= 0;
21f058b4:	e59f2080 	ldr	r2, [pc, #128]	; 21f0593c <.text+0x593c>
21f058b8:	e3a03000 	mov	r3, #0	; 0x0
21f058bc:	e5823008 	str	r3, [r2, #8]
	MCI_Device_Features.Max_Write_DataBlock_Length 	= 0;
21f058c0:	e59f2074 	ldr	r2, [pc, #116]	; 21f0593c <.text+0x593c>
21f058c4:	e3a03000 	mov	r3, #0	; 0x0
21f058c8:	e582300c 	str	r3, [r2, #12]
	MCI_Device_Features.Read_Partial 				= 0;
21f058cc:	e59f2068 	ldr	r2, [pc, #104]	; 21f0593c <.text+0x593c>
21f058d0:	e3a03000 	mov	r3, #0	; 0x0
21f058d4:	e5c23010 	strb	r3, [r2, #16]
	MCI_Device_Features.Write_Partial 				= 0;
21f058d8:	e59f205c 	ldr	r2, [pc, #92]	; 21f0593c <.text+0x593c>
21f058dc:	e3a03000 	mov	r3, #0	; 0x0
21f058e0:	e5c23011 	strb	r3, [r2, #17]
	MCI_Device_Features.Erase_Block_Enable 			= 0;
21f058e4:	e59f2050 	ldr	r2, [pc, #80]	; 21f0593c <.text+0x593c>
21f058e8:	e3a03000 	mov	r3, #0	; 0x0
21f058ec:	e5c23012 	strb	r3, [r2, #18]
	MCI_Device_Features.Sector_Size 				= 0;
21f058f0:	e59f2044 	ldr	r2, [pc, #68]	; 21f0593c <.text+0x593c>
21f058f4:	e3a03000 	mov	r3, #0	; 0x0
21f058f8:	e5c23015 	strb	r3, [r2, #21]
	MCI_Device_Features.Memory_Capacity 			= 0;
21f058fc:	e59f2038 	ldr	r2, [pc, #56]	; 21f0593c <.text+0x593c>
21f05900:	e3a03000 	mov	r3, #0	; 0x0
21f05904:	e5823018 	str	r3, [r2, #24]
	
	MCI_Device_Desc.state							= AT91C_MCI_IDLE;
21f05908:	e59f2030 	ldr	r2, [pc, #48]	; 21f05940 <.text+0x5940>
21f0590c:	e3a03000 	mov	r3, #0	; 0x0
21f05910:	e5c23000 	strb	r3, [r2]
	MCI_Device_Desc.SDCard_bus_width				= AT91C_MCI_SCDBUS;
21f05914:	e59f2024 	ldr	r2, [pc, #36]	; 21f05940 <.text+0x5940>
21f05918:	e3e0307f 	mvn	r3, #127	; 0x7f
21f0591c:	e5c23001 	strb	r3, [r2, #1]
	
	// Init AT91S_DataFlash Global Structure, by default AT45DB choosen !!!
	MCI_Device.pMCI_DeviceDesc 		= &MCI_Device_Desc;
21f05920:	e59f201c 	ldr	r2, [pc, #28]	; 21f05944 <.text+0x5944>
21f05924:	e59f3014 	ldr	r3, [pc, #20]	; 21f05940 <.text+0x5940>
21f05928:	e5823000 	str	r3, [r2]
	MCI_Device.pMCI_DeviceFeatures 	= &MCI_Device_Features;
21f0592c:	e59f2010 	ldr	r2, [pc, #16]	; 21f05944 <.text+0x5944>
21f05930:	e59f3004 	ldr	r3, [pc, #4]	; 21f0593c <.text+0x593c>
21f05934:	e5823004 	str	r3, [r2, #4]

}
21f05938:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0593c:	21f3420c 	mvncss	r4, ip, lsl #4
21f05940:	21f34228 	mvncss	r4, r8, lsr #4
21f05944:	21f3422c 	mvncss	r4, ip, lsr #4

21f05948 <AT91F_Test_SDCard>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_Test_SDCard
//* \brief Configure MCI for SDCard and complete SDCard init, then jump to Test Functions
//*----------------------------------------------------------------------------
int AT91F_Test_SDCard(void)
{
21f05948:	e1a0c00d 	mov	ip, sp
21f0594c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05950:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05954:	e24dd004 	sub	sp, sp, #4	; 0x4
	/*
	 * For SDCard Init
	 */

	AT91F_MCI_Configure(AT91C_BASE_MCI, 
21f05958:	e3a0032d 	mov	r0, #-1275068416	; 0xb4000000
21f0595c:	e1a00640 	mov	r0, r0, asr #12
21f05960:	e3a01071 	mov	r1, #113	; 0x71
21f05964:	e3a02c83 	mov	r2, #33536	; 0x8300
21f05968:	e2822001 	add	r2, r2, #1	; 0x1
21f0596c:	e3a03080 	mov	r3, #128	; 0x80
21f05970:	ebfff4f0 	bl	21f02d38 <AT91F_MCI_Configure>
			AT91C_MCI_DTOR_1MEGA_CYCLES, 
			AT91C_MCI_MR_PDCMODE	/* 15MHz for MCK = 60MHz (CLKDIV = 1)*/, 
			AT91C_MCI_SDCARD_4BITS_SLOTA);
	
	if(AT91F_MCI_SDCard_Init(&MCI_Device) != AT91C_INIT_OK)
21f05974:	e59f002c 	ldr	r0, [pc, #44]	; 21f059a8 <.text+0x59a8>
21f05978:	ebfffd57 	bl	21f04edc <AT91F_MCI_SDCard_Init>
21f0597c:	e1a03000 	mov	r3, r0
21f05980:	e3530002 	cmp	r3, #2	; 0x2
21f05984:	0a000002 	beq	21f05994 <AT91F_Test_SDCard+0x4c>
		return FALSE;
21f05988:	e3e03000 	mvn	r3, #0	; 0x0
21f0598c:	e50b3010 	str	r3, [fp, #-16]
21f05990:	ea000001 	b	21f0599c <AT91F_Test_SDCard+0x54>
	return(TRUE);
21f05994:	e3a03001 	mov	r3, #1	; 0x1
21f05998:	e50b3010 	str	r3, [fp, #-16]
21f0599c:	e51b3010 	ldr	r3, [fp, #-16]
}
21f059a0:	e1a00003 	mov	r0, r3
21f059a4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f059a8:	21f3422c 	mvncss	r4, ip, lsr #4

21f059ac <AT91F_MCI_Handler>:

//*----------------------------------------------------------------------------
//* \fn    AT91F_MCI_Handler
//* \brief MCI Handler
//*----------------------------------------------------------------------------
void AT91F_MCI_Handler(void)
{
21f059ac:	e1a0c00d 	mov	ip, sp
21f059b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f059b4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f059b8:	e24dd004 	sub	sp, sp, #4	; 0x4
	int status;
	status = ( AT91C_BASE_MCI->MCI_SR & AT91C_BASE_MCI->MCI_IMR );
21f059bc:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f059c0:	e1a03643 	mov	r3, r3, asr #12
21f059c4:	e5932040 	ldr	r2, [r3, #64]
21f059c8:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f059cc:	e1a03643 	mov	r3, r3, asr #12
21f059d0:	e593304c 	ldr	r3, [r3, #76]
21f059d4:	e0023003 	and	r3, r2, r3
21f059d8:	e50b3010 	str	r3, [fp, #-16]
	AT91F_MCI_Device_Handler(&MCI_Device,status);
21f059dc:	e51b3010 	ldr	r3, [fp, #-16]
21f059e0:	e59f0008 	ldr	r0, [pc, #8]	; 21f059f0 <.text+0x59f0>
21f059e4:	e1a01003 	mov	r1, r3
21f059e8:	ebfff96e 	bl	21f03fa8 <AT91F_MCI_Device_Handler>
}
21f059ec:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f059f0:	21f3422c 	mvncss	r4, ip, lsr #4

21f059f4 <at91sdcard_init>:


//*----------------------------------------------------------------------------
//* \fn    at91sdcard_init
//* \brief at91sdcard_init function
//*----------------------------------------------------------------------------
static int at91sdcard_init(void)
{
21f059f4:	e1a0c00d 	mov	ip, sp
21f059f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f059fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05a00:	e24dd004 	sub	sp, sp, #4	; 0x4
	// Set up PIO SDC_TYPE to switch on MMC/SDCard and not DataFlash Card
	AT91F_PIO_CfgOutput(AT91C_BASE_PIOB,AT91C_PIO_PB7);
21f05a04:	e3a0020b 	mov	r0, #-1342177280	; 0xb0000000
21f05a08:	e1a009c0 	mov	r0, r0, asr #19
21f05a0c:	e3a01080 	mov	r1, #128	; 0x80
21f05a10:	ebfff137 	bl	21f01ef4 <AT91F_PIO_CfgOutput>
	AT91F_PIO_SetOutput(AT91C_BASE_PIOB,AT91C_PIO_PB7);
21f05a14:	e3a0020b 	mov	r0, #-1342177280	; 0xb0000000
21f05a18:	e1a009c0 	mov	r0, r0, asr #19
21f05a1c:	e3a01080 	mov	r1, #128	; 0x80
21f05a20:	ebfff1a2 	bl	21f020b0 <AT91F_PIO_SetOutput>
	
	// Init MCI for MMC and SDCard interface
	AT91F_MCI_CfgPIO();	
21f05a24:	ebfff894 	bl	21f03c7c <AT91F_MCI_CfgPIO>
	AT91F_MCI_CfgPMC();
21f05a28:	ebfff88b 	bl	21f03c5c <AT91F_MCI_CfgPMC>
	AT91F_PDC_Open(AT91C_BASE_PDC_MCI);
21f05a2c:	e3e00a4b 	mvn	r0, #307200	; 0x4b000
21f05a30:	e2400eef 	sub	r0, r0, #3824	; 0xef0
21f05a34:	e240000f 	sub	r0, r0, #15	; 0xf
21f05a38:	ebffed56 	bl	21f00f98 <AT91F_PDC_Open>

	// Disable all the interrupts
	AT91C_BASE_MCI->MCI_IDR = 0xFFFFFFFF;
21f05a3c:	e3a0332d 	mov	r3, #-1275068416	; 0xb4000000
21f05a40:	e1a03643 	mov	r3, r3, asr #12
21f05a44:	e3e02000 	mvn	r2, #0	; 0x0
21f05a48:	e5832048 	str	r2, [r3, #72]

	// Init MCI Device Structures
	AT91F_CfgDevice();
21f05a4c:	ebffff8f 	bl	21f05890 <AT91F_CfgDevice>
	
	// Configure MCI interrupt 
	AT91F_AIC_ConfigureIt(AT91C_BASE_AIC,
21f05a50:	e59f3050 	ldr	r3, [pc, #80]	; 21f05aa8 <.text+0x5aa8>
21f05a54:	e58d3000 	str	r3, [sp]
21f05a58:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f05a5c:	e1a009c0 	mov	r0, r0, asr #19
21f05a60:	e3a0100a 	mov	r1, #10	; 0xa
21f05a64:	e3a02007 	mov	r2, #7	; 0x7
21f05a68:	e3a03000 	mov	r3, #0	; 0x0
21f05a6c:	ebfff4fd 	bl	21f02e68 <AT91F_AIC_ConfigureIt>
						 AT91C_ID_MCI,
						 AT91C_AIC_PRIOR_HIGHEST,
						 AT91C_AIC_SRCTYPE_INT_LEVEL_SENSITIVE,
						 AT91F_MCI_Handler);

	// Enable MCI interrupt
	AT91F_AIC_EnableIt(AT91C_BASE_AIC,AT91C_ID_MCI);
21f05a70:	e3a00102 	mov	r0, #-2147483648	; 0x80000000
21f05a74:	e1a009c0 	mov	r0, r0, asr #19
21f05a78:	e3a0100a 	mov	r1, #10	; 0xa
21f05a7c:	ebfff526 	bl	21f02f1c <AT91F_AIC_EnableIt>


	if(AT91F_Test_SDCard() == TRUE)
21f05a80:	ebffffb0 	bl	21f05948 <AT91F_Test_SDCard>
21f05a84:	e1a03000 	mov	r3, r0
21f05a88:	e3530001 	cmp	r3, #1	; 0x1
21f05a8c:	1a000002 	bne	21f05a9c <at91sdcard_init+0xa8>
		printf("\n\rTests MCI SDCard Successful !!!\n\r");
21f05a90:	e59f0014 	ldr	r0, [pc, #20]	; 21f05aac <.text+0x5aac>
21f05a94:	eb0057fc 	bl	21f1ba8c <printf>
21f05a98:	ea000001 	b	21f05aa4 <at91sdcard_init+0xb0>
	else
		printf("\n\rTests MCI SDCard Failed !!!\n\r");
21f05a9c:	e59f000c 	ldr	r0, [pc, #12]	; 21f05ab0 <.text+0x5ab0>
21f05aa0:	eb0057f9 	bl	21f1ba8c <printf>
}
21f05aa4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f05aa8:	21f059ac 	mvncss	r5, ip, lsr #19
21f05aac:	21f2f200 	mvncss	pc, r0, lsl #4
21f05ab0:	21f2f224 	mvncss	pc, r4, lsr #4

21f05ab4 <__udivsi3>:
	.globl	 __udivsi3
	.type  __udivsi3       ,function
	.align	0
 __udivsi3      :
	cmp	divisor, #0
21f05ab4:	e3510000 	cmp	r1, #0	; 0x0
	beq	Ldiv0
21f05ab8:	0a00001f 	beq	21f05b3c <Ldiv0>
	mov	curbit, #1
21f05abc:	e3a03001 	mov	r3, #1	; 0x1
	mov	result, #0
21f05ac0:	e3a02000 	mov	r2, #0	; 0x0
	cmp	dividend, divisor
21f05ac4:	e1500001 	cmp	r0, r1
	bcc	Lgot_result
21f05ac8:	3a000019 	bcc	21f05b34 <Lgot_result>

21f05acc <Loop1>:
Loop1:
	@ Unless the divisor is very big, shift it up in multiples of
	@ four bits, since this is the amount of unwinding in the main
	@ division loop.  Continue shifting until the divisor is
	@ larger than the dividend.
	cmp	divisor, #0x10000000
21f05acc:	e3510201 	cmp	r1, #268435456	; 0x10000000
	cmpcc	divisor, dividend
21f05ad0:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #4
21f05ad4:	31a01201 	movcc	r1, r1, lsl #4
	movcc	curbit, curbit, lsl #4
21f05ad8:	31a03203 	movcc	r3, r3, lsl #4
	bcc	Loop1
21f05adc:	3afffffa 	bcc	21f05acc <Loop1>

21f05ae0 <Lbignum>:
Lbignum:
	@ For very big divisors, we must shift it a bit at a time, or
	@ we will be in danger of overflowing.
	cmp	divisor, #0x80000000
21f05ae0:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
	cmpcc	divisor, dividend
21f05ae4:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #1
21f05ae8:	31a01081 	movcc	r1, r1, lsl #1
	movcc	curbit, curbit, lsl #1
21f05aec:	31a03083 	movcc	r3, r3, lsl #1
	bcc	Lbignum
21f05af0:	3afffffa 	bcc	21f05ae0 <Lbignum>

21f05af4 <Loop3>:
Loop3:
	@ Test for possible subtractions, and note which bits
	@ are done in the result.  On the final pass, this may subtract
	@ too much from the dividend, but the result will be ok, since the
	@ "bit" will have been shifted out at the bottom.
	cmp	dividend, divisor
21f05af4:	e1500001 	cmp	r0, r1
	subcs	dividend, dividend, divisor
21f05af8:	20400001 	subcs	r0, r0, r1
	orrcs	result, result, curbit
21f05afc:	21822003 	orrcs	r2, r2, r3
	cmp	dividend, divisor, lsr #1
21f05b00:	e15000a1 	cmp	r0, r1, lsr #1
	subcs	dividend, dividend, divisor, lsr #1
21f05b04:	204000a1 	subcs	r0, r0, r1, lsr #1
	orrcs	result, result, curbit, lsr #1
21f05b08:	218220a3 	orrcs	r2, r2, r3, lsr #1
	cmp	dividend, divisor, lsr #2
21f05b0c:	e1500121 	cmp	r0, r1, lsr #2
	subcs	dividend, dividend, divisor, lsr #2
21f05b10:	20400121 	subcs	r0, r0, r1, lsr #2
	orrcs	result, result, curbit, lsr #2
21f05b14:	21822123 	orrcs	r2, r2, r3, lsr #2
	cmp	dividend, divisor, lsr #3
21f05b18:	e15001a1 	cmp	r0, r1, lsr #3
	subcs	dividend, dividend, divisor, lsr #3
21f05b1c:	204001a1 	subcs	r0, r0, r1, lsr #3
	orrcs	result, result, curbit, lsr #3
21f05b20:	218221a3 	orrcs	r2, r2, r3, lsr #3
	cmp	dividend, #0			@ Early termination?
21f05b24:	e3500000 	cmp	r0, #0	; 0x0
	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
21f05b28:	11b03223 	movnes	r3, r3, lsr #4
	movne	divisor, divisor, lsr #4
21f05b2c:	11a01221 	movne	r1, r1, lsr #4
	bne	Loop3
21f05b30:	1affffef 	bne	21f05af4 <Loop3>

21f05b34 <Lgot_result>:
Lgot_result:
	mov	r0, result
21f05b34:	e1a00002 	mov	r0, r2
	mov 	pc, lr
21f05b38:	e1a0f00e 	mov	pc, lr

21f05b3c <Ldiv0>:
Ldiv0:
	str	lr, [sp, #-4]!
21f05b3c:	e52de004 	str	lr, [sp, #-4]!
	bl	 __div0       (PLT)
21f05b40:	eb000197 	bl	21f061a4 <__div0>
	mov	r0, #0			@ about as wrong as it could be
21f05b44:	e3a00000 	mov	r0, #0	; 0x0
	ldmia	sp!, {pc}
21f05b48:	e8bd8000 	ldmia	sp!, {pc}

21f05b4c <__umodsi3>:
	.globl	 __umodsi3
	.type  __umodsi3       ,function
	.align 0
 __umodsi3      :
	cmp	divisor, #0
21f05b4c:	e3510000 	cmp	r1, #0	; 0x0
	beq	Ldiv0
21f05b50:	0a000026 	beq	21f05bf0 <Ldiv0>
	mov	curbit, #1
21f05b54:	e3a03001 	mov	r3, #1	; 0x1
	cmp	dividend, divisor
21f05b58:	e1500001 	cmp	r0, r1
	movcc  	pc, lr
21f05b5c:	31a0f00e 	movcc	pc, lr

21f05b60 <Loop1>:
Loop1:
	@ Unless the divisor is very big, shift it up in multiples of
	@ four bits, since this is the amount of unwinding in the main
	@ division loop.  Continue shifting until the divisor is
	@ larger than the dividend.
	cmp	divisor, #0x10000000
21f05b60:	e3510201 	cmp	r1, #268435456	; 0x10000000
	cmpcc	divisor, dividend
21f05b64:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #4
21f05b68:	31a01201 	movcc	r1, r1, lsl #4
	movcc	curbit, curbit, lsl #4
21f05b6c:	31a03203 	movcc	r3, r3, lsl #4
	bcc	Loop1
21f05b70:	3afffffa 	bcc	21f05b60 <Loop1>

21f05b74 <Lbignum>:
Lbignum:
	@ For very big divisors, we must shift it a bit at a time, or
	@ we will be in danger of overflowing.
	cmp	divisor, #0x80000000
21f05b74:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
	cmpcc	divisor, dividend
21f05b78:	31510000 	cmpcc	r1, r0
	movcc	divisor, divisor, lsl #1
21f05b7c:	31a01081 	movcc	r1, r1, lsl #1
	movcc	curbit, curbit, lsl #1
21f05b80:	31a03083 	movcc	r3, r3, lsl #1
	bcc	Lbignum
21f05b84:	3afffffa 	bcc	21f05b74 <Lbignum>

21f05b88 <Loop3>:
Loop3:
	@ Test for possible subtractions.  On the final pass, this may
	@ subtract too much from the dividend, so keep track of which
	@ subtractions are done, we can fix them up afterwards...
	mov	overdone, #0
21f05b88:	e3a02000 	mov	r2, #0	; 0x0
	cmp	dividend, divisor
21f05b8c:	e1500001 	cmp	r0, r1
	subcs	dividend, dividend, divisor
21f05b90:	20400001 	subcs	r0, r0, r1
	cmp	dividend, divisor, lsr #1
21f05b94:	e15000a1 	cmp	r0, r1, lsr #1
	subcs	dividend, dividend, divisor, lsr #1
21f05b98:	204000a1 	subcs	r0, r0, r1, lsr #1
	orrcs	overdone, overdone, curbit, ror #1
21f05b9c:	218220e3 	orrcs	r2, r2, r3, ror #1
	cmp	dividend, divisor, lsr #2
21f05ba0:	e1500121 	cmp	r0, r1, lsr #2
	subcs	dividend, dividend, divisor, lsr #2
21f05ba4:	20400121 	subcs	r0, r0, r1, lsr #2
	orrcs	overdone, overdone, curbit, ror #2
21f05ba8:	21822163 	orrcs	r2, r2, r3, ror #2
	cmp	dividend, divisor, lsr #3
21f05bac:	e15001a1 	cmp	r0, r1, lsr #3
	subcs	dividend, dividend, divisor, lsr #3
21f05bb0:	204001a1 	subcs	r0, r0, r1, lsr #3
	orrcs	overdone, overdone, curbit, ror #3
21f05bb4:	218221e3 	orrcs	r2, r2, r3, ror #3
	mov	ip, curbit
21f05bb8:	e1a0c003 	mov	ip, r3
	cmp	dividend, #0			@ Early termination?
21f05bbc:	e3500000 	cmp	r0, #0	; 0x0
	movnes	curbit, curbit, lsr #4		@ No, any more bits to do?
21f05bc0:	11b03223 	movnes	r3, r3, lsr #4
	movne	divisor, divisor, lsr #4
21f05bc4:	11a01221 	movne	r1, r1, lsr #4
	bne	Loop3
21f05bc8:	1affffee 	bne	21f05b88 <Loop3>
	@ Any subtractions that we should not have done will be recorded in
	@ the top three bits of "overdone".  Exactly which were not needed
	@ are governed by the position of the bit, stored in ip.
	@ If we terminated early, because dividend became zero,
	@ then none of the below will match, since the bit in ip will not be
	@ in the bottom nibble.
	ands	overdone, overdone, #0xe0000000
21f05bcc:	e212220e 	ands	r2, r2, #-536870912	; 0xe0000000
	moveq  	pc, lr				@ No fixups needed
21f05bd0:	01a0f00e 	moveq	pc, lr
	tst	overdone, ip, ror #3
21f05bd4:	e11201ec 	tst	r2, ip, ror #3
	addne	dividend, dividend, divisor, lsr #3
21f05bd8:	108001a1 	addne	r0, r0, r1, lsr #3
	tst	overdone, ip, ror #2
21f05bdc:	e112016c 	tst	r2, ip, ror #2
	addne	dividend, dividend, divisor, lsr #2
21f05be0:	10800121 	addne	r0, r0, r1, lsr #2
	tst	overdone, ip, ror #1
21f05be4:	e11200ec 	tst	r2, ip, ror #1
	addne	dividend, dividend, divisor, lsr #1
21f05be8:	108000a1 	addne	r0, r0, r1, lsr #1
	mov 	pc, lr
21f05bec:	e1a0f00e 	mov	pc, lr

21f05bf0 <Ldiv0>:
Ldiv0:
	str	lr, [sp, #-4]!
21f05bf0:	e52de004 	str	lr, [sp, #-4]!
	bl	 __div0       (PLT)
21f05bf4:	eb00016a 	bl	21f061a4 <__div0>
	mov	r0, #0			@ about as wrong as it could be
21f05bf8:	e3a00000 	mov	r0, #0	; 0x0
	ldmia	sp!, {pc}
21f05bfc:	e8bd8000 	ldmia	sp!, {pc}

21f05c00 <mem_malloc_init>:
static ulong mem_malloc_brk = 0;

static
void mem_malloc_init (ulong dest_addr)
{
21f05c00:	e1a0c00d 	mov	ip, sp
21f05c04:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05c08:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05c0c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f05c10:	e50b0010 	str	r0, [fp, #-16]
	mem_malloc_start = dest_addr;
21f05c14:	e59f2058 	ldr	r2, [pc, #88]	; 21f05c74 <.text+0x5c74>
21f05c18:	e51b3010 	ldr	r3, [fp, #-16]
21f05c1c:	e5823000 	str	r3, [r2]
	mem_malloc_end = dest_addr + CFG_MALLOC_LEN;
21f05c20:	e51b3010 	ldr	r3, [fp, #-16]
21f05c24:	e2832a22 	add	r2, r3, #139264	; 0x22000
21f05c28:	e59f3048 	ldr	r3, [pc, #72]	; 21f05c78 <.text+0x5c78>
21f05c2c:	e5832000 	str	r2, [r3]
	mem_malloc_brk = mem_malloc_start;
21f05c30:	e59f303c 	ldr	r3, [pc, #60]	; 21f05c74 <.text+0x5c74>
21f05c34:	e5932000 	ldr	r2, [r3]
21f05c38:	e59f303c 	ldr	r3, [pc, #60]	; 21f05c7c <.text+0x5c7c>
21f05c3c:	e5832000 	str	r2, [r3]

	memset ((void *) mem_malloc_start, 0,
21f05c40:	e59f302c 	ldr	r3, [pc, #44]	; 21f05c74 <.text+0x5c74>
21f05c44:	e5933000 	ldr	r3, [r3]
21f05c48:	e1a01003 	mov	r1, r3
21f05c4c:	e59f3024 	ldr	r3, [pc, #36]	; 21f05c78 <.text+0x5c78>
21f05c50:	e5932000 	ldr	r2, [r3]
21f05c54:	e59f3018 	ldr	r3, [pc, #24]	; 21f05c74 <.text+0x5c74>
21f05c58:	e5933000 	ldr	r3, [r3]
21f05c5c:	e0633002 	rsb	r3, r3, r2
21f05c60:	e1a00001 	mov	r0, r1
21f05c64:	e3a01000 	mov	r1, #0	; 0x0
21f05c68:	e1a02003 	mov	r2, r3
21f05c6c:	eb00751d 	bl	21f230e8 <memset>
			mem_malloc_end - mem_malloc_start);
}
21f05c70:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f05c74:	21f3449c 	ldrcsb	r4, [r3, #76]!
21f05c78:	21f344a0 	mvncss	r4, r0, lsr #9
21f05c7c:	21f344a4 	mvncss	r4, r4, lsr #9

21f05c80 <sbrk>:

void *sbrk (ptrdiff_t increment)
{
21f05c80:	e1a0c00d 	mov	ip, sp
21f05c84:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05c88:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05c8c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f05c90:	e50b0018 	str	r0, [fp, #-24]
	ulong old = mem_malloc_brk;
21f05c94:	e59f306c 	ldr	r3, [pc, #108]	; 21f05d08 <.text+0x5d08>
21f05c98:	e5933000 	ldr	r3, [r3]
21f05c9c:	e50b3014 	str	r3, [fp, #-20]
	ulong new = old + increment;
21f05ca0:	e51b2018 	ldr	r2, [fp, #-24]
21f05ca4:	e51b3014 	ldr	r3, [fp, #-20]
21f05ca8:	e0833002 	add	r3, r3, r2
21f05cac:	e50b3010 	str	r3, [fp, #-16]

	if ((new < mem_malloc_start) || (new > mem_malloc_end)) {
21f05cb0:	e59f3054 	ldr	r3, [pc, #84]	; 21f05d0c <.text+0x5d0c>
21f05cb4:	e5932000 	ldr	r2, [r3]
21f05cb8:	e51b3010 	ldr	r3, [fp, #-16]
21f05cbc:	e1530002 	cmp	r3, r2
21f05cc0:	3a000004 	bcc	21f05cd8 <sbrk+0x58>
21f05cc4:	e59f3044 	ldr	r3, [pc, #68]	; 21f05d10 <.text+0x5d10>
21f05cc8:	e5932000 	ldr	r2, [r3]
21f05ccc:	e51b3010 	ldr	r3, [fp, #-16]
21f05cd0:	e1530002 	cmp	r3, r2
21f05cd4:	9a000002 	bls	21f05ce4 <sbrk+0x64>
		return (NULL);
21f05cd8:	e3a03000 	mov	r3, #0	; 0x0
21f05cdc:	e50b301c 	str	r3, [fp, #-28]
21f05ce0:	ea000004 	b	21f05cf8 <sbrk+0x78>
	}
	mem_malloc_brk = new;
21f05ce4:	e59f201c 	ldr	r2, [pc, #28]	; 21f05d08 <.text+0x5d08>
21f05ce8:	e51b3010 	ldr	r3, [fp, #-16]
21f05cec:	e5823000 	str	r3, [r2]

	return ((void *) old);
21f05cf0:	e51b3014 	ldr	r3, [fp, #-20]
21f05cf4:	e50b301c 	str	r3, [fp, #-28]
21f05cf8:	e51b301c 	ldr	r3, [fp, #-28]
}
21f05cfc:	e1a00003 	mov	r0, r3
21f05d00:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05d04:	e89da800 	ldmia	sp, {fp, sp, pc}
21f05d08:	21f344a4 	mvncss	r4, r4, lsr #9
21f05d0c:	21f3449c 	ldrcsb	r4, [r3, #76]!
21f05d10:	21f344a0 	mvncss	r4, r0, lsr #9

21f05d14 <init_baudrate>:

/************************************************************************
 * Init Utilities							*
 ************************************************************************
 * Some of this code should be moved into the core functions,
 * or dropped completely,
 * but let's get it working (again) first...
 */

static int init_baudrate (void)
{
21f05d14:	e1a0c00d 	mov	ip, sp
21f05d18:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05d1c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05d20:	e24dd050 	sub	sp, sp, #80	; 0x50
	char tmp[64];	/* long enough for environment variables */
	int i = getenv_r ("baudrate", tmp, sizeof (tmp));
21f05d24:	e24b3050 	sub	r3, fp, #80	; 0x50
21f05d28:	e59f008c 	ldr	r0, [pc, #140]	; 21f05dbc <.text+0x5dbc>
21f05d2c:	e1a01003 	mov	r1, r3
21f05d30:	e3a02040 	mov	r2, #64	; 0x40
21f05d34:	eb0053f5 	bl	21f1ad10 <getenv_r>
21f05d38:	e1a03000 	mov	r3, r0
21f05d3c:	e50b3010 	str	r3, [fp, #-16]
	gd->bd->bi_baudrate = gd->baudrate = (i > 0)
21f05d40:	e1a03008 	mov	r3, r8
21f05d44:	e5933000 	ldr	r3, [r3]
21f05d48:	e50b305c 	str	r3, [fp, #-92]
21f05d4c:	e50b8058 	str	r8, [fp, #-88]
21f05d50:	e51b3010 	ldr	r3, [fp, #-16]
21f05d54:	e3530000 	cmp	r3, #0	; 0x0
21f05d58:	da000007 	ble	21f05d7c <init_baudrate+0x68>
21f05d5c:	e24b3050 	sub	r3, fp, #80	; 0x50
21f05d60:	e1a00003 	mov	r0, r3
21f05d64:	e3a01000 	mov	r1, #0	; 0x0
21f05d68:	e3a0200a 	mov	r2, #10	; 0xa
21f05d6c:	eb007615 	bl	21f235c8 <simple_strtoul>
21f05d70:	e1a03000 	mov	r3, r0
21f05d74:	e50b3054 	str	r3, [fp, #-84]
21f05d78:	ea000004 	b	21f05d90 <init_baudrate+0x7c>
21f05d7c:	e3a02907 	mov	r2, #114688	; 0x1c000
21f05d80:	e50b2054 	str	r2, [fp, #-84]
21f05d84:	e51b3054 	ldr	r3, [fp, #-84]
21f05d88:	e2833c02 	add	r3, r3, #512	; 0x200
21f05d8c:	e50b3054 	str	r3, [fp, #-84]
21f05d90:	e51b3054 	ldr	r3, [fp, #-84]
21f05d94:	e51b2058 	ldr	r2, [fp, #-88]
21f05d98:	e5823008 	str	r3, [r2, #8]
21f05d9c:	e51b2058 	ldr	r2, [fp, #-88]
21f05da0:	e5923008 	ldr	r3, [r2, #8]
21f05da4:	e51b205c 	ldr	r2, [fp, #-92]
21f05da8:	e5823000 	str	r3, [r2]
			? (int) simple_strtoul (tmp, NULL, 10)
			: CONFIG_BAUDRATE;

	return (0);
21f05dac:	e3a03000 	mov	r3, #0	; 0x0
}
21f05db0:	e1a00003 	mov	r0, r3
21f05db4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05db8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f05dbc:	21f2f26c 	mvncss	pc, ip, ror #4

21f05dc0 <display_banner>:

static int display_banner (void)
{
21f05dc0:	e1a0c00d 	mov	ip, sp
21f05dc4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05dc8:	e24cb004 	sub	fp, ip, #4	; 0x4
	printf ("\n\n%s\n\n", version_string);
21f05dcc:	e59f0010 	ldr	r0, [pc, #16]	; 21f05de4 <.text+0x5de4>
21f05dd0:	e59f1010 	ldr	r1, [pc, #16]	; 21f05de8 <.text+0x5de8>
21f05dd4:	eb00572c 	bl	21f1ba8c <printf>
	debug ("U-Boot code: %08lX -> %08lX  BSS: -> %08lX\n",
	       _armboot_start, _bss_start, _bss_end);
#ifdef CONFIG_MODEM_SUPPORT
	debug ("Modem Support enabled\n");
#endif
#ifdef CONFIG_USE_IRQ
	debug ("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug ("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

	return (0);
21f05dd8:	e3a03000 	mov	r3, #0	; 0x0
}
21f05ddc:	e1a00003 	mov	r0, r3
21f05de0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f05de4:	21f2f278 	mvncss	pc, r8, ror r2
21f05de8:	21f2f244 	mvncss	pc, r4, asr #4

21f05dec <display_dram_config>:

/*
 * WARNING: this code looks "cleaner" than the PowerPC version, but
 * has the disadvantage that you either get nothing, or everything.
 * On PowerPC, you might see "DRAM: " before the system hangs - which
 * gives a simple yet clear indication which part of the
 * initialization if failing.
 */
static int display_dram_config (void)
{
21f05dec:	e1a0c00d 	mov	ip, sp
21f05df0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05df4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05df8:	e24dd008 	sub	sp, sp, #8	; 0x8
	int i;

#ifdef DEBUG
	puts ("RAM Configuration:\n");

	for(i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
		printf ("Bank #%d: %08lx ", i, gd->bd->bi_dram[i].start);
		print_size (gd->bd->bi_dram[i].size, "\n");
	}
#else
	ulong size = 0;
21f05dfc:	e3a03000 	mov	r3, #0	; 0x0
21f05e00:	e50b3010 	str	r3, [fp, #-16]

	for (i=0; i<CONFIG_NR_DRAM_BANKS; i++) {
21f05e04:	e3a03000 	mov	r3, #0	; 0x0
21f05e08:	e50b3014 	str	r3, [fp, #-20]
21f05e0c:	ea00000d 	b	21f05e48 <display_dram_config+0x5c>
		size += gd->bd->bi_dram[i].size;
21f05e10:	e1a03008 	mov	r3, r8
21f05e14:	e5931000 	ldr	r1, [r3]
21f05e18:	e51b3014 	ldr	r3, [fp, #-20]
21f05e1c:	e3a02020 	mov	r2, #32	; 0x20
21f05e20:	e1a03183 	mov	r3, r3, lsl #3
21f05e24:	e0833001 	add	r3, r3, r1
21f05e28:	e0833002 	add	r3, r3, r2
21f05e2c:	e5932000 	ldr	r2, [r3]
21f05e30:	e51b3010 	ldr	r3, [fp, #-16]
21f05e34:	e0833002 	add	r3, r3, r2
21f05e38:	e50b3010 	str	r3, [fp, #-16]
21f05e3c:	e51b3014 	ldr	r3, [fp, #-20]
21f05e40:	e2833001 	add	r3, r3, #1	; 0x1
21f05e44:	e50b3014 	str	r3, [fp, #-20]
21f05e48:	e51b3014 	ldr	r3, [fp, #-20]
21f05e4c:	e3530000 	cmp	r3, #0	; 0x0
21f05e50:	daffffee 	ble	21f05e10 <display_dram_config+0x24>
	}
	puts("DRAM:  ");
21f05e54:	e59f001c 	ldr	r0, [pc, #28]	; 21f05e78 <.text+0x5e78>
21f05e58:	eb0056f8 	bl	21f1ba40 <puts>
	print_size(size, "\n");
21f05e5c:	e51b0010 	ldr	r0, [fp, #-16]
21f05e60:	e59f1014 	ldr	r1, [pc, #20]	; 21f05e7c <.text+0x5e7c>
21f05e64:	eb0071d5 	bl	21f225c0 <print_size>
#endif

	return (0);
21f05e68:	e3a03000 	mov	r3, #0	; 0x0
}
21f05e6c:	e1a00003 	mov	r0, r3
21f05e70:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f05e74:	e89da800 	ldmia	sp, {fp, sp, pc}
21f05e78:	21f2f280 	mvncss	pc, r0, lsl #5
21f05e7c:	21f2f288 	mvncss	pc, r8, lsl #5

21f05e80 <display_flash_config>:

#ifndef CFG_NO_FLASH
static void display_flash_config (ulong size)
{
21f05e80:	e1a0c00d 	mov	ip, sp
21f05e84:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f05e88:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05e8c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f05e90:	e50b0010 	str	r0, [fp, #-16]
	puts ("Flash: ");
21f05e94:	e59f0010 	ldr	r0, [pc, #16]	; 21f05eac <.text+0x5eac>
21f05e98:	eb0056e8 	bl	21f1ba40 <puts>
	print_size (size, "\n");
21f05e9c:	e51b0010 	ldr	r0, [fp, #-16]
21f05ea0:	e59f1008 	ldr	r1, [pc, #8]	; 21f05eb0 <.text+0x5eb0>
21f05ea4:	eb0071c5 	bl	21f225c0 <print_size>
}
21f05ea8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f05eac:	21f2f28c 	mvncss	pc, ip, lsl #5
21f05eb0:	21f2f288 	mvncss	pc, r8, lsl #5

21f05eb4 <start_armboot>:
#endif /* CFG_NO_FLASH */


/*
 * Breathe some life into the board...
 *
 * Initialize a serial port as console, and carry out some hardware
 * tests.
 *
 * The first part of initialization is running from Flash memory;
 * its main purpose is to initialize the RAM so that we
 * can relocate the monitor code to RAM.
 */

/*
 * All attempts to come up with a "common" initialization sequence
 * that works for all boards and architectures failed: some of the
 * requirements are just _too_ different. To get rid of the resulting
 * mess of board dependent #ifdef'ed code we now make the whole
 * initialization sequence configurable to the user.
 *
 * The requirements for any new initalization function is simple: it
 * receives a pointer to the "global data" structure as it's only
 * argument, and returns an integer return code, where 0 means
 * "continue" and != 0 means "fatal error, hang the system".
 */
typedef int (init_fnc_t) (void);

int print_cpuinfo (void); /* test-only */

init_fnc_t *init_sequence[] = {
	cpu_init,		/* basic cpu dependent setup */
	board_init,		/* basic board dependent setup */
	interrupt_init,		/* set up exceptions */
	env_init,		/* initialize environment */
	init_baudrate,		/* initialze baudrate settings */
	serial_init,		/* serial communications setup */
	console_init_f,		/* stage 1 init of console */
	display_banner,		/* say that we are here */
#if defined(CONFIG_DISPLAY_CPUINFO)
	print_cpuinfo,		/* display cpu info (and speed) */
#endif
#if defined(CONFIG_DISPLAY_BOARDINFO)
	checkboard,		/* display board info */
#endif
	dram_init,		/* configure available RAM banks */
	display_dram_config,
	NULL,
};

void start_armboot (void)
{
21f05eb4:	e1a0c00d 	mov	ip, sp
21f05eb8:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f05ebc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f05ec0:	e24dd070 	sub	sp, sp, #112	; 0x70
	init_fnc_t **init_fnc_ptr;
	char *s;
#ifndef CFG_NO_FLASH
	ulong size;
#endif
#if defined(CONFIG_VFD) || defined(CONFIG_LCD)
	unsigned long addr;
#endif

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t*)(_armboot_start - CFG_MALLOC_LEN - sizeof(gd_t));
21f05ec4:	e59f3294 	ldr	r3, [pc, #660]	; 21f06160 <.text+0x6160>
21f05ec8:	e5933000 	ldr	r3, [r3]
21f05ecc:	e2433a22 	sub	r3, r3, #139264	; 0x22000
21f05ed0:	e2433024 	sub	r3, r3, #36	; 0x24
21f05ed4:	e1a08003 	mov	r8, r3
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset ((void*)gd, 0, sizeof (gd_t));
21f05ed8:	e1a03008 	mov	r3, r8
21f05edc:	e1a00003 	mov	r0, r3
21f05ee0:	e3a01000 	mov	r1, #0	; 0x0
21f05ee4:	e3a02024 	mov	r2, #36	; 0x24
21f05ee8:	eb00747e 	bl	21f230e8 <memset>
	gd->bd = (bd_t*)((char*)gd - sizeof(bd_t));
21f05eec:	e1a02008 	mov	r2, r8
21f05ef0:	e1a03008 	mov	r3, r8
21f05ef4:	e2433024 	sub	r3, r3, #36	; 0x24
21f05ef8:	e5823000 	str	r3, [r2]
	memset (gd->bd, 0, sizeof (bd_t));
21f05efc:	e1a03008 	mov	r3, r8
21f05f00:	e5933000 	ldr	r3, [r3]
21f05f04:	e1a00003 	mov	r0, r3
21f05f08:	e3a01000 	mov	r1, #0	; 0x0
21f05f0c:	e3a02024 	mov	r2, #36	; 0x24
21f05f10:	eb007474 	bl	21f230e8 <memset>

	monitor_flash_len = _bss_start - _armboot_start;
21f05f14:	e59f3248 	ldr	r3, [pc, #584]	; 21f06164 <.text+0x6164>
21f05f18:	e5932000 	ldr	r2, [r3]
21f05f1c:	e59f323c 	ldr	r3, [pc, #572]	; 21f06160 <.text+0x6160>
21f05f20:	e5933000 	ldr	r3, [r3]
21f05f24:	e0632002 	rsb	r2, r3, r2
21f05f28:	e59f3238 	ldr	r3, [pc, #568]	; 21f06168 <.text+0x6168>
21f05f2c:	e5832000 	str	r2, [r3]

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
21f05f30:	e59f3234 	ldr	r3, [pc, #564]	; 21f0616c <.text+0x616c>
21f05f34:	e50b3028 	str	r3, [fp, #-40]
21f05f38:	ea00000a 	b	21f05f68 <start_armboot+0xb4>
		if ((*init_fnc_ptr)() != 0) {
21f05f3c:	e51b3028 	ldr	r3, [fp, #-40]
21f05f40:	e5933000 	ldr	r3, [r3]
21f05f44:	e1a0e00f 	mov	lr, pc
21f05f48:	e1a0f003 	mov	pc, r3
21f05f4c:	e1a03000 	mov	r3, r0
21f05f50:	e3530000 	cmp	r3, #0	; 0x0
21f05f54:	0a000000 	beq	21f05f5c <start_armboot+0xa8>
			hang ();
21f05f58:	eb00008a 	bl	21f06188 <hang>
21f05f5c:	e51b3028 	ldr	r3, [fp, #-40]
21f05f60:	e2833004 	add	r3, r3, #4	; 0x4
21f05f64:	e50b3028 	str	r3, [fp, #-40]
21f05f68:	e51b3028 	ldr	r3, [fp, #-40]
21f05f6c:	e5933000 	ldr	r3, [r3]
21f05f70:	e3530000 	cmp	r3, #0	; 0x0
21f05f74:	1afffff0 	bne	21f05f3c <start_armboot+0x88>
		}
	}

#ifndef CFG_NO_FLASH
	/* configure available FLASH banks */
	size = flash_init ();
21f05f78:	eb00996f 	bl	21f2c53c <flash_init>
21f05f7c:	e1a03000 	mov	r3, r0
21f05f80:	e50b3020 	str	r3, [fp, #-32]
	display_flash_config (size);
21f05f84:	e51b0020 	ldr	r0, [fp, #-32]
21f05f88:	ebffffbc 	bl	21f05e80 <display_flash_config>
#endif /* CFG_NO_FLASH */

#ifdef CONFIG_VFD
#	ifndef PAGE_SIZE
#	  define PAGE_SIZE 4096
#	endif
	/*
	 * reserve memory for VFD display (always full pages)
	 */
	/* bss_end is defined in the board-specific linker script */
	addr = (_bss_end + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
	size = vfd_setmem (addr);
	gd->fb_base = addr;
#endif /* CONFIG_VFD */

#ifdef CONFIG_LCD
#	ifndef PAGE_SIZE
#	  define PAGE_SIZE 4096
#	endif
	/*
	 * reserve memory for LCD display (always full pages)
	 */
	/* bss_end is defined in the board-specific linker script */
	addr = (_bss_end + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);
	size = lcd_setmem (addr);
	gd->fb_base = addr;
#endif /* CONFIG_LCD */

	/* armboot_start is defined in the board-specific linker script */
	mem_malloc_init (_armboot_start - CFG_MALLOC_LEN);
21f05f8c:	e59f31cc 	ldr	r3, [pc, #460]	; 21f06160 <.text+0x6160>
21f05f90:	e5933000 	ldr	r3, [r3]
21f05f94:	e2433a22 	sub	r3, r3, #139264	; 0x22000
21f05f98:	e1a00003 	mov	r0, r3
21f05f9c:	ebffff17 	bl	21f05c00 <mem_malloc_init>

#if (CONFIG_COMMANDS & CFG_CMD_NAND)
	puts ("NAND:  ");
	nand_init();		/* go init the NAND */
#endif

#ifdef CONFIG_HAS_DATAFLASH
	AT91F_DataflashInit();
21f05fa0:	eb0025cc 	bl	21f0f6d8 <AT91F_DataflashInit>
	dataflash_print_info();
21f05fa4:	eb002833 	bl	21f10078 <dataflash_print_info>
#endif

	/* initialize environment */
	env_relocate ();
21f05fa8:	eb006380 	bl	21f1edb0 <env_relocate>

#ifdef CONFIG_VFD
	/* must do this after the framebuffer is allocated */
	drv_vfd_init();
#endif /* CONFIG_VFD */

	/* IP Address */
	gd->bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
21f05fac:	e1a03008 	mov	r3, r8
21f05fb0:	e5934000 	ldr	r4, [r3]
21f05fb4:	e59f01b4 	ldr	r0, [pc, #436]	; 21f06170 <.text+0x6170>
21f05fb8:	eb0012a9 	bl	21f0aa64 <getenv_IPaddr>
21f05fbc:	e1a03000 	mov	r3, r0
21f05fc0:	e5843004 	str	r3, [r4, #4]

	/* MAC Address */
	{
		int i;
		ulong reg;
		char *s, *e;
		char tmp[64];

		i = getenv_r ("ethaddr", tmp, sizeof (tmp));
21f05fc4:	e24b306c 	sub	r3, fp, #108	; 0x6c
21f05fc8:	e59f01a4 	ldr	r0, [pc, #420]	; 21f06174 <.text+0x6174>
21f05fcc:	e1a01003 	mov	r1, r3
21f05fd0:	e3a02040 	mov	r2, #64	; 0x40
21f05fd4:	eb00534d 	bl	21f1ad10 <getenv_r>
21f05fd8:	e1a03000 	mov	r3, r0
21f05fdc:	e50b301c 	str	r3, [fp, #-28]
		s = (i > 0) ? tmp : NULL;
21f05fe0:	e51b301c 	ldr	r3, [fp, #-28]
21f05fe4:	e3530000 	cmp	r3, #0	; 0x0
21f05fe8:	da000002 	ble	21f05ff8 <start_armboot+0x144>
21f05fec:	e24b006c 	sub	r0, fp, #108	; 0x6c
21f05ff0:	e50b0080 	str	r0, [fp, #-128]
21f05ff4:	ea000001 	b	21f06000 <start_armboot+0x14c>
21f05ff8:	e3a01000 	mov	r1, #0	; 0x0
21f05ffc:	e50b1080 	str	r1, [fp, #-128]
21f06000:	e51b3080 	ldr	r3, [fp, #-128]
21f06004:	e50b3014 	str	r3, [fp, #-20]

		for (reg = 0; reg < 6; ++reg) {
21f06008:	e3a03000 	mov	r3, #0	; 0x0
21f0600c:	e50b3018 	str	r3, [fp, #-24]
21f06010:	ea00002c 	b	21f060c8 <start_armboot+0x214>
			gd->bd->bi_enetaddr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
21f06014:	e1a03008 	mov	r3, r8
21f06018:	e5933000 	ldr	r3, [r3]
21f0601c:	e50b307c 	str	r3, [fp, #-124]
21f06020:	e51b0018 	ldr	r0, [fp, #-24]
21f06024:	e50b0078 	str	r0, [fp, #-120]
21f06028:	e51b3014 	ldr	r3, [fp, #-20]
21f0602c:	e3530000 	cmp	r3, #0	; 0x0
21f06030:	0a000008 	beq	21f06058 <start_armboot+0x1a4>
21f06034:	e24b302c 	sub	r3, fp, #44	; 0x2c
21f06038:	e51b0014 	ldr	r0, [fp, #-20]
21f0603c:	e1a01003 	mov	r1, r3
21f06040:	e3a02010 	mov	r2, #16	; 0x10
21f06044:	eb00755f 	bl	21f235c8 <simple_strtoul>
21f06048:	e1a03000 	mov	r3, r0
21f0604c:	e20330ff 	and	r3, r3, #255	; 0xff
21f06050:	e50b3074 	str	r3, [fp, #-116]
21f06054:	ea000001 	b	21f06060 <start_armboot+0x1ac>
21f06058:	e3a01000 	mov	r1, #0	; 0x0
21f0605c:	e50b1074 	str	r1, [fp, #-116]
21f06060:	e3a02008 	mov	r2, #8	; 0x8
21f06064:	e51b0078 	ldr	r0, [fp, #-120]
21f06068:	e51b107c 	ldr	r1, [fp, #-124]
21f0606c:	e0803001 	add	r3, r0, r1
21f06070:	e0832002 	add	r2, r3, r2
21f06074:	e51b0074 	ldr	r0, [fp, #-116]
21f06078:	e1a03000 	mov	r3, r0
21f0607c:	e5c23000 	strb	r3, [r2]
			if (s)
21f06080:	e51b3014 	ldr	r3, [fp, #-20]
21f06084:	e3530000 	cmp	r3, #0	; 0x0
21f06088:	0a00000b 	beq	21f060bc <start_armboot+0x208>
				s = (*e) ? e + 1 : e;
21f0608c:	e51b302c 	ldr	r3, [fp, #-44]
21f06090:	e5d33000 	ldrb	r3, [r3]
21f06094:	e3530000 	cmp	r3, #0	; 0x0
21f06098:	0a000003 	beq	21f060ac <start_armboot+0x1f8>
21f0609c:	e51b302c 	ldr	r3, [fp, #-44]
21f060a0:	e2833001 	add	r3, r3, #1	; 0x1
21f060a4:	e50b3070 	str	r3, [fp, #-112]
21f060a8:	ea000001 	b	21f060b4 <start_armboot+0x200>
21f060ac:	e51b102c 	ldr	r1, [fp, #-44]
21f060b0:	e50b1070 	str	r1, [fp, #-112]
21f060b4:	e51b3070 	ldr	r3, [fp, #-112]
21f060b8:	e50b3014 	str	r3, [fp, #-20]
21f060bc:	e51b3018 	ldr	r3, [fp, #-24]
21f060c0:	e2833001 	add	r3, r3, #1	; 0x1
21f060c4:	e50b3018 	str	r3, [fp, #-24]
21f060c8:	e51b3018 	ldr	r3, [fp, #-24]
21f060cc:	e3530005 	cmp	r3, #5	; 0x5
21f060d0:	9affffcf 	bls	21f06014 <start_armboot+0x160>
		}

#ifdef CONFIG_HAS_ETH1
		i = getenv_r ("eth1addr", tmp, sizeof (tmp));
		s = (i > 0) ? tmp : NULL;

		for (reg = 0; reg < 6; ++reg) {
			gd->bd->bi_enet1addr[reg] = s ? simple_strtoul (s, &e, 16) : 0;
			if (s)
				s = (*e) ? e + 1 : e;
		}
#endif
	}

	devices_init ();	/* get the devices list going. */
21f060d4:	eb005803 	bl	21f1c0e8 <devices_init>

#ifdef CONFIG_CMC_PU2
	load_sernum_ethaddr ();
#endif /* CONFIG_CMC_PU2 */

	jumptable_init ();
21f060d8:	eb0063fc 	bl	21f1f0d0 <jumptable_init>

	console_init_r ();	/* fully init console as a device */
21f060dc:	eb005732 	bl	21f1bdac <console_init_r>

#if defined(CONFIG_MISC_INIT_R)
	/* miscellaneous platform dependent initialisations */
	misc_init_r ();
#endif

	/* enable exceptions */
	enable_interrupts ();
21f060e0:	ebffe8a6 	bl	21f00380 <enable_interrupts>

	/* Perform network card initialisation if necessary */
#ifdef CONFIG_DRIVER_CS8900
	cs8900_get_enetaddr (gd->bd->bi_enetaddr);
#endif

#if defined(CONFIG_DRIVER_SMC91111) || defined (CONFIG_DRIVER_LAN91C96)
	if (getenv ("ethaddr")) {
		smc_set_mac_addr(gd->bd->bi_enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	if ((s = getenv ("loadaddr")) != NULL) {
21f060e4:	e59f008c 	ldr	r0, [pc, #140]	; 21f06178 <.text+0x6178>
21f060e8:	eb0052ca 	bl	21f1ac18 <getenv>
21f060ec:	e1a03000 	mov	r3, r0
21f060f0:	e50b3024 	str	r3, [fp, #-36]
21f060f4:	e51b3024 	ldr	r3, [fp, #-36]
21f060f8:	e3530000 	cmp	r3, #0	; 0x0
21f060fc:	0a000006 	beq	21f0611c <start_armboot+0x268>
		load_addr = simple_strtoul (s, NULL, 16);
21f06100:	e51b0024 	ldr	r0, [fp, #-36]
21f06104:	e3a01000 	mov	r1, #0	; 0x0
21f06108:	e3a02010 	mov	r2, #16	; 0x10
21f0610c:	eb00752d 	bl	21f235c8 <simple_strtoul>
21f06110:	e1a02000 	mov	r2, r0
21f06114:	e59f3060 	ldr	r3, [pc, #96]	; 21f0617c <.text+0x617c>
21f06118:	e5832000 	str	r2, [r3]
	}
#if (CONFIG_COMMANDS & CFG_CMD_NET)
	if ((s = getenv ("bootfile")) != NULL) {
21f0611c:	e59f005c 	ldr	r0, [pc, #92]	; 21f06180 <.text+0x6180>
21f06120:	eb0052bc 	bl	21f1ac18 <getenv>
21f06124:	e1a03000 	mov	r3, r0
21f06128:	e50b3024 	str	r3, [fp, #-36]
21f0612c:	e51b3024 	ldr	r3, [fp, #-36]
21f06130:	e3530000 	cmp	r3, #0	; 0x0
21f06134:	0a000003 	beq	21f06148 <start_armboot+0x294>
		copy_filename (BootFile, s, sizeof (BootFile));
21f06138:	e59f0044 	ldr	r0, [pc, #68]	; 21f06184 <.text+0x6184>
21f0613c:	e51b1024 	ldr	r1, [fp, #-36]
21f06140:	e3a02080 	mov	r2, #128	; 0x80
21f06144:	eb00113d 	bl	21f0a640 <copy_filename>
	}
#endif	/* CFG_CMD_NET */

#ifdef BOARD_LATE_INIT
	board_late_init ();
#endif
#if (CONFIG_COMMANDS & CFG_CMD_NET)
#if defined(CONFIG_NET_MULTI)
	puts ("Net:   ");
#endif
	eth_initialize(gd->bd);
21f06148:	e1a03008 	mov	r3, r8
21f0614c:	e5933000 	ldr	r3, [r3]
21f06150:	e1a00003 	mov	r0, r3
21f06154:	eb001b02 	bl	21f0cd64 <eth_initialize>
#endif
	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;) {
		main_loop ();
21f06158:	eb002ad7 	bl	21f10cbc <main_loop>
	}
21f0615c:	eafffffd 	b	21f06158 <start_armboot+0x2a4>
21f06160:	21f00044 	mvncss	r0, r4, asr #32
21f06164:	21f00048 	mvncss	r0, r8, asr #32
21f06168:	21f34498 	ldrcsb	r4, [r3, #72]!
21f0616c:	21f3319c 	ldrcsb	r3, [r3, #28]!
21f06170:	21f2f294 	ldrcsb	pc, [r2, #36]!
21f06174:	21f2f29c 	ldrcsb	pc, [r2, #44]!
21f06178:	21f2f2a4 	mvncss	pc, r4, lsr #5
21f0617c:	21f3322c 	mvncss	r3, ip, lsr #4
21f06180:	21f2f2b0 	ldrcsh	pc, [r2, #32]!
21f06184:	21f64584 	mvncss	r4, r4, lsl #11

21f06188 <hang>:

	/* NOTREACHED - no way out of command loop except booting */
}

void hang (void)
{
21f06188:	e1a0c00d 	mov	ip, sp
21f0618c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f06190:	e24cb004 	sub	fp, ip, #4	; 0x4
	puts ("### ERROR ### Please RESET the board ###\n");
21f06194:	e59f0004 	ldr	r0, [pc, #4]	; 21f061a0 <.text+0x61a0>
21f06198:	eb005628 	bl	21f1ba40 <puts>
	for (;;);
21f0619c:	eafffffe 	b	21f0619c <hang+0x14>
21f061a0:	21f2f2bc 	ldrcsh	pc, [r2, #44]!

21f061a4 <__div0>:
 */

/* Replacement (=dummy) for GNU/Linux division-by zero handler */
void __div0 (void)
{
21f061a4:	e1a0c00d 	mov	ip, sp
21f061a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f061ac:	e24cb004 	sub	fp, ip, #4	; 0x4
	extern void hang (void);

	hang();
21f061b0:	ebfffff4 	bl	21f06188 <hang>
}
21f061b4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f061b8 <downcase>:
 * Convert a string to lowercase.
 */
static void
downcase(char *str)
{
21f061b8:	e1a0c00d 	mov	ip, sp
21f061bc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f061c0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f061c4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f061c8:	e50b0010 	str	r0, [fp, #-16]
	while (*str != '\0') {
21f061cc:	ea000012 	b	21f0621c <downcase+0x64>
		TOLOWER(*str);
21f061d0:	e51b3010 	ldr	r3, [fp, #-16]
21f061d4:	e5d33000 	ldrb	r3, [r3]
21f061d8:	e3530040 	cmp	r3, #64	; 0x40
21f061dc:	9a00000b 	bls	21f06210 <downcase+0x58>
21f061e0:	e51b3010 	ldr	r3, [fp, #-16]
21f061e4:	e5d33000 	ldrb	r3, [r3]
21f061e8:	e353005a 	cmp	r3, #90	; 0x5a
21f061ec:	8a000007 	bhi	21f06210 <downcase+0x58>
21f061f0:	e51b3010 	ldr	r3, [fp, #-16]
21f061f4:	e5d33000 	ldrb	r3, [r3]
21f061f8:	e20330ff 	and	r3, r3, #255	; 0xff
21f061fc:	e2833020 	add	r3, r3, #32	; 0x20
21f06200:	e20330ff 	and	r3, r3, #255	; 0xff
21f06204:	e20330ff 	and	r3, r3, #255	; 0xff
21f06208:	e51b2010 	ldr	r2, [fp, #-16]
21f0620c:	e5c23000 	strb	r3, [r2]
		str++;
21f06210:	e51b3010 	ldr	r3, [fp, #-16]
21f06214:	e2833001 	add	r3, r3, #1	; 0x1
21f06218:	e50b3010 	str	r3, [fp, #-16]
21f0621c:	e51b3010 	ldr	r3, [fp, #-16]
21f06220:	e5d33000 	ldrb	r3, [r3]
21f06224:	e3530000 	cmp	r3, #0	; 0x0
21f06228:	1affffe8 	bne	21f061d0 <downcase+0x18>
	}
}
21f0622c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f06230 <disk_read>:

static  block_dev_desc_t *cur_dev = NULL;
static unsigned long part_offset = 0;
static int cur_part = 1;

#define DOS_PART_TBL_OFFSET	0x1be
#define DOS_PART_MAGIC_OFFSET	0x1fe
#define DOS_FS_TYPE_OFFSET	0x36

int disk_read (__u32 startblock, __u32 getsize, __u8 * bufptr)
{
21f06230:	e1a0c00d 	mov	ip, sp
21f06234:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f06238:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0623c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f06240:	e50b0014 	str	r0, [fp, #-20]
21f06244:	e50b1018 	str	r1, [fp, #-24]
21f06248:	e50b201c 	str	r2, [fp, #-28]
	startblock += part_offset;
21f0624c:	e59f3094 	ldr	r3, [pc, #148]	; 21f062e8 <.text+0x62e8>
21f06250:	e5932000 	ldr	r2, [r3]
21f06254:	e51b3014 	ldr	r3, [fp, #-20]
21f06258:	e0833002 	add	r3, r3, r2
21f0625c:	e50b3014 	str	r3, [fp, #-20]
	if (cur_dev == NULL)
21f06260:	e59f3084 	ldr	r3, [pc, #132]	; 21f062ec <.text+0x62ec>
21f06264:	e5933000 	ldr	r3, [r3]
21f06268:	e3530000 	cmp	r3, #0	; 0x0
21f0626c:	1a000002 	bne	21f0627c <disk_read+0x4c>
		return -1;
21f06270:	e3e03000 	mvn	r3, #0	; 0x0
21f06274:	e50b3020 	str	r3, [fp, #-32]
21f06278:	ea000016 	b	21f062d8 <disk_read+0xa8>
	if (cur_dev->block_read) {
21f0627c:	e59f3068 	ldr	r3, [pc, #104]	; 21f062ec <.text+0x62ec>
21f06280:	e5933000 	ldr	r3, [r3]
21f06284:	e5933060 	ldr	r3, [r3, #96]
21f06288:	e3530000 	cmp	r3, #0	; 0x0
21f0628c:	0a00000f 	beq	21f062d0 <disk_read+0xa0>
		return cur_dev->block_read (cur_dev->dev, startblock, getsize, (unsigned long *)bufptr);
21f06290:	e59f3054 	ldr	r3, [pc, #84]	; 21f062ec <.text+0x62ec>
21f06294:	e5933000 	ldr	r3, [r3]
21f06298:	e5934060 	ldr	r4, [r3, #96]
21f0629c:	e59f3048 	ldr	r3, [pc, #72]	; 21f062ec <.text+0x62ec>
21f062a0:	e5933000 	ldr	r3, [r3]
21f062a4:	e5933004 	ldr	r3, [r3, #4]
21f062a8:	e51bc01c 	ldr	ip, [fp, #-28]
21f062ac:	e1a00003 	mov	r0, r3
21f062b0:	e51b1014 	ldr	r1, [fp, #-20]
21f062b4:	e51b2018 	ldr	r2, [fp, #-24]
21f062b8:	e1a0300c 	mov	r3, ip
21f062bc:	e1a0e00f 	mov	lr, pc
21f062c0:	e1a0f004 	mov	pc, r4
21f062c4:	e1a03000 	mov	r3, r0
21f062c8:	e50b3020 	str	r3, [fp, #-32]
21f062cc:	ea000001 	b	21f062d8 <disk_read+0xa8>
	}
	return -1;
21f062d0:	e3e03000 	mvn	r3, #0	; 0x0
21f062d4:	e50b3020 	str	r3, [fp, #-32]
21f062d8:	e51b3020 	ldr	r3, [fp, #-32]
}
21f062dc:	e1a00003 	mov	r0, r3
21f062e0:	e24bd010 	sub	sp, fp, #16	; 0x10
21f062e4:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f062e8:	21f644ac 	mvncss	r4, ip, lsr #9
21f062ec:	21f644a8 	mvncss	r4, r8, lsr #9

21f062f0 <fat_register_device>:


int
fat_register_device(block_dev_desc_t *dev_desc, int part_no)
{
21f062f0:	e1a0c00d 	mov	ip, sp
21f062f4:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f062f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f062fc:	e24ddf96 	sub	sp, sp, #600	; 0x258
21f06300:	e50b0260 	str	r0, [fp, #-608]
21f06304:	e50b1264 	str	r1, [fp, #-612]
	unsigned char buffer[SECTOR_SIZE];

	if (!dev_desc->block_read)
21f06308:	e51b3260 	ldr	r3, [fp, #-608]
21f0630c:	e5933060 	ldr	r3, [r3, #96]
21f06310:	e3530000 	cmp	r3, #0	; 0x0
21f06314:	1a000002 	bne	21f06324 <fat_register_device+0x34>
		return -1;
21f06318:	e3e03000 	mvn	r3, #0	; 0x0
21f0631c:	e50b3268 	str	r3, [fp, #-616]
21f06320:	ea00004b 	b	21f06454 <fat_register_device+0x164>
	cur_dev=dev_desc;
21f06324:	e59f2138 	ldr	r2, [pc, #312]	; 21f06464 <.text+0x6464>
21f06328:	e51b3260 	ldr	r3, [fp, #-608]
21f0632c:	e5823000 	str	r3, [r2]
	/* check if we have a MBR (on floppies we have only a PBR) */
	if (dev_desc->block_read (dev_desc->dev, 0, 1, (ulong *) buffer) != 1) {
21f06330:	e51b3260 	ldr	r3, [fp, #-608]
21f06334:	e5934060 	ldr	r4, [r3, #96]
21f06338:	e51b3260 	ldr	r3, [fp, #-608]
21f0633c:	e5933004 	ldr	r3, [r3, #4]
21f06340:	e24bce21 	sub	ip, fp, #528	; 0x210
21f06344:	e1a00003 	mov	r0, r3
21f06348:	e3a01000 	mov	r1, #0	; 0x0
21f0634c:	e3a02001 	mov	r2, #1	; 0x1
21f06350:	e1a0300c 	mov	r3, ip
21f06354:	e1a0e00f 	mov	lr, pc
21f06358:	e1a0f004 	mov	pc, r4
21f0635c:	e1a03000 	mov	r3, r0
21f06360:	e3530001 	cmp	r3, #1	; 0x1
21f06364:	0a000007 	beq	21f06388 <fat_register_device+0x98>
		printf ("** Can't read from device %d **\n", dev_desc->dev);
21f06368:	e51b3260 	ldr	r3, [fp, #-608]
21f0636c:	e5933004 	ldr	r3, [r3, #4]
21f06370:	e59f00f0 	ldr	r0, [pc, #240]	; 21f06468 <.text+0x6468>
21f06374:	e1a01003 	mov	r1, r3
21f06378:	eb0055c3 	bl	21f1ba8c <printf>
		return -1;
21f0637c:	e3e03000 	mvn	r3, #0	; 0x0
21f06380:	e50b3268 	str	r3, [fp, #-616]
21f06384:	ea000032 	b	21f06454 <fat_register_device+0x164>
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
21f06388:	e55b3012 	ldrb	r3, [fp, #-18]
21f0638c:	e3530055 	cmp	r3, #85	; 0x55
21f06390:	1a000002 	bne	21f063a0 <fat_register_device+0xb0>
21f06394:	e55b3011 	ldrb	r3, [fp, #-17]
21f06398:	e35300aa 	cmp	r3, #170	; 0xaa
21f0639c:	0a000002 	beq	21f063ac <fat_register_device+0xbc>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		/* no signature found */
		return -1;
21f063a0:	e3e03000 	mvn	r3, #0	; 0x0
21f063a4:	e50b3268 	str	r3, [fp, #-616]
21f063a8:	ea000029 	b	21f06454 <fat_register_device+0x164>
	}
	if(!strncmp((char *)&buffer[DOS_FS_TYPE_OFFSET],"FAT",3)) {
21f063ac:	e24b3e21 	sub	r3, fp, #528	; 0x210
21f063b0:	e2833036 	add	r3, r3, #54	; 0x36
21f063b4:	e1a00003 	mov	r0, r3
21f063b8:	e59f10ac 	ldr	r1, [pc, #172]	; 21f0646c <.text+0x646c>
21f063bc:	e3a02003 	mov	r2, #3	; 0x3
21f063c0:	eb00718b 	bl	21f229f4 <strncmp>
21f063c4:	e1a03000 	mov	r3, r0
21f063c8:	e3530000 	cmp	r3, #0	; 0x0
21f063cc:	1a000006 	bne	21f063ec <fat_register_device+0xfc>
		/* ok, we assume we are on a PBR only */
		cur_part = 1;
21f063d0:	e59f2098 	ldr	r2, [pc, #152]	; 21f06470 <.text+0x6470>
21f063d4:	e3a03001 	mov	r3, #1	; 0x1
21f063d8:	e5823000 	str	r3, [r2]
		part_offset=0;
21f063dc:	e59f2090 	ldr	r2, [pc, #144]	; 21f06474 <.text+0x6474>
21f063e0:	e3a03000 	mov	r3, #0	; 0x0
21f063e4:	e5823000 	str	r3, [r2]
21f063e8:	ea000017 	b	21f0644c <fat_register_device+0x15c>
	}
	else {
#if (CONFIG_COMMANDS & CFG_CMD_IDE) || (CONFIG_COMMANDS & CFG_CMD_SCSI) || \
    (CONFIG_COMMANDS & CFG_CMD_USB) || defined(CONFIG_SYSTEMACE) || defined (CONFIG_MMC)
		disk_partition_t info;
		if(!get_partition_info(dev_desc, part_no, &info)) {
21f063ec:	e24b3f97 	sub	r3, fp, #604	; 0x25c
21f063f0:	e51b0260 	ldr	r0, [fp, #-608]
21f063f4:	e51b1264 	ldr	r1, [fp, #-612]
21f063f8:	e1a02003 	mov	r2, r3
21f063fc:	eb0021e3 	bl	21f0eb90 <get_partition_info>
21f06400:	e1a03000 	mov	r3, r0
21f06404:	e3530000 	cmp	r3, #0	; 0x0
21f06408:	1a000006 	bne	21f06428 <fat_register_device+0x138>
			part_offset = info.start;
21f0640c:	e51b225c 	ldr	r2, [fp, #-604]
21f06410:	e59f305c 	ldr	r3, [pc, #92]	; 21f06474 <.text+0x6474>
21f06414:	e5832000 	str	r2, [r3]
			cur_part = part_no;
21f06418:	e59f2050 	ldr	r2, [pc, #80]	; 21f06470 <.text+0x6470>
21f0641c:	e51b3264 	ldr	r3, [fp, #-612]
21f06420:	e5823000 	str	r3, [r2]
21f06424:	ea000008 	b	21f0644c <fat_register_device+0x15c>
		}
		else {
			printf ("** Partition %d not valid on device %d **\n",part_no,dev_desc->dev);
21f06428:	e51b3260 	ldr	r3, [fp, #-608]
21f0642c:	e5933004 	ldr	r3, [r3, #4]
21f06430:	e59f0040 	ldr	r0, [pc, #64]	; 21f06478 <.text+0x6478>
21f06434:	e51b1264 	ldr	r1, [fp, #-612]
21f06438:	e1a02003 	mov	r2, r3
21f0643c:	eb005592 	bl	21f1ba8c <printf>
			return -1;
21f06440:	e3e03000 	mvn	r3, #0	; 0x0
21f06444:	e50b3268 	str	r3, [fp, #-616]
21f06448:	ea000001 	b	21f06454 <fat_register_device+0x164>
		}
#else
		/* FIXME we need to determine the start block of the
		 * partition where the DOS FS resides. This can be done
		 * by using the get_partition_info routine. For this
		 * purpose the libpart must be included.
		 */
		part_offset=32;
		cur_part = 1;
#endif
	}
	return 0;
21f0644c:	e3a03000 	mov	r3, #0	; 0x0
21f06450:	e50b3268 	str	r3, [fp, #-616]
21f06454:	e51b3268 	ldr	r3, [fp, #-616]
}
21f06458:	e1a00003 	mov	r0, r3
21f0645c:	e24bd010 	sub	sp, fp, #16	; 0x10
21f06460:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f06464:	21f644a8 	mvncss	r4, r8, lsr #9
21f06468:	21f2f2e8 	mvncss	pc, r8, ror #5
21f0646c:	21f2f30c 	mvncss	pc, ip, lsl #6
21f06470:	21f331c8 	mvncss	r3, r8, asr #3
21f06474:	21f644ac 	mvncss	r4, ip, lsr #9
21f06478:	21f2f310 	mvncss	pc, r0, lsl r3

21f0647c <dirdelim>:


/*
 * Get the first occurence of a directory delimiter ('/' or '\') in a string.
 * Return index into string if found, -1 otherwise.
 */
static int
dirdelim(char *str)
{
21f0647c:	e1a0c00d 	mov	ip, sp
21f06480:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f06484:	e24cb004 	sub	fp, ip, #4	; 0x4
21f06488:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0648c:	e50b0014 	str	r0, [fp, #-20]
	char *start = str;
21f06490:	e51b3014 	ldr	r3, [fp, #-20]
21f06494:	e50b3010 	str	r3, [fp, #-16]

	while (*str != '\0') {
21f06498:	ea00000f 	b	21f064dc <dirdelim+0x60>
		if (ISDIRDELIM(*str)) return str - start;
21f0649c:	e51b3014 	ldr	r3, [fp, #-20]
21f064a0:	e5d33000 	ldrb	r3, [r3]
21f064a4:	e353002f 	cmp	r3, #47	; 0x2f
21f064a8:	0a000003 	beq	21f064bc <dirdelim+0x40>
21f064ac:	e51b3014 	ldr	r3, [fp, #-20]
21f064b0:	e5d33000 	ldrb	r3, [r3]
21f064b4:	e353005c 	cmp	r3, #92	; 0x5c
21f064b8:	1a000004 	bne	21f064d0 <dirdelim+0x54>
21f064bc:	e51b2014 	ldr	r2, [fp, #-20]
21f064c0:	e51b3010 	ldr	r3, [fp, #-16]
21f064c4:	e0632002 	rsb	r2, r3, r2
21f064c8:	e50b2018 	str	r2, [fp, #-24]
21f064cc:	ea000008 	b	21f064f4 <dirdelim+0x78>
		str++;
21f064d0:	e51b3014 	ldr	r3, [fp, #-20]
21f064d4:	e2833001 	add	r3, r3, #1	; 0x1
21f064d8:	e50b3014 	str	r3, [fp, #-20]
21f064dc:	e51b3014 	ldr	r3, [fp, #-20]
21f064e0:	e5d33000 	ldrb	r3, [r3]
21f064e4:	e3530000 	cmp	r3, #0	; 0x0
21f064e8:	1affffeb 	bne	21f0649c <dirdelim+0x20>
	}
	return -1;
21f064ec:	e3e03000 	mvn	r3, #0	; 0x0
21f064f0:	e50b3018 	str	r3, [fp, #-24]
21f064f4:	e51b3018 	ldr	r3, [fp, #-24]
}
21f064f8:	e1a00003 	mov	r0, r3
21f064fc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f06500:	e89da800 	ldmia	sp, {fp, sp, pc}

21f06504 <compare_sign>:


/*
 * Match volume_info fs_type strings.
 * Return 0 on match, -1 otherwise.
 */
static int
compare_sign(char *str1, char *str2)
{
21f06504:	e1a0c00d 	mov	ip, sp
21f06508:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0650c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f06510:	e24dd010 	sub	sp, sp, #16	; 0x10
21f06514:	e50b0014 	str	r0, [fp, #-20]
21f06518:	e50b1018 	str	r1, [fp, #-24]
	char *end = str1+SIGNLEN;
21f0651c:	e51b3014 	ldr	r3, [fp, #-20]
21f06520:	e2833008 	add	r3, r3, #8	; 0x8
21f06524:	e50b3010 	str	r3, [fp, #-16]

	while (str1 != end) {
21f06528:	ea00000e 	b	21f06568 <compare_sign+0x64>
		if (*str1 != *str2) {
21f0652c:	e51b3014 	ldr	r3, [fp, #-20]
21f06530:	e5d32000 	ldrb	r2, [r3]
21f06534:	e51b3018 	ldr	r3, [fp, #-24]
21f06538:	e5d33000 	ldrb	r3, [r3]
21f0653c:	e1520003 	cmp	r2, r3
21f06540:	0a000002 	beq	21f06550 <compare_sign+0x4c>
			return -1;
21f06544:	e3e03000 	mvn	r3, #0	; 0x0
21f06548:	e50b301c 	str	r3, [fp, #-28]
21f0654c:	ea00000b 	b	21f06580 <compare_sign+0x7c>
		}
		str1++;
21f06550:	e51b3014 	ldr	r3, [fp, #-20]
21f06554:	e2833001 	add	r3, r3, #1	; 0x1
21f06558:	e50b3014 	str	r3, [fp, #-20]
		str2++;
21f0655c:	e51b3018 	ldr	r3, [fp, #-24]
21f06560:	e2833001 	add	r3, r3, #1	; 0x1
21f06564:	e50b3018 	str	r3, [fp, #-24]
21f06568:	e51b2014 	ldr	r2, [fp, #-20]
21f0656c:	e51b3010 	ldr	r3, [fp, #-16]
21f06570:	e1520003 	cmp	r2, r3
21f06574:	1affffec 	bne	21f0652c <compare_sign+0x28>
	}

	return 0;
21f06578:	e3a03000 	mov	r3, #0	; 0x0
21f0657c:	e50b301c 	str	r3, [fp, #-28]
21f06580:	e51b301c 	ldr	r3, [fp, #-28]
}
21f06584:	e1a00003 	mov	r0, r3
21f06588:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0658c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f06590 <get_name>:


/*
 * Extract zero terminated short name from a directory entry.
 */
static void get_name (dir_entry *dirent, char *s_name)
{
21f06590:	e1a0c00d 	mov	ip, sp
21f06594:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f06598:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0659c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f065a0:	e50b0014 	str	r0, [fp, #-20]
21f065a4:	e50b1018 	str	r1, [fp, #-24]
	char *ptr;

	memcpy (s_name, dirent->name, 8);
21f065a8:	e51b3014 	ldr	r3, [fp, #-20]
21f065ac:	e51b0018 	ldr	r0, [fp, #-24]
21f065b0:	e1a01003 	mov	r1, r3
21f065b4:	e3a02008 	mov	r2, #8	; 0x8
21f065b8:	eb007303 	bl	21f231cc <memcpy>
	s_name[8] = '\0';
21f065bc:	e51b3018 	ldr	r3, [fp, #-24]
21f065c0:	e2832008 	add	r2, r3, #8	; 0x8
21f065c4:	e3a03000 	mov	r3, #0	; 0x0
21f065c8:	e5c23000 	strb	r3, [r2]
	ptr = s_name;
21f065cc:	e51b3018 	ldr	r3, [fp, #-24]
21f065d0:	e50b3010 	str	r3, [fp, #-16]
	while (*ptr && *ptr != ' ')
21f065d4:	ea000002 	b	21f065e4 <get_name+0x54>
		ptr++;
21f065d8:	e51b3010 	ldr	r3, [fp, #-16]
21f065dc:	e2833001 	add	r3, r3, #1	; 0x1
21f065e0:	e50b3010 	str	r3, [fp, #-16]
21f065e4:	e51b3010 	ldr	r3, [fp, #-16]
21f065e8:	e5d33000 	ldrb	r3, [r3]
21f065ec:	e3530000 	cmp	r3, #0	; 0x0
21f065f0:	0a000003 	beq	21f06604 <get_name+0x74>
21f065f4:	e51b3010 	ldr	r3, [fp, #-16]
21f065f8:	e5d33000 	ldrb	r3, [r3]
21f065fc:	e3530020 	cmp	r3, #32	; 0x20
21f06600:	1afffff4 	bne	21f065d8 <get_name+0x48>
	if (dirent->ext[0] && dirent->ext[0] != ' ') {
21f06604:	e51b3014 	ldr	r3, [fp, #-20]
21f06608:	e5d33008 	ldrb	r3, [r3, #8]
21f0660c:	e3530000 	cmp	r3, #0	; 0x0
21f06610:	0a00001f 	beq	21f06694 <get_name+0x104>
21f06614:	e51b3014 	ldr	r3, [fp, #-20]
21f06618:	e5d33008 	ldrb	r3, [r3, #8]
21f0661c:	e3530020 	cmp	r3, #32	; 0x20
21f06620:	0a00001b 	beq	21f06694 <get_name+0x104>
		*ptr = '.';
21f06624:	e51b2010 	ldr	r2, [fp, #-16]
21f06628:	e3a0302e 	mov	r3, #46	; 0x2e
21f0662c:	e5c23000 	strb	r3, [r2]
		ptr++;
21f06630:	e51b3010 	ldr	r3, [fp, #-16]
21f06634:	e2833001 	add	r3, r3, #1	; 0x1
21f06638:	e50b3010 	str	r3, [fp, #-16]
		memcpy (ptr, dirent->ext, 3);
21f0663c:	e51b3014 	ldr	r3, [fp, #-20]
21f06640:	e2833008 	add	r3, r3, #8	; 0x8
21f06644:	e51b0010 	ldr	r0, [fp, #-16]
21f06648:	e1a01003 	mov	r1, r3
21f0664c:	e3a02003 	mov	r2, #3	; 0x3
21f06650:	eb0072dd 	bl	21f231cc <memcpy>
		ptr[3] = '\0';
21f06654:	e51b3010 	ldr	r3, [fp, #-16]
21f06658:	e2832003 	add	r2, r3, #3	; 0x3
21f0665c:	e3a03000 	mov	r3, #0	; 0x0
21f06660:	e5c23000 	strb	r3, [r2]
		while (*ptr && *ptr != ' ')
21f06664:	ea000002 	b	21f06674 <get_name+0xe4>
			ptr++;
21f06668:	e51b3010 	ldr	r3, [fp, #-16]
21f0666c:	e2833001 	add	r3, r3, #1	; 0x1
21f06670:	e50b3010 	str	r3, [fp, #-16]
21f06674:	e51b3010 	ldr	r3, [fp, #-16]
21f06678:	e5d33000 	ldrb	r3, [r3]
21f0667c:	e3530000 	cmp	r3, #0	; 0x0
21f06680:	0a000003 	beq	21f06694 <get_name+0x104>
21f06684:	e51b3010 	ldr	r3, [fp, #-16]
21f06688:	e5d33000 	ldrb	r3, [r3]
21f0668c:	e3530020 	cmp	r3, #32	; 0x20
21f06690:	1afffff4 	bne	21f06668 <get_name+0xd8>
	}
	*ptr = '\0';
21f06694:	e51b2010 	ldr	r2, [fp, #-16]
21f06698:	e3a03000 	mov	r3, #0	; 0x0
21f0669c:	e5c23000 	strb	r3, [r2]
	if (*s_name == DELETED_FLAG)
21f066a0:	e51b3018 	ldr	r3, [fp, #-24]
21f066a4:	e5d33000 	ldrb	r3, [r3]
21f066a8:	e35300e5 	cmp	r3, #229	; 0xe5
21f066ac:	1a000003 	bne	21f066c0 <get_name+0x130>
		*s_name = '\0';
21f066b0:	e51b3018 	ldr	r3, [fp, #-24]
21f066b4:	e3a02000 	mov	r2, #0	; 0x0
21f066b8:	e5c32000 	strb	r2, [r3]
21f066bc:	ea000006 	b	21f066dc <get_name+0x14c>
	else if (*s_name == aRING)
21f066c0:	e51b3018 	ldr	r3, [fp, #-24]
21f066c4:	e5d33000 	ldrb	r3, [r3]
21f066c8:	e3530005 	cmp	r3, #5	; 0x5
21f066cc:	1a000002 	bne	21f066dc <get_name+0x14c>
		*s_name = '';
21f066d0:	e51b3018 	ldr	r3, [fp, #-24]
21f066d4:	e3e0201a 	mvn	r2, #26	; 0x1a
21f066d8:	e5c32000 	strb	r2, [r3]
	downcase (s_name);
21f066dc:	e51b0018 	ldr	r0, [fp, #-24]
21f066e0:	ebfffeb4 	bl	21f061b8 <downcase>
}
21f066e4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f066e8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f066ec <get_fatent>:

/*
 * Get the entry at index 'entry' in a FAT (12/16/32) table.
 * On failure 0x00 is returned.
 */
static __u32
get_fatent(fsdata *mydata, __u32 entry)
{
21f066ec:	e1a0c00d 	mov	ip, sp
21f066f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f066f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f066f8:	e24dd038 	sub	sp, sp, #56	; 0x38
21f066fc:	e50b0034 	str	r0, [fp, #-52]
21f06700:	e50b1038 	str	r1, [fp, #-56]
	__u32 bufnum;
	__u32 offset;
	__u32 ret = 0x00;
21f06704:	e3a03000 	mov	r3, #0	; 0x0
21f06708:	e50b3028 	str	r3, [fp, #-40]

	switch (mydata->fatsize) {
21f0670c:	e51b3034 	ldr	r3, [fp, #-52]
21f06710:	e5933c00 	ldr	r3, [r3, #3072]
21f06714:	e50b3044 	str	r3, [fp, #-68]
21f06718:	e51b1044 	ldr	r1, [fp, #-68]
21f0671c:	e3510010 	cmp	r1, #16	; 0x10
21f06720:	0a000015 	beq	21f0677c <get_fatent+0x90>
21f06724:	e51b3044 	ldr	r3, [fp, #-68]
21f06728:	e3530020 	cmp	r3, #32	; 0x20
21f0672c:	0a000003 	beq	21f06740 <get_fatent+0x54>
21f06730:	e51b1044 	ldr	r1, [fp, #-68]
21f06734:	e351000c 	cmp	r1, #12	; 0xc
21f06738:	0a00001e 	beq	21f067b8 <get_fatent+0xcc>
21f0673c:	ea000026 	b	21f067dc <get_fatent+0xf0>
	case 32:
		bufnum = entry / FAT32BUFSIZE;
21f06740:	e51b2038 	ldr	r2, [fp, #-56]
21f06744:	e59f3398 	ldr	r3, [pc, #920]	; 21f06ae4 <.text+0x6ae4>
21f06748:	e0831392 	umull	r1, r3, r2, r3
21f0674c:	e1a034a3 	mov	r3, r3, lsr #9
21f06750:	e50b3030 	str	r3, [fp, #-48]
		offset = entry - bufnum * FAT32BUFSIZE;
21f06754:	e51b2030 	ldr	r2, [fp, #-48]
21f06758:	e1a03002 	mov	r3, r2
21f0675c:	e1a03083 	mov	r3, r3, lsl #1
21f06760:	e0833002 	add	r3, r3, r2
21f06764:	e1a03403 	mov	r3, r3, lsl #8
21f06768:	e1a02003 	mov	r2, r3
21f0676c:	e51b3038 	ldr	r3, [fp, #-56]
21f06770:	e0623003 	rsb	r3, r2, r3
21f06774:	e50b302c 	str	r3, [fp, #-44]
		break;
21f06778:	ea00001a 	b	21f067e8 <get_fatent+0xfc>
	case 16:
		bufnum = entry / FAT16BUFSIZE;
21f0677c:	e51b2038 	ldr	r2, [fp, #-56]
21f06780:	e59f335c 	ldr	r3, [pc, #860]	; 21f06ae4 <.text+0x6ae4>
21f06784:	e0831392 	umull	r1, r3, r2, r3
21f06788:	e1a03523 	mov	r3, r3, lsr #10
21f0678c:	e50b3030 	str	r3, [fp, #-48]
		offset = entry - bufnum * FAT16BUFSIZE;
21f06790:	e51b2030 	ldr	r2, [fp, #-48]
21f06794:	e1a03002 	mov	r3, r2
21f06798:	e1a03083 	mov	r3, r3, lsl #1
21f0679c:	e0833002 	add	r3, r3, r2
21f067a0:	e1a03483 	mov	r3, r3, lsl #9
21f067a4:	e1a02003 	mov	r2, r3
21f067a8:	e51b3038 	ldr	r3, [fp, #-56]
21f067ac:	e0623003 	rsb	r3, r2, r3
21f067b0:	e50b302c 	str	r3, [fp, #-44]
		break;
21f067b4:	ea00000b 	b	21f067e8 <get_fatent+0xfc>
	case 12:
		bufnum = entry / FAT12BUFSIZE;
21f067b8:	e51b3038 	ldr	r3, [fp, #-56]
21f067bc:	e1a035a3 	mov	r3, r3, lsr #11
21f067c0:	e50b3030 	str	r3, [fp, #-48]
		offset = entry - bufnum * FAT12BUFSIZE;
21f067c4:	e51b3030 	ldr	r3, [fp, #-48]
21f067c8:	e1a02583 	mov	r2, r3, lsl #11
21f067cc:	e51b3038 	ldr	r3, [fp, #-56]
21f067d0:	e0623003 	rsb	r3, r2, r3
21f067d4:	e50b302c 	str	r3, [fp, #-44]
		break;
21f067d8:	ea000002 	b	21f067e8 <get_fatent+0xfc>

	default:
		/* Unsupported FAT size */
		return ret;
21f067dc:	e51b3028 	ldr	r3, [fp, #-40]
21f067e0:	e50b3040 	str	r3, [fp, #-64]
21f067e4:	ea0000ba 	b	21f06ad4 <.text+0x6ad4>
	}

	/* Read a new block of FAT entries into the cache. */
	if (bufnum != mydata->fatbufnum) {
21f067e8:	e51b3034 	ldr	r3, [fp, #-52]
21f067ec:	e5933c10 	ldr	r3, [r3, #3088]
21f067f0:	e1a02003 	mov	r2, r3
21f067f4:	e51b3030 	ldr	r3, [fp, #-48]
21f067f8:	e1520003 	cmp	r2, r3
21f067fc:	0a00002d 	beq	21f068b8 <get_fatent+0x1cc>
		int getsize = FATBUFSIZE/FS_BLOCK_SIZE;
21f06800:	e3a03006 	mov	r3, #6	; 0x6
21f06804:	e50b3024 	str	r3, [fp, #-36]
		__u8 *bufptr = mydata->fatbuf;
21f06808:	e51b3034 	ldr	r3, [fp, #-52]
21f0680c:	e50b3020 	str	r3, [fp, #-32]
		__u32 fatlength = mydata->fatlength;
21f06810:	e51b2034 	ldr	r2, [fp, #-52]
21f06814:	e3a03b03 	mov	r3, #3072	; 0xc00
21f06818:	e2833004 	add	r3, r3, #4	; 0x4
21f0681c:	e19230b3 	ldrh	r3, [r2, r3]
21f06820:	e50b301c 	str	r3, [fp, #-28]
		__u32 startblock = bufnum * FATBUFBLOCKS;
21f06824:	e51b2030 	ldr	r2, [fp, #-48]
21f06828:	e1a03002 	mov	r3, r2
21f0682c:	e1a03083 	mov	r3, r3, lsl #1
21f06830:	e0833002 	add	r3, r3, r2
21f06834:	e1a03083 	mov	r3, r3, lsl #1
21f06838:	e50b3018 	str	r3, [fp, #-24]

		fatlength *= SECTOR_SIZE;	/* We want it in bytes now */
21f0683c:	e51b301c 	ldr	r3, [fp, #-28]
21f06840:	e1a03483 	mov	r3, r3, lsl #9
21f06844:	e50b301c 	str	r3, [fp, #-28]
		startblock += mydata->fat_sect;	/* Offset from start of disk */
21f06848:	e51b2034 	ldr	r2, [fp, #-52]
21f0684c:	e3a03b03 	mov	r3, #3072	; 0xc00
21f06850:	e2833006 	add	r3, r3, #6	; 0x6
21f06854:	e19230b3 	ldrh	r3, [r2, r3]
21f06858:	e1a02003 	mov	r2, r3
21f0685c:	e51b3018 	ldr	r3, [fp, #-24]
21f06860:	e0833002 	add	r3, r3, r2
21f06864:	e50b3018 	str	r3, [fp, #-24]

		if (getsize > fatlength) getsize = fatlength;
21f06868:	e51b2024 	ldr	r2, [fp, #-36]
21f0686c:	e51b301c 	ldr	r3, [fp, #-28]
21f06870:	e1520003 	cmp	r2, r3
21f06874:	9a000001 	bls	21f06880 <get_fatent+0x194>
21f06878:	e51b301c 	ldr	r3, [fp, #-28]
21f0687c:	e50b3024 	str	r3, [fp, #-36]
		if (disk_read(startblock, getsize, bufptr) < 0) {
21f06880:	e51b3024 	ldr	r3, [fp, #-36]
21f06884:	e51b0018 	ldr	r0, [fp, #-24]
21f06888:	e1a01003 	mov	r1, r3
21f0688c:	e51b2020 	ldr	r2, [fp, #-32]
21f06890:	ebfffe66 	bl	21f06230 <disk_read>
21f06894:	e1a03000 	mov	r3, r0
21f06898:	e3530000 	cmp	r3, #0	; 0x0
21f0689c:	aa000002 	bge	21f068ac <get_fatent+0x1c0>
			FAT_DPRINT("Error reading FAT blocks\n");
			return ret;
21f068a0:	e51b1028 	ldr	r1, [fp, #-40]
21f068a4:	e50b1040 	str	r1, [fp, #-64]
21f068a8:	ea000089 	b	21f06ad4 <.text+0x6ad4>
		}
		mydata->fatbufnum = bufnum;
21f068ac:	e51b2030 	ldr	r2, [fp, #-48]
21f068b0:	e51b3034 	ldr	r3, [fp, #-52]
21f068b4:	e5832c10 	str	r2, [r3, #3088]
	}

	/* Get the actual entry from the table */
	switch (mydata->fatsize) {
21f068b8:	e51b3034 	ldr	r3, [fp, #-52]
21f068bc:	e5933c00 	ldr	r3, [r3, #3072]
21f068c0:	e50b303c 	str	r3, [fp, #-60]
21f068c4:	e51b303c 	ldr	r3, [fp, #-60]
21f068c8:	e3530010 	cmp	r3, #16	; 0x10
21f068cc:	0a00000e 	beq	21f0690c <get_fatent+0x220>
21f068d0:	e51b103c 	ldr	r1, [fp, #-60]
21f068d4:	e3510020 	cmp	r1, #32	; 0x20
21f068d8:	0a000003 	beq	21f068ec <get_fatent+0x200>
21f068dc:	e51b303c 	ldr	r3, [fp, #-60]
21f068e0:	e353000c 	cmp	r3, #12	; 0xc
21f068e4:	0a000010 	beq	21f0692c <get_fatent+0x240>
21f068e8:	ea000077 	b	21f06acc <.text+0x6acc>
	case 32:
		ret = FAT2CPU32(((__u32*)mydata->fatbuf)[offset]);
21f068ec:	e51b3034 	ldr	r3, [fp, #-52]
21f068f0:	e1a02003 	mov	r2, r3
21f068f4:	e51b302c 	ldr	r3, [fp, #-44]
21f068f8:	e1a03103 	mov	r3, r3, lsl #2
21f068fc:	e0823003 	add	r3, r2, r3
21f06900:	e5933000 	ldr	r3, [r3]
21f06904:	e50b3028 	str	r3, [fp, #-40]
		break;
21f06908:	ea00006f 	b	21f06acc <.text+0x6acc>
	case 16:
		ret = FAT2CPU16(((__u16*)mydata->fatbuf)[offset]);
21f0690c:	e51b3034 	ldr	r3, [fp, #-52]
21f06910:	e1a02003 	mov	r2, r3
21f06914:	e51b302c 	ldr	r3, [fp, #-44]
21f06918:	e1a03083 	mov	r3, r3, lsl #1
21f0691c:	e0823003 	add	r3, r2, r3
21f06920:	e1d330b0 	ldrh	r3, [r3]
21f06924:	e50b3028 	str	r3, [fp, #-40]
		break;
21f06928:	ea000067 	b	21f06acc <.text+0x6acc>
	case 12: {
		__u32 off16 = (offset*3)/4;
21f0692c:	e51b202c 	ldr	r2, [fp, #-44]
21f06930:	e1a03002 	mov	r3, r2
21f06934:	e1a03083 	mov	r3, r3, lsl #1
21f06938:	e0833002 	add	r3, r3, r2
21f0693c:	e1a03123 	mov	r3, r3, lsr #2
21f06940:	e50b3014 	str	r3, [fp, #-20]
		__u16 val1, val2;

		switch (offset & 0x3) {
21f06944:	e51b302c 	ldr	r3, [fp, #-44]
21f06948:	e2033003 	and	r3, r3, #3	; 0x3
21f0694c:	e3530003 	cmp	r3, #3	; 0x3
21f06950:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f06954:	ea00005c 	b	21f06acc <.text+0x6acc>
21f06958:	21f06968 	mvncss	r6, r8, ror #18
21f0695c:	21f06998 	ldrcsb	r6, [r0, #152]!
21f06960:	21f06a18 	mvncss	r6, r8, lsl sl
21f06964:	21f06a98 	ldrcsb	r6, [r0, #168]!
		case 0:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
21f06968:	e51b3034 	ldr	r3, [fp, #-52]
21f0696c:	e1a02003 	mov	r2, r3
21f06970:	e51b3014 	ldr	r3, [fp, #-20]
21f06974:	e1a03083 	mov	r3, r3, lsl #1
21f06978:	e0823003 	add	r3, r2, r3
21f0697c:	e1d330b0 	ldrh	r3, [r3]
21f06980:	e50b3028 	str	r3, [fp, #-40]
			ret &= 0xfff;
21f06984:	e51b3028 	ldr	r3, [fp, #-40]
21f06988:	e1a03a03 	mov	r3, r3, lsl #20
21f0698c:	e1a03a23 	mov	r3, r3, lsr #20
21f06990:	e50b3028 	str	r3, [fp, #-40]
			break;
21f06994:	ea00004c 	b	21f06acc <.text+0x6acc>
		case 1:
			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
21f06998:	e51b3034 	ldr	r3, [fp, #-52]
21f0699c:	e1a02003 	mov	r2, r3
21f069a0:	e51b3014 	ldr	r3, [fp, #-20]
21f069a4:	e1a03083 	mov	r3, r3, lsl #1
21f069a8:	e0823003 	add	r3, r2, r3
21f069ac:	e1d330b0 	ldrh	r3, [r3]
21f069b0:	e14b31b0 	strh	r3, [fp, #-16]
			val1 &= 0xf000;
21f069b4:	e3a03a0f 	mov	r3, #61440	; 0xf000
21f069b8:	e1a02003 	mov	r2, r3
21f069bc:	e15b31b0 	ldrh	r3, [fp, #-16]
21f069c0:	e0023003 	and	r3, r2, r3
21f069c4:	e14b31b0 	strh	r3, [fp, #-16]
			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
21f069c8:	e51b3034 	ldr	r3, [fp, #-52]
21f069cc:	e1a02003 	mov	r2, r3
21f069d0:	e51b3014 	ldr	r3, [fp, #-20]
21f069d4:	e1a03083 	mov	r3, r3, lsl #1
21f069d8:	e0823003 	add	r3, r2, r3
21f069dc:	e2833002 	add	r3, r3, #2	; 0x2
21f069e0:	e1d330b0 	ldrh	r3, [r3]
21f069e4:	e14b30be 	strh	r3, [fp, #-14]
			val2 &= 0x00ff;
21f069e8:	e15b30be 	ldrh	r3, [fp, #-14]
21f069ec:	e20330ff 	and	r3, r3, #255	; 0xff
21f069f0:	e14b30be 	strh	r3, [fp, #-14]
			ret = (val2 << 4) | (val1 >> 12);
21f069f4:	e15b30be 	ldrh	r3, [fp, #-14]
21f069f8:	e1a02203 	mov	r2, r3, lsl #4
21f069fc:	e15b31b0 	ldrh	r3, [fp, #-16]
21f06a00:	e1a03623 	mov	r3, r3, lsr #12
21f06a04:	e1a03803 	mov	r3, r3, lsl #16
21f06a08:	e1a03823 	mov	r3, r3, lsr #16
21f06a0c:	e1823003 	orr	r3, r2, r3
21f06a10:	e50b3028 	str	r3, [fp, #-40]
			break;
21f06a14:	ea00002c 	b	21f06acc <.text+0x6acc>
		case 2:
			val1 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);
21f06a18:	e51b3034 	ldr	r3, [fp, #-52]
21f06a1c:	e1a02003 	mov	r2, r3
21f06a20:	e51b3014 	ldr	r3, [fp, #-20]
21f06a24:	e1a03083 	mov	r3, r3, lsl #1
21f06a28:	e0823003 	add	r3, r2, r3
21f06a2c:	e1d330b0 	ldrh	r3, [r3]
21f06a30:	e14b31b0 	strh	r3, [fp, #-16]
			val1 &= 0xff00;
21f06a34:	e3a03cff 	mov	r3, #65280	; 0xff00
21f06a38:	e1a02003 	mov	r2, r3
21f06a3c:	e15b31b0 	ldrh	r3, [fp, #-16]
21f06a40:	e0023003 	and	r3, r2, r3
21f06a44:	e14b31b0 	strh	r3, [fp, #-16]
			val2 = FAT2CPU16(((__u16*)mydata->fatbuf)[off16+1]);
21f06a48:	e51b3034 	ldr	r3, [fp, #-52]
21f06a4c:	e1a02003 	mov	r2, r3
21f06a50:	e51b3014 	ldr	r3, [fp, #-20]
21f06a54:	e1a03083 	mov	r3, r3, lsl #1
21f06a58:	e0823003 	add	r3, r2, r3
21f06a5c:	e2833002 	add	r3, r3, #2	; 0x2
21f06a60:	e1d330b0 	ldrh	r3, [r3]
21f06a64:	e14b30be 	strh	r3, [fp, #-14]
			val2 &= 0x000f;
21f06a68:	e15b30be 	ldrh	r3, [fp, #-14]
21f06a6c:	e203300f 	and	r3, r3, #15	; 0xf
21f06a70:	e14b30be 	strh	r3, [fp, #-14]
			ret = (val2 << 8) | (val1 >> 8);
21f06a74:	e15b30be 	ldrh	r3, [fp, #-14]
21f06a78:	e1a02403 	mov	r2, r3, lsl #8
21f06a7c:	e15b31b0 	ldrh	r3, [fp, #-16]
21f06a80:	e1a03423 	mov	r3, r3, lsr #8
21f06a84:	e1a03803 	mov	r3, r3, lsl #16
21f06a88:	e1a03823 	mov	r3, r3, lsr #16
21f06a8c:	e1823003 	orr	r3, r2, r3
21f06a90:	e50b3028 	str	r3, [fp, #-40]
			break;
21f06a94:	ea00000c 	b	21f06acc <.text+0x6acc>
		case 3:
			ret = FAT2CPU16(((__u16*)mydata->fatbuf)[off16]);;
21f06a98:	e51b3034 	ldr	r3, [fp, #-52]
21f06a9c:	e1a02003 	mov	r2, r3
21f06aa0:	e51b3014 	ldr	r3, [fp, #-20]
21f06aa4:	e1a03083 	mov	r3, r3, lsl #1
21f06aa8:	e0823003 	add	r3, r2, r3
21f06aac:	e1d330b0 	ldrh	r3, [r3]
21f06ab0:	e50b3028 	str	r3, [fp, #-40]
			ret = (ret & 0xfff0) >> 4;
21f06ab4:	e51b3028 	ldr	r3, [fp, #-40]
21f06ab8:	e3c3300f 	bic	r3, r3, #15	; 0xf
21f06abc:	e1a03803 	mov	r3, r3, lsl #16
21f06ac0:	e1a03823 	mov	r3, r3, lsr #16
21f06ac4:	e1a03223 	mov	r3, r3, lsr #4
21f06ac8:	e50b3028 	str	r3, [fp, #-40]
			break;
		default:
			break;
		}
	}
	break;
	}
	FAT_DPRINT("ret: %d, offset: %d\n", ret, offset);

	return ret;
21f06acc:	e51b1028 	ldr	r1, [fp, #-40]
21f06ad0:	e50b1040 	str	r1, [fp, #-64]
21f06ad4:	e51b3040 	ldr	r3, [fp, #-64]
}
21f06ad8:	e1a00003 	mov	r0, r3
21f06adc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f06ae0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f06ae4:	aaaaaaab 	bge	209b1598 <.text-0x154ea68>

21f06ae8 <get_cluster>:


/*
 * Read at most 'size' bytes from the specified cluster into 'buffer'.
 * Return 0 on success, -1 otherwise.
 */
static int
get_cluster(fsdata *mydata, __u32 clustnum, __u8 *buffer, unsigned long size)
{
21f06ae8:	e1a0c00d 	mov	ip, sp
21f06aec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f06af0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f06af4:	e24ddf87 	sub	sp, sp, #540	; 0x21c
21f06af8:	e50b0218 	str	r0, [fp, #-536]
21f06afc:	e50b121c 	str	r1, [fp, #-540]
21f06b00:	e50b2220 	str	r2, [fp, #-544]
21f06b04:	e50b3224 	str	r3, [fp, #-548]
	int idx = 0;
21f06b08:	e3a03000 	mov	r3, #0	; 0x0
21f06b0c:	e50b3014 	str	r3, [fp, #-20]
	__u32 startsect;

	if (clustnum > 0) {
21f06b10:	e51b321c 	ldr	r3, [fp, #-540]
21f06b14:	e3530000 	cmp	r3, #0	; 0x0
21f06b18:	0a00000f 	beq	21f06b5c <get_cluster+0x74>
		startsect = mydata->data_begin + clustnum*mydata->clust_size;
21f06b1c:	e51b2218 	ldr	r2, [fp, #-536]
21f06b20:	e3a03b03 	mov	r3, #3072	; 0xc00
21f06b24:	e283300c 	add	r3, r3, #12	; 0xc
21f06b28:	e19230b3 	ldrh	r3, [r2, r3]
21f06b2c:	e1a03803 	mov	r3, r3, lsl #16
21f06b30:	e1a01843 	mov	r1, r3, asr #16
21f06b34:	e51b2218 	ldr	r2, [fp, #-536]
21f06b38:	e3a03b03 	mov	r3, #3072	; 0xc00
21f06b3c:	e283300a 	add	r3, r3, #10	; 0xa
21f06b40:	e19230b3 	ldrh	r3, [r2, r3]
21f06b44:	e1a02003 	mov	r2, r3
21f06b48:	e51b321c 	ldr	r3, [fp, #-540]
21f06b4c:	e0030392 	mul	r3, r2, r3
21f06b50:	e0813003 	add	r3, r1, r3
21f06b54:	e50b3010 	str	r3, [fp, #-16]
21f06b58:	ea000004 	b	21f06b70 <get_cluster+0x88>
	} else {
		startsect = mydata->rootdir_sect;
21f06b5c:	e51b3218 	ldr	r3, [fp, #-536]
21f06b60:	e3a02b03 	mov	r2, #3072	; 0xc00
21f06b64:	e2822008 	add	r2, r2, #8	; 0x8
21f06b68:	e19330b2 	ldrh	r3, [r3, r2]
21f06b6c:	e50b3010 	str	r3, [fp, #-16]
	}

	FAT_DPRINT("gc - clustnum: %d, startsect: %d\n", clustnum, startsect);
	if (disk_read(startsect, size/FS_BLOCK_SIZE , buffer) < 0) {
21f06b70:	e51b3224 	ldr	r3, [fp, #-548]
21f06b74:	e1a034a3 	mov	r3, r3, lsr #9
21f06b78:	e51b0010 	ldr	r0, [fp, #-16]
21f06b7c:	e1a01003 	mov	r1, r3
21f06b80:	e51b2220 	ldr	r2, [fp, #-544]
21f06b84:	ebfffda9 	bl	21f06230 <disk_read>
21f06b88:	e1a03000 	mov	r3, r0
21f06b8c:	e3530000 	cmp	r3, #0	; 0x0
21f06b90:	aa000002 	bge	21f06ba0 <get_cluster+0xb8>
		FAT_DPRINT("Error reading data\n");
		return -1;
21f06b94:	e3e03000 	mvn	r3, #0	; 0x0
21f06b98:	e50b3228 	str	r3, [fp, #-552]
21f06b9c:	ea000027 	b	21f06c40 <get_cluster+0x158>
	}
	if(size % FS_BLOCK_SIZE) {
21f06ba0:	e51b3224 	ldr	r3, [fp, #-548]
21f06ba4:	e1a03b83 	mov	r3, r3, lsl #23
21f06ba8:	e1a03ba3 	mov	r3, r3, lsr #23
21f06bac:	e3530000 	cmp	r3, #0	; 0x0
21f06bb0:	0a000020 	beq	21f06c38 <get_cluster+0x150>
		__u8 tmpbuf[FS_BLOCK_SIZE];
		idx= size/FS_BLOCK_SIZE;
21f06bb4:	e51b3224 	ldr	r3, [fp, #-548]
21f06bb8:	e1a034a3 	mov	r3, r3, lsr #9
21f06bbc:	e50b3014 	str	r3, [fp, #-20]
		if (disk_read(startsect + idx, 1, tmpbuf) < 0) {
21f06bc0:	e51b2014 	ldr	r2, [fp, #-20]
21f06bc4:	e51b3010 	ldr	r3, [fp, #-16]
21f06bc8:	e0823003 	add	r3, r2, r3
21f06bcc:	e24b2f85 	sub	r2, fp, #532	; 0x214
21f06bd0:	e1a00003 	mov	r0, r3
21f06bd4:	e3a01001 	mov	r1, #1	; 0x1
21f06bd8:	ebfffd94 	bl	21f06230 <disk_read>
21f06bdc:	e1a03000 	mov	r3, r0
21f06be0:	e3530000 	cmp	r3, #0	; 0x0
21f06be4:	aa000002 	bge	21f06bf4 <get_cluster+0x10c>
			FAT_DPRINT("Error reading data\n");
			return -1;
21f06be8:	e3e03000 	mvn	r3, #0	; 0x0
21f06bec:	e50b3228 	str	r3, [fp, #-552]
21f06bf0:	ea000012 	b	21f06c40 <get_cluster+0x158>
		}
		buffer += idx*FS_BLOCK_SIZE;
21f06bf4:	e51b3014 	ldr	r3, [fp, #-20]
21f06bf8:	e1a03483 	mov	r3, r3, lsl #9
21f06bfc:	e1a02003 	mov	r2, r3
21f06c00:	e51b3220 	ldr	r3, [fp, #-544]
21f06c04:	e0833002 	add	r3, r3, r2
21f06c08:	e50b3220 	str	r3, [fp, #-544]

		memcpy(buffer, tmpbuf, size % FS_BLOCK_SIZE);
21f06c0c:	e51b3224 	ldr	r3, [fp, #-548]
21f06c10:	e1a03b83 	mov	r3, r3, lsl #23
21f06c14:	e1a03ba3 	mov	r3, r3, lsr #23
21f06c18:	e24b2f85 	sub	r2, fp, #532	; 0x214
21f06c1c:	e51b0220 	ldr	r0, [fp, #-544]
21f06c20:	e1a01002 	mov	r1, r2
21f06c24:	e1a02003 	mov	r2, r3
21f06c28:	eb007167 	bl	21f231cc <memcpy>
		return 0;
21f06c2c:	e3a03000 	mov	r3, #0	; 0x0
21f06c30:	e50b3228 	str	r3, [fp, #-552]
21f06c34:	ea000001 	b	21f06c40 <get_cluster+0x158>
	}

	return 0;
21f06c38:	e3a03000 	mov	r3, #0	; 0x0
21f06c3c:	e50b3228 	str	r3, [fp, #-552]
21f06c40:	e51b3228 	ldr	r3, [fp, #-552]
}
21f06c44:	e1a00003 	mov	r0, r3
21f06c48:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f06c4c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f06c50 <get_contents>:


/*
 * Read at most 'maxsize' bytes from the file associated with 'dentptr'
 * into 'buffer'.
 * Return the number of bytes read or -1 on fatal errors.
 */
static long
get_contents(fsdata *mydata, dir_entry *dentptr, __u8 *buffer,
	     unsigned long maxsize)
{
21f06c50:	e1a0c00d 	mov	ip, sp
21f06c54:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f06c58:	e24cb004 	sub	fp, ip, #4	; 0x4
21f06c5c:	e24dd038 	sub	sp, sp, #56	; 0x38
21f06c60:	e50b002c 	str	r0, [fp, #-44]
21f06c64:	e50b1030 	str	r1, [fp, #-48]
21f06c68:	e50b2034 	str	r2, [fp, #-52]
21f06c6c:	e50b3038 	str	r3, [fp, #-56]
	unsigned long filesize = FAT2CPU32(dentptr->size), gotsize = 0;
21f06c70:	e51b3030 	ldr	r3, [fp, #-48]
21f06c74:	e593301c 	ldr	r3, [r3, #28]
21f06c78:	e50b3028 	str	r3, [fp, #-40]
21f06c7c:	e3a03000 	mov	r3, #0	; 0x0
21f06c80:	e50b3024 	str	r3, [fp, #-36]
	unsigned int bytesperclust = mydata->clust_size * SECTOR_SIZE;
21f06c84:	e51b202c 	ldr	r2, [fp, #-44]
21f06c88:	e3a03b03 	mov	r3, #3072	; 0xc00
21f06c8c:	e283300a 	add	r3, r3, #10	; 0xa
21f06c90:	e19230b3 	ldrh	r3, [r2, r3]
21f06c94:	e1a03483 	mov	r3, r3, lsl #9
21f06c98:	e50b3020 	str	r3, [fp, #-32]
	__u32 curclust = START(dentptr);
21f06c9c:	e51b3030 	ldr	r3, [fp, #-48]
21f06ca0:	e1d331ba 	ldrh	r3, [r3, #26]
21f06ca4:	e50b3044 	str	r3, [fp, #-68]
21f06ca8:	e51b302c 	ldr	r3, [fp, #-44]
21f06cac:	e5933c00 	ldr	r3, [r3, #3072]
21f06cb0:	e3530020 	cmp	r3, #32	; 0x20
21f06cb4:	1a000004 	bne	21f06ccc <get_contents+0x7c>
21f06cb8:	e51b3030 	ldr	r3, [fp, #-48]
21f06cbc:	e1d331b4 	ldrh	r3, [r3, #20]
21f06cc0:	e1a03803 	mov	r3, r3, lsl #16
21f06cc4:	e50b3040 	str	r3, [fp, #-64]
21f06cc8:	ea000001 	b	21f06cd4 <get_contents+0x84>
21f06ccc:	e3a01000 	mov	r1, #0	; 0x0
21f06cd0:	e50b1040 	str	r1, [fp, #-64]
21f06cd4:	e51b2044 	ldr	r2, [fp, #-68]
21f06cd8:	e51b1040 	ldr	r1, [fp, #-64]
21f06cdc:	e0823001 	add	r3, r2, r1
21f06ce0:	e50b301c 	str	r3, [fp, #-28]
	__u32 endclust, newclust;
	unsigned long actsize;

	FAT_DPRINT("Filesize: %ld bytes\n", filesize);

	if (maxsize > 0 && filesize > maxsize) filesize = maxsize;
21f06ce4:	e51b3038 	ldr	r3, [fp, #-56]
21f06ce8:	e3530000 	cmp	r3, #0	; 0x0
21f06cec:	0a000005 	beq	21f06d08 <get_contents+0xb8>
21f06cf0:	e51b2028 	ldr	r2, [fp, #-40]
21f06cf4:	e51b3038 	ldr	r3, [fp, #-56]
21f06cf8:	e1520003 	cmp	r2, r3
21f06cfc:	9a000001 	bls	21f06d08 <get_contents+0xb8>
21f06d00:	e51b3038 	ldr	r3, [fp, #-56]
21f06d04:	e50b3028 	str	r3, [fp, #-40]

	FAT_DPRINT("Reading: %ld bytes\n", filesize);

	actsize=bytesperclust;
21f06d08:	e51b3020 	ldr	r3, [fp, #-32]
21f06d0c:	e50b3010 	str	r3, [fp, #-16]
	endclust=curclust;
21f06d10:	e51b301c 	ldr	r3, [fp, #-28]
21f06d14:	e50b3018 	str	r3, [fp, #-24]
21f06d18:	ea00001a 	b	21f06d88 <get_contents+0x138>
	do {
		/* search for consecutive clusters */
		while(actsize < filesize) {
			newclust = get_fatent(mydata, endclust);
21f06d1c:	e51b002c 	ldr	r0, [fp, #-44]
21f06d20:	e51b1018 	ldr	r1, [fp, #-24]
21f06d24:	ebfffe70 	bl	21f066ec <get_fatent>
21f06d28:	e1a03000 	mov	r3, r0
21f06d2c:	e50b3014 	str	r3, [fp, #-20]
			if((newclust -1)!=endclust)
21f06d30:	e51b3014 	ldr	r3, [fp, #-20]
21f06d34:	e2432001 	sub	r2, r3, #1	; 0x1
21f06d38:	e51b3018 	ldr	r3, [fp, #-24]
21f06d3c:	e1520003 	cmp	r2, r3
21f06d40:	1a000047 	bne	21f06e64 <get_contents+0x214>
				goto getit;
			if (newclust <= 0x0001 || newclust >= 0xfff0) {
21f06d44:	e51b3014 	ldr	r3, [fp, #-20]
21f06d48:	e3530001 	cmp	r3, #1	; 0x1
21f06d4c:	9a000004 	bls	21f06d64 <get_contents+0x114>
21f06d50:	e51b2014 	ldr	r2, [fp, #-20]
21f06d54:	e3a03cff 	mov	r3, #65280	; 0xff00
21f06d58:	e28330ef 	add	r3, r3, #239	; 0xef
21f06d5c:	e1520003 	cmp	r2, r3
21f06d60:	9a000002 	bls	21f06d70 <get_contents+0x120>
				FAT_DPRINT("curclust: 0x%x\n", newclust);
				FAT_DPRINT("Invalid FAT entry\n");
				return gotsize;
21f06d64:	e51b2024 	ldr	r2, [fp, #-36]
21f06d68:	e50b203c 	str	r2, [fp, #-60]
21f06d6c:	ea00006c 	b	21f06f24 <get_contents+0x2d4>
			}
			endclust=newclust;
21f06d70:	e51b3014 	ldr	r3, [fp, #-20]
21f06d74:	e50b3018 	str	r3, [fp, #-24]
			actsize+= bytesperclust;
21f06d78:	e51b2010 	ldr	r2, [fp, #-16]
21f06d7c:	e51b3020 	ldr	r3, [fp, #-32]
21f06d80:	e0823003 	add	r3, r2, r3
21f06d84:	e50b3010 	str	r3, [fp, #-16]
21f06d88:	e51b2010 	ldr	r2, [fp, #-16]
21f06d8c:	e51b3028 	ldr	r3, [fp, #-40]
21f06d90:	e1520003 	cmp	r2, r3
21f06d94:	3affffe0 	bcc	21f06d1c <get_contents+0xcc>
		}
		/* actsize >= file size */
		actsize -= bytesperclust;
21f06d98:	e51b2010 	ldr	r2, [fp, #-16]
21f06d9c:	e51b3020 	ldr	r3, [fp, #-32]
21f06da0:	e0633002 	rsb	r3, r3, r2
21f06da4:	e50b3010 	str	r3, [fp, #-16]
		/* get remaining clusters */
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
21f06da8:	e51b002c 	ldr	r0, [fp, #-44]
21f06dac:	e51b101c 	ldr	r1, [fp, #-28]
21f06db0:	e51b2034 	ldr	r2, [fp, #-52]
21f06db4:	e51b3010 	ldr	r3, [fp, #-16]
21f06db8:	ebffff4a 	bl	21f06ae8 <get_cluster>
21f06dbc:	e1a03000 	mov	r3, r0
21f06dc0:	e3530000 	cmp	r3, #0	; 0x0
21f06dc4:	0a000004 	beq	21f06ddc <get_contents+0x18c>
			FAT_ERROR("Error reading cluster\n");
21f06dc8:	e59f0164 	ldr	r0, [pc, #356]	; 21f06f34 <.text+0x6f34>
21f06dcc:	eb00532e 	bl	21f1ba8c <printf>
			return -1;
21f06dd0:	e3e03000 	mvn	r3, #0	; 0x0
21f06dd4:	e50b303c 	str	r3, [fp, #-60]
21f06dd8:	ea000051 	b	21f06f24 <get_contents+0x2d4>
		}
		/* get remaining bytes */
		gotsize += (int)actsize;
21f06ddc:	e51b2024 	ldr	r2, [fp, #-36]
21f06de0:	e51b3010 	ldr	r3, [fp, #-16]
21f06de4:	e0823003 	add	r3, r2, r3
21f06de8:	e50b3024 	str	r3, [fp, #-36]
		filesize -= actsize;
21f06dec:	e51b2028 	ldr	r2, [fp, #-40]
21f06df0:	e51b3010 	ldr	r3, [fp, #-16]
21f06df4:	e0633002 	rsb	r3, r3, r2
21f06df8:	e50b3028 	str	r3, [fp, #-40]
		buffer += actsize;
21f06dfc:	e51b2010 	ldr	r2, [fp, #-16]
21f06e00:	e51b3034 	ldr	r3, [fp, #-52]
21f06e04:	e0833002 	add	r3, r3, r2
21f06e08:	e50b3034 	str	r3, [fp, #-52]
		actsize= filesize;
21f06e0c:	e51b3028 	ldr	r3, [fp, #-40]
21f06e10:	e50b3010 	str	r3, [fp, #-16]
		if (get_cluster(mydata, endclust, buffer, (int)actsize) != 0) {
21f06e14:	e51b002c 	ldr	r0, [fp, #-44]
21f06e18:	e51b1018 	ldr	r1, [fp, #-24]
21f06e1c:	e51b2034 	ldr	r2, [fp, #-52]
21f06e20:	e51b3010 	ldr	r3, [fp, #-16]
21f06e24:	ebffff2f 	bl	21f06ae8 <get_cluster>
21f06e28:	e1a03000 	mov	r3, r0
21f06e2c:	e3530000 	cmp	r3, #0	; 0x0
21f06e30:	0a000004 	beq	21f06e48 <get_contents+0x1f8>
			FAT_ERROR("Error reading cluster\n");
21f06e34:	e59f00f8 	ldr	r0, [pc, #248]	; 21f06f34 <.text+0x6f34>
21f06e38:	eb005313 	bl	21f1ba8c <printf>
			return -1;
21f06e3c:	e3e01000 	mvn	r1, #0	; 0x0
21f06e40:	e50b103c 	str	r1, [fp, #-60]
21f06e44:	ea000036 	b	21f06f24 <get_contents+0x2d4>
		}
		gotsize+=actsize;
21f06e48:	e51b3024 	ldr	r3, [fp, #-36]
21f06e4c:	e51b2010 	ldr	r2, [fp, #-16]
21f06e50:	e0833002 	add	r3, r3, r2
21f06e54:	e50b3024 	str	r3, [fp, #-36]
		return gotsize;
21f06e58:	e51b2024 	ldr	r2, [fp, #-36]
21f06e5c:	e50b203c 	str	r2, [fp, #-60]
21f06e60:	ea00002f 	b	21f06f24 <get_contents+0x2d4>
getit:
		if (get_cluster(mydata, curclust, buffer, (int)actsize) != 0) {
21f06e64:	e51b002c 	ldr	r0, [fp, #-44]
21f06e68:	e51b101c 	ldr	r1, [fp, #-28]
21f06e6c:	e51b2034 	ldr	r2, [fp, #-52]
21f06e70:	e51b3010 	ldr	r3, [fp, #-16]
21f06e74:	ebffff1b 	bl	21f06ae8 <get_cluster>
21f06e78:	e1a03000 	mov	r3, r0
21f06e7c:	e3530000 	cmp	r3, #0	; 0x0
21f06e80:	0a000004 	beq	21f06e98 <get_contents+0x248>
			FAT_ERROR("Error reading cluster\n");
21f06e84:	e59f00a8 	ldr	r0, [pc, #168]	; 21f06f34 <.text+0x6f34>
21f06e88:	eb0052ff 	bl	21f1ba8c <printf>
			return -1;
21f06e8c:	e3e03000 	mvn	r3, #0	; 0x0
21f06e90:	e50b303c 	str	r3, [fp, #-60]
21f06e94:	ea000022 	b	21f06f24 <get_contents+0x2d4>
		}
		gotsize += (int)actsize;
21f06e98:	e51b2024 	ldr	r2, [fp, #-36]
21f06e9c:	e51b3010 	ldr	r3, [fp, #-16]
21f06ea0:	e0823003 	add	r3, r2, r3
21f06ea4:	e50b3024 	str	r3, [fp, #-36]
		filesize -= actsize;
21f06ea8:	e51b2028 	ldr	r2, [fp, #-40]
21f06eac:	e51b3010 	ldr	r3, [fp, #-16]
21f06eb0:	e0633002 	rsb	r3, r3, r2
21f06eb4:	e50b3028 	str	r3, [fp, #-40]
		buffer += actsize;
21f06eb8:	e51b2010 	ldr	r2, [fp, #-16]
21f06ebc:	e51b3034 	ldr	r3, [fp, #-52]
21f06ec0:	e0833002 	add	r3, r3, r2
21f06ec4:	e50b3034 	str	r3, [fp, #-52]
		curclust = get_fatent(mydata, endclust);
21f06ec8:	e51b002c 	ldr	r0, [fp, #-44]
21f06ecc:	e51b1018 	ldr	r1, [fp, #-24]
21f06ed0:	ebfffe05 	bl	21f066ec <get_fatent>
21f06ed4:	e1a03000 	mov	r3, r0
21f06ed8:	e50b301c 	str	r3, [fp, #-28]
		if (curclust <= 0x0001 || curclust >= 0xfff0) {
21f06edc:	e51b301c 	ldr	r3, [fp, #-28]
21f06ee0:	e3530001 	cmp	r3, #1	; 0x1
21f06ee4:	9a000004 	bls	21f06efc <get_contents+0x2ac>
21f06ee8:	e51b201c 	ldr	r2, [fp, #-28]
21f06eec:	e3a03cff 	mov	r3, #65280	; 0xff00
21f06ef0:	e28330ef 	add	r3, r3, #239	; 0xef
21f06ef4:	e1520003 	cmp	r2, r3
21f06ef8:	9a000004 	bls	21f06f10 <get_contents+0x2c0>
			FAT_DPRINT("curclust: 0x%x\n", curclust);
			FAT_ERROR("Invalid FAT entry\n");
21f06efc:	e59f0034 	ldr	r0, [pc, #52]	; 21f06f38 <.text+0x6f38>
21f06f00:	eb0052e1 	bl	21f1ba8c <printf>
			return gotsize;
21f06f04:	e51b1024 	ldr	r1, [fp, #-36]
21f06f08:	e50b103c 	str	r1, [fp, #-60]
21f06f0c:	ea000004 	b	21f06f24 <get_contents+0x2d4>
		}
		actsize=bytesperclust;
21f06f10:	e51b3020 	ldr	r3, [fp, #-32]
21f06f14:	e50b3010 	str	r3, [fp, #-16]
		endclust=curclust;
21f06f18:	e51b301c 	ldr	r3, [fp, #-28]
21f06f1c:	e50b3018 	str	r3, [fp, #-24]
	} while (1);
21f06f20:	eaffff98 	b	21f06d88 <get_contents+0x138>
21f06f24:	e51b303c 	ldr	r3, [fp, #-60]
}
21f06f28:	e1a00003 	mov	r0, r3
21f06f2c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f06f30:	e89da800 	ldmia	sp, {fp, sp, pc}
21f06f34:	21f2f33c 	mvncss	pc, ip, lsr r3
21f06f38:	21f2f354 	mvncss	pc, r4, asr r3

21f06f3c <slot2str>:


#ifdef CONFIG_SUPPORT_VFAT
/*
 * Extract the file name information from 'slotptr' into 'l_name',
 * starting at l_name[*idx].
 * Return 1 if terminator (zero byte) is found, 0 otherwise.
 */
static int
slot2str(dir_slot *slotptr, char *l_name, int *idx)
{
21f06f3c:	e1a0c00d 	mov	ip, sp
21f06f40:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f06f44:	e24cb004 	sub	fp, ip, #4	; 0x4
21f06f48:	e24dd014 	sub	sp, sp, #20	; 0x14
21f06f4c:	e50b0014 	str	r0, [fp, #-20]
21f06f50:	e50b1018 	str	r1, [fp, #-24]
21f06f54:	e50b201c 	str	r2, [fp, #-28]
	int j;

	for (j = 0; j <= 8; j += 2) {
21f06f58:	e3a03000 	mov	r3, #0	; 0x0
21f06f5c:	e50b3010 	str	r3, [fp, #-16]
21f06f60:	ea00001e 	b	21f06fe0 <slot2str+0xa4>
		l_name[*idx] = slotptr->name0_4[j];
21f06f64:	e51b301c 	ldr	r3, [fp, #-28]
21f06f68:	e5933000 	ldr	r3, [r3]
21f06f6c:	e1a02003 	mov	r2, r3
21f06f70:	e51b3018 	ldr	r3, [fp, #-24]
21f06f74:	e0820003 	add	r0, r2, r3
21f06f78:	e51b1010 	ldr	r1, [fp, #-16]
21f06f7c:	e51b3014 	ldr	r3, [fp, #-20]
21f06f80:	e3a02001 	mov	r2, #1	; 0x1
21f06f84:	e0833001 	add	r3, r3, r1
21f06f88:	e0833002 	add	r3, r3, r2
21f06f8c:	e5d33000 	ldrb	r3, [r3]
21f06f90:	e5c03000 	strb	r3, [r0]
		if (l_name[*idx] == 0x00) return 1;
21f06f94:	e51b301c 	ldr	r3, [fp, #-28]
21f06f98:	e5933000 	ldr	r3, [r3]
21f06f9c:	e1a02003 	mov	r2, r3
21f06fa0:	e51b3018 	ldr	r3, [fp, #-24]
21f06fa4:	e0823003 	add	r3, r2, r3
21f06fa8:	e5d33000 	ldrb	r3, [r3]
21f06fac:	e3530000 	cmp	r3, #0	; 0x0
21f06fb0:	1a000002 	bne	21f06fc0 <slot2str+0x84>
21f06fb4:	e3a03001 	mov	r3, #1	; 0x1
21f06fb8:	e50b3020 	str	r3, [fp, #-32]
21f06fbc:	ea000056 	b	21f0711c <slot2str+0x1e0>
		(*idx)++;
21f06fc0:	e51b301c 	ldr	r3, [fp, #-28]
21f06fc4:	e5933000 	ldr	r3, [r3]
21f06fc8:	e2832001 	add	r2, r3, #1	; 0x1
21f06fcc:	e51b301c 	ldr	r3, [fp, #-28]
21f06fd0:	e5832000 	str	r2, [r3]
21f06fd4:	e51b3010 	ldr	r3, [fp, #-16]
21f06fd8:	e2833002 	add	r3, r3, #2	; 0x2
21f06fdc:	e50b3010 	str	r3, [fp, #-16]
21f06fe0:	e51b3010 	ldr	r3, [fp, #-16]
21f06fe4:	e3530008 	cmp	r3, #8	; 0x8
21f06fe8:	daffffdd 	ble	21f06f64 <slot2str+0x28>
	}
	for (j = 0; j <= 10; j += 2) {
21f06fec:	e3a03000 	mov	r3, #0	; 0x0
21f06ff0:	e50b3010 	str	r3, [fp, #-16]
21f06ff4:	ea00001e 	b	21f07074 <slot2str+0x138>
		l_name[*idx] = slotptr->name5_10[j];
21f06ff8:	e51b301c 	ldr	r3, [fp, #-28]
21f06ffc:	e5933000 	ldr	r3, [r3]
21f07000:	e1a02003 	mov	r2, r3
21f07004:	e51b3018 	ldr	r3, [fp, #-24]
21f07008:	e0820003 	add	r0, r2, r3
21f0700c:	e51b1010 	ldr	r1, [fp, #-16]
21f07010:	e51b3014 	ldr	r3, [fp, #-20]
21f07014:	e3a0200c 	mov	r2, #12	; 0xc
21f07018:	e0813003 	add	r3, r1, r3
21f0701c:	e0833002 	add	r3, r3, r2
21f07020:	e5d33002 	ldrb	r3, [r3, #2]
21f07024:	e5c03000 	strb	r3, [r0]
		if (l_name[*idx] == 0x00) return 1;
21f07028:	e51b301c 	ldr	r3, [fp, #-28]
21f0702c:	e5933000 	ldr	r3, [r3]
21f07030:	e1a02003 	mov	r2, r3
21f07034:	e51b3018 	ldr	r3, [fp, #-24]
21f07038:	e0823003 	add	r3, r2, r3
21f0703c:	e5d33000 	ldrb	r3, [r3]
21f07040:	e3530000 	cmp	r3, #0	; 0x0
21f07044:	1a000002 	bne	21f07054 <slot2str+0x118>
21f07048:	e3a03001 	mov	r3, #1	; 0x1
21f0704c:	e50b3020 	str	r3, [fp, #-32]
21f07050:	ea000031 	b	21f0711c <slot2str+0x1e0>
		(*idx)++;
21f07054:	e51b301c 	ldr	r3, [fp, #-28]
21f07058:	e5933000 	ldr	r3, [r3]
21f0705c:	e2832001 	add	r2, r3, #1	; 0x1
21f07060:	e51b301c 	ldr	r3, [fp, #-28]
21f07064:	e5832000 	str	r2, [r3]
21f07068:	e51b3010 	ldr	r3, [fp, #-16]
21f0706c:	e2833002 	add	r3, r3, #2	; 0x2
21f07070:	e50b3010 	str	r3, [fp, #-16]
21f07074:	e51b3010 	ldr	r3, [fp, #-16]
21f07078:	e353000a 	cmp	r3, #10	; 0xa
21f0707c:	daffffdd 	ble	21f06ff8 <slot2str+0xbc>
	}
	for (j = 0; j <= 2; j += 2) {
21f07080:	e3a03000 	mov	r3, #0	; 0x0
21f07084:	e50b3010 	str	r3, [fp, #-16]
21f07088:	ea00001e 	b	21f07108 <slot2str+0x1cc>
		l_name[*idx] = slotptr->name11_12[j];
21f0708c:	e51b301c 	ldr	r3, [fp, #-28]
21f07090:	e5933000 	ldr	r3, [r3]
21f07094:	e1a02003 	mov	r2, r3
21f07098:	e51b3018 	ldr	r3, [fp, #-24]
21f0709c:	e0820003 	add	r0, r2, r3
21f070a0:	e51b1010 	ldr	r1, [fp, #-16]
21f070a4:	e51b3014 	ldr	r3, [fp, #-20]
21f070a8:	e3a0201c 	mov	r2, #28	; 0x1c
21f070ac:	e0813003 	add	r3, r1, r3
21f070b0:	e0833002 	add	r3, r3, r2
21f070b4:	e5d33000 	ldrb	r3, [r3]
21f070b8:	e5c03000 	strb	r3, [r0]
		if (l_name[*idx] == 0x00) return 1;
21f070bc:	e51b301c 	ldr	r3, [fp, #-28]
21f070c0:	e5933000 	ldr	r3, [r3]
21f070c4:	e1a02003 	mov	r2, r3
21f070c8:	e51b3018 	ldr	r3, [fp, #-24]
21f070cc:	e0823003 	add	r3, r2, r3
21f070d0:	e5d33000 	ldrb	r3, [r3]
21f070d4:	e3530000 	cmp	r3, #0	; 0x0
21f070d8:	1a000002 	bne	21f070e8 <slot2str+0x1ac>
21f070dc:	e3a03001 	mov	r3, #1	; 0x1
21f070e0:	e50b3020 	str	r3, [fp, #-32]
21f070e4:	ea00000c 	b	21f0711c <slot2str+0x1e0>
		(*idx)++;
21f070e8:	e51b301c 	ldr	r3, [fp, #-28]
21f070ec:	e5933000 	ldr	r3, [r3]
21f070f0:	e2832001 	add	r2, r3, #1	; 0x1
21f070f4:	e51b301c 	ldr	r3, [fp, #-28]
21f070f8:	e5832000 	str	r2, [r3]
21f070fc:	e51b3010 	ldr	r3, [fp, #-16]
21f07100:	e2833002 	add	r3, r3, #2	; 0x2
21f07104:	e50b3010 	str	r3, [fp, #-16]
21f07108:	e51b3010 	ldr	r3, [fp, #-16]
21f0710c:	e3530002 	cmp	r3, #2	; 0x2
21f07110:	daffffdd 	ble	21f0708c <slot2str+0x150>
	}

	return 0;
21f07114:	e3a03000 	mov	r3, #0	; 0x0
21f07118:	e50b3020 	str	r3, [fp, #-32]
21f0711c:	e51b3020 	ldr	r3, [fp, #-32]
}
21f07120:	e1a00003 	mov	r0, r3
21f07124:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f07128:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0712c <get_vfatname>:


/*
 * Extract the full long filename starting at 'retdent' (which is really
 * a slot) into 'l_name'. If successful also copy the real directory entry
 * into 'retdent'
 * Return 0 on success, -1 otherwise.
 */
__u8	 get_vfatname_block[MAX_CLUSTSIZE];
static int
get_vfatname(fsdata *mydata, int curclust, __u8 *cluster,
	     dir_entry *retdent, char *l_name)
{
21f0712c:	e1a0c00d 	mov	ip, sp
21f07130:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f07134:	e24cb004 	sub	fp, ip, #4	; 0x4
21f07138:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f0713c:	e50b0028 	str	r0, [fp, #-40]
21f07140:	e50b102c 	str	r1, [fp, #-44]
21f07144:	e50b2030 	str	r2, [fp, #-48]
21f07148:	e50b3034 	str	r3, [fp, #-52]
	dir_entry *realdent;
	dir_slot  *slotptr = (dir_slot*) retdent;
21f0714c:	e51b3034 	ldr	r3, [fp, #-52]
21f07150:	e50b301c 	str	r3, [fp, #-28]
	__u8	  *nextclust = cluster + mydata->clust_size * SECTOR_SIZE;
21f07154:	e51b2028 	ldr	r2, [fp, #-40]
21f07158:	e3a03b03 	mov	r3, #3072	; 0xc00
21f0715c:	e283300a 	add	r3, r3, #10	; 0xa
21f07160:	e19230b3 	ldrh	r3, [r2, r3]
21f07164:	e1a03483 	mov	r3, r3, lsl #9
21f07168:	e1a02003 	mov	r2, r3
21f0716c:	e51b3030 	ldr	r3, [fp, #-48]
21f07170:	e0823003 	add	r3, r2, r3
21f07174:	e50b3018 	str	r3, [fp, #-24]
	__u8	   counter = (slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff;
21f07178:	e51b301c 	ldr	r3, [fp, #-28]
21f0717c:	e5d32000 	ldrb	r2, [r3]
21f07180:	e3a030bf 	mov	r3, #191	; 0xbf
21f07184:	e0023003 	and	r3, r2, r3
21f07188:	e54b3011 	strb	r3, [fp, #-17]
	int idx = 0;
21f0718c:	e3a03000 	mov	r3, #0	; 0x0
21f07190:	e50b3024 	str	r3, [fp, #-36]

	while ((__u8*)slotptr < nextclust) {
21f07194:	ea000011 	b	21f071e0 <get_vfatname+0xb4>
		if (counter == 0) break;
21f07198:	e55b3011 	ldrb	r3, [fp, #-17]
21f0719c:	e3530000 	cmp	r3, #0	; 0x0
21f071a0:	0a000012 	beq	21f071f0 <get_vfatname+0xc4>
		if (((slotptr->id & ~LAST_LONG_ENTRY_MASK) & 0xff) != counter)
21f071a4:	e51b301c 	ldr	r3, [fp, #-28]
21f071a8:	e5d33000 	ldrb	r3, [r3]
21f071ac:	e20320bf 	and	r2, r3, #191	; 0xbf
21f071b0:	e55b3011 	ldrb	r3, [fp, #-17]
21f071b4:	e1520003 	cmp	r2, r3
21f071b8:	0a000002 	beq	21f071c8 <get_vfatname+0x9c>
			return -1;
21f071bc:	e3e03000 	mvn	r3, #0	; 0x0
21f071c0:	e50b3038 	str	r3, [fp, #-56]
21f071c4:	ea00007d 	b	21f073c0 <get_vfatname+0x294>
		slotptr++;
21f071c8:	e51b301c 	ldr	r3, [fp, #-28]
21f071cc:	e2833020 	add	r3, r3, #32	; 0x20
21f071d0:	e50b301c 	str	r3, [fp, #-28]
		counter--;
21f071d4:	e55b3011 	ldrb	r3, [fp, #-17]
21f071d8:	e2433001 	sub	r3, r3, #1	; 0x1
21f071dc:	e54b3011 	strb	r3, [fp, #-17]
21f071e0:	e51b201c 	ldr	r2, [fp, #-28]
21f071e4:	e51b3018 	ldr	r3, [fp, #-24]
21f071e8:	e1520003 	cmp	r2, r3
21f071ec:	3affffe9 	bcc	21f07198 <get_vfatname+0x6c>
	}

	if ((__u8*)slotptr >= nextclust) {
21f071f0:	e51b201c 	ldr	r2, [fp, #-28]
21f071f4:	e51b3018 	ldr	r3, [fp, #-24]
21f071f8:	e1520003 	cmp	r2, r3
21f071fc:	3a00003f 	bcc	21f07300 <get_vfatname+0x1d4>
		dir_slot *slotptr2;

		slotptr--;
21f07200:	e51b301c 	ldr	r3, [fp, #-28]
21f07204:	e2433020 	sub	r3, r3, #32	; 0x20
21f07208:	e50b301c 	str	r3, [fp, #-28]
		curclust = get_fatent(mydata, curclust);
21f0720c:	e51b302c 	ldr	r3, [fp, #-44]
21f07210:	e51b0028 	ldr	r0, [fp, #-40]
21f07214:	e1a01003 	mov	r1, r3
21f07218:	ebfffd33 	bl	21f066ec <get_fatent>
21f0721c:	e1a03000 	mov	r3, r0
21f07220:	e50b302c 	str	r3, [fp, #-44]
		if (curclust <= 0x0001 || curclust >= 0xfff0) {
21f07224:	e51b302c 	ldr	r3, [fp, #-44]
21f07228:	e3530001 	cmp	r3, #1	; 0x1
21f0722c:	da000004 	ble	21f07244 <get_vfatname+0x118>
21f07230:	e51b202c 	ldr	r2, [fp, #-44]
21f07234:	e3a03cff 	mov	r3, #65280	; 0xff00
21f07238:	e28330ef 	add	r3, r3, #239	; 0xef
21f0723c:	e1520003 	cmp	r2, r3
21f07240:	da000004 	ble	21f07258 <get_vfatname+0x12c>
			FAT_DPRINT("curclust: 0x%x\n", curclust);
			FAT_ERROR("Invalid FAT entry\n");
21f07244:	e59f0184 	ldr	r0, [pc, #388]	; 21f073d0 <.text+0x73d0>
21f07248:	eb00520f 	bl	21f1ba8c <printf>
			return -1;
21f0724c:	e3e03000 	mvn	r3, #0	; 0x0
21f07250:	e50b3038 	str	r3, [fp, #-56]
21f07254:	ea000059 	b	21f073c0 <get_vfatname+0x294>
		}
		if (get_cluster(mydata, curclust, get_vfatname_block,
21f07258:	e51b102c 	ldr	r1, [fp, #-44]
21f0725c:	e51b2028 	ldr	r2, [fp, #-40]
21f07260:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07264:	e283300a 	add	r3, r3, #10	; 0xa
21f07268:	e19230b3 	ldrh	r3, [r2, r3]
21f0726c:	e1a03483 	mov	r3, r3, lsl #9
21f07270:	e51b0028 	ldr	r0, [fp, #-40]
21f07274:	e59f2158 	ldr	r2, [pc, #344]	; 21f073d4 <.text+0x73d4>
21f07278:	ebfffe1a 	bl	21f06ae8 <get_cluster>
21f0727c:	e1a03000 	mov	r3, r0
21f07280:	e3530000 	cmp	r3, #0	; 0x0
21f07284:	0a000002 	beq	21f07294 <get_vfatname+0x168>
				mydata->clust_size * SECTOR_SIZE) != 0) {
			FAT_DPRINT("Error: reading directory block\n");
			return -1;
21f07288:	e3e03000 	mvn	r3, #0	; 0x0
21f0728c:	e50b3038 	str	r3, [fp, #-56]
21f07290:	ea00004a 	b	21f073c0 <get_vfatname+0x294>
		}
		slotptr2 = (dir_slot*) get_vfatname_block;
21f07294:	e59f3138 	ldr	r3, [pc, #312]	; 21f073d4 <.text+0x73d4>
21f07298:	e50b3010 	str	r3, [fp, #-16]
		while (slotptr2->id > 0x01) {
21f0729c:	ea000002 	b	21f072ac <get_vfatname+0x180>
			slotptr2++;
21f072a0:	e51b3010 	ldr	r3, [fp, #-16]
21f072a4:	e2833020 	add	r3, r3, #32	; 0x20
21f072a8:	e50b3010 	str	r3, [fp, #-16]
21f072ac:	e51b3010 	ldr	r3, [fp, #-16]
21f072b0:	e5d33000 	ldrb	r3, [r3]
21f072b4:	e3530001 	cmp	r3, #1	; 0x1
21f072b8:	8afffff8 	bhi	21f072a0 <get_vfatname+0x174>
		}
		/* Save the real directory entry */
		realdent = (dir_entry*)slotptr2 + 1;
21f072bc:	e51b3010 	ldr	r3, [fp, #-16]
21f072c0:	e2833020 	add	r3, r3, #32	; 0x20
21f072c4:	e50b3020 	str	r3, [fp, #-32]
		while ((__u8*)slotptr2 >= get_vfatname_block) {
21f072c8:	ea000007 	b	21f072ec <get_vfatname+0x1c0>
			slot2str(slotptr2, l_name, &idx);
21f072cc:	e24b3024 	sub	r3, fp, #36	; 0x24
21f072d0:	e51b0010 	ldr	r0, [fp, #-16]
21f072d4:	e59b1004 	ldr	r1, [fp, #4]
21f072d8:	e1a02003 	mov	r2, r3
21f072dc:	ebffff16 	bl	21f06f3c <slot2str>
			slotptr2--;
21f072e0:	e51b3010 	ldr	r3, [fp, #-16]
21f072e4:	e2433020 	sub	r3, r3, #32	; 0x20
21f072e8:	e50b3010 	str	r3, [fp, #-16]
21f072ec:	e51b2010 	ldr	r2, [fp, #-16]
21f072f0:	e59f30dc 	ldr	r3, [pc, #220]	; 21f073d4 <.text+0x73d4>
21f072f4:	e1520003 	cmp	r2, r3
21f072f8:	2afffff3 	bcs	21f072cc <get_vfatname+0x1a0>
21f072fc:	ea000001 	b	21f07308 <get_vfatname+0x1dc>
		}
	} else {
		/* Save the real directory entry */
		realdent = (dir_entry*)slotptr;
21f07300:	e51b301c 	ldr	r3, [fp, #-28]
21f07304:	e50b3020 	str	r3, [fp, #-32]
	}

	do {
		slotptr--;
21f07308:	e51b301c 	ldr	r3, [fp, #-28]
21f0730c:	e2433020 	sub	r3, r3, #32	; 0x20
21f07310:	e50b301c 	str	r3, [fp, #-28]
		if (slot2str(slotptr, l_name, &idx)) break;
21f07314:	e24b3024 	sub	r3, fp, #36	; 0x24
21f07318:	e51b001c 	ldr	r0, [fp, #-28]
21f0731c:	e59b1004 	ldr	r1, [fp, #4]
21f07320:	e1a02003 	mov	r2, r3
21f07324:	ebffff04 	bl	21f06f3c <slot2str>
21f07328:	e1a03000 	mov	r3, r0
21f0732c:	e3530000 	cmp	r3, #0	; 0x0
21f07330:	1a000005 	bne	21f0734c <get_vfatname+0x220>
	} while (!(slotptr->id & LAST_LONG_ENTRY_MASK));
21f07334:	e51b301c 	ldr	r3, [fp, #-28]
21f07338:	e5d33000 	ldrb	r3, [r3]
21f0733c:	e1a03323 	mov	r3, r3, lsr #6
21f07340:	e2033001 	and	r3, r3, #1	; 0x1
21f07344:	e3530000 	cmp	r3, #0	; 0x0
21f07348:	0affffee 	beq	21f07308 <get_vfatname+0x1dc>

	l_name[idx] = '\0';
21f0734c:	e51b3024 	ldr	r3, [fp, #-36]
21f07350:	e1a02003 	mov	r2, r3
21f07354:	e59b3004 	ldr	r3, [fp, #4]
21f07358:	e0822003 	add	r2, r2, r3
21f0735c:	e3a03000 	mov	r3, #0	; 0x0
21f07360:	e5c23000 	strb	r3, [r2]
	if (*l_name == DELETED_FLAG) *l_name = '\0';
21f07364:	e59b3004 	ldr	r3, [fp, #4]
21f07368:	e5d33000 	ldrb	r3, [r3]
21f0736c:	e35300e5 	cmp	r3, #229	; 0xe5
21f07370:	1a000003 	bne	21f07384 <get_vfatname+0x258>
21f07374:	e59b3004 	ldr	r3, [fp, #4]
21f07378:	e3a02000 	mov	r2, #0	; 0x0
21f0737c:	e5c32000 	strb	r2, [r3]
21f07380:	ea000006 	b	21f073a0 <get_vfatname+0x274>
	else if (*l_name == aRING) *l_name = '';
21f07384:	e59b3004 	ldr	r3, [fp, #4]
21f07388:	e5d33000 	ldrb	r3, [r3]
21f0738c:	e3530005 	cmp	r3, #5	; 0x5
21f07390:	1a000002 	bne	21f073a0 <get_vfatname+0x274>
21f07394:	e59b3004 	ldr	r3, [fp, #4]
21f07398:	e3e0201a 	mvn	r2, #26	; 0x1a
21f0739c:	e5c32000 	strb	r2, [r3]
	downcase(l_name);
21f073a0:	e59b0004 	ldr	r0, [fp, #4]
21f073a4:	ebfffb83 	bl	21f061b8 <downcase>

	/* Return the real directory entry */
	memcpy(retdent, realdent, sizeof(dir_entry));
21f073a8:	e51b0034 	ldr	r0, [fp, #-52]
21f073ac:	e51b1020 	ldr	r1, [fp, #-32]
21f073b0:	e3a02020 	mov	r2, #32	; 0x20
21f073b4:	eb006f84 	bl	21f231cc <memcpy>

	return 0;
21f073b8:	e3a03000 	mov	r3, #0	; 0x0
21f073bc:	e50b3038 	str	r3, [fp, #-56]
21f073c0:	e51b3038 	ldr	r3, [fp, #-56]
}
21f073c4:	e1a00003 	mov	r0, r3
21f073c8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f073cc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f073d0:	21f2f354 	mvncss	pc, r4, asr r3
21f073d4:	21f344a8 	mvncss	r4, r8, lsr #9

21f073d8 <mkcksum>:


/* Calculate short name checksum */
static __u8
mkcksum(const char *str)
{
21f073d8:	e1a0c00d 	mov	ip, sp
21f073dc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f073e0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f073e4:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f073e8:	e50b0018 	str	r0, [fp, #-24]
	int i;
	__u8 ret = 0;
21f073ec:	e3a03000 	mov	r3, #0	; 0x0
21f073f0:	e54b300d 	strb	r3, [fp, #-13]

	for (i = 0; i < 11; i++) {
21f073f4:	e3a03000 	mov	r3, #0	; 0x0
21f073f8:	e50b3014 	str	r3, [fp, #-20]
21f073fc:	ea000016 	b	21f0745c <mkcksum+0x84>
		ret = (((ret&1)<<7)|((ret&0xfe)>>1)) + str[i];
21f07400:	e55b300d 	ldrb	r3, [fp, #-13]
21f07404:	e2033001 	and	r3, r3, #1	; 0x1
21f07408:	e1a03383 	mov	r3, r3, lsl #7
21f0740c:	e20320ff 	and	r2, r3, #255	; 0xff
21f07410:	e55b300d 	ldrb	r3, [fp, #-13]
21f07414:	e20330fe 	and	r3, r3, #254	; 0xfe
21f07418:	e1a030c3 	mov	r3, r3, asr #1
21f0741c:	e20330ff 	and	r3, r3, #255	; 0xff
21f07420:	e1823003 	orr	r3, r2, r3
21f07424:	e20310ff 	and	r1, r3, #255	; 0xff
21f07428:	e51b3014 	ldr	r3, [fp, #-20]
21f0742c:	e1a02003 	mov	r2, r3
21f07430:	e51b3018 	ldr	r3, [fp, #-24]
21f07434:	e0823003 	add	r3, r2, r3
21f07438:	e5d33000 	ldrb	r3, [r3]
21f0743c:	e20330ff 	and	r3, r3, #255	; 0xff
21f07440:	e1a02001 	mov	r2, r1
21f07444:	e0823003 	add	r3, r2, r3
21f07448:	e20330ff 	and	r3, r3, #255	; 0xff
21f0744c:	e54b300d 	strb	r3, [fp, #-13]
21f07450:	e51b3014 	ldr	r3, [fp, #-20]
21f07454:	e2833001 	add	r3, r3, #1	; 0x1
21f07458:	e50b3014 	str	r3, [fp, #-20]
21f0745c:	e51b3014 	ldr	r3, [fp, #-20]
21f07460:	e353000a 	cmp	r3, #10	; 0xa
21f07464:	daffffe5 	ble	21f07400 <mkcksum+0x28>
	}

	return ret;
21f07468:	e55b300d 	ldrb	r3, [fp, #-13]
}
21f0746c:	e1a00003 	mov	r0, r3
21f07470:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f07474:	e89da800 	ldmia	sp, {fp, sp, pc}

21f07478 <get_dentfromdir>:
#endif


/*
 * Get the directory entry associated with 'filename' from the directory
 * starting at 'startsect'
 */
__u8 get_dentfromdir_block[MAX_CLUSTSIZE];
static dir_entry *get_dentfromdir (fsdata * mydata, int startsect,
				   char *filename, dir_entry * retdent,
				   int dols)
{
21f07478:	e1a0c00d 	mov	ip, sp
21f0747c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f07480:	e24cb004 	sub	fp, ip, #4	; 0x4
21f07484:	e24ddf57 	sub	sp, sp, #348	; 0x15c
21f07488:	e50b014c 	str	r0, [fp, #-332]
21f0748c:	e50b1150 	str	r1, [fp, #-336]
21f07490:	e50b2154 	str	r2, [fp, #-340]
21f07494:	e50b3158 	str	r3, [fp, #-344]
    __u16 prevcksum = 0xffff;
21f07498:	e3e03000 	mvn	r3, #0	; 0x0
21f0749c:	e14b33ba 	strh	r3, [fp, #-58]
    __u32 curclust = START (retdent);
21f074a0:	e51b3158 	ldr	r3, [fp, #-344]
21f074a4:	e1d331ba 	ldrh	r3, [r3, #26]
21f074a8:	e50b3164 	str	r3, [fp, #-356]
21f074ac:	e51b314c 	ldr	r3, [fp, #-332]
21f074b0:	e5933c00 	ldr	r3, [r3, #3072]
21f074b4:	e3530020 	cmp	r3, #32	; 0x20
21f074b8:	1a000004 	bne	21f074d0 <get_dentfromdir+0x58>
21f074bc:	e51b3158 	ldr	r3, [fp, #-344]
21f074c0:	e1d331b4 	ldrh	r3, [r3, #20]
21f074c4:	e1a03803 	mov	r3, r3, lsl #16
21f074c8:	e50b3160 	str	r3, [fp, #-352]
21f074cc:	ea000001 	b	21f074d8 <get_dentfromdir+0x60>
21f074d0:	e3a01000 	mov	r1, #0	; 0x0
21f074d4:	e50b1160 	str	r1, [fp, #-352]
21f074d8:	e51b2164 	ldr	r2, [fp, #-356]
21f074dc:	e51b1160 	ldr	r1, [fp, #-352]
21f074e0:	e0823001 	add	r3, r2, r1
21f074e4:	e50b3038 	str	r3, [fp, #-56]
    int files = 0, dirs = 0;
21f074e8:	e3a03000 	mov	r3, #0	; 0x0
21f074ec:	e50b3034 	str	r3, [fp, #-52]
21f074f0:	e3a03000 	mov	r3, #0	; 0x0
21f074f4:	e50b3030 	str	r3, [fp, #-48]

    FAT_DPRINT ("get_dentfromdir: %s\n", filename);
    while (1) {
	dir_entry *dentptr;
	int i;

	if (get_cluster (mydata, curclust, get_dentfromdir_block,
21f074f8:	e51b214c 	ldr	r2, [fp, #-332]
21f074fc:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07500:	e283300a 	add	r3, r3, #10	; 0xa
21f07504:	e19230b3 	ldrh	r3, [r2, r3]
21f07508:	e1a03483 	mov	r3, r3, lsl #9
21f0750c:	e51b014c 	ldr	r0, [fp, #-332]
21f07510:	e51b1038 	ldr	r1, [fp, #-56]
21f07514:	e59f2410 	ldr	r2, [pc, #1040]	; 21f0792c <.text+0x792c>
21f07518:	ebfffd72 	bl	21f06ae8 <get_cluster>
21f0751c:	e1a03000 	mov	r3, r0
21f07520:	e3530000 	cmp	r3, #0	; 0x0
21f07524:	0a000002 	beq	21f07534 <get_dentfromdir+0xbc>
		 mydata->clust_size * SECTOR_SIZE) != 0) {
	    FAT_DPRINT ("Error: reading directory block\n");
	    return NULL;
21f07528:	e3a02000 	mov	r2, #0	; 0x0
21f0752c:	e50b215c 	str	r2, [fp, #-348]
21f07530:	ea0000f9 	b	21f0791c <get_dentfromdir+0x4a4>
	}
	dentptr = (dir_entry *) get_dentfromdir_block;
21f07534:	e59f33f0 	ldr	r3, [pc, #1008]	; 21f0792c <.text+0x792c>
21f07538:	e50b302c 	str	r3, [fp, #-44]
	for (i = 0; i < DIRENTSPERCLUST; i++) {
21f0753c:	e3a03000 	mov	r3, #0	; 0x0
21f07540:	e50b3028 	str	r3, [fp, #-40]
21f07544:	ea0000da 	b	21f078b4 <get_dentfromdir+0x43c>
	    char s_name[14], l_name[256];

	    l_name[0] = '\0';
21f07548:	e3a03000 	mov	r3, #0	; 0x0
21f0754c:	e54b3148 	strb	r3, [fp, #-328]
	    if (dentptr->name[0] == DELETED_FLAG) {
21f07550:	e51b302c 	ldr	r3, [fp, #-44]
21f07554:	e5d33000 	ldrb	r3, [r3]
21f07558:	e35300e5 	cmp	r3, #229	; 0xe5
21f0755c:	1a000003 	bne	21f07570 <get_dentfromdir+0xf8>
		    dentptr++;
21f07560:	e51b302c 	ldr	r3, [fp, #-44]
21f07564:	e2833020 	add	r3, r3, #32	; 0x20
21f07568:	e50b302c 	str	r3, [fp, #-44]
		    continue;
21f0756c:	ea0000cd 	b	21f078a8 <get_dentfromdir+0x430>
	    }
	    if ((dentptr->attr & ATTR_VOLUME)) {
21f07570:	e51b302c 	ldr	r3, [fp, #-44]
21f07574:	e5d3300b 	ldrb	r3, [r3, #11]
21f07578:	e1a031a3 	mov	r3, r3, lsr #3
21f0757c:	e2033001 	and	r3, r3, #1	; 0x1
21f07580:	e20330ff 	and	r3, r3, #255	; 0xff
21f07584:	e3530000 	cmp	r3, #0	; 0x0
21f07588:	0a000054 	beq	21f076e0 <get_dentfromdir+0x268>
#ifdef CONFIG_SUPPORT_VFAT
		if ((dentptr->attr & ATTR_VFAT) &&
21f0758c:	e51b302c 	ldr	r3, [fp, #-44]
21f07590:	e5d3300b 	ldrb	r3, [r3, #11]
21f07594:	e203300f 	and	r3, r3, #15	; 0xf
21f07598:	e3530000 	cmp	r3, #0	; 0x0
21f0759c:	0a00004b 	beq	21f076d0 <get_dentfromdir+0x258>
21f075a0:	e51b302c 	ldr	r3, [fp, #-44]
21f075a4:	e5d33000 	ldrb	r3, [r3]
21f075a8:	e1a03323 	mov	r3, r3, lsr #6
21f075ac:	e2033001 	and	r3, r3, #1	; 0x1
21f075b0:	e20330ff 	and	r3, r3, #255	; 0xff
21f075b4:	e2233001 	eor	r3, r3, #1	; 0x1
21f075b8:	e20330ff 	and	r3, r3, #255	; 0xff
21f075bc:	e3530000 	cmp	r3, #0	; 0x0
21f075c0:	1a000042 	bne	21f076d0 <get_dentfromdir+0x258>
		    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
		    prevcksum = ((dir_slot *) dentptr)
21f075c4:	e51b302c 	ldr	r3, [fp, #-44]
21f075c8:	e5d3300d 	ldrb	r3, [r3, #13]
21f075cc:	e14b33ba 	strh	r3, [fp, #-58]
			    ->alias_checksum;
		    get_vfatname (mydata, curclust, get_dentfromdir_block,
21f075d0:	e51b2038 	ldr	r2, [fp, #-56]
21f075d4:	e24b3f52 	sub	r3, fp, #328	; 0x148
21f075d8:	e58d3000 	str	r3, [sp]
21f075dc:	e51b014c 	ldr	r0, [fp, #-332]
21f075e0:	e1a01002 	mov	r1, r2
21f075e4:	e59f2340 	ldr	r2, [pc, #832]	; 21f0792c <.text+0x792c>
21f075e8:	e51b302c 	ldr	r3, [fp, #-44]
21f075ec:	ebfffece 	bl	21f0712c <get_vfatname>
				  dentptr, l_name);
		    if (dols) {
21f075f0:	e59b3004 	ldr	r3, [fp, #4]
21f075f4:	e3530000 	cmp	r3, #0	; 0x0
21f075f8:	0a000038 	beq	21f076e0 <get_dentfromdir+0x268>
			int isdir = (dentptr->attr & ATTR_DIR);
21f075fc:	e51b302c 	ldr	r3, [fp, #-44]
21f07600:	e5d3300b 	ldrb	r3, [r3, #11]
21f07604:	e2033010 	and	r3, r3, #16	; 0x10
21f07608:	e50b3024 	str	r3, [fp, #-36]
			char dirc;
			int doit = 0;
21f0760c:	e3a03000 	mov	r3, #0	; 0x0
21f07610:	e50b301c 	str	r3, [fp, #-28]

			if (isdir) {
21f07614:	e51b3024 	ldr	r3, [fp, #-36]
21f07618:	e3530000 	cmp	r3, #0	; 0x0
21f0761c:	0a000007 	beq	21f07640 <get_dentfromdir+0x1c8>
			    dirs++;
21f07620:	e51b3030 	ldr	r3, [fp, #-48]
21f07624:	e2833001 	add	r3, r3, #1	; 0x1
21f07628:	e50b3030 	str	r3, [fp, #-48]
			    dirc = '/';
21f0762c:	e3a0302f 	mov	r3, #47	; 0x2f
21f07630:	e54b301d 	strb	r3, [fp, #-29]
			    doit = 1;
21f07634:	e3a03001 	mov	r3, #1	; 0x1
21f07638:	e50b301c 	str	r3, [fp, #-28]
21f0763c:	ea000009 	b	21f07668 <get_dentfromdir+0x1f0>
			} else {
			    dirc = ' ';
21f07640:	e3a03020 	mov	r3, #32	; 0x20
21f07644:	e54b301d 	strb	r3, [fp, #-29]
			    if (l_name[0] != 0) {
21f07648:	e55b3148 	ldrb	r3, [fp, #-328]
21f0764c:	e3530000 	cmp	r3, #0	; 0x0
21f07650:	0a000004 	beq	21f07668 <get_dentfromdir+0x1f0>
				files++;
21f07654:	e51b3034 	ldr	r3, [fp, #-52]
21f07658:	e2833001 	add	r3, r3, #1	; 0x1
21f0765c:	e50b3034 	str	r3, [fp, #-52]
				doit = 1;
21f07660:	e3a03001 	mov	r3, #1	; 0x1
21f07664:	e50b301c 	str	r3, [fp, #-28]
			    }
			}
			if (doit) {
21f07668:	e51b301c 	ldr	r3, [fp, #-28]
21f0766c:	e3530000 	cmp	r3, #0	; 0x0
21f07670:	0a000012 	beq	21f076c0 <get_dentfromdir+0x248>
			    if (dirc == ' ') {
21f07674:	e55b301d 	ldrb	r3, [fp, #-29]
21f07678:	e3530020 	cmp	r3, #32	; 0x20
21f0767c:	1a00000a 	bne	21f076ac <get_dentfromdir+0x234>
				printf (" %8ld   %s%c\n",
21f07680:	e51b302c 	ldr	r3, [fp, #-44]
21f07684:	e593301c 	ldr	r3, [r3, #28]
21f07688:	e1a02003 	mov	r2, r3
21f0768c:	e55bc01d 	ldrb	ip, [fp, #-29]
21f07690:	e24b3f52 	sub	r3, fp, #328	; 0x148
21f07694:	e59f0294 	ldr	r0, [pc, #660]	; 21f07930 <.text+0x7930>
21f07698:	e1a01002 	mov	r1, r2
21f0769c:	e1a02003 	mov	r2, r3
21f076a0:	e1a0300c 	mov	r3, ip
21f076a4:	eb0050f8 	bl	21f1ba8c <printf>
21f076a8:	ea000004 	b	21f076c0 <get_dentfromdir+0x248>
					(long) FAT2CPU32 (dentptr->size),
					l_name, dirc);
			    } else {
				printf ("            %s%c\n", l_name, dirc);
21f076ac:	e55b201d 	ldrb	r2, [fp, #-29]
21f076b0:	e24b3f52 	sub	r3, fp, #328	; 0x148
21f076b4:	e59f0278 	ldr	r0, [pc, #632]	; 21f07934 <.text+0x7934>
21f076b8:	e1a01003 	mov	r1, r3
21f076bc:	eb0050f2 	bl	21f1ba8c <printf>
			    }
			}
			dentptr++;
21f076c0:	e51b302c 	ldr	r3, [fp, #-44]
21f076c4:	e2833020 	add	r3, r3, #32	; 0x20
21f076c8:	e50b302c 	str	r3, [fp, #-44]
			continue;
21f076cc:	ea000075 	b	21f078a8 <get_dentfromdir+0x430>
		    }
		    FAT_DPRINT ("vfatname: |%s|\n", l_name);
		} else
#endif
		{
		    /* Volume label or VFAT entry */
		    dentptr++;
21f076d0:	e51b302c 	ldr	r3, [fp, #-44]
21f076d4:	e2833020 	add	r3, r3, #32	; 0x20
21f076d8:	e50b302c 	str	r3, [fp, #-44]
		    continue;
21f076dc:	ea000071 	b	21f078a8 <get_dentfromdir+0x430>
		}
	    }
	    if (dentptr->name[0] == 0) {
21f076e0:	e51b302c 	ldr	r3, [fp, #-44]
21f076e4:	e5d33000 	ldrb	r3, [r3]
21f076e8:	e3530000 	cmp	r3, #0	; 0x0
21f076ec:	1a000009 	bne	21f07718 <get_dentfromdir+0x2a0>
		if (dols) {
21f076f0:	e59b3004 	ldr	r3, [fp, #4]
21f076f4:	e3530000 	cmp	r3, #0	; 0x0
21f076f8:	0a000003 	beq	21f0770c <get_dentfromdir+0x294>
		    printf ("\n%d file(s), %d dir(s)\n\n", files, dirs);
21f076fc:	e59f0234 	ldr	r0, [pc, #564]	; 21f07938 <.text+0x7938>
21f07700:	e51b1034 	ldr	r1, [fp, #-52]
21f07704:	e51b2030 	ldr	r2, [fp, #-48]
21f07708:	eb0050df 	bl	21f1ba8c <printf>
		}
		FAT_DPRINT ("Dentname == NULL - %d\n", i);
		return NULL;
21f0770c:	e3a03000 	mov	r3, #0	; 0x0
21f07710:	e50b315c 	str	r3, [fp, #-348]
21f07714:	ea000080 	b	21f0791c <get_dentfromdir+0x4a4>
	    }
#ifdef CONFIG_SUPPORT_VFAT
	    if (dols && mkcksum (dentptr->name) == prevcksum) {
21f07718:	e59b3004 	ldr	r3, [fp, #4]
21f0771c:	e3530000 	cmp	r3, #0	; 0x0
21f07720:	0a00000b 	beq	21f07754 <get_dentfromdir+0x2dc>
21f07724:	e51b302c 	ldr	r3, [fp, #-44]
21f07728:	e1a00003 	mov	r0, r3
21f0772c:	ebffff29 	bl	21f073d8 <mkcksum>
21f07730:	e1a03000 	mov	r3, r0
21f07734:	e1a02003 	mov	r2, r3
21f07738:	e15b33ba 	ldrh	r3, [fp, #-58]
21f0773c:	e1530002 	cmp	r3, r2
21f07740:	1a000003 	bne	21f07754 <get_dentfromdir+0x2dc>
		dentptr++;
21f07744:	e51b302c 	ldr	r3, [fp, #-44]
21f07748:	e2833020 	add	r3, r3, #32	; 0x20
21f0774c:	e50b302c 	str	r3, [fp, #-44]
		continue;
21f07750:	ea000054 	b	21f078a8 <get_dentfromdir+0x430>
	    }
#endif
	    get_name (dentptr, s_name);
21f07754:	e24b3048 	sub	r3, fp, #72	; 0x48
21f07758:	e51b002c 	ldr	r0, [fp, #-44]
21f0775c:	e1a01003 	mov	r1, r3
21f07760:	ebfffb8a 	bl	21f06590 <get_name>
	    if (dols) {
21f07764:	e59b3004 	ldr	r3, [fp, #4]
21f07768:	e3530000 	cmp	r3, #0	; 0x0
21f0776c:	0a000034 	beq	21f07844 <get_dentfromdir+0x3cc>
		int isdir = (dentptr->attr & ATTR_DIR);
21f07770:	e51b302c 	ldr	r3, [fp, #-44]
21f07774:	e5d3300b 	ldrb	r3, [r3, #11]
21f07778:	e2033010 	and	r3, r3, #16	; 0x10
21f0777c:	e50b3018 	str	r3, [fp, #-24]
		char dirc;
		int doit = 0;
21f07780:	e3a03000 	mov	r3, #0	; 0x0
21f07784:	e50b3010 	str	r3, [fp, #-16]

		if (isdir) {
21f07788:	e51b3018 	ldr	r3, [fp, #-24]
21f0778c:	e3530000 	cmp	r3, #0	; 0x0
21f07790:	0a000007 	beq	21f077b4 <get_dentfromdir+0x33c>
		    dirs++;
21f07794:	e51b3030 	ldr	r3, [fp, #-48]
21f07798:	e2833001 	add	r3, r3, #1	; 0x1
21f0779c:	e50b3030 	str	r3, [fp, #-48]
		    dirc = '/';
21f077a0:	e3a0302f 	mov	r3, #47	; 0x2f
21f077a4:	e54b3011 	strb	r3, [fp, #-17]
		    doit = 1;
21f077a8:	e3a03001 	mov	r3, #1	; 0x1
21f077ac:	e50b3010 	str	r3, [fp, #-16]
21f077b0:	ea000009 	b	21f077dc <get_dentfromdir+0x364>
		} else {
		    dirc = ' ';
21f077b4:	e3a03020 	mov	r3, #32	; 0x20
21f077b8:	e54b3011 	strb	r3, [fp, #-17]
		    if (s_name[0] != 0) {
21f077bc:	e55b3048 	ldrb	r3, [fp, #-72]
21f077c0:	e3530000 	cmp	r3, #0	; 0x0
21f077c4:	0a000004 	beq	21f077dc <get_dentfromdir+0x364>
			files++;
21f077c8:	e51b3034 	ldr	r3, [fp, #-52]
21f077cc:	e2833001 	add	r3, r3, #1	; 0x1
21f077d0:	e50b3034 	str	r3, [fp, #-52]
			doit = 1;
21f077d4:	e3a03001 	mov	r3, #1	; 0x1
21f077d8:	e50b3010 	str	r3, [fp, #-16]
		    }
		}
		if (doit) {
21f077dc:	e51b3010 	ldr	r3, [fp, #-16]
21f077e0:	e3530000 	cmp	r3, #0	; 0x0
21f077e4:	0a000012 	beq	21f07834 <get_dentfromdir+0x3bc>
		    if (dirc == ' ') {
21f077e8:	e55b3011 	ldrb	r3, [fp, #-17]
21f077ec:	e3530020 	cmp	r3, #32	; 0x20
21f077f0:	1a00000a 	bne	21f07820 <get_dentfromdir+0x3a8>
			printf (" %8ld   %s%c\n",
21f077f4:	e51b302c 	ldr	r3, [fp, #-44]
21f077f8:	e593301c 	ldr	r3, [r3, #28]
21f077fc:	e1a02003 	mov	r2, r3
21f07800:	e55bc011 	ldrb	ip, [fp, #-17]
21f07804:	e24b3048 	sub	r3, fp, #72	; 0x48
21f07808:	e59f0120 	ldr	r0, [pc, #288]	; 21f07930 <.text+0x7930>
21f0780c:	e1a01002 	mov	r1, r2
21f07810:	e1a02003 	mov	r2, r3
21f07814:	e1a0300c 	mov	r3, ip
21f07818:	eb00509b 	bl	21f1ba8c <printf>
21f0781c:	ea000004 	b	21f07834 <get_dentfromdir+0x3bc>
				(long) FAT2CPU32 (dentptr->size), s_name,
				dirc);
		    } else {
			printf ("            %s%c\n", s_name, dirc);
21f07820:	e55b2011 	ldrb	r2, [fp, #-17]
21f07824:	e24b3048 	sub	r3, fp, #72	; 0x48
21f07828:	e59f0104 	ldr	r0, [pc, #260]	; 21f07934 <.text+0x7934>
21f0782c:	e1a01003 	mov	r1, r3
21f07830:	eb005095 	bl	21f1ba8c <printf>
		    }
		}
		dentptr++;
21f07834:	e51b302c 	ldr	r3, [fp, #-44]
21f07838:	e2833020 	add	r3, r3, #32	; 0x20
21f0783c:	e50b302c 	str	r3, [fp, #-44]
		continue;
21f07840:	ea000018 	b	21f078a8 <get_dentfromdir+0x430>
	    }
	    if (strcmp (filename, s_name) && strcmp (filename, l_name)) {
21f07844:	e24b3048 	sub	r3, fp, #72	; 0x48
21f07848:	e51b0154 	ldr	r0, [fp, #-340]
21f0784c:	e1a01003 	mov	r1, r3
21f07850:	eb006c3d 	bl	21f2294c <strcmp>
21f07854:	e1a03000 	mov	r3, r0
21f07858:	e3530000 	cmp	r3, #0	; 0x0
21f0785c:	0a00000a 	beq	21f0788c <get_dentfromdir+0x414>
21f07860:	e24b3f52 	sub	r3, fp, #328	; 0x148
21f07864:	e51b0154 	ldr	r0, [fp, #-340]
21f07868:	e1a01003 	mov	r1, r3
21f0786c:	eb006c36 	bl	21f2294c <strcmp>
21f07870:	e1a03000 	mov	r3, r0
21f07874:	e3530000 	cmp	r3, #0	; 0x0
21f07878:	0a000003 	beq	21f0788c <get_dentfromdir+0x414>
		FAT_DPRINT ("Mismatch: |%s|%s|\n", s_name, l_name);
		dentptr++;
21f0787c:	e51b302c 	ldr	r3, [fp, #-44]
21f07880:	e2833020 	add	r3, r3, #32	; 0x20
21f07884:	e50b302c 	str	r3, [fp, #-44]
		continue;
21f07888:	ea000006 	b	21f078a8 <get_dentfromdir+0x430>
	    }
	    memcpy (retdent, dentptr, sizeof (dir_entry));
21f0788c:	e51b0158 	ldr	r0, [fp, #-344]
21f07890:	e51b102c 	ldr	r1, [fp, #-44]
21f07894:	e3a02020 	mov	r2, #32	; 0x20
21f07898:	eb006e4b 	bl	21f231cc <memcpy>

	    FAT_DPRINT ("DentName: %s", s_name);
	    FAT_DPRINT (", start: 0x%x", START (dentptr));
	    FAT_DPRINT (", size:  0x%x %s\n",
			FAT2CPU32 (dentptr->size),
			(dentptr->attr & ATTR_DIR) ? "(DIR)" : "");

	    return retdent;
21f0789c:	e51b1158 	ldr	r1, [fp, #-344]
21f078a0:	e50b115c 	str	r1, [fp, #-348]
21f078a4:	ea00001c 	b	21f0791c <get_dentfromdir+0x4a4>
21f078a8:	e51b3028 	ldr	r3, [fp, #-40]
21f078ac:	e2833001 	add	r3, r3, #1	; 0x1
21f078b0:	e50b3028 	str	r3, [fp, #-40]
21f078b4:	e51b1028 	ldr	r1, [fp, #-40]
21f078b8:	e51b214c 	ldr	r2, [fp, #-332]
21f078bc:	e3a03b03 	mov	r3, #3072	; 0xc00
21f078c0:	e283300a 	add	r3, r3, #10	; 0xa
21f078c4:	e19230b3 	ldrh	r3, [r2, r3]
21f078c8:	e1a03483 	mov	r3, r3, lsl #9
21f078cc:	e1a032a3 	mov	r3, r3, lsr #5
21f078d0:	e1510003 	cmp	r1, r3
21f078d4:	3affff1b 	bcc	21f07548 <get_dentfromdir+0xd0>
	}
	curclust = get_fatent (mydata, curclust);
21f078d8:	e51b014c 	ldr	r0, [fp, #-332]
21f078dc:	e51b1038 	ldr	r1, [fp, #-56]
21f078e0:	ebfffb81 	bl	21f066ec <get_fatent>
21f078e4:	e1a03000 	mov	r3, r0
21f078e8:	e50b3038 	str	r3, [fp, #-56]
	if (curclust <= 0x0001 || curclust >= 0xfff0) {
21f078ec:	e51b3038 	ldr	r3, [fp, #-56]
21f078f0:	e3530001 	cmp	r3, #1	; 0x1
21f078f4:	9a000004 	bls	21f0790c <get_dentfromdir+0x494>
21f078f8:	e51b2038 	ldr	r2, [fp, #-56]
21f078fc:	e3a03cff 	mov	r3, #65280	; 0xff00
21f07900:	e28330ef 	add	r3, r3, #239	; 0xef
21f07904:	e1520003 	cmp	r2, r3
21f07908:	9afffefa 	bls	21f074f8 <get_dentfromdir+0x80>
	    FAT_DPRINT ("curclust: 0x%x\n", curclust);
	    FAT_ERROR ("Invalid FAT entry\n");
21f0790c:	e59f0028 	ldr	r0, [pc, #40]	; 21f0793c <.text+0x793c>
21f07910:	eb00505d 	bl	21f1ba8c <printf>
	    return NULL;
21f07914:	e3a02000 	mov	r2, #0	; 0x0
21f07918:	e50b215c 	str	r2, [fp, #-348]
21f0791c:	e51b315c 	ldr	r3, [fp, #-348]
	}
    }

    return NULL;
}
21f07920:	e1a00003 	mov	r0, r3
21f07924:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f07928:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0792c:	21f444a8 	mvncss	r4, r8, lsr #9
21f07930:	21f2f368 	mvncss	pc, r8, ror #6
21f07934:	21f2f378 	mvncss	pc, r8, ror r3
21f07938:	21f2f38c 	mvncss	pc, ip, lsl #7
21f0793c:	21f2f354 	mvncss	pc, r4, asr r3

21f07940 <read_bootsectandvi>:


/*
 * Read boot sector and volume info from a FAT filesystem
 */
static int
read_bootsectandvi(boot_sector *bs, volume_info *volinfo, int *fatsize)
{
21f07940:	e1a0c00d 	mov	ip, sp
21f07944:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f07948:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0794c:	e24ddf85 	sub	sp, sp, #532	; 0x214
21f07950:	e50b0214 	str	r0, [fp, #-532]
21f07954:	e50b1218 	str	r1, [fp, #-536]
21f07958:	e50b221c 	str	r2, [fp, #-540]
	__u8 block[FS_BLOCK_SIZE];
	volume_info *vistart;

	if (disk_read(0, 1, block) < 0) {
21f0795c:	e24b3e21 	sub	r3, fp, #528	; 0x210
21f07960:	e3a00000 	mov	r0, #0	; 0x0
21f07964:	e3a01001 	mov	r1, #1	; 0x1
21f07968:	e1a02003 	mov	r2, r3
21f0796c:	ebfffa2f 	bl	21f06230 <disk_read>
21f07970:	e1a03000 	mov	r3, r0
21f07974:	e3530000 	cmp	r3, #0	; 0x0
21f07978:	aa000002 	bge	21f07988 <read_bootsectandvi+0x48>
		FAT_DPRINT("Error: reading block\n");
		return -1;
21f0797c:	e3e03000 	mvn	r3, #0	; 0x0
21f07980:	e50b3220 	str	r3, [fp, #-544]
21f07984:	ea000071 	b	21f07b50 <read_bootsectandvi+0x210>
	}

	memcpy(bs, block, sizeof(boot_sector));
21f07988:	e24b3e21 	sub	r3, fp, #528	; 0x210
21f0798c:	e51b0214 	ldr	r0, [fp, #-532]
21f07990:	e1a01003 	mov	r1, r3
21f07994:	e3a02040 	mov	r2, #64	; 0x40
21f07998:	eb006e0b 	bl	21f231cc <memcpy>
	bs->reserved	= FAT2CPU16(bs->reserved);
21f0799c:	e51b3214 	ldr	r3, [fp, #-532]
21f079a0:	e1d320be 	ldrh	r2, [r3, #14]
21f079a4:	e51b3214 	ldr	r3, [fp, #-532]
21f079a8:	e1c320be 	strh	r2, [r3, #14]
	bs->fat_length	= FAT2CPU16(bs->fat_length);
21f079ac:	e51b3214 	ldr	r3, [fp, #-532]
21f079b0:	e1d321b6 	ldrh	r2, [r3, #22]
21f079b4:	e51b3214 	ldr	r3, [fp, #-532]
21f079b8:	e1c321b6 	strh	r2, [r3, #22]
	bs->secs_track	= FAT2CPU16(bs->secs_track);
21f079bc:	e51b3214 	ldr	r3, [fp, #-532]
21f079c0:	e1d321b8 	ldrh	r2, [r3, #24]
21f079c4:	e51b3214 	ldr	r3, [fp, #-532]
21f079c8:	e1c321b8 	strh	r2, [r3, #24]
	bs->heads	= FAT2CPU16(bs->heads);
21f079cc:	e51b3214 	ldr	r3, [fp, #-532]
21f079d0:	e1d321ba 	ldrh	r2, [r3, #26]
21f079d4:	e51b3214 	ldr	r3, [fp, #-532]
21f079d8:	e1c321ba 	strh	r2, [r3, #26]
#if 0 /* UNUSED */
	bs->hidden	= FAT2CPU32(bs->hidden);
#endif
	bs->total_sect	= FAT2CPU32(bs->total_sect);
21f079dc:	e51b3214 	ldr	r3, [fp, #-532]
21f079e0:	e5932020 	ldr	r2, [r3, #32]
21f079e4:	e51b3214 	ldr	r3, [fp, #-532]
21f079e8:	e5832020 	str	r2, [r3, #32]

	/* FAT32 entries */
	if (bs->fat_length == 0) {
21f079ec:	e51b3214 	ldr	r3, [fp, #-532]
21f079f0:	e1d331b6 	ldrh	r3, [r3, #22]
21f079f4:	e3530000 	cmp	r3, #0	; 0x0
21f079f8:	1a00001a 	bne	21f07a68 <read_bootsectandvi+0x128>
		/* Assume FAT32 */
		bs->fat32_length = FAT2CPU32(bs->fat32_length);
21f079fc:	e51b3214 	ldr	r3, [fp, #-532]
21f07a00:	e5932024 	ldr	r2, [r3, #36]
21f07a04:	e51b3214 	ldr	r3, [fp, #-532]
21f07a08:	e5832024 	str	r2, [r3, #36]
		bs->flags	 = FAT2CPU16(bs->flags);
21f07a0c:	e51b3214 	ldr	r3, [fp, #-532]
21f07a10:	e1d322b8 	ldrh	r2, [r3, #40]
21f07a14:	e51b3214 	ldr	r3, [fp, #-532]
21f07a18:	e1c322b8 	strh	r2, [r3, #40]
		bs->root_cluster = FAT2CPU32(bs->root_cluster);
21f07a1c:	e51b3214 	ldr	r3, [fp, #-532]
21f07a20:	e593202c 	ldr	r2, [r3, #44]
21f07a24:	e51b3214 	ldr	r3, [fp, #-532]
21f07a28:	e583202c 	str	r2, [r3, #44]
		bs->info_sector  = FAT2CPU16(bs->info_sector);
21f07a2c:	e51b3214 	ldr	r3, [fp, #-532]
21f07a30:	e1d323b0 	ldrh	r2, [r3, #48]
21f07a34:	e51b3214 	ldr	r3, [fp, #-532]
21f07a38:	e1c323b0 	strh	r2, [r3, #48]
		bs->backup_boot  = FAT2CPU16(bs->backup_boot);
21f07a3c:	e51b3214 	ldr	r3, [fp, #-532]
21f07a40:	e1d323b2 	ldrh	r2, [r3, #50]
21f07a44:	e51b3214 	ldr	r3, [fp, #-532]
21f07a48:	e1c323b2 	strh	r2, [r3, #50]
		vistart = (volume_info*) (block + sizeof(boot_sector));
21f07a4c:	e24b3e21 	sub	r3, fp, #528	; 0x210
21f07a50:	e2833040 	add	r3, r3, #64	; 0x40
21f07a54:	e50b3010 	str	r3, [fp, #-16]
		*fatsize = 32;
21f07a58:	e51b221c 	ldr	r2, [fp, #-540]
21f07a5c:	e3a03020 	mov	r3, #32	; 0x20
21f07a60:	e5823000 	str	r3, [r2]
21f07a64:	ea000005 	b	21f07a80 <read_bootsectandvi+0x140>
	} else {
		vistart = (volume_info*) &(bs->fat32_length);
21f07a68:	e51b3214 	ldr	r3, [fp, #-532]
21f07a6c:	e2833024 	add	r3, r3, #36	; 0x24
21f07a70:	e50b3010 	str	r3, [fp, #-16]
		*fatsize = 0;
21f07a74:	e51b221c 	ldr	r2, [fp, #-540]
21f07a78:	e3a03000 	mov	r3, #0	; 0x0
21f07a7c:	e5823000 	str	r3, [r2]
	}
	memcpy(volinfo, vistart, sizeof(volume_info));
21f07a80:	e51b0218 	ldr	r0, [fp, #-536]
21f07a84:	e51b1010 	ldr	r1, [fp, #-16]
21f07a88:	e3a0201c 	mov	r2, #28	; 0x1c
21f07a8c:	eb006dce 	bl	21f231cc <memcpy>

	/* Terminate fs_type string. Writing past the end of vistart
	   is ok - it's just the buffer. */
	vistart->fs_type[8] = '\0';
21f07a90:	e51b2010 	ldr	r2, [fp, #-16]
21f07a94:	e3a03000 	mov	r3, #0	; 0x0
21f07a98:	e5c2301a 	strb	r3, [r2, #26]

	if (*fatsize == 32) {
21f07a9c:	e51b321c 	ldr	r3, [fp, #-540]
21f07aa0:	e5933000 	ldr	r3, [r3]
21f07aa4:	e3530020 	cmp	r3, #32	; 0x20
21f07aa8:	1a00000a 	bne	21f07ad8 <read_bootsectandvi+0x198>
		if (compare_sign(FAT32_SIGN, vistart->fs_type) == 0) {
21f07aac:	e51b3010 	ldr	r3, [fp, #-16]
21f07ab0:	e2833012 	add	r3, r3, #18	; 0x12
21f07ab4:	e59f00a4 	ldr	r0, [pc, #164]	; 21f07b60 <.text+0x7b60>
21f07ab8:	e1a01003 	mov	r1, r3
21f07abc:	ebfffa90 	bl	21f06504 <compare_sign>
21f07ac0:	e1a03000 	mov	r3, r0
21f07ac4:	e3530000 	cmp	r3, #0	; 0x0
21f07ac8:	1a00001e 	bne	21f07b48 <read_bootsectandvi+0x208>
			return 0;
21f07acc:	e3a03000 	mov	r3, #0	; 0x0
21f07ad0:	e50b3220 	str	r3, [fp, #-544]
21f07ad4:	ea00001d 	b	21f07b50 <read_bootsectandvi+0x210>
		}
	} else {
		if (compare_sign(FAT12_SIGN, vistart->fs_type) == 0) {
21f07ad8:	e51b3010 	ldr	r3, [fp, #-16]
21f07adc:	e2833012 	add	r3, r3, #18	; 0x12
21f07ae0:	e59f007c 	ldr	r0, [pc, #124]	; 21f07b64 <.text+0x7b64>
21f07ae4:	e1a01003 	mov	r1, r3
21f07ae8:	ebfffa85 	bl	21f06504 <compare_sign>
21f07aec:	e1a03000 	mov	r3, r0
21f07af0:	e3530000 	cmp	r3, #0	; 0x0
21f07af4:	1a000005 	bne	21f07b10 <read_bootsectandvi+0x1d0>
			*fatsize = 12;
21f07af8:	e51b221c 	ldr	r2, [fp, #-540]
21f07afc:	e3a0300c 	mov	r3, #12	; 0xc
21f07b00:	e5823000 	str	r3, [r2]
			return 0;
21f07b04:	e3a03000 	mov	r3, #0	; 0x0
21f07b08:	e50b3220 	str	r3, [fp, #-544]
21f07b0c:	ea00000f 	b	21f07b50 <read_bootsectandvi+0x210>
		}
		if (compare_sign(FAT16_SIGN, vistart->fs_type) == 0) {
21f07b10:	e51b3010 	ldr	r3, [fp, #-16]
21f07b14:	e2833012 	add	r3, r3, #18	; 0x12
21f07b18:	e59f0048 	ldr	r0, [pc, #72]	; 21f07b68 <.text+0x7b68>
21f07b1c:	e1a01003 	mov	r1, r3
21f07b20:	ebfffa77 	bl	21f06504 <compare_sign>
21f07b24:	e1a03000 	mov	r3, r0
21f07b28:	e3530000 	cmp	r3, #0	; 0x0
21f07b2c:	1a000005 	bne	21f07b48 <read_bootsectandvi+0x208>
			*fatsize = 16;
21f07b30:	e51b221c 	ldr	r2, [fp, #-540]
21f07b34:	e3a03010 	mov	r3, #16	; 0x10
21f07b38:	e5823000 	str	r3, [r2]
			return 0;
21f07b3c:	e3a03000 	mov	r3, #0	; 0x0
21f07b40:	e50b3220 	str	r3, [fp, #-544]
21f07b44:	ea000001 	b	21f07b50 <read_bootsectandvi+0x210>
		}
	}

	FAT_DPRINT("Error: broken fs_type sign\n");
	return -1;
21f07b48:	e3e03000 	mvn	r3, #0	; 0x0
21f07b4c:	e50b3220 	str	r3, [fp, #-544]
21f07b50:	e51b3220 	ldr	r3, [fp, #-544]
}
21f07b54:	e1a00003 	mov	r0, r3
21f07b58:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f07b5c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f07b60:	21f2f3a8 	mvncss	pc, r8, lsr #7
21f07b64:	21f2f3b4 	ldrcsh	pc, [r2, #52]!
21f07b68:	21f2f3c0 	mvncss	pc, r0, asr #7

21f07b6c <do_fat_read>:


__u8 do_fat_read_block[MAX_CLUSTSIZE];  /* Block buffer */
long
do_fat_read (const char *filename, void *buffer, unsigned long maxsize,
	     int dols)
{
21f07b6c:	e1a0c00d 	mov	ip, sp
21f07b70:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f07b74:	e24cb004 	sub	fp, ip, #4	; 0x4
21f07b78:	e24ddd57 	sub	sp, sp, #5568	; 0x15c0
21f07b7c:	e24dd03c 	sub	sp, sp, #60	; 0x3c
21f07b80:	e3e0cd57 	mvn	ip, #5568	; 0x15c0
21f07b84:	e24cc017 	sub	ip, ip, #23	; 0x17
21f07b88:	e24be00c 	sub	lr, fp, #12	; 0xc
21f07b8c:	e78e000c 	str	r0, [lr, ip]
21f07b90:	e3e00d57 	mvn	r0, #5568	; 0x15c0
21f07b94:	e240001b 	sub	r0, r0, #27	; 0x1b
21f07b98:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f07b9c:	e78c1000 	str	r1, [ip, r0]
21f07ba0:	e3e01d57 	mvn	r1, #5568	; 0x15c0
21f07ba4:	e241101f 	sub	r1, r1, #31	; 0x1f
21f07ba8:	e24be00c 	sub	lr, fp, #12	; 0xc
21f07bac:	e78e2001 	str	r2, [lr, r1]
21f07bb0:	e3e02d57 	mvn	r2, #5568	; 0x15c0
21f07bb4:	e2422023 	sub	r2, r2, #35	; 0x23
21f07bb8:	e24b000c 	sub	r0, fp, #12	; 0xc
21f07bbc:	e7803002 	str	r3, [r0, r2]
#if CONFIG_NIOS /* NIOS CPU cannot access big automatic arrays */
    static
#endif
    char fnamecopy[2048];
    boot_sector bs;
    volume_info volinfo;
    fsdata datablock;
    fsdata *mydata = &datablock;
21f07bc0:	e24b3d53 	sub	r3, fp, #5312	; 0x14c0
21f07bc4:	e243300c 	sub	r3, r3, #12	; 0xc
21f07bc8:	e2433004 	sub	r3, r3, #4	; 0x4
21f07bcc:	e50b3060 	str	r3, [fp, #-96]
    dir_entry *dentptr;
    __u16 prevcksum = 0xffff;
21f07bd0:	e3e03000 	mvn	r3, #0	; 0x0
21f07bd4:	e14b35b6 	strh	r3, [fp, #-86]
    char *subname = "";
21f07bd8:	e59f3bc8 	ldr	r3, [pc, #3016]	; 21f087a8 <.text+0x87a8>
21f07bdc:	e50b3054 	str	r3, [fp, #-84]
    int rootdir_size, cursect;
    int idx, isdir = 0;
21f07be0:	e3a03000 	mov	r3, #0	; 0x0
21f07be4:	e50b3044 	str	r3, [fp, #-68]
    int files = 0, dirs = 0;
21f07be8:	e3a03000 	mov	r3, #0	; 0x0
21f07bec:	e50b3040 	str	r3, [fp, #-64]
21f07bf0:	e3a03000 	mov	r3, #0	; 0x0
21f07bf4:	e50b303c 	str	r3, [fp, #-60]
    long ret = 0;
21f07bf8:	e3a03000 	mov	r3, #0	; 0x0
21f07bfc:	e50b3038 	str	r3, [fp, #-56]
    int firsttime;

    if (read_bootsectandvi (&bs, &volinfo, &mydata->fatsize)) {
21f07c00:	e51b3060 	ldr	r3, [fp, #-96]
21f07c04:	e283cb03 	add	ip, r3, #3072	; 0xc00
21f07c08:	e24b3e89 	sub	r3, fp, #2192	; 0x890
21f07c0c:	e243300c 	sub	r3, r3, #12	; 0xc
21f07c10:	e2433004 	sub	r3, r3, #4	; 0x4
21f07c14:	e24b2e8b 	sub	r2, fp, #2224	; 0x8b0
21f07c18:	e242200c 	sub	r2, r2, #12	; 0xc
21f07c1c:	e1a00003 	mov	r0, r3
21f07c20:	e1a01002 	mov	r1, r2
21f07c24:	e1a0200c 	mov	r2, ip
21f07c28:	ebffff44 	bl	21f07940 <read_bootsectandvi>
21f07c2c:	e1a03000 	mov	r3, r0
21f07c30:	e3530000 	cmp	r3, #0	; 0x0
21f07c34:	0a000003 	beq	21f07c48 <do_fat_read+0xdc>
	FAT_DPRINT ("Error: reading boot sector\n");
	return -1;
21f07c38:	e3e02000 	mvn	r2, #0	; 0x0
21f07c3c:	e24b1a01 	sub	r1, fp, #4096	; 0x1000
21f07c40:	e5012604 	str	r2, [r1, #-1540]
21f07c44:	ea0002d2 	b	21f08794 <do_fat_read+0xc28>
    }
    if (mydata->fatsize == 32) {
21f07c48:	e51b3060 	ldr	r3, [fp, #-96]
21f07c4c:	e5933c00 	ldr	r3, [r3, #3072]
21f07c50:	e3530020 	cmp	r3, #32	; 0x20
21f07c54:	1a000007 	bne	21f07c78 <do_fat_read+0x10c>
	mydata->fatlength = bs.fat32_length;
21f07c58:	e51b387c 	ldr	r3, [fp, #-2172]
21f07c5c:	e1a03803 	mov	r3, r3, lsl #16
21f07c60:	e1a01823 	mov	r1, r3, lsr #16
21f07c64:	e51b2060 	ldr	r2, [fp, #-96]
21f07c68:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07c6c:	e2833004 	add	r3, r3, #4	; 0x4
21f07c70:	e18210b3 	strh	r1, [r2, r3]
21f07c74:	ea000007 	b	21f07c98 <do_fat_read+0x12c>
    } else {
	mydata->fatlength = bs.fat_length;
21f07c78:	e3e03e87 	mvn	r3, #2160	; 0x870
21f07c7c:	e243300d 	sub	r3, r3, #13	; 0xd
21f07c80:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f07c84:	e19c10b3 	ldrh	r1, [ip, r3]
21f07c88:	e51b2060 	ldr	r2, [fp, #-96]
21f07c8c:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07c90:	e2833004 	add	r3, r3, #4	; 0x4
21f07c94:	e18210b3 	strh	r1, [r2, r3]
    }
    mydata->fat_sect = bs.reserved;
21f07c98:	e3e03d22 	mvn	r3, #2176	; 0x880
21f07c9c:	e2433005 	sub	r3, r3, #5	; 0x5
21f07ca0:	e24be00c 	sub	lr, fp, #12	; 0xc
21f07ca4:	e19e10b3 	ldrh	r1, [lr, r3]
21f07ca8:	e51b2060 	ldr	r2, [fp, #-96]
21f07cac:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07cb0:	e2833006 	add	r3, r3, #6	; 0x6
21f07cb4:	e18210b3 	strh	r1, [r2, r3]
    cursect = mydata->rootdir_sect
21f07cb8:	e51b2060 	ldr	r2, [fp, #-96]
21f07cbc:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07cc0:	e2833006 	add	r3, r3, #6	; 0x6
21f07cc4:	e19230b3 	ldrh	r3, [r2, r3]
21f07cc8:	e1a01003 	mov	r1, r3
21f07ccc:	e51b2060 	ldr	r2, [fp, #-96]
21f07cd0:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07cd4:	e2833004 	add	r3, r3, #4	; 0x4
21f07cd8:	e19220b3 	ldrh	r2, [r2, r3]
21f07cdc:	e55b3890 	ldrb	r3, [fp, #-2192]
21f07ce0:	e0030392 	mul	r3, r2, r3
21f07ce4:	e1a03803 	mov	r3, r3, lsl #16
21f07ce8:	e1a03823 	mov	r3, r3, lsr #16
21f07cec:	e1a02001 	mov	r2, r1
21f07cf0:	e0823003 	add	r3, r2, r3
21f07cf4:	e1a03803 	mov	r3, r3, lsl #16
21f07cf8:	e1a03823 	mov	r3, r3, lsr #16
21f07cfc:	e1a03803 	mov	r3, r3, lsl #16
21f07d00:	e1a01823 	mov	r1, r3, lsr #16
21f07d04:	e51b2060 	ldr	r2, [fp, #-96]
21f07d08:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07d0c:	e2833008 	add	r3, r3, #8	; 0x8
21f07d10:	e18210b3 	strh	r1, [r2, r3]
21f07d14:	e51b2060 	ldr	r2, [fp, #-96]
21f07d18:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07d1c:	e2833008 	add	r3, r3, #8	; 0x8
21f07d20:	e19230b3 	ldrh	r3, [r2, r3]
21f07d24:	e50b304c 	str	r3, [fp, #-76]
	    = mydata->fat_sect + mydata->fatlength * bs.fats;
    mydata->clust_size = bs.cluster_size;
21f07d28:	e55b3893 	ldrb	r3, [fp, #-2195]
21f07d2c:	e1a01003 	mov	r1, r3
21f07d30:	e51b2060 	ldr	r2, [fp, #-96]
21f07d34:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07d38:	e283300a 	add	r3, r3, #10	; 0xa
21f07d3c:	e18210b3 	strh	r1, [r2, r3]
    if (mydata->fatsize == 32) {
21f07d40:	e51b3060 	ldr	r3, [fp, #-96]
21f07d44:	e5933c00 	ldr	r3, [r3, #3072]
21f07d48:	e3530020 	cmp	r3, #32	; 0x20
21f07d4c:	1a000019 	bne	21f07db8 <do_fat_read+0x24c>
	rootdir_size = mydata->clust_size;
21f07d50:	e51b2060 	ldr	r2, [fp, #-96]
21f07d54:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07d58:	e283300a 	add	r3, r3, #10	; 0xa
21f07d5c:	e19230b3 	ldrh	r3, [r2, r3]
21f07d60:	e50b3050 	str	r3, [fp, #-80]
	mydata->data_begin = mydata->rootdir_sect   /* + rootdir_size */
21f07d64:	e51b2060 	ldr	r2, [fp, #-96]
21f07d68:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07d6c:	e2833008 	add	r3, r3, #8	; 0x8
21f07d70:	e19230b3 	ldrh	r3, [r2, r3]
21f07d74:	e1a01003 	mov	r1, r3
21f07d78:	e51b2060 	ldr	r2, [fp, #-96]
21f07d7c:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07d80:	e283300a 	add	r3, r3, #10	; 0xa
21f07d84:	e19230b3 	ldrh	r3, [r2, r3]
21f07d88:	e1a03083 	mov	r3, r3, lsl #1
21f07d8c:	e1a03803 	mov	r3, r3, lsl #16
21f07d90:	e1a03823 	mov	r3, r3, lsr #16
21f07d94:	e1a02001 	mov	r2, r1
21f07d98:	e0633002 	rsb	r3, r3, r2
21f07d9c:	e1a03803 	mov	r3, r3, lsl #16
21f07da0:	e1a01823 	mov	r1, r3, lsr #16
21f07da4:	e51b2060 	ldr	r2, [fp, #-96]
21f07da8:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07dac:	e283300c 	add	r3, r3, #12	; 0xc
21f07db0:	e18210b3 	strh	r1, [r2, r3]
21f07db4:	ea000020 	b	21f07e3c <do_fat_read+0x2d0>
		- (mydata->clust_size * 2);
    } else {
	rootdir_size = ((bs.dir_entries[1] * (int) 256 + bs.dir_entries[0])
21f07db8:	e55b388e 	ldrb	r3, [fp, #-2190]
21f07dbc:	e1a02403 	mov	r2, r3, lsl #8
21f07dc0:	e55b388f 	ldrb	r3, [fp, #-2191]
21f07dc4:	e0823003 	add	r3, r2, r3
21f07dc8:	e1a03283 	mov	r3, r3, lsl #5
21f07dcc:	e1a034a3 	mov	r3, r3, lsr #9
21f07dd0:	e50b3050 	str	r3, [fp, #-80]
			* sizeof (dir_entry)) / SECTOR_SIZE;
	mydata->data_begin = mydata->rootdir_sect + rootdir_size
21f07dd4:	e51b2060 	ldr	r2, [fp, #-96]
21f07dd8:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07ddc:	e2833008 	add	r3, r3, #8	; 0x8
21f07de0:	e19230b3 	ldrh	r3, [r2, r3]
21f07de4:	e1a02003 	mov	r2, r3
21f07de8:	e51b3050 	ldr	r3, [fp, #-80]
21f07dec:	e1a03803 	mov	r3, r3, lsl #16
21f07df0:	e1a03823 	mov	r3, r3, lsr #16
21f07df4:	e0823003 	add	r3, r2, r3
21f07df8:	e1a03803 	mov	r3, r3, lsl #16
21f07dfc:	e1a01823 	mov	r1, r3, lsr #16
21f07e00:	e51b2060 	ldr	r2, [fp, #-96]
21f07e04:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07e08:	e283300a 	add	r3, r3, #10	; 0xa
21f07e0c:	e19230b3 	ldrh	r3, [r2, r3]
21f07e10:	e1a03083 	mov	r3, r3, lsl #1
21f07e14:	e1a03803 	mov	r3, r3, lsl #16
21f07e18:	e1a03823 	mov	r3, r3, lsr #16
21f07e1c:	e1a02001 	mov	r2, r1
21f07e20:	e0633002 	rsb	r3, r3, r2
21f07e24:	e1a03803 	mov	r3, r3, lsl #16
21f07e28:	e1a01823 	mov	r1, r3, lsr #16
21f07e2c:	e51b2060 	ldr	r2, [fp, #-96]
21f07e30:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07e34:	e283300c 	add	r3, r3, #12	; 0xc
21f07e38:	e18210b3 	strh	r1, [r2, r3]
		- (mydata->clust_size * 2);
    }
    mydata->fatbufnum = -1;
21f07e3c:	e51b2060 	ldr	r2, [fp, #-96]
21f07e40:	e3e03000 	mvn	r3, #0	; 0x0
21f07e44:	e5823c10 	str	r3, [r2, #3088]

    FAT_DPRINT ("FAT%d, fatlength: %d\n", mydata->fatsize,
		mydata->fatlength);
    FAT_DPRINT ("Rootdir begins at sector: %d, offset: %x, size: %d\n"
		"Data begins at: %d\n",
		mydata->rootdir_sect, mydata->rootdir_sect * SECTOR_SIZE,
		rootdir_size, mydata->data_begin);
    FAT_DPRINT ("Cluster size: %d\n", mydata->clust_size);

    /* "cwd" is always the root... */
    while (ISDIRDELIM (*filename))
21f07e48:	ea000008 	b	21f07e70 <do_fat_read+0x304>
	filename++;
21f07e4c:	e3e02d57 	mvn	r2, #5568	; 0x15c0
21f07e50:	e2422017 	sub	r2, r2, #23	; 0x17
21f07e54:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f07e58:	e2433017 	sub	r3, r3, #23	; 0x17
21f07e5c:	e24b000c 	sub	r0, fp, #12	; 0xc
21f07e60:	e7903003 	ldr	r3, [r0, r3]
21f07e64:	e2833001 	add	r3, r3, #1	; 0x1
21f07e68:	e24b100c 	sub	r1, fp, #12	; 0xc
21f07e6c:	e7813002 	str	r3, [r1, r2]
21f07e70:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f07e74:	e2433017 	sub	r3, r3, #23	; 0x17
21f07e78:	e24b200c 	sub	r2, fp, #12	; 0xc
21f07e7c:	e7923003 	ldr	r3, [r2, r3]
21f07e80:	e5d33000 	ldrb	r3, [r3]
21f07e84:	e353002f 	cmp	r3, #47	; 0x2f
21f07e88:	0affffef 	beq	21f07e4c <do_fat_read+0x2e0>
21f07e8c:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f07e90:	e2433017 	sub	r3, r3, #23	; 0x17
21f07e94:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f07e98:	e79c3003 	ldr	r3, [ip, r3]
21f07e9c:	e5d33000 	ldrb	r3, [r3]
21f07ea0:	e353005c 	cmp	r3, #92	; 0x5c
21f07ea4:	0affffe8 	beq	21f07e4c <do_fat_read+0x2e0>
    /* Make a copy of the filename and convert it to lowercase */
    strcpy (fnamecopy, filename);
21f07ea8:	e24b2e85 	sub	r2, fp, #2128	; 0x850
21f07eac:	e242200c 	sub	r2, r2, #12	; 0xc
21f07eb0:	e2422004 	sub	r2, r2, #4	; 0x4
21f07eb4:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f07eb8:	e2433017 	sub	r3, r3, #23	; 0x17
21f07ebc:	e1a00002 	mov	r0, r2
21f07ec0:	e24be00c 	sub	lr, fp, #12	; 0xc
21f07ec4:	e79e1003 	ldr	r1, [lr, r3]
21f07ec8:	eb006a01 	bl	21f226d4 <strcpy>
    downcase (fnamecopy);
21f07ecc:	e24b3e85 	sub	r3, fp, #2128	; 0x850
21f07ed0:	e243300c 	sub	r3, r3, #12	; 0xc
21f07ed4:	e2433004 	sub	r3, r3, #4	; 0x4
21f07ed8:	e1a00003 	mov	r0, r3
21f07edc:	ebfff8b5 	bl	21f061b8 <downcase>
    if (*fnamecopy == '\0') {
21f07ee0:	e55b3860 	ldrb	r3, [fp, #-2144]
21f07ee4:	e3530000 	cmp	r3, #0	; 0x0
21f07ee8:	1a00000f 	bne	21f07f2c <do_fat_read+0x3c0>
	if (!dols)
21f07eec:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f07ef0:	e2433023 	sub	r3, r3, #35	; 0x23
21f07ef4:	e24b000c 	sub	r0, fp, #12	; 0xc
21f07ef8:	e7903003 	ldr	r3, [r0, r3]
21f07efc:	e3530000 	cmp	r3, #0	; 0x0
21f07f00:	1a000003 	bne	21f07f14 <do_fat_read+0x3a8>
	    return -1;
21f07f04:	e3e02000 	mvn	r2, #0	; 0x0
21f07f08:	e24b1a01 	sub	r1, fp, #4096	; 0x1000
21f07f0c:	e5012604 	str	r2, [r1, #-1540]
21f07f10:	ea00021f 	b	21f08794 <do_fat_read+0xc28>
	dols = LS_ROOT;
21f07f14:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f07f18:	e2433023 	sub	r3, r3, #35	; 0x23
21f07f1c:	e3a02002 	mov	r2, #2	; 0x2
21f07f20:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f07f24:	e78c2003 	str	r2, [ip, r3]
21f07f28:	ea000030 	b	21f07ff0 <do_fat_read+0x484>
    } else if ((idx = dirdelim (fnamecopy)) >= 0) {
21f07f2c:	e24b3e85 	sub	r3, fp, #2128	; 0x850
21f07f30:	e243300c 	sub	r3, r3, #12	; 0xc
21f07f34:	e2433004 	sub	r3, r3, #4	; 0x4
21f07f38:	e1a00003 	mov	r0, r3
21f07f3c:	ebfff94e 	bl	21f0647c <dirdelim>
21f07f40:	e1a03000 	mov	r3, r0
21f07f44:	e50b3048 	str	r3, [fp, #-72]
21f07f48:	e51b3048 	ldr	r3, [fp, #-72]
21f07f4c:	e3530000 	cmp	r3, #0	; 0x0
21f07f50:	ba00001e 	blt	21f07fd0 <do_fat_read+0x464>
	isdir = 1;
21f07f54:	e3a03001 	mov	r3, #1	; 0x1
21f07f58:	e50b3044 	str	r3, [fp, #-68]
	fnamecopy[idx] = '\0';
21f07f5c:	e51b2048 	ldr	r2, [fp, #-72]
21f07f60:	e3e03e85 	mvn	r3, #2128	; 0x850
21f07f64:	e2433003 	sub	r3, r3, #3	; 0x3
21f07f68:	e24be00c 	sub	lr, fp, #12	; 0xc
21f07f6c:	e08e2002 	add	r2, lr, r2
21f07f70:	e0822003 	add	r2, r2, r3
21f07f74:	e3a03000 	mov	r3, #0	; 0x0
21f07f78:	e5c23000 	strb	r3, [r2]
	subname = fnamecopy + idx + 1;
21f07f7c:	e51b3048 	ldr	r3, [fp, #-72]
21f07f80:	e1a02003 	mov	r2, r3
21f07f84:	e24b3e85 	sub	r3, fp, #2128	; 0x850
21f07f88:	e243300c 	sub	r3, r3, #12	; 0xc
21f07f8c:	e2433004 	sub	r3, r3, #4	; 0x4
21f07f90:	e0833002 	add	r3, r3, r2
21f07f94:	e2833001 	add	r3, r3, #1	; 0x1
21f07f98:	e50b3054 	str	r3, [fp, #-84]
	/* Handle multiple delimiters */
	while (ISDIRDELIM (*subname))
21f07f9c:	ea000002 	b	21f07fac <do_fat_read+0x440>
	    subname++;
21f07fa0:	e51b3054 	ldr	r3, [fp, #-84]
21f07fa4:	e2833001 	add	r3, r3, #1	; 0x1
21f07fa8:	e50b3054 	str	r3, [fp, #-84]
21f07fac:	e51b3054 	ldr	r3, [fp, #-84]
21f07fb0:	e5d33000 	ldrb	r3, [r3]
21f07fb4:	e353002f 	cmp	r3, #47	; 0x2f
21f07fb8:	0afffff8 	beq	21f07fa0 <do_fat_read+0x434>
21f07fbc:	e51b3054 	ldr	r3, [fp, #-84]
21f07fc0:	e5d33000 	ldrb	r3, [r3]
21f07fc4:	e353005c 	cmp	r3, #92	; 0x5c
21f07fc8:	0afffff4 	beq	21f07fa0 <do_fat_read+0x434>
21f07fcc:	ea000007 	b	21f07ff0 <do_fat_read+0x484>
    } else if (dols) {
21f07fd0:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f07fd4:	e2433023 	sub	r3, r3, #35	; 0x23
21f07fd8:	e24b000c 	sub	r0, fp, #12	; 0xc
21f07fdc:	e7903003 	ldr	r3, [r0, r3]
21f07fe0:	e3530000 	cmp	r3, #0	; 0x0
21f07fe4:	0a000001 	beq	21f07ff0 <do_fat_read+0x484>
	isdir = 1;
21f07fe8:	e3a03001 	mov	r3, #1	; 0x1
21f07fec:	e50b3044 	str	r3, [fp, #-68]
    }

    while (1) {
	int i;

	if (disk_read (cursect, mydata->clust_size, do_fat_read_block) < 0) {
21f07ff0:	e51b104c 	ldr	r1, [fp, #-76]
21f07ff4:	e51b2060 	ldr	r2, [fp, #-96]
21f07ff8:	e3a03b03 	mov	r3, #3072	; 0xc00
21f07ffc:	e283300a 	add	r3, r3, #10	; 0xa
21f08000:	e19230b3 	ldrh	r3, [r2, r3]
21f08004:	e1a00001 	mov	r0, r1
21f08008:	e1a01003 	mov	r1, r3
21f0800c:	e59f2798 	ldr	r2, [pc, #1944]	; 21f087ac <.text+0x87ac>
21f08010:	ebfff886 	bl	21f06230 <disk_read>
21f08014:	e1a03000 	mov	r3, r0
21f08018:	e3530000 	cmp	r3, #0	; 0x0
21f0801c:	aa000003 	bge	21f08030 <do_fat_read+0x4c4>
	    FAT_DPRINT ("Error: reading rootdir block\n");
	    return -1;
21f08020:	e3e02000 	mvn	r2, #0	; 0x0
21f08024:	e24b1a01 	sub	r1, fp, #4096	; 0x1000
21f08028:	e5012604 	str	r2, [r1, #-1540]
21f0802c:	ea0001d8 	b	21f08794 <do_fat_read+0xc28>
	}
	dentptr = (dir_entry *) do_fat_read_block;
21f08030:	e59f3774 	ldr	r3, [pc, #1908]	; 21f087ac <.text+0x87ac>
21f08034:	e50b305c 	str	r3, [fp, #-92]
	for (i = 0; i < DIRENTSPERBLOCK; i++) {
21f08038:	e3a03000 	mov	r3, #0	; 0x0
21f0803c:	e50b3030 	str	r3, [fp, #-48]
21f08040:	ea00010d 	b	21f0847c <do_fat_read+0x910>
	    char s_name[14], l_name[256];

	    l_name[0] = '\0';
21f08044:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08048:	e2433013 	sub	r3, r3, #19	; 0x13
21f0804c:	e3a02000 	mov	r2, #0	; 0x0
21f08050:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f08054:	e7cc2003 	strb	r2, [ip, r3]
	    if ((dentptr->attr & ATTR_VOLUME)) {
21f08058:	e51b305c 	ldr	r3, [fp, #-92]
21f0805c:	e5d3300b 	ldrb	r3, [r3, #11]
21f08060:	e1a031a3 	mov	r3, r3, lsr #3
21f08064:	e2033001 	and	r3, r3, #1	; 0x1
21f08068:	e20330ff 	and	r3, r3, #255	; 0xff
21f0806c:	e3530000 	cmp	r3, #0	; 0x0
21f08070:	0a00005f 	beq	21f081f4 <do_fat_read+0x688>
#ifdef CONFIG_SUPPORT_VFAT
		if ((dentptr->attr & ATTR_VFAT) &&
21f08074:	e51b305c 	ldr	r3, [fp, #-92]
21f08078:	e5d3300b 	ldrb	r3, [r3, #11]
21f0807c:	e203300f 	and	r3, r3, #15	; 0xf
21f08080:	e3530000 	cmp	r3, #0	; 0x0
21f08084:	0a000056 	beq	21f081e4 <do_fat_read+0x678>
21f08088:	e51b305c 	ldr	r3, [fp, #-92]
21f0808c:	e5d33000 	ldrb	r3, [r3]
21f08090:	e1a03323 	mov	r3, r3, lsr #6
21f08094:	e2033001 	and	r3, r3, #1	; 0x1
21f08098:	e20330ff 	and	r3, r3, #255	; 0xff
21f0809c:	e2233001 	eor	r3, r3, #1	; 0x1
21f080a0:	e20330ff 	and	r3, r3, #255	; 0xff
21f080a4:	e3530000 	cmp	r3, #0	; 0x0
21f080a8:	1a00004d 	bne	21f081e4 <do_fat_read+0x678>
		    (dentptr->name[0] & LAST_LONG_ENTRY_MASK)) {
		    prevcksum = ((dir_slot *) dentptr)->alias_checksum;
21f080ac:	e51b305c 	ldr	r3, [fp, #-92]
21f080b0:	e5d3300d 	ldrb	r3, [r3, #13]
21f080b4:	e14b35b6 	strh	r3, [fp, #-86]
		    get_vfatname (mydata, 0, do_fat_read_block, dentptr, l_name);
21f080b8:	e24b3d57 	sub	r3, fp, #5568	; 0x15c0
21f080bc:	e243300c 	sub	r3, r3, #12	; 0xc
21f080c0:	e2433014 	sub	r3, r3, #20	; 0x14
21f080c4:	e58d3000 	str	r3, [sp]
21f080c8:	e51b0060 	ldr	r0, [fp, #-96]
21f080cc:	e3a01000 	mov	r1, #0	; 0x0
21f080d0:	e59f26d4 	ldr	r2, [pc, #1748]	; 21f087ac <.text+0x87ac>
21f080d4:	e51b305c 	ldr	r3, [fp, #-92]
21f080d8:	ebfffc13 	bl	21f0712c <get_vfatname>
		    if (dols == LS_ROOT) {
21f080dc:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f080e0:	e2433023 	sub	r3, r3, #35	; 0x23
21f080e4:	e24be00c 	sub	lr, fp, #12	; 0xc
21f080e8:	e79e3003 	ldr	r3, [lr, r3]
21f080ec:	e3530002 	cmp	r3, #2	; 0x2
21f080f0:	1a000067 	bne	21f08294 <do_fat_read+0x728>
			int isdir = (dentptr->attr & ATTR_DIR);
21f080f4:	e51b305c 	ldr	r3, [fp, #-92]
21f080f8:	e5d3300b 	ldrb	r3, [r3, #11]
21f080fc:	e2033010 	and	r3, r3, #16	; 0x10
21f08100:	e50b302c 	str	r3, [fp, #-44]
			char dirc;
			int doit = 0;
21f08104:	e3a03000 	mov	r3, #0	; 0x0
21f08108:	e50b3024 	str	r3, [fp, #-36]

			if (isdir) {
21f0810c:	e51b302c 	ldr	r3, [fp, #-44]
21f08110:	e3530000 	cmp	r3, #0	; 0x0
21f08114:	0a000007 	beq	21f08138 <do_fat_read+0x5cc>
			    dirs++;
21f08118:	e51b303c 	ldr	r3, [fp, #-60]
21f0811c:	e2833001 	add	r3, r3, #1	; 0x1
21f08120:	e50b303c 	str	r3, [fp, #-60]
			    dirc = '/';
21f08124:	e3a0302f 	mov	r3, #47	; 0x2f
21f08128:	e54b3025 	strb	r3, [fp, #-37]
			    doit = 1;
21f0812c:	e3a03001 	mov	r3, #1	; 0x1
21f08130:	e50b3024 	str	r3, [fp, #-36]
21f08134:	ea00000c 	b	21f0816c <do_fat_read+0x600>
			} else {
			    dirc = ' ';
21f08138:	e3a03020 	mov	r3, #32	; 0x20
21f0813c:	e54b3025 	strb	r3, [fp, #-37]
			    if (l_name[0] != 0) {
21f08140:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08144:	e2433013 	sub	r3, r3, #19	; 0x13
21f08148:	e24b000c 	sub	r0, fp, #12	; 0xc
21f0814c:	e7d03003 	ldrb	r3, [r0, r3]
21f08150:	e3530000 	cmp	r3, #0	; 0x0
21f08154:	0a000004 	beq	21f0816c <do_fat_read+0x600>
				files++;
21f08158:	e51b3040 	ldr	r3, [fp, #-64]
21f0815c:	e2833001 	add	r3, r3, #1	; 0x1
21f08160:	e50b3040 	str	r3, [fp, #-64]
				doit = 1;
21f08164:	e3a03001 	mov	r3, #1	; 0x1
21f08168:	e50b3024 	str	r3, [fp, #-36]
			    }
			}
			if (doit) {
21f0816c:	e51b3024 	ldr	r3, [fp, #-36]
21f08170:	e3530000 	cmp	r3, #0	; 0x0
21f08174:	0a000016 	beq	21f081d4 <do_fat_read+0x668>
			    if (dirc == ' ') {
21f08178:	e55b3025 	ldrb	r3, [fp, #-37]
21f0817c:	e3530020 	cmp	r3, #32	; 0x20
21f08180:	1a00000c 	bne	21f081b8 <do_fat_read+0x64c>
				printf (" %8ld   %s%c\n",
21f08184:	e51b305c 	ldr	r3, [fp, #-92]
21f08188:	e593301c 	ldr	r3, [r3, #28]
21f0818c:	e1a02003 	mov	r2, r3
21f08190:	e55bc025 	ldrb	ip, [fp, #-37]
21f08194:	e24b3d57 	sub	r3, fp, #5568	; 0x15c0
21f08198:	e243300c 	sub	r3, r3, #12	; 0xc
21f0819c:	e2433014 	sub	r3, r3, #20	; 0x14
21f081a0:	e59f0608 	ldr	r0, [pc, #1544]	; 21f087b0 <.text+0x87b0>
21f081a4:	e1a01002 	mov	r1, r2
21f081a8:	e1a02003 	mov	r2, r3
21f081ac:	e1a0300c 	mov	r3, ip
21f081b0:	eb004e35 	bl	21f1ba8c <printf>
21f081b4:	ea000006 	b	21f081d4 <do_fat_read+0x668>
					(long) FAT2CPU32 (dentptr->size),
					l_name, dirc);
			    } else {
				printf ("            %s%c\n", l_name, dirc);
21f081b8:	e55b2025 	ldrb	r2, [fp, #-37]
21f081bc:	e24b3d57 	sub	r3, fp, #5568	; 0x15c0
21f081c0:	e243300c 	sub	r3, r3, #12	; 0xc
21f081c4:	e2433014 	sub	r3, r3, #20	; 0x14
21f081c8:	e59f05e4 	ldr	r0, [pc, #1508]	; 21f087b4 <.text+0x87b4>
21f081cc:	e1a01003 	mov	r1, r3
21f081d0:	eb004e2d 	bl	21f1ba8c <printf>
			    }
			}
			dentptr++;
21f081d4:	e51b305c 	ldr	r3, [fp, #-92]
21f081d8:	e2833020 	add	r3, r3, #32	; 0x20
21f081dc:	e50b305c 	str	r3, [fp, #-92]
			continue;
21f081e0:	ea0000a2 	b	21f08470 <do_fat_read+0x904>
		    }
		    FAT_DPRINT ("Rootvfatname: |%s|\n", l_name);
		} else
#endif
		{
		    /* Volume label or VFAT entry */
		    dentptr++;
21f081e4:	e51b305c 	ldr	r3, [fp, #-92]
21f081e8:	e2833020 	add	r3, r3, #32	; 0x20
21f081ec:	e50b305c 	str	r3, [fp, #-92]
		    continue;
21f081f0:	ea00009e 	b	21f08470 <do_fat_read+0x904>
		}
	    } else if (dentptr->name[0] == 0) {
21f081f4:	e51b305c 	ldr	r3, [fp, #-92]
21f081f8:	e5d33000 	ldrb	r3, [r3]
21f081fc:	e3530000 	cmp	r3, #0	; 0x0
21f08200:	1a000011 	bne	21f0824c <do_fat_read+0x6e0>
		FAT_DPRINT ("RootDentname == NULL - %d\n", i);
		if (dols == LS_ROOT) {
21f08204:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08208:	e2433023 	sub	r3, r3, #35	; 0x23
21f0820c:	e24b100c 	sub	r1, fp, #12	; 0xc
21f08210:	e7913003 	ldr	r3, [r1, r3]
21f08214:	e3530002 	cmp	r3, #2	; 0x2
21f08218:	1a000007 	bne	21f0823c <do_fat_read+0x6d0>
		    printf ("\n%d file(s), %d dir(s)\n\n", files, dirs);
21f0821c:	e59f0594 	ldr	r0, [pc, #1428]	; 21f087b8 <.text+0x87b8>
21f08220:	e51b1040 	ldr	r1, [fp, #-64]
21f08224:	e51b203c 	ldr	r2, [fp, #-60]
21f08228:	eb004e17 	bl	21f1ba8c <printf>
		    return 0;
21f0822c:	e3a03000 	mov	r3, #0	; 0x0
21f08230:	e24b2a01 	sub	r2, fp, #4096	; 0x1000
21f08234:	e5023604 	str	r3, [r2, #-1540]
21f08238:	ea000155 	b	21f08794 <do_fat_read+0xc28>
		}
		return -1;
21f0823c:	e3e0e000 	mvn	lr, #0	; 0x0
21f08240:	e24bca01 	sub	ip, fp, #4096	; 0x1000
21f08244:	e50ce604 	str	lr, [ip, #-1540]
21f08248:	ea000151 	b	21f08794 <do_fat_read+0xc28>
	    }
#ifdef CONFIG_SUPPORT_VFAT
	    else if (dols == LS_ROOT
21f0824c:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08250:	e2433023 	sub	r3, r3, #35	; 0x23
21f08254:	e24b000c 	sub	r0, fp, #12	; 0xc
21f08258:	e7903003 	ldr	r3, [r0, r3]
21f0825c:	e3530002 	cmp	r3, #2	; 0x2
21f08260:	1a00000b 	bne	21f08294 <do_fat_read+0x728>
21f08264:	e51b305c 	ldr	r3, [fp, #-92]
21f08268:	e1a00003 	mov	r0, r3
21f0826c:	ebfffc59 	bl	21f073d8 <mkcksum>
21f08270:	e1a03000 	mov	r3, r0
21f08274:	e1a02003 	mov	r2, r3
21f08278:	e15b35b6 	ldrh	r3, [fp, #-86]
21f0827c:	e1530002 	cmp	r3, r2
21f08280:	1a000003 	bne	21f08294 <do_fat_read+0x728>
		     && mkcksum (dentptr->name) == prevcksum) {
		dentptr++;
21f08284:	e51b305c 	ldr	r3, [fp, #-92]
21f08288:	e2833020 	add	r3, r3, #32	; 0x20
21f0828c:	e50b305c 	str	r3, [fp, #-92]
		continue;
21f08290:	ea000076 	b	21f08470 <do_fat_read+0x904>
	    }
#endif
	    get_name (dentptr, s_name);
21f08294:	e24b3d53 	sub	r3, fp, #5312	; 0x14c0
21f08298:	e243300c 	sub	r3, r3, #12	; 0xc
21f0829c:	e2433012 	sub	r3, r3, #18	; 0x12
21f082a0:	e51b005c 	ldr	r0, [fp, #-92]
21f082a4:	e1a01003 	mov	r1, r3
21f082a8:	ebfff8b8 	bl	21f06590 <get_name>
	    if (dols == LS_ROOT) {
21f082ac:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f082b0:	e2433023 	sub	r3, r3, #35	; 0x23
21f082b4:	e24b100c 	sub	r1, fp, #12	; 0xc
21f082b8:	e7913003 	ldr	r3, [r1, r3]
21f082bc:	e3530002 	cmp	r3, #2	; 0x2
21f082c0:	1a000041 	bne	21f083cc <do_fat_read+0x860>
		int isdir = (dentptr->attr & ATTR_DIR);
21f082c4:	e51b305c 	ldr	r3, [fp, #-92]
21f082c8:	e5d3300b 	ldrb	r3, [r3, #11]
21f082cc:	e2033010 	and	r3, r3, #16	; 0x10
21f082d0:	e50b3020 	str	r3, [fp, #-32]
		char dirc;
		int doit = 0;
21f082d4:	e3a03000 	mov	r3, #0	; 0x0
21f082d8:	e50b3018 	str	r3, [fp, #-24]

		if (isdir) {
21f082dc:	e51b3020 	ldr	r3, [fp, #-32]
21f082e0:	e3530000 	cmp	r3, #0	; 0x0
21f082e4:	0a00000d 	beq	21f08320 <do_fat_read+0x7b4>
		    dirc = '/';
21f082e8:	e3a0302f 	mov	r3, #47	; 0x2f
21f082ec:	e54b3019 	strb	r3, [fp, #-25]
		    if (s_name[0] != 0) {
21f082f0:	e3e03d53 	mvn	r3, #5312	; 0x14c0
21f082f4:	e2433011 	sub	r3, r3, #17	; 0x11
21f082f8:	e24b200c 	sub	r2, fp, #12	; 0xc
21f082fc:	e7d23003 	ldrb	r3, [r2, r3]
21f08300:	e3530000 	cmp	r3, #0	; 0x0
21f08304:	0a000012 	beq	21f08354 <do_fat_read+0x7e8>
			dirs++;
21f08308:	e51b303c 	ldr	r3, [fp, #-60]
21f0830c:	e2833001 	add	r3, r3, #1	; 0x1
21f08310:	e50b303c 	str	r3, [fp, #-60]
			doit = 1;
21f08314:	e3a03001 	mov	r3, #1	; 0x1
21f08318:	e50b3018 	str	r3, [fp, #-24]
21f0831c:	ea00000c 	b	21f08354 <do_fat_read+0x7e8>
		    }
		} else {
		    dirc = ' ';
21f08320:	e3a03020 	mov	r3, #32	; 0x20
21f08324:	e54b3019 	strb	r3, [fp, #-25]
		    if (s_name[0] != 0) {
21f08328:	e3e03d53 	mvn	r3, #5312	; 0x14c0
21f0832c:	e2433011 	sub	r3, r3, #17	; 0x11
21f08330:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f08334:	e7dc3003 	ldrb	r3, [ip, r3]
21f08338:	e3530000 	cmp	r3, #0	; 0x0
21f0833c:	0a000004 	beq	21f08354 <do_fat_read+0x7e8>
			files++;
21f08340:	e51b3040 	ldr	r3, [fp, #-64]
21f08344:	e2833001 	add	r3, r3, #1	; 0x1
21f08348:	e50b3040 	str	r3, [fp, #-64]
			doit = 1;
21f0834c:	e3a03001 	mov	r3, #1	; 0x1
21f08350:	e50b3018 	str	r3, [fp, #-24]
		    }
		}
		if (doit) {
21f08354:	e51b3018 	ldr	r3, [fp, #-24]
21f08358:	e3530000 	cmp	r3, #0	; 0x0
21f0835c:	0a000016 	beq	21f083bc <do_fat_read+0x850>
		    if (dirc == ' ') {
21f08360:	e55b3019 	ldrb	r3, [fp, #-25]
21f08364:	e3530020 	cmp	r3, #32	; 0x20
21f08368:	1a00000c 	bne	21f083a0 <do_fat_read+0x834>
			printf (" %8ld   %s%c\n",
21f0836c:	e51b305c 	ldr	r3, [fp, #-92]
21f08370:	e593301c 	ldr	r3, [r3, #28]
21f08374:	e1a02003 	mov	r2, r3
21f08378:	e55bc019 	ldrb	ip, [fp, #-25]
21f0837c:	e24b3d53 	sub	r3, fp, #5312	; 0x14c0
21f08380:	e243300c 	sub	r3, r3, #12	; 0xc
21f08384:	e2433012 	sub	r3, r3, #18	; 0x12
21f08388:	e59f0420 	ldr	r0, [pc, #1056]	; 21f087b0 <.text+0x87b0>
21f0838c:	e1a01002 	mov	r1, r2
21f08390:	e1a02003 	mov	r2, r3
21f08394:	e1a0300c 	mov	r3, ip
21f08398:	eb004dbb 	bl	21f1ba8c <printf>
21f0839c:	ea000006 	b	21f083bc <do_fat_read+0x850>
				(long) FAT2CPU32 (dentptr->size), s_name,
				dirc);
		    } else {
			printf ("            %s%c\n", s_name, dirc);
21f083a0:	e55b2019 	ldrb	r2, [fp, #-25]
21f083a4:	e24b3d53 	sub	r3, fp, #5312	; 0x14c0
21f083a8:	e243300c 	sub	r3, r3, #12	; 0xc
21f083ac:	e2433012 	sub	r3, r3, #18	; 0x12
21f083b0:	e59f03fc 	ldr	r0, [pc, #1020]	; 21f087b4 <.text+0x87b4>
21f083b4:	e1a01003 	mov	r1, r3
21f083b8:	eb004db3 	bl	21f1ba8c <printf>
		    }
		}
		dentptr++;
21f083bc:	e51b305c 	ldr	r3, [fp, #-92]
21f083c0:	e2833020 	add	r3, r3, #32	; 0x20
21f083c4:	e50b305c 	str	r3, [fp, #-92]
		continue;
21f083c8:	ea000028 	b	21f08470 <do_fat_read+0x904>
	    }
	    if (strcmp (fnamecopy, s_name) && strcmp (fnamecopy, l_name)) {
21f083cc:	e24b3e85 	sub	r3, fp, #2128	; 0x850
21f083d0:	e243300c 	sub	r3, r3, #12	; 0xc
21f083d4:	e2433004 	sub	r3, r3, #4	; 0x4
21f083d8:	e24b2d53 	sub	r2, fp, #5312	; 0x14c0
21f083dc:	e242200c 	sub	r2, r2, #12	; 0xc
21f083e0:	e2422012 	sub	r2, r2, #18	; 0x12
21f083e4:	e1a00003 	mov	r0, r3
21f083e8:	e1a01002 	mov	r1, r2
21f083ec:	eb006956 	bl	21f2294c <strcmp>
21f083f0:	e1a03000 	mov	r3, r0
21f083f4:	e3530000 	cmp	r3, #0	; 0x0
21f083f8:	0a00000f 	beq	21f0843c <do_fat_read+0x8d0>
21f083fc:	e24b3e85 	sub	r3, fp, #2128	; 0x850
21f08400:	e243300c 	sub	r3, r3, #12	; 0xc
21f08404:	e2433004 	sub	r3, r3, #4	; 0x4
21f08408:	e24b2d57 	sub	r2, fp, #5568	; 0x15c0
21f0840c:	e242200c 	sub	r2, r2, #12	; 0xc
21f08410:	e2422014 	sub	r2, r2, #20	; 0x14
21f08414:	e1a00003 	mov	r0, r3
21f08418:	e1a01002 	mov	r1, r2
21f0841c:	eb00694a 	bl	21f2294c <strcmp>
21f08420:	e1a03000 	mov	r3, r0
21f08424:	e3530000 	cmp	r3, #0	; 0x0
21f08428:	0a000003 	beq	21f0843c <do_fat_read+0x8d0>
		FAT_DPRINT ("RootMismatch: |%s|%s|\n", s_name, l_name);
		dentptr++;
21f0842c:	e51b305c 	ldr	r3, [fp, #-92]
21f08430:	e2833020 	add	r3, r3, #32	; 0x20
21f08434:	e50b305c 	str	r3, [fp, #-92]
		continue;
21f08438:	ea00000c 	b	21f08470 <do_fat_read+0x904>
	    }
	    if (isdir && !(dentptr->attr & ATTR_DIR))
21f0843c:	e51b3044 	ldr	r3, [fp, #-68]
21f08440:	e3530000 	cmp	r3, #0	; 0x0
21f08444:	0a000013 	beq	21f08498 <do_fat_read+0x92c>
21f08448:	e51b305c 	ldr	r3, [fp, #-92]
21f0844c:	e5d3300b 	ldrb	r3, [r3, #11]
21f08450:	e1a03223 	mov	r3, r3, lsr #4
21f08454:	e2033001 	and	r3, r3, #1	; 0x1
21f08458:	e3530000 	cmp	r3, #0	; 0x0
21f0845c:	1a00000d 	bne	21f08498 <do_fat_read+0x92c>
		return -1;
21f08460:	e3e00000 	mvn	r0, #0	; 0x0
21f08464:	e24bea01 	sub	lr, fp, #4096	; 0x1000
21f08468:	e50e0604 	str	r0, [lr, #-1540]
21f0846c:	ea0000c8 	b	21f08794 <do_fat_read+0xc28>
21f08470:	e51b3030 	ldr	r3, [fp, #-48]
21f08474:	e2833001 	add	r3, r3, #1	; 0x1
21f08478:	e50b3030 	str	r3, [fp, #-48]
21f0847c:	e51b3030 	ldr	r3, [fp, #-48]
21f08480:	e353000f 	cmp	r3, #15	; 0xf
21f08484:	9afffeee 	bls	21f08044 <do_fat_read+0x4d8>

	    FAT_DPRINT ("RootName: %s", s_name);
	    FAT_DPRINT (", start: 0x%x", START (dentptr));
	    FAT_DPRINT (", size:  0x%x %s\n",
			FAT2CPU32 (dentptr->size), isdir ? "(DIR)" : "");

	    goto rootdir_done;  /* We got a match */
	}
	cursect++;
21f08488:	e51b304c 	ldr	r3, [fp, #-76]
21f0848c:	e2833001 	add	r3, r3, #1	; 0x1
21f08490:	e50b304c 	str	r3, [fp, #-76]
    }
21f08494:	eafffed5 	b	21f07ff0 <do_fat_read+0x484>
  rootdir_done:

    firsttime = 1;
21f08498:	e3a03001 	mov	r3, #1	; 0x1
21f0849c:	e50b3034 	str	r3, [fp, #-52]
    while (isdir) {
21f084a0:	ea0000a8 	b	21f08748 <do_fat_read+0xbdc>
	int startsect = mydata->data_begin
		+ START (dentptr) * mydata->clust_size;
21f084a4:	e51b2060 	ldr	r2, [fp, #-96]
21f084a8:	e3a03b03 	mov	r3, #3072	; 0xc00
21f084ac:	e283300c 	add	r3, r3, #12	; 0xc
21f084b0:	e19230b3 	ldrh	r3, [r2, r3]
21f084b4:	e1a03803 	mov	r3, r3, lsl #16
21f084b8:	e1a02843 	mov	r2, r3, asr #16
21f084bc:	e24b1a01 	sub	r1, fp, #4096	; 0x1000
21f084c0:	e5012600 	str	r2, [r1, #-1536]
21f084c4:	e51b305c 	ldr	r3, [fp, #-92]
21f084c8:	e1d331ba 	ldrh	r3, [r3, #26]
21f084cc:	e24bca01 	sub	ip, fp, #4096	; 0x1000
21f084d0:	e50c35fc 	str	r3, [ip, #-1532]
21f084d4:	e51b3060 	ldr	r3, [fp, #-96]
21f084d8:	e5933c00 	ldr	r3, [r3, #3072]
21f084dc:	e3530020 	cmp	r3, #32	; 0x20
21f084e0:	1a000005 	bne	21f084fc <do_fat_read+0x990>
21f084e4:	e51b305c 	ldr	r3, [fp, #-92]
21f084e8:	e1d331b4 	ldrh	r3, [r3, #20]
21f084ec:	e1a00803 	mov	r0, r3, lsl #16
21f084f0:	e24bea01 	sub	lr, fp, #4096	; 0x1000
21f084f4:	e50e05f8 	str	r0, [lr, #-1528]
21f084f8:	ea000002 	b	21f08508 <do_fat_read+0x99c>
21f084fc:	e3a02000 	mov	r2, #0	; 0x0
21f08500:	e24b1a01 	sub	r1, fp, #4096	; 0x1000
21f08504:	e50125f8 	str	r2, [r1, #-1528]
21f08508:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0850c:	e513c5fc 	ldr	ip, [r3, #-1532]
21f08510:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f08514:	e51335f8 	ldr	r3, [r3, #-1528]
21f08518:	e08c1003 	add	r1, ip, r3
21f0851c:	e51b2060 	ldr	r2, [fp, #-96]
21f08520:	e3a03b03 	mov	r3, #3072	; 0xc00
21f08524:	e283300a 	add	r3, r3, #10	; 0xa
21f08528:	e19230b3 	ldrh	r3, [r2, r3]
21f0852c:	e0030391 	mul	r3, r1, r3
21f08530:	e24bca01 	sub	ip, fp, #4096	; 0x1000
21f08534:	e51cc600 	ldr	ip, [ip, #-1536]
21f08538:	e08c3003 	add	r3, ip, r3
21f0853c:	e50b3014 	str	r3, [fp, #-20]
	dir_entry dent;
	char *nextname = NULL;
21f08540:	e3a03000 	mov	r3, #0	; 0x0
21f08544:	e50b3010 	str	r3, [fp, #-16]

	dent = *dentptr;
21f08548:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f0854c:	e2433013 	sub	r3, r3, #19	; 0x13
21f08550:	e51b205c 	ldr	r2, [fp, #-92]
21f08554:	e24b000c 	sub	r0, fp, #12	; 0xc
21f08558:	e080e003 	add	lr, r0, r3
21f0855c:	e1a0c002 	mov	ip, r2
21f08560:	e8bc000f 	ldmia	ip!, {r0, r1, r2, r3}
21f08564:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
21f08568:	e89c000f 	ldmia	ip, {r0, r1, r2, r3}
21f0856c:	e88e000f 	stmia	lr, {r0, r1, r2, r3}
	dentptr = &dent;
21f08570:	e24b3d57 	sub	r3, fp, #5568	; 0x15c0
21f08574:	e243300c 	sub	r3, r3, #12	; 0xc
21f08578:	e2433014 	sub	r3, r3, #20	; 0x14
21f0857c:	e50b305c 	str	r3, [fp, #-92]

	idx = dirdelim (subname);
21f08580:	e51b0054 	ldr	r0, [fp, #-84]
21f08584:	ebfff7bc 	bl	21f0647c <dirdelim>
21f08588:	e1a03000 	mov	r3, r0
21f0858c:	e50b3048 	str	r3, [fp, #-72]
	if (idx >= 0) {
21f08590:	e51b3048 	ldr	r3, [fp, #-72]
21f08594:	e3530000 	cmp	r3, #0	; 0x0
21f08598:	ba000024 	blt	21f08630 <do_fat_read+0xac4>
	    subname[idx] = '\0';
21f0859c:	e51b3048 	ldr	r3, [fp, #-72]
21f085a0:	e1a02003 	mov	r2, r3
21f085a4:	e51b3054 	ldr	r3, [fp, #-84]
21f085a8:	e0822003 	add	r2, r2, r3
21f085ac:	e3a03000 	mov	r3, #0	; 0x0
21f085b0:	e5c23000 	strb	r3, [r2]
	    nextname = subname + idx + 1;
21f085b4:	e51b3048 	ldr	r3, [fp, #-72]
21f085b8:	e1a02003 	mov	r2, r3
21f085bc:	e51b3054 	ldr	r3, [fp, #-84]
21f085c0:	e0823003 	add	r3, r2, r3
21f085c4:	e2833001 	add	r3, r3, #1	; 0x1
21f085c8:	e50b3010 	str	r3, [fp, #-16]
	    /* Handle multiple delimiters */
	    while (ISDIRDELIM (*nextname))
21f085cc:	ea000002 	b	21f085dc <do_fat_read+0xa70>
		nextname++;
21f085d0:	e51b3010 	ldr	r3, [fp, #-16]
21f085d4:	e2833001 	add	r3, r3, #1	; 0x1
21f085d8:	e50b3010 	str	r3, [fp, #-16]
21f085dc:	e51b3010 	ldr	r3, [fp, #-16]
21f085e0:	e5d33000 	ldrb	r3, [r3]
21f085e4:	e353002f 	cmp	r3, #47	; 0x2f
21f085e8:	0afffff8 	beq	21f085d0 <do_fat_read+0xa64>
21f085ec:	e51b3010 	ldr	r3, [fp, #-16]
21f085f0:	e5d33000 	ldrb	r3, [r3]
21f085f4:	e353005c 	cmp	r3, #92	; 0x5c
21f085f8:	0afffff4 	beq	21f085d0 <do_fat_read+0xa64>
	    if (dols && *nextname == '\0')
21f085fc:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08600:	e2433023 	sub	r3, r3, #35	; 0x23
21f08604:	e24b100c 	sub	r1, fp, #12	; 0xc
21f08608:	e7913003 	ldr	r3, [r1, r3]
21f0860c:	e3530000 	cmp	r3, #0	; 0x0
21f08610:	0a000014 	beq	21f08668 <do_fat_read+0xafc>
21f08614:	e51b3010 	ldr	r3, [fp, #-16]
21f08618:	e5d33000 	ldrb	r3, [r3]
21f0861c:	e3530000 	cmp	r3, #0	; 0x0
21f08620:	1a000010 	bne	21f08668 <do_fat_read+0xafc>
		firsttime = 0;
21f08624:	e3a03000 	mov	r3, #0	; 0x0
21f08628:	e50b3034 	str	r3, [fp, #-52]
21f0862c:	ea00000d 	b	21f08668 <do_fat_read+0xafc>
	} else {
	    if (dols && firsttime) {
21f08630:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08634:	e2433023 	sub	r3, r3, #35	; 0x23
21f08638:	e24b200c 	sub	r2, fp, #12	; 0xc
21f0863c:	e7923003 	ldr	r3, [r2, r3]
21f08640:	e3530000 	cmp	r3, #0	; 0x0
21f08644:	0a000005 	beq	21f08660 <do_fat_read+0xaf4>
21f08648:	e51b3034 	ldr	r3, [fp, #-52]
21f0864c:	e3530000 	cmp	r3, #0	; 0x0
21f08650:	0a000002 	beq	21f08660 <do_fat_read+0xaf4>
		firsttime = 0;
21f08654:	e3a03000 	mov	r3, #0	; 0x0
21f08658:	e50b3034 	str	r3, [fp, #-52]
21f0865c:	ea000001 	b	21f08668 <do_fat_read+0xafc>
	    } else {
		isdir = 0;
21f08660:	e3a03000 	mov	r3, #0	; 0x0
21f08664:	e50b3044 	str	r3, [fp, #-68]
	    }
	}

	if (get_dentfromdir (mydata, startsect, subname, dentptr,
21f08668:	e51b3044 	ldr	r3, [fp, #-68]
21f0866c:	e3530000 	cmp	r3, #0	; 0x0
21f08670:	1a000006 	bne	21f08690 <do_fat_read+0xb24>
21f08674:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08678:	e2433023 	sub	r3, r3, #35	; 0x23
21f0867c:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f08680:	e79ce003 	ldr	lr, [ip, r3]
21f08684:	e24bca01 	sub	ip, fp, #4096	; 0x1000
21f08688:	e50ce5f4 	str	lr, [ip, #-1524]
21f0868c:	ea000002 	b	21f0869c <do_fat_read+0xb30>
21f08690:	e3a01000 	mov	r1, #0	; 0x0
21f08694:	e24b0a01 	sub	r0, fp, #4096	; 0x1000
21f08698:	e50015f4 	str	r1, [r0, #-1524]
21f0869c:	e24b2a01 	sub	r2, fp, #4096	; 0x1000
21f086a0:	e51225f4 	ldr	r2, [r2, #-1524]
21f086a4:	e58d2000 	str	r2, [sp]
21f086a8:	e51b0060 	ldr	r0, [fp, #-96]
21f086ac:	e51b1014 	ldr	r1, [fp, #-20]
21f086b0:	e51b2054 	ldr	r2, [fp, #-84]
21f086b4:	e51b305c 	ldr	r3, [fp, #-92]
21f086b8:	ebfffb6e 	bl	21f07478 <get_dentfromdir>
21f086bc:	e1a03000 	mov	r3, r0
21f086c0:	e3530000 	cmp	r3, #0	; 0x0
21f086c4:	1a000010 	bne	21f0870c <do_fat_read+0xba0>
			     isdir ? 0 : dols) == NULL) {
	    if (dols && !isdir)
21f086c8:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f086cc:	e2433023 	sub	r3, r3, #35	; 0x23
21f086d0:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f086d4:	e79c3003 	ldr	r3, [ip, r3]
21f086d8:	e3530000 	cmp	r3, #0	; 0x0
21f086dc:	0a000006 	beq	21f086fc <do_fat_read+0xb90>
21f086e0:	e51b3044 	ldr	r3, [fp, #-68]
21f086e4:	e3530000 	cmp	r3, #0	; 0x0
21f086e8:	1a000003 	bne	21f086fc <do_fat_read+0xb90>
		return 0;
21f086ec:	e3a00000 	mov	r0, #0	; 0x0
21f086f0:	e24bea01 	sub	lr, fp, #4096	; 0x1000
21f086f4:	e50e0604 	str	r0, [lr, #-1540]
21f086f8:	ea000025 	b	21f08794 <do_fat_read+0xc28>
	    return -1;
21f086fc:	e3e02000 	mvn	r2, #0	; 0x0
21f08700:	e24b1a01 	sub	r1, fp, #4096	; 0x1000
21f08704:	e5012604 	str	r2, [r1, #-1540]
21f08708:	ea000021 	b	21f08794 <do_fat_read+0xc28>
	}

	if (idx >= 0) {
21f0870c:	e51b3048 	ldr	r3, [fp, #-72]
21f08710:	e3530000 	cmp	r3, #0	; 0x0
21f08714:	ba00000b 	blt	21f08748 <do_fat_read+0xbdc>
	    if (!(dentptr->attr & ATTR_DIR))
21f08718:	e51b305c 	ldr	r3, [fp, #-92]
21f0871c:	e5d3300b 	ldrb	r3, [r3, #11]
21f08720:	e1a03223 	mov	r3, r3, lsr #4
21f08724:	e2033001 	and	r3, r3, #1	; 0x1
21f08728:	e3530000 	cmp	r3, #0	; 0x0
21f0872c:	1a000003 	bne	21f08740 <do_fat_read+0xbd4>
		return -1;
21f08730:	e3e0c000 	mvn	ip, #0	; 0x0
21f08734:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f08738:	e503c604 	str	ip, [r3, #-1540]
21f0873c:	ea000014 	b	21f08794 <do_fat_read+0xc28>
	    subname = nextname;
21f08740:	e51b3010 	ldr	r3, [fp, #-16]
21f08744:	e50b3054 	str	r3, [fp, #-84]
21f08748:	e51b3044 	ldr	r3, [fp, #-68]
21f0874c:	e3530000 	cmp	r3, #0	; 0x0
21f08750:	1affff53 	bne	21f084a4 <do_fat_read+0x938>
	}
    }
    ret = get_contents (mydata, dentptr, buffer, maxsize);
21f08754:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08758:	e243301b 	sub	r3, r3, #27	; 0x1b
21f0875c:	e24be00c 	sub	lr, fp, #12	; 0xc
21f08760:	e79e2003 	ldr	r2, [lr, r3]
21f08764:	e3e03d57 	mvn	r3, #5568	; 0x15c0
21f08768:	e243301f 	sub	r3, r3, #31	; 0x1f
21f0876c:	e51b0060 	ldr	r0, [fp, #-96]
21f08770:	e51b105c 	ldr	r1, [fp, #-92]
21f08774:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f08778:	e79c3003 	ldr	r3, [ip, r3]
21f0877c:	ebfff933 	bl	21f06c50 <get_contents>
21f08780:	e1a03000 	mov	r3, r0
21f08784:	e50b3038 	str	r3, [fp, #-56]
    FAT_DPRINT ("Size: %d, got: %ld\n", FAT2CPU32 (dentptr->size), ret);

    return ret;
21f08788:	e51b0038 	ldr	r0, [fp, #-56]
21f0878c:	e24bea01 	sub	lr, fp, #4096	; 0x1000
21f08790:	e50e0604 	str	r0, [lr, #-1540]
21f08794:	e24b1a01 	sub	r1, fp, #4096	; 0x1000
21f08798:	e5113604 	ldr	r3, [r1, #-1540]
}
21f0879c:	e1a00003 	mov	r0, r3
21f087a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f087a4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f087a8:	21f2f3cc 	mvncss	pc, ip, asr #7
21f087ac:	21f544a8 	mvncss	r4, r8, lsr #9
21f087b0:	21f2f368 	mvncss	pc, r8, ror #6
21f087b4:	21f2f378 	mvncss	pc, r8, ror r3
21f087b8:	21f2f38c 	mvncss	pc, ip, lsl #7

21f087bc <file_fat_detectfs>:


int
file_fat_detectfs(void)
{
21f087bc:	e1a0c00d 	mov	ip, sp
21f087c0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f087c4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f087c8:	e24dd070 	sub	sp, sp, #112	; 0x70
	boot_sector	bs;
	volume_info	volinfo;
	int		fatsize;
	char	vol_label[12];

	if(cur_dev==NULL) {
21f087cc:	e59f3178 	ldr	r3, [pc, #376]	; 21f0894c <.text+0x894c>
21f087d0:	e5933000 	ldr	r3, [r3]
21f087d4:	e3530000 	cmp	r3, #0	; 0x0
21f087d8:	1a000004 	bne	21f087f0 <file_fat_detectfs+0x34>
		printf("No current device\n");
21f087dc:	e59f016c 	ldr	r0, [pc, #364]	; 21f08950 <.text+0x8950>
21f087e0:	eb004ca9 	bl	21f1ba8c <printf>
		return 1;
21f087e4:	e3a03001 	mov	r3, #1	; 0x1
21f087e8:	e50b307c 	str	r3, [fp, #-124]
21f087ec:	ea000052 	b	21f0893c <.text+0x893c>
	}
#if (CONFIG_COMMANDS & CFG_CMD_IDE) || (CONFIG_COMMANDS & CFG_CMD_SCSI) || \
    (CONFIG_COMMANDS & CFG_CMD_USB) || (CONFIG_MMC)
	printf("Interface:  ");
21f087f0:	e59f015c 	ldr	r0, [pc, #348]	; 21f08954 <.text+0x8954>
21f087f4:	eb004ca4 	bl	21f1ba8c <printf>
	switch(cur_dev->if_type) {
21f087f8:	e59f314c 	ldr	r3, [pc, #332]	; 21f0894c <.text+0x894c>
21f087fc:	e5933000 	ldr	r3, [r3]
21f08800:	e5933000 	ldr	r3, [r3]
21f08804:	e2433001 	sub	r3, r3, #1	; 0x1
21f08808:	e3530005 	cmp	r3, #5	; 0x5
21f0880c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f08810:	ea000017 	b	21f08874 <.text+0x8874>
21f08814:	21f0882c 	mvncss	r8, ip, lsr #16
21f08818:	21f08838 	mvncss	r8, r8, lsr r8
21f0881c:	21f08844 	mvncss	r8, r4, asr #16
21f08820:	21f08850 	mvncss	r8, r0, asr r8
21f08824:	21f0885c 	mvncss	r8, ip, asr r8
21f08828:	21f08868 	mvncss	r8, r8, ror #16
		case IF_TYPE_IDE :	printf("IDE"); break;
21f0882c:	e59f0124 	ldr	r0, [pc, #292]	; 21f08958 <.text+0x8958>
21f08830:	eb004c95 	bl	21f1ba8c <printf>
21f08834:	ea000010 	b	21f0887c <.text+0x887c>
		case IF_TYPE_SCSI :	printf("SCSI"); break;
21f08838:	e59f011c 	ldr	r0, [pc, #284]	; 21f0895c <.text+0x895c>
21f0883c:	eb004c92 	bl	21f1ba8c <printf>
21f08840:	ea00000d 	b	21f0887c <.text+0x887c>
		case IF_TYPE_ATAPI :	printf("ATAPI"); break;
21f08844:	e59f0114 	ldr	r0, [pc, #276]	; 21f08960 <.text+0x8960>
21f08848:	eb004c8f 	bl	21f1ba8c <printf>
21f0884c:	ea00000a 	b	21f0887c <.text+0x887c>
		case IF_TYPE_USB :	printf("USB"); break;
21f08850:	e59f010c 	ldr	r0, [pc, #268]	; 21f08964 <.text+0x8964>
21f08854:	eb004c8c 	bl	21f1ba8c <printf>
21f08858:	ea000007 	b	21f0887c <.text+0x887c>
		case IF_TYPE_DOC :	printf("DOC"); break;
21f0885c:	e59f0104 	ldr	r0, [pc, #260]	; 21f08968 <.text+0x8968>
21f08860:	eb004c89 	bl	21f1ba8c <printf>
21f08864:	ea000004 	b	21f0887c <.text+0x887c>
		case IF_TYPE_MMC :	printf("MMC"); break;
21f08868:	e59f00fc 	ldr	r0, [pc, #252]	; 21f0896c <.text+0x896c>
21f0886c:	eb004c86 	bl	21f1ba8c <printf>
21f08870:	ea000001 	b	21f0887c <.text+0x887c>
		default :		printf("Unknown");
21f08874:	e59f00f4 	ldr	r0, [pc, #244]	; 21f08970 <.text+0x8970>
21f08878:	eb004c83 	bl	21f1ba8c <printf>
	}
	printf("\n  Device %d: ",cur_dev->dev);
21f0887c:	e59f30c8 	ldr	r3, [pc, #200]	; 21f0894c <.text+0x894c>
21f08880:	e5933000 	ldr	r3, [r3]
21f08884:	e5933004 	ldr	r3, [r3, #4]
21f08888:	e59f00e4 	ldr	r0, [pc, #228]	; 21f08974 <.text+0x8974>
21f0888c:	e1a01003 	mov	r1, r3
21f08890:	eb004c7d 	bl	21f1ba8c <printf>
	dev_print(cur_dev);
21f08894:	e59f30b0 	ldr	r3, [pc, #176]	; 21f0894c <.text+0x894c>
21f08898:	e5933000 	ldr	r3, [r3]
21f0889c:	e1a00003 	mov	r0, r3
21f088a0:	eb0017fe 	bl	21f0e8a0 <dev_print>
#endif
	if(read_bootsectandvi(&bs, &volinfo, &fatsize)) {
21f088a4:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f088a8:	e24b2068 	sub	r2, fp, #104	; 0x68
21f088ac:	e24bc06c 	sub	ip, fp, #108	; 0x6c
21f088b0:	e1a00003 	mov	r0, r3
21f088b4:	e1a01002 	mov	r1, r2
21f088b8:	e1a0200c 	mov	r2, ip
21f088bc:	ebfffc1f 	bl	21f07940 <read_bootsectandvi>
21f088c0:	e1a03000 	mov	r3, r0
21f088c4:	e3530000 	cmp	r3, #0	; 0x0
21f088c8:	0a000004 	beq	21f088e0 <.text+0x88e0>
		printf("\nNo valid FAT fs found\n");
21f088cc:	e59f00a4 	ldr	r0, [pc, #164]	; 21f08978 <.text+0x8978>
21f088d0:	eb004c6d 	bl	21f1ba8c <printf>
		return 1;
21f088d4:	e3a03001 	mov	r3, #1	; 0x1
21f088d8:	e50b307c 	str	r3, [fp, #-124]
21f088dc:	ea000016 	b	21f0893c <.text+0x893c>
	}
	memcpy (vol_label, volinfo.volume_label, 11);
21f088e0:	e24b2078 	sub	r2, fp, #120	; 0x78
21f088e4:	e24b3068 	sub	r3, fp, #104	; 0x68
21f088e8:	e2833007 	add	r3, r3, #7	; 0x7
21f088ec:	e1a00002 	mov	r0, r2
21f088f0:	e1a01003 	mov	r1, r3
21f088f4:	e3a0200b 	mov	r2, #11	; 0xb
21f088f8:	eb006a33 	bl	21f231cc <memcpy>
	vol_label[11] = '\0';
21f088fc:	e3a03000 	mov	r3, #0	; 0x0
21f08900:	e54b306d 	strb	r3, [fp, #-109]
	volinfo.fs_type[5]='\0';
21f08904:	e3a03000 	mov	r3, #0	; 0x0
21f08908:	e54b3051 	strb	r3, [fp, #-81]
	printf("Partition %d: Filesystem: %s \"%s\"\n",cur_part,volinfo.fs_type,vol_label);
21f0890c:	e59f3068 	ldr	r3, [pc, #104]	; 21f0897c <.text+0x897c>
21f08910:	e5932000 	ldr	r2, [r3]
21f08914:	e24b3068 	sub	r3, fp, #104	; 0x68
21f08918:	e2833012 	add	r3, r3, #18	; 0x12
21f0891c:	e24bc078 	sub	ip, fp, #120	; 0x78
21f08920:	e59f0058 	ldr	r0, [pc, #88]	; 21f08980 <.text+0x8980>
21f08924:	e1a01002 	mov	r1, r2
21f08928:	e1a02003 	mov	r2, r3
21f0892c:	e1a0300c 	mov	r3, ip
21f08930:	eb004c55 	bl	21f1ba8c <printf>
	return 0;
21f08934:	e3a03000 	mov	r3, #0	; 0x0
21f08938:	e50b307c 	str	r3, [fp, #-124]
21f0893c:	e51b307c 	ldr	r3, [fp, #-124]
}
21f08940:	e1a00003 	mov	r0, r3
21f08944:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f08948:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0894c:	21f644a8 	mvncss	r4, r8, lsr #9
21f08950:	21f2f3d0 	ldrcssb	pc, [r2, #48]!
21f08954:	21f2f3e4 	mvncss	pc, r4, ror #7
21f08958:	21f2f3f4 	ldrcssh	pc, [r2, #52]!
21f0895c:	21f2f3f8 	ldrcssh	pc, [r2, #56]!
21f08960:	21f2f400 	mvncss	pc, r0, lsl #8
21f08964:	21f2f408 	mvncss	pc, r8, lsl #8
21f08968:	21f2f40c 	mvncss	pc, ip, lsl #8
21f0896c:	21f2f410 	mvncss	pc, r0, lsl r4
21f08970:	21f2f414 	mvncss	pc, r4, lsl r4
21f08974:	21f2f41c 	mvncss	pc, ip, lsl r4
21f08978:	21f2f42c 	mvncss	pc, ip, lsr #8
21f0897c:	21f331c8 	mvncss	r3, r8, asr #3
21f08980:	21f2f444 	mvncss	pc, r4, asr #8

21f08984 <file_fat_ls>:


int
file_fat_ls(const char *dir)
{
21f08984:	e1a0c00d 	mov	ip, sp
21f08988:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0898c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f08990:	e24dd004 	sub	sp, sp, #4	; 0x4
21f08994:	e50b0010 	str	r0, [fp, #-16]
	return do_fat_read(dir, NULL, 0, LS_YES);
21f08998:	e51b0010 	ldr	r0, [fp, #-16]
21f0899c:	e3a01000 	mov	r1, #0	; 0x0
21f089a0:	e3a02000 	mov	r2, #0	; 0x0
21f089a4:	e3a03001 	mov	r3, #1	; 0x1
21f089a8:	ebfffc6f 	bl	21f07b6c <do_fat_read>
21f089ac:	e1a03000 	mov	r3, r0
}
21f089b0:	e1a00003 	mov	r0, r3
21f089b4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f089b8 <file_fat_read>:


long
file_fat_read(const char *filename, void *buffer, unsigned long maxsize)
{
21f089b8:	e1a0c00d 	mov	ip, sp
21f089bc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f089c0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f089c4:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f089c8:	e50b0010 	str	r0, [fp, #-16]
21f089cc:	e50b1014 	str	r1, [fp, #-20]
21f089d0:	e50b2018 	str	r2, [fp, #-24]
	printf("reading %s\n",filename);
21f089d4:	e59f0028 	ldr	r0, [pc, #40]	; 21f08a04 <.text+0x8a04>
21f089d8:	e51b1010 	ldr	r1, [fp, #-16]
21f089dc:	eb004c2a 	bl	21f1ba8c <printf>
	return do_fat_read(filename, buffer, maxsize, LS_NO);
21f089e0:	e51b0010 	ldr	r0, [fp, #-16]
21f089e4:	e51b1014 	ldr	r1, [fp, #-20]
21f089e8:	e51b2018 	ldr	r2, [fp, #-24]
21f089ec:	e3a03000 	mov	r3, #0	; 0x0
21f089f0:	ebfffc5d 	bl	21f07b6c <do_fat_read>
21f089f4:	e1a03000 	mov	r3, r0
}
21f089f8:	e1a00003 	mov	r0, r3
21f089fc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f08a00:	e89da800 	ldmia	sp, {fp, sp, pc}
21f08a04:	21f2f468 	mvncss	pc, r8, ror #8

21f08a08 <ArpRequest>:
ulong		NetArpWaitTimerStart;
int		NetArpWaitTry;

void ArpRequest (void)
{
21f08a08:	e1a0c00d 	mov	ip, sp
21f08a0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f08a10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f08a14:	e24dd00c 	sub	sp, sp, #12	; 0xc
	int i;
	volatile uchar *pkt;
	ARP_t *arp;

#ifdef ET_DEBUG
	printf ("ARP broadcast %d\n", NetArpWaitTry);
#endif
	pkt = NetTxPacket;
21f08a18:	e59f31dc 	ldr	r3, [pc, #476]	; 21f08bfc <.text+0x8bfc>
21f08a1c:	e5933000 	ldr	r3, [r3]
21f08a20:	e50b3014 	str	r3, [fp, #-20]

	pkt += NetSetEther (pkt, NetBcastAddr, PROT_ARP);
21f08a24:	e51b0014 	ldr	r0, [fp, #-20]
21f08a28:	e59f11d0 	ldr	r1, [pc, #464]	; 21f08c00 <.text+0x8c00>
21f08a2c:	e3a02b02 	mov	r2, #2048	; 0x800
21f08a30:	e2822006 	add	r2, r2, #6	; 0x6
21f08a34:	eb000629 	bl	21f0a2e0 <NetSetEther>
21f08a38:	e1a03000 	mov	r3, r0
21f08a3c:	e1a02003 	mov	r2, r3
21f08a40:	e51b3014 	ldr	r3, [fp, #-20]
21f08a44:	e0833002 	add	r3, r3, r2
21f08a48:	e50b3014 	str	r3, [fp, #-20]

	arp = (ARP_t *) pkt;
21f08a4c:	e51b3014 	ldr	r3, [fp, #-20]
21f08a50:	e50b3010 	str	r3, [fp, #-16]

	arp->ar_hrd = htons (ARP_ETHER);
21f08a54:	e3a00001 	mov	r0, #1	; 0x1
21f08a58:	eb00007d 	bl	21f08c54 <__fswab16>
21f08a5c:	e1a03000 	mov	r3, r0
21f08a60:	e1a02003 	mov	r2, r3
21f08a64:	e51b3010 	ldr	r3, [fp, #-16]
21f08a68:	e1c320b0 	strh	r2, [r3]
	arp->ar_pro = htons (PROT_IP);
21f08a6c:	e3a00b02 	mov	r0, #2048	; 0x800
21f08a70:	eb000077 	bl	21f08c54 <__fswab16>
21f08a74:	e1a03000 	mov	r3, r0
21f08a78:	e1a02003 	mov	r2, r3
21f08a7c:	e51b3010 	ldr	r3, [fp, #-16]
21f08a80:	e1c320b2 	strh	r2, [r3, #2]
	arp->ar_hln = 6;
21f08a84:	e51b2010 	ldr	r2, [fp, #-16]
21f08a88:	e3a03006 	mov	r3, #6	; 0x6
21f08a8c:	e5c23004 	strb	r3, [r2, #4]
	arp->ar_pln = 4;
21f08a90:	e51b2010 	ldr	r2, [fp, #-16]
21f08a94:	e3a03004 	mov	r3, #4	; 0x4
21f08a98:	e5c23005 	strb	r3, [r2, #5]
	arp->ar_op = htons (ARPOP_REQUEST);
21f08a9c:	e3a00001 	mov	r0, #1	; 0x1
21f08aa0:	eb00006b 	bl	21f08c54 <__fswab16>
21f08aa4:	e1a03000 	mov	r3, r0
21f08aa8:	e1a02003 	mov	r2, r3
21f08aac:	e51b3010 	ldr	r3, [fp, #-16]
21f08ab0:	e1c320b6 	strh	r2, [r3, #6]

	memcpy (&arp->ar_data[0], NetOurEther, 6);		/* source ET addr	*/
21f08ab4:	e51b3010 	ldr	r3, [fp, #-16]
21f08ab8:	e2833008 	add	r3, r3, #8	; 0x8
21f08abc:	e1a00003 	mov	r0, r3
21f08ac0:	e59f113c 	ldr	r1, [pc, #316]	; 21f08c04 <.text+0x8c04>
21f08ac4:	e3a02006 	mov	r2, #6	; 0x6
21f08ac8:	eb0069bf 	bl	21f231cc <memcpy>
	NetWriteIP ((uchar *) & arp->ar_data[6], NetOurIP);	/* source IP addr	*/
21f08acc:	e51b3010 	ldr	r3, [fp, #-16]
21f08ad0:	e2833008 	add	r3, r3, #8	; 0x8
21f08ad4:	e2832006 	add	r2, r3, #6	; 0x6
21f08ad8:	e59f3128 	ldr	r3, [pc, #296]	; 21f08c08 <.text+0x8c08>
21f08adc:	e5933000 	ldr	r3, [r3]
21f08ae0:	e1a00002 	mov	r0, r2
21f08ae4:	e1a01003 	mov	r1, r3
21f08ae8:	eb00004c 	bl	21f08c20 <NetWriteIP>
	for (i = 10; i < 16; ++i) {
21f08aec:	e3a0300a 	mov	r3, #10	; 0xa
21f08af0:	e50b3018 	str	r3, [fp, #-24]
21f08af4:	ea000009 	b	21f08b20 <ArpRequest+0x118>
		arp->ar_data[i] = 0;				/* dest ET addr = 0     */
21f08af8:	e51b1018 	ldr	r1, [fp, #-24]
21f08afc:	e51b3010 	ldr	r3, [fp, #-16]
21f08b00:	e3a02008 	mov	r2, #8	; 0x8
21f08b04:	e0813003 	add	r3, r1, r3
21f08b08:	e0832002 	add	r2, r3, r2
21f08b0c:	e3a03000 	mov	r3, #0	; 0x0
21f08b10:	e5c23000 	strb	r3, [r2]
21f08b14:	e51b3018 	ldr	r3, [fp, #-24]
21f08b18:	e2833001 	add	r3, r3, #1	; 0x1
21f08b1c:	e50b3018 	str	r3, [fp, #-24]
21f08b20:	e51b3018 	ldr	r3, [fp, #-24]
21f08b24:	e353000f 	cmp	r3, #15	; 0xf
21f08b28:	dafffff2 	ble	21f08af8 <ArpRequest+0xf0>
	}

	if ((NetArpWaitPacketIP & NetOurSubnetMask) !=
21f08b2c:	e59f30d8 	ldr	r3, [pc, #216]	; 21f08c0c <.text+0x8c0c>
21f08b30:	e5932000 	ldr	r2, [r3]
21f08b34:	e59f30d4 	ldr	r3, [pc, #212]	; 21f08c10 <.text+0x8c10>
21f08b38:	e5933000 	ldr	r3, [r3]
21f08b3c:	e0021003 	and	r1, r2, r3
21f08b40:	e59f30c0 	ldr	r3, [pc, #192]	; 21f08c08 <.text+0x8c08>
21f08b44:	e5932000 	ldr	r2, [r3]
21f08b48:	e59f30c0 	ldr	r3, [pc, #192]	; 21f08c10 <.text+0x8c10>
21f08b4c:	e5933000 	ldr	r3, [r3]
21f08b50:	e0023003 	and	r3, r2, r3
21f08b54:	e1510003 	cmp	r1, r3
21f08b58:	0a00000f 	beq	21f08b9c <ArpRequest+0x194>
	    (NetOurIP & NetOurSubnetMask)) {
		if (NetOurGatewayIP == 0) {
21f08b5c:	e59f30b0 	ldr	r3, [pc, #176]	; 21f08c14 <.text+0x8c14>
21f08b60:	e5933000 	ldr	r3, [r3]
21f08b64:	e3530000 	cmp	r3, #0	; 0x0
21f08b68:	1a000006 	bne	21f08b88 <ArpRequest+0x180>
			puts ("## Warning: gatewayip needed but not set\n");
21f08b6c:	e59f00a4 	ldr	r0, [pc, #164]	; 21f08c18 <.text+0x8c18>
21f08b70:	eb004bb2 	bl	21f1ba40 <puts>
			NetArpWaitReplyIP = NetArpWaitPacketIP;
21f08b74:	e59f3090 	ldr	r3, [pc, #144]	; 21f08c0c <.text+0x8c0c>
21f08b78:	e5932000 	ldr	r2, [r3]
21f08b7c:	e59f3098 	ldr	r3, [pc, #152]	; 21f08c1c <.text+0x8c1c>
21f08b80:	e5832000 	str	r2, [r3]
21f08b84:	ea000008 	b	21f08bac <ArpRequest+0x1a4>
		} else {
			NetArpWaitReplyIP = NetOurGatewayIP;
21f08b88:	e59f3084 	ldr	r3, [pc, #132]	; 21f08c14 <.text+0x8c14>
21f08b8c:	e5932000 	ldr	r2, [r3]
21f08b90:	e59f3084 	ldr	r3, [pc, #132]	; 21f08c1c <.text+0x8c1c>
21f08b94:	e5832000 	str	r2, [r3]
21f08b98:	ea000003 	b	21f08bac <ArpRequest+0x1a4>
		}
	} else {
		NetArpWaitReplyIP = NetArpWaitPacketIP;
21f08b9c:	e59f3068 	ldr	r3, [pc, #104]	; 21f08c0c <.text+0x8c0c>
21f08ba0:	e5932000 	ldr	r2, [r3]
21f08ba4:	e59f3070 	ldr	r3, [pc, #112]	; 21f08c1c <.text+0x8c1c>
21f08ba8:	e5832000 	str	r2, [r3]
	}

	NetWriteIP ((uchar *) & arp->ar_data[16], NetArpWaitReplyIP);
21f08bac:	e51b3010 	ldr	r3, [fp, #-16]
21f08bb0:	e2833008 	add	r3, r3, #8	; 0x8
21f08bb4:	e2832010 	add	r2, r3, #16	; 0x10
21f08bb8:	e59f305c 	ldr	r3, [pc, #92]	; 21f08c1c <.text+0x8c1c>
21f08bbc:	e5933000 	ldr	r3, [r3]
21f08bc0:	e1a00002 	mov	r0, r2
21f08bc4:	e1a01003 	mov	r1, r3
21f08bc8:	eb000014 	bl	21f08c20 <NetWriteIP>
	(void) eth_send (NetTxPacket, (pkt - NetTxPacket) + ARP_HDR_SIZE);
21f08bcc:	e59f3028 	ldr	r3, [pc, #40]	; 21f08bfc <.text+0x8bfc>
21f08bd0:	e5931000 	ldr	r1, [r3]
21f08bd4:	e51b2014 	ldr	r2, [fp, #-20]
21f08bd8:	e59f301c 	ldr	r3, [pc, #28]	; 21f08bfc <.text+0x8bfc>
21f08bdc:	e5933000 	ldr	r3, [r3]
21f08be0:	e0633002 	rsb	r3, r3, r2
21f08be4:	e283301c 	add	r3, r3, #28	; 0x1c
21f08be8:	e1a00001 	mov	r0, r1
21f08bec:	e1a01003 	mov	r1, r3
21f08bf0:	eb00951b 	bl	21f2e064 <eth_send>
}
21f08bf4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f08bf8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f08bfc:	21f6454c 	mvncss	r4, ip, asr #10
21f08c00:	21f331cc 	mvncss	r3, ip, asr #3
21f08c04:	21f64554 	mvncss	r4, r4, asr r5
21f08c08:	21f6455c 	mvncss	r4, ip, asr r5
21f08c0c:	21f66424 	mvncss	r6, r4, lsr #8
21f08c10:	21f644b0 	ldrcsh	r4, [r6, #64]!
21f08c14:	21f644b4 	ldrcsh	r4, [r6, #68]!
21f08c18:	21f2f474 	mvncss	pc, r4, ror r4
21f08c1c:	21f66428 	mvncss	r6, r8, lsr #8

21f08c20 <NetWriteIP>:
}

/* write IP *in network byteorder* */
static inline void NetWriteIP(void *to, IPaddr_t ip)
{
21f08c20:	e1a0c00d 	mov	ip, sp
21f08c24:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f08c28:	e24cb004 	sub	fp, ip, #4	; 0x4
21f08c2c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f08c30:	e50b0010 	str	r0, [fp, #-16]
21f08c34:	e50b1014 	str	r1, [fp, #-20]
	memcpy(to, (void*)&ip, sizeof(ip));
21f08c38:	e24b3014 	sub	r3, fp, #20	; 0x14
21f08c3c:	e51b0010 	ldr	r0, [fp, #-16]
21f08c40:	e1a01003 	mov	r1, r3
21f08c44:	e3a02004 	mov	r2, #4	; 0x4
21f08c48:	eb00695f 	bl	21f231cc <memcpy>
}
21f08c4c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f08c50:	e89da800 	ldmia	sp, {fp, sp, pc}

21f08c54 <__fswab16>:
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
21f08c54:	e1a0c00d 	mov	ip, sp
21f08c58:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f08c5c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f08c60:	e24dd004 	sub	sp, sp, #4	; 0x4
21f08c64:	e1a03000 	mov	r3, r0
21f08c68:	e14b31b0 	strh	r3, [fp, #-16]
	return __arch__swab16(x);
21f08c6c:	e15b31b0 	ldrh	r3, [fp, #-16]
21f08c70:	e20330ff 	and	r3, r3, #255	; 0xff
21f08c74:	e1a03403 	mov	r3, r3, lsl #8
21f08c78:	e1a03803 	mov	r3, r3, lsl #16
21f08c7c:	e1a02823 	mov	r2, r3, lsr #16
21f08c80:	e15b31b0 	ldrh	r3, [fp, #-16]
21f08c84:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f08c88:	e1a03443 	mov	r3, r3, asr #8
21f08c8c:	e1a03803 	mov	r3, r3, lsl #16
21f08c90:	e1a03823 	mov	r3, r3, lsr #16
21f08c94:	e1823003 	orr	r3, r2, r3
21f08c98:	e1a03803 	mov	r3, r3, lsl #16
21f08c9c:	e1a03823 	mov	r3, r3, lsr #16
21f08ca0:	e1a03803 	mov	r3, r3, lsl #16
21f08ca4:	e1a03823 	mov	r3, r3, lsr #16
}
21f08ca8:	e1a00003 	mov	r0, r3
21f08cac:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f08cb0 <ArpTimeoutCheck>:

void ArpTimeoutCheck(void)
{
21f08cb0:	e1a0c00d 	mov	ip, sp
21f08cb4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f08cb8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f08cbc:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong t;

	if (!NetArpWaitPacketIP)
21f08cc0:	e59f308c 	ldr	r3, [pc, #140]	; 21f08d54 <.text+0x8d54>
21f08cc4:	e5933000 	ldr	r3, [r3]
21f08cc8:	e3530000 	cmp	r3, #0	; 0x0
21f08ccc:	0a00001f 	beq	21f08d50 <ArpTimeoutCheck+0xa0>
		return;

	t = get_timer(0);
21f08cd0:	e3a00000 	mov	r0, #0	; 0x0
21f08cd4:	ebffdf5e 	bl	21f00a54 <get_timer>
21f08cd8:	e1a03000 	mov	r3, r0
21f08cdc:	e50b3010 	str	r3, [fp, #-16]

	/* check for arp timeout */
	if ((t - NetArpWaitTimerStart) > ARP_TIMEOUT * CFG_HZ) {
21f08ce0:	e59f3070 	ldr	r3, [pc, #112]	; 21f08d58 <.text+0x8d58>
21f08ce4:	e5932000 	ldr	r2, [r3]
21f08ce8:	e51b3010 	ldr	r3, [fp, #-16]
21f08cec:	e0622003 	rsb	r2, r2, r3
21f08cf0:	e3a03d4e 	mov	r3, #4992	; 0x1380
21f08cf4:	e2833008 	add	r3, r3, #8	; 0x8
21f08cf8:	e1520003 	cmp	r2, r3
21f08cfc:	9a000013 	bls	21f08d50 <ArpTimeoutCheck+0xa0>
		NetArpWaitTry++;
21f08d00:	e59f3054 	ldr	r3, [pc, #84]	; 21f08d5c <.text+0x8d5c>
21f08d04:	e5933000 	ldr	r3, [r3]
21f08d08:	e2832001 	add	r2, r3, #1	; 0x1
21f08d0c:	e59f3048 	ldr	r3, [pc, #72]	; 21f08d5c <.text+0x8d5c>
21f08d10:	e5832000 	str	r2, [r3]

		if (NetArpWaitTry >= ARP_TIMEOUT_COUNT) {
21f08d14:	e59f3040 	ldr	r3, [pc, #64]	; 21f08d5c <.text+0x8d5c>
21f08d18:	e5933000 	ldr	r3, [r3]
21f08d1c:	e3530013 	cmp	r3, #19	; 0x13
21f08d20:	da000006 	ble	21f08d40 <ArpTimeoutCheck+0x90>
			puts ("\nARP Retry count exceeded; starting again\n");
21f08d24:	e59f0034 	ldr	r0, [pc, #52]	; 21f08d60 <.text+0x8d60>
21f08d28:	eb004b44 	bl	21f1ba40 <puts>
			NetArpWaitTry = 0;
21f08d2c:	e59f2028 	ldr	r2, [pc, #40]	; 21f08d5c <.text+0x8d5c>
21f08d30:	e3a03000 	mov	r3, #0	; 0x0
21f08d34:	e5823000 	str	r3, [r2]
			NetStartAgain();
21f08d38:	eb000199 	bl	21f093a4 <NetStartAgain>
21f08d3c:	ea000003 	b	21f08d50 <ArpTimeoutCheck+0xa0>
		} else {
			NetArpWaitTimerStart = t;
21f08d40:	e59f2010 	ldr	r2, [pc, #16]	; 21f08d58 <.text+0x8d58>
21f08d44:	e51b3010 	ldr	r3, [fp, #-16]
21f08d48:	e5823000 	str	r3, [r2]
			ArpRequest();
21f08d4c:	ebffff2d 	bl	21f08a08 <ArpRequest>
		}
	}
}
21f08d50:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f08d54:	21f66424 	mvncss	r6, r4, lsr #8
21f08d58:	21f66a58 	mvncss	r6, r8, asr sl
21f08d5c:	21f66a5c 	mvncss	r6, ip, asr sl
21f08d60:	21f2f4a0 	mvncss	pc, r0, lsr #9

21f08d64 <NetLoop>:

/**********************************************************************/
/*
 *	Main network processing loop.
 */

int
NetLoop(proto_t protocol)
{
21f08d64:	e1a0c00d 	mov	ip, sp
21f08d68:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f08d6c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f08d70:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f08d74:	e50b0028 	str	r0, [fp, #-40]
	bd_t *bd = gd->bd;
21f08d78:	e1a03008 	mov	r3, r8
21f08d7c:	e5933000 	ldr	r3, [r3]
21f08d80:	e50b3018 	str	r3, [fp, #-24]

#ifdef CONFIG_NET_MULTI
	NetRestarted = 0;
	NetDevExists = 0;
#endif

	/* XXX problem with bss workaround */
	NetArpWaitPacketMAC = NULL;
21f08d84:	e59f2514 	ldr	r2, [pc, #1300]	; 21f092a0 <.text+0x92a0>
21f08d88:	e3a03000 	mov	r3, #0	; 0x0
21f08d8c:	e5823000 	str	r3, [r2]
	NetArpWaitTxPacket = NULL;
21f08d90:	e59f250c 	ldr	r2, [pc, #1292]	; 21f092a4 <.text+0x92a4>
21f08d94:	e3a03000 	mov	r3, #0	; 0x0
21f08d98:	e5823000 	str	r3, [r2]
	NetArpWaitPacketIP = 0;
21f08d9c:	e59f2504 	ldr	r2, [pc, #1284]	; 21f092a8 <.text+0x92a8>
21f08da0:	e3a03000 	mov	r3, #0	; 0x0
21f08da4:	e5823000 	str	r3, [r2]
	NetArpWaitReplyIP = 0;
21f08da8:	e59f24fc 	ldr	r2, [pc, #1276]	; 21f092ac <.text+0x92ac>
21f08dac:	e3a03000 	mov	r3, #0	; 0x0
21f08db0:	e5823000 	str	r3, [r2]
	NetArpWaitTxPacket = NULL;
21f08db4:	e59f24e8 	ldr	r2, [pc, #1256]	; 21f092a4 <.text+0x92a4>
21f08db8:	e3a03000 	mov	r3, #0	; 0x0
21f08dbc:	e5823000 	str	r3, [r2]
	NetTxPacket = NULL;
21f08dc0:	e59f24e8 	ldr	r2, [pc, #1256]	; 21f092b0 <.text+0x92b0>
21f08dc4:	e3a03000 	mov	r3, #0	; 0x0
21f08dc8:	e5823000 	str	r3, [r2]

	if (!NetTxPacket) {
21f08dcc:	e59f34dc 	ldr	r3, [pc, #1244]	; 21f092b0 <.text+0x92b0>
21f08dd0:	e5933000 	ldr	r3, [r3]
21f08dd4:	e3530000 	cmp	r3, #0	; 0x0
21f08dd8:	1a00001d 	bne	21f08e54 <NetLoop+0xf0>
		int	i;
		/*
		 *	Setup packet buffers, aligned correctly.
		 */
		NetTxPacket = &PktBuf[0] + (PKTALIGN - 1);
21f08ddc:	e59f24d0 	ldr	r2, [pc, #1232]	; 21f092b4 <.text+0x92b4>
21f08de0:	e59f34c8 	ldr	r3, [pc, #1224]	; 21f092b0 <.text+0x92b0>
21f08de4:	e5832000 	str	r2, [r3]
		NetTxPacket -= (ulong)NetTxPacket % PKTALIGN;
21f08de8:	e59f34c0 	ldr	r3, [pc, #1216]	; 21f092b0 <.text+0x92b0>
21f08dec:	e5933000 	ldr	r3, [r3]
21f08df0:	e3c3201f 	bic	r2, r3, #31	; 0x1f
21f08df4:	e59f34b4 	ldr	r3, [pc, #1204]	; 21f092b0 <.text+0x92b0>
21f08df8:	e5832000 	str	r2, [r3]
		for (i = 0; i < PKTBUFSRX; i++) {
21f08dfc:	e3a03000 	mov	r3, #0	; 0x0
21f08e00:	e50b3014 	str	r3, [fp, #-20]
21f08e04:	ea00000f 	b	21f08e48 <NetLoop+0xe4>
			NetRxPackets[i] = NetTxPacket + (i+1)*PKTSIZE_ALIGN;
21f08e08:	e51b1014 	ldr	r1, [fp, #-20]
21f08e0c:	e51b2014 	ldr	r2, [fp, #-20]
21f08e10:	e1a03002 	mov	r3, r2
21f08e14:	e1a03083 	mov	r3, r3, lsl #1
21f08e18:	e0833002 	add	r3, r3, r2
21f08e1c:	e1a03483 	mov	r3, r3, lsl #9
21f08e20:	e1a02003 	mov	r2, r3
21f08e24:	e59f3484 	ldr	r3, [pc, #1156]	; 21f092b0 <.text+0x92b0>
21f08e28:	e5933000 	ldr	r3, [r3]
21f08e2c:	e0823003 	add	r3, r2, r3
21f08e30:	e2832c06 	add	r2, r3, #1536	; 0x600
21f08e34:	e59f347c 	ldr	r3, [pc, #1148]	; 21f092b8 <.text+0x92b8>
21f08e38:	e7832101 	str	r2, [r3, r1, lsl #2]
21f08e3c:	e51b3014 	ldr	r3, [fp, #-20]
21f08e40:	e2833001 	add	r3, r3, #1	; 0x1
21f08e44:	e50b3014 	str	r3, [fp, #-20]
21f08e48:	e51b3014 	ldr	r3, [fp, #-20]
21f08e4c:	e3530003 	cmp	r3, #3	; 0x3
21f08e50:	daffffec 	ble	21f08e08 <NetLoop+0xa4>
		}
	}

	if (!NetArpWaitTxPacket) {
21f08e54:	e59f3448 	ldr	r3, [pc, #1096]	; 21f092a4 <.text+0x92a4>
21f08e58:	e5933000 	ldr	r3, [r3]
21f08e5c:	e3530000 	cmp	r3, #0	; 0x0
21f08e60:	1a00000a 	bne	21f08e90 <NetLoop+0x12c>
		NetArpWaitTxPacket = &NetArpWaitPacketBuf[0] + (PKTALIGN - 1);
21f08e64:	e59f2450 	ldr	r2, [pc, #1104]	; 21f092bc <.text+0x92bc>
21f08e68:	e59f3434 	ldr	r3, [pc, #1076]	; 21f092a4 <.text+0x92a4>
21f08e6c:	e5832000 	str	r2, [r3]
		NetArpWaitTxPacket -= (ulong)NetArpWaitTxPacket % PKTALIGN;
21f08e70:	e59f342c 	ldr	r3, [pc, #1068]	; 21f092a4 <.text+0x92a4>
21f08e74:	e5933000 	ldr	r3, [r3]
21f08e78:	e3c3201f 	bic	r2, r3, #31	; 0x1f
21f08e7c:	e59f3420 	ldr	r3, [pc, #1056]	; 21f092a4 <.text+0x92a4>
21f08e80:	e5832000 	str	r2, [r3]
		NetArpWaitTxPacketSize = 0;
21f08e84:	e59f2434 	ldr	r2, [pc, #1076]	; 21f092c0 <.text+0x92c0>
21f08e88:	e3a03000 	mov	r3, #0	; 0x0
21f08e8c:	e5823000 	str	r3, [r2]
	}

	eth_halt();
21f08e90:	eb0094dd 	bl	21f2e20c <eth_halt>
#ifdef CONFIG_NET_MULTI
	eth_set_current();
#endif
	if (eth_init(bd) < 0) {
21f08e94:	e51b0018 	ldr	r0, [fp, #-24]
21f08e98:	eb0093b0 	bl	21f2dd60 <eth_init>
21f08e9c:	e1a03000 	mov	r3, r0
21f08ea0:	e3530000 	cmp	r3, #0	; 0x0
21f08ea4:	aa000003 	bge	21f08eb8 <NetLoop+0x154>
		eth_halt();
21f08ea8:	eb0094d7 	bl	21f2e20c <eth_halt>
		return(-1);
21f08eac:	e3e02000 	mvn	r2, #0	; 0x0
21f08eb0:	e50b2034 	str	r2, [fp, #-52]
21f08eb4:	ea0000f5 	b	21f09290 <.text+0x9290>
	}

restart:
#ifdef CONFIG_NET_MULTI
	memcpy (NetOurEther, eth_get_dev()->enetaddr, 6);
#else
	memcpy (NetOurEther, bd->bi_enetaddr, 6);
21f08eb8:	e51b3018 	ldr	r3, [fp, #-24]
21f08ebc:	e2833008 	add	r3, r3, #8	; 0x8
21f08ec0:	e59f03fc 	ldr	r0, [pc, #1020]	; 21f092c4 <.text+0x92c4>
21f08ec4:	e1a01003 	mov	r1, r3
21f08ec8:	e3a02006 	mov	r2, #6	; 0x6
21f08ecc:	eb0068be 	bl	21f231cc <memcpy>
#endif

	NetState = NETLOOP_CONTINUE;
21f08ed0:	e59f23f0 	ldr	r2, [pc, #1008]	; 21f092c8 <.text+0x92c8>
21f08ed4:	e3a03001 	mov	r3, #1	; 0x1
21f08ed8:	e5823000 	str	r3, [r2]

	/*
	 *	Start the ball rolling with the given start function.  From
	 *	here on, this code is a state machine driven by received
	 *	packets and timer events.
	 */

	switch (protocol) {
21f08edc:	e51b3028 	ldr	r3, [fp, #-40]
21f08ee0:	e3530009 	cmp	r3, #9	; 0x9
21f08ee4:	8a00005b 	bhi	21f09058 <NetLoop+0x2f4>
21f08ee8:	e3a03001 	mov	r3, #1	; 0x1
21f08eec:	e51b2028 	ldr	r2, [fp, #-40]
21f08ef0:	e1a03213 	mov	r3, r3, lsl r2
21f08ef4:	e50b3038 	str	r3, [fp, #-56]
21f08ef8:	e51b2038 	ldr	r2, [fp, #-56]
21f08efc:	e2023fa2 	and	r3, r2, #648	; 0x288
21f08f00:	e3530000 	cmp	r3, #0	; 0x0
21f08f04:	1a000008 	bne	21f08f2c <NetLoop+0x1c8>
21f08f08:	e51b2038 	ldr	r2, [fp, #-56]
21f08f0c:	e2023003 	and	r3, r2, #3	; 0x3
21f08f10:	e3530000 	cmp	r3, #0	; 0x0
21f08f14:	1a00002f 	bne	21f08fd8 <NetLoop+0x274>
21f08f18:	e51b2038 	ldr	r2, [fp, #-56]
21f08f1c:	e2023c01 	and	r3, r2, #256	; 0x100
21f08f20:	e3530000 	cmp	r3, #0	; 0x0
21f08f24:	1a00003f 	bne	21f09028 <NetLoop+0x2c4>
21f08f28:	ea00004a 	b	21f09058 <NetLoop+0x2f4>
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
	case NFS:
#endif
#if (CONFIG_COMMANDS & CFG_CMD_PING)
	case PING:
#endif
#if (CONFIG_COMMANDS & CFG_CMD_SNTP)
	case SNTP:
#endif
	case NETCONS:
	case TFTP:
		NetCopyIP(&NetOurIP, &bd->bi_ip_addr);
21f08f2c:	e51b3018 	ldr	r3, [fp, #-24]
21f08f30:	e2833004 	add	r3, r3, #4	; 0x4
21f08f34:	e59f0390 	ldr	r0, [pc, #912]	; 21f092cc <.text+0x92cc>
21f08f38:	e1a01003 	mov	r1, r3
21f08f3c:	eb0000fa 	bl	21f0932c <NetCopyIP>
		NetOurGatewayIP = getenv_IPaddr ("gatewayip");
21f08f40:	e59f0388 	ldr	r0, [pc, #904]	; 21f092d0 <.text+0x92d0>
21f08f44:	eb0006c6 	bl	21f0aa64 <getenv_IPaddr>
21f08f48:	e1a02000 	mov	r2, r0
21f08f4c:	e59f3380 	ldr	r3, [pc, #896]	; 21f092d4 <.text+0x92d4>
21f08f50:	e5832000 	str	r2, [r3]
		NetOurSubnetMask= getenv_IPaddr ("netmask");
21f08f54:	e59f037c 	ldr	r0, [pc, #892]	; 21f092d8 <.text+0x92d8>
21f08f58:	eb0006c1 	bl	21f0aa64 <getenv_IPaddr>
21f08f5c:	e1a02000 	mov	r2, r0
21f08f60:	e59f3374 	ldr	r3, [pc, #884]	; 21f092dc <.text+0x92dc>
21f08f64:	e5832000 	str	r2, [r3]
		NetOurVLAN = getenv_VLAN("vlan");
21f08f68:	e59f0370 	ldr	r0, [pc, #880]	; 21f092e0 <.text+0x92e0>
21f08f6c:	eb0006c9 	bl	21f0aa98 <getenv_VLAN>
21f08f70:	e1a03000 	mov	r3, r0
21f08f74:	e1a02003 	mov	r2, r3
21f08f78:	e59f3364 	ldr	r3, [pc, #868]	; 21f092e4 <.text+0x92e4>
21f08f7c:	e1c320b0 	strh	r2, [r3]
		NetOurNativeVLAN = getenv_VLAN("nvlan");
21f08f80:	e59f0360 	ldr	r0, [pc, #864]	; 21f092e8 <.text+0x92e8>
21f08f84:	eb0006c3 	bl	21f0aa98 <getenv_VLAN>
21f08f88:	e1a03000 	mov	r3, r0
21f08f8c:	e1a02003 	mov	r2, r3
21f08f90:	e59f3354 	ldr	r3, [pc, #852]	; 21f092ec <.text+0x92ec>
21f08f94:	e1c320b0 	strh	r2, [r3]

		switch (protocol) {
21f08f98:	e51b3028 	ldr	r3, [fp, #-40]
21f08f9c:	e3530009 	cmp	r3, #9	; 0x9
21f08fa0:	8a00002c 	bhi	21f09058 <NetLoop+0x2f4>
21f08fa4:	e3a02001 	mov	r2, #1	; 0x1
21f08fa8:	e51b3028 	ldr	r3, [fp, #-40]
21f08fac:	e1a03312 	mov	r3, r2, lsl r3
21f08fb0:	e2033fa2 	and	r3, r3, #648	; 0x288
21f08fb4:	e3530000 	cmp	r3, #0	; 0x0
21f08fb8:	1a000000 	bne	21f08fc0 <NetLoop+0x25c>
21f08fbc:	ea000025 	b	21f09058 <NetLoop+0x2f4>
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
		case NFS:
#endif
		case NETCONS:
		case TFTP:
			NetServerIP = getenv_IPaddr ("serverip");
21f08fc0:	e59f0328 	ldr	r0, [pc, #808]	; 21f092f0 <.text+0x92f0>
21f08fc4:	eb0006a6 	bl	21f0aa64 <getenv_IPaddr>
21f08fc8:	e1a02000 	mov	r2, r0
21f08fcc:	e59f3320 	ldr	r3, [pc, #800]	; 21f092f4 <.text+0x92f4>
21f08fd0:	e5832000 	str	r2, [r3]
21f08fd4:	ea00001f 	b	21f09058 <NetLoop+0x2f4>
			break;
#if (CONFIG_COMMANDS & CFG_CMD_PING)
		case PING:
			/* nothing */
			break;
#endif
#if (CONFIG_COMMANDS & CFG_CMD_SNTP)
		case SNTP:
			/* nothing */
			break;
#endif
		default:
			break;
		}

		break;
	case BOOTP:
	case RARP:
		/*
		 * initialize our IP addr to 0 in order to accept ANY
		 * IP addr assigned to us by the BOOTP / RARP server
		 */
		NetOurIP = 0;
21f08fd8:	e59f22ec 	ldr	r2, [pc, #748]	; 21f092cc <.text+0x92cc>
21f08fdc:	e3a03000 	mov	r3, #0	; 0x0
21f08fe0:	e5823000 	str	r3, [r2]
		NetServerIP = getenv_IPaddr ("serverip");
21f08fe4:	e59f0304 	ldr	r0, [pc, #772]	; 21f092f0 <.text+0x92f0>
21f08fe8:	eb00069d 	bl	21f0aa64 <getenv_IPaddr>
21f08fec:	e1a02000 	mov	r2, r0
21f08ff0:	e59f32fc 	ldr	r3, [pc, #764]	; 21f092f4 <.text+0x92f4>
21f08ff4:	e5832000 	str	r2, [r3]
		NetOurVLAN = getenv_VLAN("vlan");	/* VLANs must be read */
21f08ff8:	e59f02e0 	ldr	r0, [pc, #736]	; 21f092e0 <.text+0x92e0>
21f08ffc:	eb0006a5 	bl	21f0aa98 <getenv_VLAN>
21f09000:	e1a03000 	mov	r3, r0
21f09004:	e1a02003 	mov	r2, r3
21f09008:	e59f32d4 	ldr	r3, [pc, #724]	; 21f092e4 <.text+0x92e4>
21f0900c:	e1c320b0 	strh	r2, [r3]
		NetOurNativeVLAN = getenv_VLAN("nvlan");
21f09010:	e59f02d0 	ldr	r0, [pc, #720]	; 21f092e8 <.text+0x92e8>
21f09014:	eb00069f 	bl	21f0aa98 <getenv_VLAN>
21f09018:	e1a03000 	mov	r3, r0
21f0901c:	e1a02003 	mov	r2, r3
21f09020:	e59f32c4 	ldr	r3, [pc, #708]	; 21f092ec <.text+0x92ec>
21f09024:	e1c320b0 	strh	r2, [r3]
	case CDP:
		NetOurVLAN = getenv_VLAN("vlan");	/* VLANs must be read */
21f09028:	e59f02b0 	ldr	r0, [pc, #688]	; 21f092e0 <.text+0x92e0>
21f0902c:	eb000699 	bl	21f0aa98 <getenv_VLAN>
21f09030:	e1a03000 	mov	r3, r0
21f09034:	e1a02003 	mov	r2, r3
21f09038:	e59f32a4 	ldr	r3, [pc, #676]	; 21f092e4 <.text+0x92e4>
21f0903c:	e1c320b0 	strh	r2, [r3]
		NetOurNativeVLAN = getenv_VLAN("nvlan");
21f09040:	e59f02a0 	ldr	r0, [pc, #672]	; 21f092e8 <.text+0x92e8>
21f09044:	eb000693 	bl	21f0aa98 <getenv_VLAN>
21f09048:	e1a03000 	mov	r3, r0
21f0904c:	e1a02003 	mov	r2, r3
21f09050:	e59f3294 	ldr	r3, [pc, #660]	; 21f092ec <.text+0x92ec>
21f09054:	e1c320b0 	strh	r2, [r3]
		break;
	default:
		break;
	}

	switch (net_check_prereq (protocol)) {
21f09058:	e51b0028 	ldr	r0, [fp, #-40]
21f0905c:	eb0003f5 	bl	21f0a038 <net_check_prereq>
21f09060:	e50b0030 	str	r0, [fp, #-48]
21f09064:	e51b3030 	ldr	r3, [fp, #-48]
21f09068:	e3530000 	cmp	r3, #0	; 0x0
21f0906c:	0a000007 	beq	21f09090 <NetLoop+0x32c>
21f09070:	e51b2030 	ldr	r2, [fp, #-48]
21f09074:	e3520001 	cmp	r2, #1	; 0x1
21f09078:	0a000000 	beq	21f09080 <NetLoop+0x31c>
21f0907c:	ea00002c 	b	21f09134 <.text+0x9134>
	case 1:
		/* network not configured */
		eth_halt();
21f09080:	eb009461 	bl	21f2e20c <eth_halt>
		return (-1);
21f09084:	e3e03000 	mvn	r3, #0	; 0x0
21f09088:	e50b3034 	str	r3, [fp, #-52]
21f0908c:	ea00007f 	b	21f09290 <.text+0x9290>

#ifdef CONFIG_NET_MULTI
	case 2:
		/* network device not configured */
		break;
#endif /* CONFIG_NET_MULTI */

	case 0:
#ifdef CONFIG_NET_MULTI
		NetDevExists = 1;
#endif
		switch (protocol) {
21f09090:	e51b3028 	ldr	r3, [fp, #-40]
21f09094:	e3530007 	cmp	r3, #7	; 0x7
21f09098:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0909c:	ea000021 	b	21f09128 <.text+0x9128>
21f090a0:	21f090fc 	ldrcssh	r9, [r0, #12]!
21f090a4:	21f09110 	mvncss	r9, r0, lsl r1
21f090a8:	21f09128 	mvncss	r9, r8, lsr #2
21f090ac:	21f090c0 	mvncss	r9, r0, asr #1
21f090b0:	21f090c8 	mvncss	r9, r8, asr #1
21f090b4:	21f09128 	mvncss	r9, r8, lsr #2
21f090b8:	21f09128 	mvncss	r9, r8, lsr #2
21f090bc:	21f09124 	mvncss	r9, r4, lsr #2
		case TFTP:
			/* always use ARP to get server ethernet address */
			TftpStart();
21f090c0:	eb0008a7 	bl	21f0b364 <TftpStart>
			break;
21f090c4:	ea000017 	b	21f09128 <.text+0x9128>

#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
		case DHCP:
			/* Start with a clean slate... */
			BootpTry = 0;
21f090c8:	e59f2228 	ldr	r2, [pc, #552]	; 21f092f8 <.text+0x92f8>
21f090cc:	e3a03000 	mov	r3, #0	; 0x0
21f090d0:	e5823000 	str	r3, [r2]
			NetOurIP = 0;
21f090d4:	e59f21f0 	ldr	r2, [pc, #496]	; 21f092cc <.text+0x92cc>
21f090d8:	e3a03000 	mov	r3, #0	; 0x0
21f090dc:	e5823000 	str	r3, [r2]
			NetServerIP = getenv_IPaddr ("serverip");
21f090e0:	e59f0208 	ldr	r0, [pc, #520]	; 21f092f0 <.text+0x92f0>
21f090e4:	eb00065e 	bl	21f0aa64 <getenv_IPaddr>
21f090e8:	e1a02000 	mov	r2, r0
21f090ec:	e59f3200 	ldr	r3, [pc, #512]	; 21f092f4 <.text+0x92f4>
21f090f0:	e5832000 	str	r2, [r3]
			DhcpRequest();		/* Basically same as BOOTP */
21f090f4:	eb000e4e 	bl	21f0ca34 <DhcpRequest>
			break;
21f090f8:	ea00000a 	b	21f09128 <.text+0x9128>
#endif /* CFG_CMD_DHCP */

		case BOOTP:
			BootpTry = 0;
21f090fc:	e59f21f4 	ldr	r2, [pc, #500]	; 21f092f8 <.text+0x92f8>
21f09100:	e3a03000 	mov	r3, #0	; 0x0
21f09104:	e5823000 	str	r3, [r2]
			BootpRequest ();
21f09108:	eb000b4b 	bl	21f0be3c <BootpRequest>
			break;
21f0910c:	ea000005 	b	21f09128 <.text+0x9128>

		case RARP:
			RarpTry = 0;
21f09110:	e59f21e4 	ldr	r2, [pc, #484]	; 21f092fc <.text+0x92fc>
21f09114:	e3a03000 	mov	r3, #0	; 0x0
21f09118:	e5823000 	str	r3, [r2]
			RarpRequest ();
21f0911c:	eb000e85 	bl	21f0cb38 <RarpRequest>
			break;
21f09120:	ea000000 	b	21f09128 <.text+0x9128>
#if (CONFIG_COMMANDS & CFG_CMD_PING)
		case PING:
			PingStart();
			break;
#endif
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
		case NFS:
			NfsStart();
21f09124:	eb0014fa 	bl	21f0e514 <NfsStart>
			break;
#endif
#if (CONFIG_COMMANDS & CFG_CMD_CDP)
		case CDP:
			CDPStart();
			break;
#endif
#ifdef CONFIG_NETCONSOLE
		case NETCONS:
			NcStart();
			break;
#endif
#if (CONFIG_COMMANDS & CFG_CMD_SNTP)
		case SNTP:
			SntpStart();
			break;
#endif
		default:
			break;
		}

		NetBootFileXferSize = 0;
21f09128:	e59f21d0 	ldr	r2, [pc, #464]	; 21f09300 <.text+0x9300>
21f0912c:	e3a03000 	mov	r3, #0	; 0x0
21f09130:	e5823000 	str	r3, [r2]
		break;
	}

#if defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII)
#if defined(CFG_FAULT_ECHO_LINK_DOWN) && defined(CONFIG_STATUS_LED) && defined(STATUS_LED_RED)
	/*
	 * Echo the inverted link state to the fault LED.
	 */
	if(miiphy_link(eth_get_dev()->name, CFG_FAULT_MII_ADDR)) {
		status_led_set (STATUS_LED_RED, STATUS_LED_OFF);
	} else {
		status_led_set (STATUS_LED_RED, STATUS_LED_ON);
	}
#endif /* CFG_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */

	/*
	 *	Main packet reception loop.  Loop receiving packets until
	 *	someone sets `NetState' to a state that terminates.
	 */
	for (;;) {
		WATCHDOG_RESET();
#ifdef CONFIG_SHOW_ACTIVITY
		{
			extern void show_activity(int arg);
			show_activity(1);
		}
#endif
		/*
		 *	Check the ethernet for a new packet.  The ethernet
		 *	receive routine will process it.
		 */
			eth_rx();
21f09134:	eb0093f2 	bl	21f2e104 <eth_rx>

		/*
		 *	Abort if ctrl-c was pressed.
		 */
		if (ctrlc()) {
21f09138:	eb004a7c 	bl	21f1bb30 <ctrlc>
21f0913c:	e1a03000 	mov	r3, r0
21f09140:	e3530000 	cmp	r3, #0	; 0x0
21f09144:	0a000005 	beq	21f09160 <.text+0x9160>
			eth_halt();
21f09148:	eb00942f 	bl	21f2e20c <eth_halt>
			puts ("\nAbort\n");
21f0914c:	e59f01b0 	ldr	r0, [pc, #432]	; 21f09304 <.text+0x9304>
21f09150:	eb004a3a 	bl	21f1ba40 <puts>
			return (-1);
21f09154:	e3e02000 	mvn	r2, #0	; 0x0
21f09158:	e50b2034 	str	r2, [fp, #-52]
21f0915c:	ea00004b 	b	21f09290 <.text+0x9290>
		}

		ArpTimeoutCheck();
21f09160:	ebfffed2 	bl	21f08cb0 <ArpTimeoutCheck>

		/*
		 *	Check for a timeout, and run the timeout handler
		 *	if we have one.
		 */
		if (timeHandler && ((get_timer(0) - timeStart) > timeDelta)) {
21f09164:	e59f319c 	ldr	r3, [pc, #412]	; 21f09308 <.text+0x9308>
21f09168:	e5933000 	ldr	r3, [r3]
21f0916c:	e3530000 	cmp	r3, #0	; 0x0
21f09170:	0a000012 	beq	21f091c0 <.text+0x91c0>
21f09174:	e3a00000 	mov	r0, #0	; 0x0
21f09178:	ebffde35 	bl	21f00a54 <get_timer>
21f0917c:	e1a02000 	mov	r2, r0
21f09180:	e59f3184 	ldr	r3, [pc, #388]	; 21f0930c <.text+0x930c>
21f09184:	e5933000 	ldr	r3, [r3]
21f09188:	e0632002 	rsb	r2, r3, r2
21f0918c:	e59f317c 	ldr	r3, [pc, #380]	; 21f09310 <.text+0x9310>
21f09190:	e5933000 	ldr	r3, [r3]
21f09194:	e1520003 	cmp	r2, r3
21f09198:	9a000008 	bls	21f091c0 <.text+0x91c0>
			thand_f *x;

#if defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII)
#  if defined(CFG_FAULT_ECHO_LINK_DOWN) && \
      defined(CONFIG_STATUS_LED) &&	   \
      defined(STATUS_LED_RED)
			/*
			 * Echo the inverted link state to the fault LED.
			 */
			if(miiphy_link(eth_get_dev()->name, CFG_FAULT_MII_ADDR)) {
				status_led_set (STATUS_LED_RED, STATUS_LED_OFF);
			} else {
				status_led_set (STATUS_LED_RED, STATUS_LED_ON);
			}
#  endif /* CFG_FAULT_ECHO_LINK_DOWN, ... */
#endif /* CONFIG_MII, ... */
			x = timeHandler;
21f0919c:	e59f3164 	ldr	r3, [pc, #356]	; 21f09308 <.text+0x9308>
21f091a0:	e5933000 	ldr	r3, [r3]
21f091a4:	e50b3010 	str	r3, [fp, #-16]
			timeHandler = (thand_f *)0;
21f091a8:	e59f2158 	ldr	r2, [pc, #344]	; 21f09308 <.text+0x9308>
21f091ac:	e3a03000 	mov	r3, #0	; 0x0
21f091b0:	e5823000 	str	r3, [r2]
			(*x)();
21f091b4:	e51b3010 	ldr	r3, [fp, #-16]
21f091b8:	e1a0e00f 	mov	lr, pc
21f091bc:	e1a0f003 	mov	pc, r3
		}


		switch (NetState) {
21f091c0:	e59f3100 	ldr	r3, [pc, #256]	; 21f092c8 <.text+0x92c8>
21f091c4:	e5933000 	ldr	r3, [r3]
21f091c8:	e50b302c 	str	r3, [fp, #-44]
21f091cc:	e51b302c 	ldr	r3, [fp, #-44]
21f091d0:	e3530003 	cmp	r3, #3	; 0x3
21f091d4:	0a000006 	beq	21f091f4 <.text+0x91f4>
21f091d8:	e51b202c 	ldr	r2, [fp, #-44]
21f091dc:	e3520004 	cmp	r2, #4	; 0x4
21f091e0:	0a000028 	beq	21f09288 <.text+0x9288>
21f091e4:	e51b302c 	ldr	r3, [fp, #-44]
21f091e8:	e3530002 	cmp	r3, #2	; 0x2
21f091ec:	0affff31 	beq	21f08eb8 <NetLoop+0x154>
21f091f0:	eaffffcf 	b	21f09134 <.text+0x9134>

		case NETLOOP_RESTART:
#ifdef CONFIG_NET_MULTI
			NetRestarted = 1;
#endif
			goto restart;

		case NETLOOP_SUCCESS:
			if (NetBootFileXferSize > 0) {
21f091f4:	e59f3104 	ldr	r3, [pc, #260]	; 21f09300 <.text+0x9300>
21f091f8:	e5933000 	ldr	r3, [r3]
21f091fc:	e3530000 	cmp	r3, #0	; 0x0
21f09200:	0a00001b 	beq	21f09274 <.text+0x9274>
				char buf[10];
				printf("Bytes transferred = %ld (%lx hex)\n",
21f09204:	e59f30f4 	ldr	r3, [pc, #244]	; 21f09300 <.text+0x9300>
21f09208:	e5932000 	ldr	r2, [r3]
21f0920c:	e59f30ec 	ldr	r3, [pc, #236]	; 21f09300 <.text+0x9300>
21f09210:	e5933000 	ldr	r3, [r3]
21f09214:	e59f00f8 	ldr	r0, [pc, #248]	; 21f09314 <.text+0x9314>
21f09218:	e1a01002 	mov	r1, r2
21f0921c:	e1a02003 	mov	r2, r3
21f09220:	eb004a19 	bl	21f1ba8c <printf>
					NetBootFileXferSize,
					NetBootFileXferSize);
				sprintf(buf, "%lx", NetBootFileXferSize);
21f09224:	e59f30d4 	ldr	r3, [pc, #212]	; 21f09300 <.text+0x9300>
21f09228:	e5932000 	ldr	r2, [r3]
21f0922c:	e24b3022 	sub	r3, fp, #34	; 0x22
21f09230:	e1a00003 	mov	r0, r3
21f09234:	e59f10dc 	ldr	r1, [pc, #220]	; 21f09318 <.text+0x9318>
21f09238:	eb006d22 	bl	21f246c8 <sprintf>
				setenv("filesize", buf);
21f0923c:	e24b3022 	sub	r3, fp, #34	; 0x22
21f09240:	e59f00d4 	ldr	r0, [pc, #212]	; 21f0931c <.text+0x931c>
21f09244:	e1a01003 	mov	r1, r3
21f09248:	eb00463e 	bl	21f1ab48 <setenv>

				sprintf(buf, "%lX", (unsigned long)load_addr);
21f0924c:	e59f30cc 	ldr	r3, [pc, #204]	; 21f09320 <.text+0x9320>
21f09250:	e5932000 	ldr	r2, [r3]
21f09254:	e24b3022 	sub	r3, fp, #34	; 0x22
21f09258:	e1a00003 	mov	r0, r3
21f0925c:	e59f10c0 	ldr	r1, [pc, #192]	; 21f09324 <.text+0x9324>
21f09260:	eb006d18 	bl	21f246c8 <sprintf>
				setenv("fileaddr", buf);
21f09264:	e24b3022 	sub	r3, fp, #34	; 0x22
21f09268:	e59f00b8 	ldr	r0, [pc, #184]	; 21f09328 <.text+0x9328>
21f0926c:	e1a01003 	mov	r1, r3
21f09270:	eb004634 	bl	21f1ab48 <setenv>
			}
			eth_halt();
21f09274:	eb0093e4 	bl	21f2e20c <eth_halt>
			return NetBootFileXferSize;
21f09278:	e59f3080 	ldr	r3, [pc, #128]	; 21f09300 <.text+0x9300>
21f0927c:	e5933000 	ldr	r3, [r3]
21f09280:	e50b3034 	str	r3, [fp, #-52]
21f09284:	ea000001 	b	21f09290 <.text+0x9290>

		case NETLOOP_FAIL:
			return (-1);
21f09288:	e3e02000 	mvn	r2, #0	; 0x0
21f0928c:	e50b2034 	str	r2, [fp, #-52]
21f09290:	e51b3034 	ldr	r3, [fp, #-52]
		}
	}
}
21f09294:	e1a00003 	mov	r0, r3
21f09298:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0929c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f092a0:	21f6642c 	mvncss	r6, ip, lsr #8
21f092a4:	21f66430 	mvncss	r6, r0, lsr r4
21f092a8:	21f66424 	mvncss	r6, r4, lsr #8
21f092ac:	21f66428 	mvncss	r6, r8, lsr #8
21f092b0:	21f6454c 	mvncss	r4, ip, asr #10
21f092b4:	21f64623 	mvncss	r4, r3, lsr #12
21f092b8:	21f64564 	mvncss	r4, r4, ror #10
21f092bc:	21f66457 	mvncss	r6, r7, asr r4
21f092c0:	21f66434 	mvncss	r6, r4, lsr r4
21f092c4:	21f64554 	mvncss	r4, r4, asr r5
21f092c8:	21f64580 	mvncss	r4, r0, lsl #11
21f092cc:	21f6455c 	mvncss	r4, ip, asr r5
21f092d0:	21f2f4cc 	mvncss	pc, ip, asr #9
21f092d4:	21f644b4 	ldrcsh	r4, [r6, #68]!
21f092d8:	21f2f4d8 	ldrcssb	pc, [r2, #72]!
21f092dc:	21f644b0 	ldrcsh	r4, [r6, #64]!
21f092e0:	21f2f4e0 	mvncss	pc, r0, ror #9
21f092e4:	21f331d2 	ldrcssb	r3, [r3, #18]!
21f092e8:	21f2f4e8 	mvncss	pc, r8, ror #9
21f092ec:	21f331d4 	ldrcssb	r3, [r3, #20]!
21f092f0:	21f2f4f0 	ldrcssh	pc, [r2, #64]!
21f092f4:	21f64560 	mvncss	r4, r0, ror #10
21f092f8:	21f66ab4 	ldrcsh	r6, [r6, #164]!
21f092fc:	21f66ab8 	ldrcsh	r6, [r6, #168]!
21f09300:	21f64550 	mvncss	r4, r0, asr r5
21f09304:	21f2f4fc 	ldrcssh	pc, [r2, #76]!
21f09308:	21f66a64 	mvncss	r6, r4, ror #20
21f0930c:	21f66a68 	mvncss	r6, r8, ror #20
21f09310:	21f66a6c 	mvncss	r6, ip, ror #20
21f09314:	21f2f504 	mvncss	pc, r4, lsl #10
21f09318:	21f2f528 	mvncss	pc, r8, lsr #10
21f0931c:	21f2f52c 	mvncss	pc, ip, lsr #10
21f09320:	21f3322c 	mvncss	r3, ip, lsr #4
21f09324:	21f2f538 	mvncss	pc, r8, lsr r5
21f09328:	21f2f53c 	mvncss	pc, ip, lsr r5

21f0932c <NetCopyIP>:
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
21f0932c:	e1a0c00d 	mov	ip, sp
21f09330:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f09334:	e24cb004 	sub	fp, ip, #4	; 0x4
21f09338:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0933c:	e50b0010 	str	r0, [fp, #-16]
21f09340:	e50b1014 	str	r1, [fp, #-20]
	memcpy(to, from, sizeof(IPaddr_t));
21f09344:	e51b0010 	ldr	r0, [fp, #-16]
21f09348:	e51b1014 	ldr	r1, [fp, #-20]
21f0934c:	e3a02004 	mov	r2, #4	; 0x4
21f09350:	eb00679d 	bl	21f231cc <memcpy>
}
21f09354:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f09358:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0935c <startAgainTimeout>:

/**********************************************************************/

static void
startAgainTimeout(void)
{
21f0935c:	e1a0c00d 	mov	ip, sp
21f09360:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f09364:	e24cb004 	sub	fp, ip, #4	; 0x4
	NetState = NETLOOP_RESTART;
21f09368:	e59f2008 	ldr	r2, [pc, #8]	; 21f09378 <.text+0x9378>
21f0936c:	e3a03002 	mov	r3, #2	; 0x2
21f09370:	e5823000 	str	r3, [r2]
}
21f09374:	e89da800 	ldmia	sp, {fp, sp, pc}
21f09378:	21f64580 	mvncss	r4, r0, lsl #11

21f0937c <startAgainHandler>:

static void
startAgainHandler(uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
21f0937c:	e1a0c00d 	mov	ip, sp
21f09380:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f09384:	e24cb004 	sub	fp, ip, #4	; 0x4
21f09388:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0938c:	e50b0010 	str	r0, [fp, #-16]
21f09390:	e50b1014 	str	r1, [fp, #-20]
21f09394:	e50b2018 	str	r2, [fp, #-24]
21f09398:	e50b301c 	str	r3, [fp, #-28]
	/* Totally ignore the packet */
}
21f0939c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f093a0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f093a4 <NetStartAgain>:

void NetStartAgain (void)
{
21f093a4:	e1a0c00d 	mov	ip, sp
21f093a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f093ac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f093b0:	e24dd00c 	sub	sp, sp, #12	; 0xc
	char *nretry;
	int noretry = 0, once = 0;
21f093b4:	e3a03000 	mov	r3, #0	; 0x0
21f093b8:	e50b3014 	str	r3, [fp, #-20]
21f093bc:	e3a03000 	mov	r3, #0	; 0x0
21f093c0:	e50b3010 	str	r3, [fp, #-16]

	if ((nretry = getenv ("netretry")) != NULL) {
21f093c4:	e59f0094 	ldr	r0, [pc, #148]	; 21f09460 <.text+0x9460>
21f093c8:	eb004612 	bl	21f1ac18 <getenv>
21f093cc:	e1a03000 	mov	r3, r0
21f093d0:	e50b3018 	str	r3, [fp, #-24]
21f093d4:	e51b3018 	ldr	r3, [fp, #-24]
21f093d8:	e3530000 	cmp	r3, #0	; 0x0
21f093dc:	0a00000f 	beq	21f09420 <NetStartAgain+0x7c>
		noretry = (strcmp (nretry, "no") == 0);
21f093e0:	e51b0018 	ldr	r0, [fp, #-24]
21f093e4:	e59f1078 	ldr	r1, [pc, #120]	; 21f09464 <.text+0x9464>
21f093e8:	eb006557 	bl	21f2294c <strcmp>
21f093ec:	e1a03000 	mov	r3, r0
21f093f0:	e3530000 	cmp	r3, #0	; 0x0
21f093f4:	13a03000 	movne	r3, #0	; 0x0
21f093f8:	03a03001 	moveq	r3, #1	; 0x1
21f093fc:	e50b3014 	str	r3, [fp, #-20]
		once = (strcmp (nretry, "once") == 0);
21f09400:	e51b0018 	ldr	r0, [fp, #-24]
21f09404:	e59f105c 	ldr	r1, [pc, #92]	; 21f09468 <.text+0x9468>
21f09408:	eb00654f 	bl	21f2294c <strcmp>
21f0940c:	e1a03000 	mov	r3, r0
21f09410:	e3530000 	cmp	r3, #0	; 0x0
21f09414:	13a03000 	movne	r3, #0	; 0x0
21f09418:	03a03001 	moveq	r3, #1	; 0x1
21f0941c:	e50b3010 	str	r3, [fp, #-16]
	}
	if (noretry) {
21f09420:	e51b3014 	ldr	r3, [fp, #-20]
21f09424:	e3530000 	cmp	r3, #0	; 0x0
21f09428:	0a000004 	beq	21f09440 <NetStartAgain+0x9c>
		eth_halt ();
21f0942c:	eb009376 	bl	21f2e20c <eth_halt>
		NetState = NETLOOP_FAIL;
21f09430:	e59f2034 	ldr	r2, [pc, #52]	; 21f0946c <.text+0x946c>
21f09434:	e3a03004 	mov	r3, #4	; 0x4
21f09438:	e5823000 	str	r3, [r2]
		return;
21f0943c:	ea000005 	b	21f09458 <NetStartAgain+0xb4>
	}
#ifndef CONFIG_NET_MULTI
	NetSetTimeout (10 * CFG_HZ, startAgainTimeout);
21f09440:	e3a00c27 	mov	r0, #9984	; 0x2700
21f09444:	e2800010 	add	r0, r0, #16	; 0x10
21f09448:	e59f1020 	ldr	r1, [pc, #32]	; 21f09470 <.text+0x9470>
21f0944c:	eb000013 	bl	21f094a0 <NetSetTimeout>
	NetSetHandler (startAgainHandler);
21f09450:	e59f001c 	ldr	r0, [pc, #28]	; 21f09474 <.text+0x9474>
21f09454:	eb000007 	bl	21f09478 <NetSetHandler>
#else	/* !CONFIG_NET_MULTI*/
	eth_halt ();
	eth_try_another (!NetRestarted);
	eth_init (gd->bd);
	if (NetRestartWrap) {
		NetRestartWrap = 0;
		if (NetDevExists && !once) {
			NetSetTimeout (10 * CFG_HZ, startAgainTimeout);
			NetSetHandler (startAgainHandler);
		} else {
			NetState = NETLOOP_FAIL;
		}
	} else {
		NetState = NETLOOP_RESTART;
	}
#endif	/* CONFIG_NET_MULTI */
}
21f09458:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0945c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f09460:	21f2f548 	mvncss	pc, r8, asr #10
21f09464:	21f2f554 	mvncss	pc, r4, asr r5
21f09468:	21f2f558 	mvncss	pc, r8, asr r5
21f0946c:	21f64580 	mvncss	r4, r0, lsl #11
21f09470:	21f0935c 	mvncss	r9, ip, asr r3
21f09474:	21f0937c 	mvncss	r9, ip, ror r3

21f09478 <NetSetHandler>:

/**********************************************************************/
/*
 *	Miscelaneous bits.
 */

void
NetSetHandler(rxhand_f * f)
{
21f09478:	e1a0c00d 	mov	ip, sp
21f0947c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f09480:	e24cb004 	sub	fp, ip, #4	; 0x4
21f09484:	e24dd004 	sub	sp, sp, #4	; 0x4
21f09488:	e50b0010 	str	r0, [fp, #-16]
	packetHandler = f;
21f0948c:	e59f2008 	ldr	r2, [pc, #8]	; 21f0949c <.text+0x949c>
21f09490:	e51b3010 	ldr	r3, [fp, #-16]
21f09494:	e5823000 	str	r3, [r2]
}
21f09498:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f0949c:	21f66a60 	mvncss	r6, r0, ror #20

21f094a0 <NetSetTimeout>:


void
NetSetTimeout(ulong iv, thand_f * f)
{
21f094a0:	e1a0c00d 	mov	ip, sp
21f094a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f094a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f094ac:	e24dd008 	sub	sp, sp, #8	; 0x8
21f094b0:	e50b0010 	str	r0, [fp, #-16]
21f094b4:	e50b1014 	str	r1, [fp, #-20]
	if (iv == 0) {
21f094b8:	e51b3010 	ldr	r3, [fp, #-16]
21f094bc:	e3530000 	cmp	r3, #0	; 0x0
21f094c0:	1a000003 	bne	21f094d4 <NetSetTimeout+0x34>
		timeHandler = (thand_f *)0;
21f094c4:	e59f203c 	ldr	r2, [pc, #60]	; 21f09508 <.text+0x9508>
21f094c8:	e3a03000 	mov	r3, #0	; 0x0
21f094cc:	e5823000 	str	r3, [r2]
21f094d0:	ea00000a 	b	21f09500 <NetSetTimeout+0x60>
	} else {
		timeHandler = f;
21f094d4:	e59f202c 	ldr	r2, [pc, #44]	; 21f09508 <.text+0x9508>
21f094d8:	e51b3014 	ldr	r3, [fp, #-20]
21f094dc:	e5823000 	str	r3, [r2]
		timeStart = get_timer(0);
21f094e0:	e3a00000 	mov	r0, #0	; 0x0
21f094e4:	ebffdd5a 	bl	21f00a54 <get_timer>
21f094e8:	e1a02000 	mov	r2, r0
21f094ec:	e59f3018 	ldr	r3, [pc, #24]	; 21f0950c <.text+0x950c>
21f094f0:	e5832000 	str	r2, [r3]
		timeDelta = iv;
21f094f4:	e59f2014 	ldr	r2, [pc, #20]	; 21f09510 <.text+0x9510>
21f094f8:	e51b3010 	ldr	r3, [fp, #-16]
21f094fc:	e5823000 	str	r3, [r2]
	}
}
21f09500:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f09504:	e89da800 	ldmia	sp, {fp, sp, pc}
21f09508:	21f66a64 	mvncss	r6, r4, ror #20
21f0950c:	21f66a68 	mvncss	r6, r8, ror #20
21f09510:	21f66a6c 	mvncss	r6, ip, ror #20

21f09514 <NetSendPacket>:


void
NetSendPacket(volatile uchar * pkt, int len)
{
21f09514:	e1a0c00d 	mov	ip, sp
21f09518:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0951c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f09520:	e24dd008 	sub	sp, sp, #8	; 0x8
21f09524:	e50b0010 	str	r0, [fp, #-16]
21f09528:	e50b1014 	str	r1, [fp, #-20]
	(void) eth_send(pkt, len);
21f0952c:	e51b0010 	ldr	r0, [fp, #-16]
21f09530:	e51b1014 	ldr	r1, [fp, #-20]
21f09534:	eb0092ca 	bl	21f2e064 <eth_send>
}
21f09538:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0953c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f09540 <NetSendUDPPacket>:

int
NetSendUDPPacket(uchar *ether, IPaddr_t dest, int dport, int sport, int len)
{
21f09540:	e1a0c00d 	mov	ip, sp
21f09544:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f09548:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0954c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f09550:	e50b0014 	str	r0, [fp, #-20]
21f09554:	e50b1018 	str	r1, [fp, #-24]
21f09558:	e50b201c 	str	r2, [fp, #-28]
21f0955c:	e50b3020 	str	r3, [fp, #-32]
	uchar *pkt;

	/* convert to new style broadcast */
	if (dest == 0)
21f09560:	e51b3018 	ldr	r3, [fp, #-24]
21f09564:	e3530000 	cmp	r3, #0	; 0x0
21f09568:	1a000001 	bne	21f09574 <NetSendUDPPacket+0x34>
		dest = 0xFFFFFFFF;
21f0956c:	e3e03000 	mvn	r3, #0	; 0x0
21f09570:	e50b3018 	str	r3, [fp, #-24]

	/* if broadcast, make the ether address a broadcast and don't do ARP */
	if (dest == 0xFFFFFFFF)
21f09574:	e51b3018 	ldr	r3, [fp, #-24]
21f09578:	e3730001 	cmn	r3, #1	; 0x1
21f0957c:	1a000001 	bne	21f09588 <NetSendUDPPacket+0x48>
		ether = NetBcastAddr;
21f09580:	e59f31b8 	ldr	r3, [pc, #440]	; 21f09740 <.text+0x9740>
21f09584:	e50b3014 	str	r3, [fp, #-20]

	/* if MAC address was not discovered yet, save the packet and do an ARP request */
	if (memcmp(ether, NetEtherNullAddr, 6) == 0) {
21f09588:	e51b0014 	ldr	r0, [fp, #-20]
21f0958c:	e59f11b0 	ldr	r1, [pc, #432]	; 21f09744 <.text+0x9744>
21f09590:	e3a02006 	mov	r2, #6	; 0x6
21f09594:	eb00676a 	bl	21f23344 <memcmp>
21f09598:	e1a03000 	mov	r3, r0
21f0959c:	e3530000 	cmp	r3, #0	; 0x0
21f095a0:	1a000040 	bne	21f096a8 <NetSendUDPPacket+0x168>

#ifdef ET_DEBUG
		printf("sending ARP for %08lx\n", dest);
#endif
		NetArpWaitPacketIP = dest;
21f095a4:	e59f219c 	ldr	r2, [pc, #412]	; 21f09748 <.text+0x9748>
21f095a8:	e51b3018 	ldr	r3, [fp, #-24]
21f095ac:	e5823000 	str	r3, [r2]
		NetArpWaitPacketMAC = ether;
21f095b0:	e59f2194 	ldr	r2, [pc, #404]	; 21f0974c <.text+0x974c>
21f095b4:	e51b3014 	ldr	r3, [fp, #-20]
21f095b8:	e5823000 	str	r3, [r2]

		pkt = NetArpWaitTxPacket;
21f095bc:	e59f318c 	ldr	r3, [pc, #396]	; 21f09750 <.text+0x9750>
21f095c0:	e5933000 	ldr	r3, [r3]
21f095c4:	e50b3010 	str	r3, [fp, #-16]
		pkt += NetSetEther (pkt, NetArpWaitPacketMAC, PROT_IP);
21f095c8:	e59f317c 	ldr	r3, [pc, #380]	; 21f0974c <.text+0x974c>
21f095cc:	e5933000 	ldr	r3, [r3]
21f095d0:	e51b0010 	ldr	r0, [fp, #-16]
21f095d4:	e1a01003 	mov	r1, r3
21f095d8:	e3a02b02 	mov	r2, #2048	; 0x800
21f095dc:	eb00033f 	bl	21f0a2e0 <NetSetEther>
21f095e0:	e1a03000 	mov	r3, r0
21f095e4:	e1a02003 	mov	r2, r3
21f095e8:	e51b3010 	ldr	r3, [fp, #-16]
21f095ec:	e0833002 	add	r3, r3, r2
21f095f0:	e50b3010 	str	r3, [fp, #-16]

		NetSetIP (pkt, dest, dport, sport, len);
21f095f4:	e59b3004 	ldr	r3, [fp, #4]
21f095f8:	e58d3000 	str	r3, [sp]
21f095fc:	e51b0010 	ldr	r0, [fp, #-16]
21f09600:	e51b1018 	ldr	r1, [fp, #-24]
21f09604:	e51b201c 	ldr	r2, [fp, #-28]
21f09608:	e51b3020 	ldr	r3, [fp, #-32]
21f0960c:	eb000389 	bl	21f0a438 <NetSetIP>
		memcpy(pkt + IP_HDR_SIZE, (uchar *)NetTxPacket + (pkt - (uchar *)NetArpWaitTxPacket) + IP_HDR_SIZE, len);
21f09610:	e51b3010 	ldr	r3, [fp, #-16]
21f09614:	e283101c 	add	r1, r3, #28	; 0x1c
21f09618:	e51b2010 	ldr	r2, [fp, #-16]
21f0961c:	e59f312c 	ldr	r3, [pc, #300]	; 21f09750 <.text+0x9750>
21f09620:	e5933000 	ldr	r3, [r3]
21f09624:	e0633002 	rsb	r3, r3, r2
21f09628:	e1a02003 	mov	r2, r3
21f0962c:	e59f3120 	ldr	r3, [pc, #288]	; 21f09754 <.text+0x9754>
21f09630:	e5933000 	ldr	r3, [r3]
21f09634:	e0823003 	add	r3, r2, r3
21f09638:	e283301c 	add	r3, r3, #28	; 0x1c
21f0963c:	e59b2004 	ldr	r2, [fp, #4]
21f09640:	e1a00001 	mov	r0, r1
21f09644:	e1a01003 	mov	r1, r3
21f09648:	eb0066df 	bl	21f231cc <memcpy>

		/* size of the waiting packet */
		NetArpWaitTxPacketSize = (pkt - NetArpWaitTxPacket) + IP_HDR_SIZE + len;
21f0964c:	e51b2010 	ldr	r2, [fp, #-16]
21f09650:	e59f30f8 	ldr	r3, [pc, #248]	; 21f09750 <.text+0x9750>
21f09654:	e5933000 	ldr	r3, [r3]
21f09658:	e0633002 	rsb	r3, r3, r2
21f0965c:	e1a02003 	mov	r2, r3
21f09660:	e59b3004 	ldr	r3, [fp, #4]
21f09664:	e0823003 	add	r3, r2, r3
21f09668:	e283301c 	add	r3, r3, #28	; 0x1c
21f0966c:	e1a02003 	mov	r2, r3
21f09670:	e59f30e0 	ldr	r3, [pc, #224]	; 21f09758 <.text+0x9758>
21f09674:	e5832000 	str	r2, [r3]

		/* and do the ARP request */
		NetArpWaitTry = 1;
21f09678:	e59f20dc 	ldr	r2, [pc, #220]	; 21f0975c <.text+0x975c>
21f0967c:	e3a03001 	mov	r3, #1	; 0x1
21f09680:	e5823000 	str	r3, [r2]
		NetArpWaitTimerStart = get_timer(0);
21f09684:	e3a00000 	mov	r0, #0	; 0x0
21f09688:	ebffdcf1 	bl	21f00a54 <get_timer>
21f0968c:	e1a02000 	mov	r2, r0
21f09690:	e59f30c8 	ldr	r3, [pc, #200]	; 21f09760 <.text+0x9760>
21f09694:	e5832000 	str	r2, [r3]
		ArpRequest();
21f09698:	ebfffcda 	bl	21f08a08 <ArpRequest>
		return 1;	/* waiting */
21f0969c:	e3a03001 	mov	r3, #1	; 0x1
21f096a0:	e50b3024 	str	r3, [fp, #-36]
21f096a4:	ea000021 	b	21f09730 <NetSendUDPPacket+0x1f0>
	}

#ifdef ET_DEBUG
	printf("sending UDP to %08lx/%02x:%02x:%02x:%02x:%02x:%02x\n",
		dest, ether[0], ether[1], ether[2], ether[3], ether[4], ether[5]);
#endif

	pkt = (uchar *)NetTxPacket;
21f096a8:	e59f30a4 	ldr	r3, [pc, #164]	; 21f09754 <.text+0x9754>
21f096ac:	e5933000 	ldr	r3, [r3]
21f096b0:	e50b3010 	str	r3, [fp, #-16]
	pkt += NetSetEther (pkt, ether, PROT_IP);
21f096b4:	e51b0010 	ldr	r0, [fp, #-16]
21f096b8:	e51b1014 	ldr	r1, [fp, #-20]
21f096bc:	e3a02b02 	mov	r2, #2048	; 0x800
21f096c0:	eb000306 	bl	21f0a2e0 <NetSetEther>
21f096c4:	e1a03000 	mov	r3, r0
21f096c8:	e1a02003 	mov	r2, r3
21f096cc:	e51b3010 	ldr	r3, [fp, #-16]
21f096d0:	e0833002 	add	r3, r3, r2
21f096d4:	e50b3010 	str	r3, [fp, #-16]
	NetSetIP (pkt, dest, dport, sport, len);
21f096d8:	e59b3004 	ldr	r3, [fp, #4]
21f096dc:	e58d3000 	str	r3, [sp]
21f096e0:	e51b0010 	ldr	r0, [fp, #-16]
21f096e4:	e51b1018 	ldr	r1, [fp, #-24]
21f096e8:	e51b201c 	ldr	r2, [fp, #-28]
21f096ec:	e51b3020 	ldr	r3, [fp, #-32]
21f096f0:	eb000350 	bl	21f0a438 <NetSetIP>
	(void) eth_send(NetTxPacket, (pkt - NetTxPacket) + IP_HDR_SIZE + len);
21f096f4:	e59f3058 	ldr	r3, [pc, #88]	; 21f09754 <.text+0x9754>
21f096f8:	e5931000 	ldr	r1, [r3]
21f096fc:	e51b2010 	ldr	r2, [fp, #-16]
21f09700:	e59f304c 	ldr	r3, [pc, #76]	; 21f09754 <.text+0x9754>
21f09704:	e5933000 	ldr	r3, [r3]
21f09708:	e0633002 	rsb	r3, r3, r2
21f0970c:	e1a02003 	mov	r2, r3
21f09710:	e59b3004 	ldr	r3, [fp, #4]
21f09714:	e0823003 	add	r3, r2, r3
21f09718:	e283301c 	add	r3, r3, #28	; 0x1c
21f0971c:	e1a00001 	mov	r0, r1
21f09720:	e1a01003 	mov	r1, r3
21f09724:	eb00924e 	bl	21f2e064 <eth_send>

	return 0;	/* transmitted */
21f09728:	e3a03000 	mov	r3, #0	; 0x0
21f0972c:	e50b3024 	str	r3, [fp, #-36]
21f09730:	e51b3024 	ldr	r3, [fp, #-36]
}
21f09734:	e1a00003 	mov	r0, r3
21f09738:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0973c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f09740:	21f331cc 	mvncss	r3, ip, asr #3
21f09744:	21f64544 	mvncss	r4, r4, asr #10
21f09748:	21f66424 	mvncss	r6, r4, lsr #8
21f0974c:	21f6642c 	mvncss	r6, ip, lsr #8
21f09750:	21f66430 	mvncss	r6, r0, lsr r4
21f09754:	21f6454c 	mvncss	r4, ip, asr #10
21f09758:	21f66434 	mvncss	r6, r4, lsr r4
21f0975c:	21f66a5c 	mvncss	r6, ip, asr sl
21f09760:	21f66a58 	mvncss	r6, r8, asr sl

21f09764 <NetReceive>:

#if (CONFIG_COMMANDS & CFG_CMD_PING)
static ushort PingSeqNo;

int PingSend(void)
{
	static uchar mac[6];
	volatile IP_t *ip;
	volatile ushort *s;
	uchar *pkt;

	/* XXX always send arp request */

	memcpy(mac, NetEtherNullAddr, 6);

#ifdef ET_DEBUG
	printf("sending ARP for %08lx\n", NetPingIP);
#endif

	NetArpWaitPacketIP = NetPingIP;
	NetArpWaitPacketMAC = mac;

	pkt = NetArpWaitTxPacket;
	pkt += NetSetEther(pkt, mac, PROT_IP);

	ip = (volatile IP_t *)pkt;

	/*
	 *	Construct an IP and ICMP header.  (need to set no fragment bit - XXX)
	 */
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE_NO_UDP + 8);
	ip->ip_id    = htons(NetIPID++);
	ip->ip_off   = htons(0x4000);	/* No fragmentation */
	ip->ip_ttl   = 255;
	ip->ip_p     = 0x01;		/* ICMP */
	ip->ip_sum   = 0;
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
	NetCopyIP((void*)&ip->ip_dst, &NetPingIP);	   /* - "" - */
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);

	s = &ip->udp_src;		/* XXX ICMP starts here */
	s[0] = htons(0x0800);		/* echo-request, code */
	s[1] = 0;			/* checksum */
	s[2] = 0; 			/* identifier */
	s[3] = htons(PingSeqNo++);	/* sequence number */
	s[1] = ~NetCksum((uchar *)s, 8/2);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize = (pkt - NetArpWaitTxPacket) + IP_HDR_SIZE_NO_UDP + 8;

	/* and do the ARP request */
	NetArpWaitTry = 1;
	NetArpWaitTimerStart = get_timer(0);
	ArpRequest();
	return 1;	/* waiting */
}

static void
PingTimeout (void)
{
	eth_halt();
	NetState = NETLOOP_FAIL;	/* we did not get the reply */
}

static void
PingHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
	IPaddr_t tmp;
	volatile IP_t *ip = (volatile IP_t *)pkt;

	tmp = NetReadIP((void *)&ip->ip_src);
	if (tmp != NetPingIP)
		return;

	NetState = NETLOOP_SUCCESS;
}

static void PingStart(void)
{
#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif	/* CONFIG_NET_MULTI */
	NetSetTimeout (10 * CFG_HZ, PingTimeout);
	NetSetHandler (PingHandler);

	PingSend();
}
#endif	/* CFG_CMD_PING */

#if (CONFIG_COMMANDS & CFG_CMD_CDP)

#define CDP_DEVICE_ID_TLV		0x0001
#define CDP_ADDRESS_TLV			0x0002
#define CDP_PORT_ID_TLV			0x0003
#define CDP_CAPABILITIES_TLV		0x0004
#define CDP_VERSION_TLV			0x0005
#define CDP_PLATFORM_TLV		0x0006
#define CDP_NATIVE_VLAN_TLV		0x000a
#define CDP_APPLIANCE_VLAN_TLV		0x000e
#define CDP_TRIGGER_TLV			0x000f
#define CDP_POWER_CONSUMPTION_TLV	0x0010
#define CDP_SYSNAME_TLV			0x0014
#define CDP_SYSOBJECT_TLV		0x0015
#define CDP_MANAGEMENT_ADDRESS_TLV	0x0016

#define CDP_TIMEOUT			(CFG_HZ/4)	/* one packet every 250ms */

static int CDPSeq;
static int CDPOK;

ushort CDPNativeVLAN;
ushort CDPApplianceVLAN;

static const uchar CDP_SNAP_hdr[8] = { 0xAA, 0xAA, 0x03, 0x00, 0x00, 0x0C, 0x20, 0x00 };

static ushort CDP_compute_csum(const uchar *buff, ushort len)
{
	ushort csum;
	int     odd;
	ulong   result = 0;
	ushort  leftover;
	ushort *p;

	if (len > 0) {
		odd = 1 & (ulong)buff;
		if (odd) {
			result = *buff << 8;
			len--;
			buff++;
		}
		while (len > 1) {
			p = (ushort *)buff;
			result += *p++;
			buff = (uchar *)p;
			if (result & 0x80000000)
				result = (result & 0xFFFF) + (result >> 16);
			len -= 2;
		}
		if (len) {
			leftover = (signed short)(*(const signed char *)buff);
			/* CISCO SUCKS big time! (and blows too):
			 * CDP uses the IP checksum algorithm with a twist;
			 * for the last byte it *sign* extends and sums.
			 */
			result = (result & 0xffff0000) | ((result + leftover) & 0x0000ffff);
		}
		while (result >> 16)
			result = (result & 0xFFFF) + (result >> 16);

		if (odd)
			result = ((result >> 8) & 0xff) | ((result & 0xff) << 8);
	}

	/* add up 16-bit and 17-bit words for 17+c bits */
	result = (result & 0xffff) + (result >> 16);
	/* add up 16-bit and 2-bit for 16+c bit */
	result = (result & 0xffff) + (result >> 16);
	/* add up carry.. */
	result = (result & 0xffff) + (result >> 16);

	/* negate */
	csum = ~(ushort)result;

	/* run time endian detection */
	if (csum != htons(csum))	/* little endian */
		csum = htons(csum);

	return csum;
}

int CDPSendTrigger(void)
{
	volatile uchar *pkt;
	volatile ushort *s;
	volatile ushort *cp;
	Ethernet_t *et;
	int len;
	ushort chksum;
#if defined(CONFIG_CDP_DEVICE_ID) || defined(CONFIG_CDP_PORT_ID)   || \
    defined(CONFIG_CDP_VERSION)   || defined(CONFIG_CDP_PLATFORM)
	char buf[32];
#endif

	pkt = NetTxPacket;
	et = (Ethernet_t *)pkt;

	/* NOTE: trigger sent not on any VLAN */

	/* form ethernet header */
	memcpy(et->et_dest, NetCDPAddr, 6);
	memcpy(et->et_src, NetOurEther, 6);

	pkt += ETHER_HDR_SIZE;

	/* SNAP header */
	memcpy((uchar *)pkt, CDP_SNAP_hdr, sizeof(CDP_SNAP_hdr));
	pkt += sizeof(CDP_SNAP_hdr);

	/* CDP header */
	*pkt++ = 0x02;				/* CDP version 2 */
	*pkt++ = 180;				/* TTL */
	s = (volatile ushort *)pkt;
	cp = s;
	*s++ = htons(0);			/* checksum (0 for later calculation) */

	/* CDP fields */
#ifdef CONFIG_CDP_DEVICE_ID
	*s++ = htons(CDP_DEVICE_ID_TLV);
	*s++ = htons(CONFIG_CDP_DEVICE_ID);
	memset(buf, 0, sizeof(buf));
	sprintf(buf, CONFIG_CDP_DEVICE_ID_PREFIX "%02X%02X%02X%02X%02X%02X",
		NetOurEther[0] & 0xff, NetOurEther[1] & 0xff,
		NetOurEther[2] & 0xff, NetOurEther[3] & 0xff,
		NetOurEther[4] & 0xff, NetOurEther[5] & 0xff);
	memcpy((uchar *)s, buf, 16);
	s += 16 / 2;
#endif

#ifdef CONFIG_CDP_PORT_ID
	*s++ = htons(CDP_PORT_ID_TLV);
	memset(buf, 0, sizeof(buf));
	sprintf(buf, CONFIG_CDP_PORT_ID, eth_get_dev_index());
	len = strlen(buf);
	if (len & 1)	/* make it even */
		len++;
	*s++ = htons(len + 4);
	memcpy((uchar *)s, buf, len);
	s += len / 2;
#endif

#ifdef CONFIG_CDP_CAPABILITIES
	*s++ = htons(CDP_CAPABILITIES_TLV);
	*s++ = htons(8);
	*(ulong *)s = htonl(CONFIG_CDP_CAPABILITIES);
	s += 2;
#endif

#ifdef CONFIG_CDP_VERSION
	*s++ = htons(CDP_VERSION_TLV);
	memset(buf, 0, sizeof(buf));
	strcpy(buf, CONFIG_CDP_VERSION);
	len = strlen(buf);
	if (len & 1)	/* make it even */
		len++;
	*s++ = htons(len + 4);
	memcpy((uchar *)s, buf, len);
	s += len / 2;
#endif

#ifdef CONFIG_CDP_PLATFORM
	*s++ = htons(CDP_PLATFORM_TLV);
	memset(buf, 0, sizeof(buf));
	strcpy(buf, CONFIG_CDP_PLATFORM);
	len = strlen(buf);
	if (len & 1)	/* make it even */
		len++;
	*s++ = htons(len + 4);
	memcpy((uchar *)s, buf, len);
	s += len / 2;
#endif

#ifdef CONFIG_CDP_TRIGGER
	*s++ = htons(CDP_TRIGGER_TLV);
	*s++ = htons(8);
	*(ulong *)s = htonl(CONFIG_CDP_TRIGGER);
	s += 2;
#endif

#ifdef CONFIG_CDP_POWER_CONSUMPTION
	*s++ = htons(CDP_POWER_CONSUMPTION_TLV);
	*s++ = htons(6);
	*s++ = htons(CONFIG_CDP_POWER_CONSUMPTION);
#endif

	/* length of ethernet packet */
	len = (uchar *)s - ((uchar *)NetTxPacket + ETHER_HDR_SIZE);
	et->et_protlen = htons(len);

	len = ETHER_HDR_SIZE + sizeof(CDP_SNAP_hdr);
	chksum = CDP_compute_csum((uchar *)NetTxPacket + len, (uchar *)s - (NetTxPacket + len));
	if (chksum == 0)
		chksum = 0xFFFF;
	*cp = htons(chksum);

	(void) eth_send(NetTxPacket, (uchar *)s - NetTxPacket);
	return 0;
}

static void
CDPTimeout (void)
{
	CDPSeq++;

	if (CDPSeq < 3) {
		NetSetTimeout (CDP_TIMEOUT, CDPTimeout);
		CDPSendTrigger();
		return;
	}

	/* if not OK try again */
	if (!CDPOK)
		NetStartAgain();
	else
		NetState = NETLOOP_SUCCESS;
}

static void
CDPDummyHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
	/* nothing */
}

static void
CDPHandler(const uchar * pkt, unsigned len)
{
	const uchar *t;
	const ushort *ss;
	ushort type, tlen;
	uchar applid;
	ushort vlan, nvlan;

	/* minimum size? */
	if (len < sizeof(CDP_SNAP_hdr) + 4)
		goto pkt_short;

	/* check for valid CDP SNAP header */
	if (memcmp(pkt, CDP_SNAP_hdr, sizeof(CDP_SNAP_hdr)) != 0)
		return;

	pkt += sizeof(CDP_SNAP_hdr);
	len -= sizeof(CDP_SNAP_hdr);

	/* Version of CDP protocol must be >= 2 and TTL != 0 */
	if (pkt[0] < 0x02 || pkt[1] == 0)
		return;

	/* if version is greater than 0x02 maybe we'll have a problem; output a warning */
	if (pkt[0] != 0x02)
		printf("** WARNING: CDP packet received with a protocol version %d > 2\n",
				pkt[0] & 0xff);

	if (CDP_compute_csum(pkt, len) != 0)
		return;

	pkt += 4;
	len -= 4;

	vlan = htons(-1);
	nvlan = htons(-1);
	while (len > 0) {
		if (len < 4)
			goto pkt_short;

		ss = (const ushort *)pkt;
		type = ntohs(ss[0]);
		tlen = ntohs(ss[1]);
		if (tlen > len) {
			goto pkt_short;
		}

		pkt += tlen;
		len -= tlen;

		ss += 2;	/* point ss to the data of the TLV */
		tlen -= 4;

		switch (type) {
			case CDP_DEVICE_ID_TLV:
				break;
			case CDP_ADDRESS_TLV:
				break;
			case CDP_PORT_ID_TLV:
				break;
			case CDP_CAPABILITIES_TLV:
				break;
			case CDP_VERSION_TLV:
				break;
			case CDP_PLATFORM_TLV:
				break;
			case CDP_NATIVE_VLAN_TLV:
				nvlan = *ss;
				break;
			case CDP_APPLIANCE_VLAN_TLV:
				t = (const uchar *)ss;
				while (tlen > 0) {
					if (tlen < 3)
						goto pkt_short;

					applid = t[0];
					ss = (const ushort *)(t + 1);

#ifdef CONFIG_CDP_APPLIANCE_VLAN_TYPE
					if (applid == CONFIG_CDP_APPLIANCE_VLAN_TYPE)
						vlan = *ss;
#else
					vlan = ntohs(*ss);	/* XXX will this work; dunno */
#endif
					t += 3; tlen -= 3;
				}
				break;
			case CDP_TRIGGER_TLV:
				break;
			case CDP_POWER_CONSUMPTION_TLV:
				break;
			case CDP_SYSNAME_TLV:
				break;
			case CDP_SYSOBJECT_TLV:
				break;
			case CDP_MANAGEMENT_ADDRESS_TLV:
				break;
		}
	}

	CDPApplianceVLAN = vlan;
	CDPNativeVLAN = nvlan;

	CDPOK = 1;
	return;

 pkt_short:
	printf("** CDP packet is too short\n");
	return;
}

static void CDPStart(void)
{
#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif
	CDPSeq = 0;
	CDPOK = 0;

	CDPNativeVLAN = htons(-1);
	CDPApplianceVLAN = htons(-1);

	NetSetTimeout (CDP_TIMEOUT, CDPTimeout);
	NetSetHandler (CDPDummyHandler);

	CDPSendTrigger();
}
#endif	/* CFG_CMD_CDP */


void
NetReceive(volatile uchar * inpkt, int len)
{
21f09764:	e1a0c00d 	mov	ip, sp
21f09768:	e92dd8f0 	stmdb	sp!, {r4, r5, r6, r7, fp, ip, lr, pc}
21f0976c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f09770:	e24dd038 	sub	sp, sp, #56	; 0x38
21f09774:	e50b0048 	str	r0, [fp, #-72]
21f09778:	e50b104c 	str	r1, [fp, #-76]
	Ethernet_t *et;
	IP_t	*ip;
	ARP_t	*arp;
	IPaddr_t tmp;
	int	x;
	uchar *pkt;
#if (CONFIG_COMMANDS & CFG_CMD_CDP)
	int iscdp;
#endif
	ushort cti = 0, vlanid = VLAN_NONE, myvlanid, mynvlanid;
21f0977c:	e3a03000 	mov	r3, #0	; 0x0
21f09780:	e14b32bc 	strh	r3, [fp, #-44]
21f09784:	e3e03a0f 	mvn	r3, #61440	; 0xf000
21f09788:	e14b32ba 	strh	r3, [fp, #-42]

#ifdef ET_DEBUG
	printf("packet received\n");
#endif

	NetRxPkt = inpkt;
21f0978c:	e59f2820 	ldr	r2, [pc, #2080]	; 21f09fb4 <.text+0x9fb4>
21f09790:	e51b3048 	ldr	r3, [fp, #-72]
21f09794:	e5823000 	str	r3, [r2]
	NetRxPktLen = len;
21f09798:	e59f2818 	ldr	r2, [pc, #2072]	; 21f09fb8 <.text+0x9fb8>
21f0979c:	e51b304c 	ldr	r3, [fp, #-76]
21f097a0:	e5823000 	str	r3, [r2]
	et = (Ethernet_t *)inpkt;
21f097a4:	e51b3048 	ldr	r3, [fp, #-72]
21f097a8:	e50b3044 	str	r3, [fp, #-68]

	/* too small packet? */
	if (len < ETHER_HDR_SIZE)
21f097ac:	e51b304c 	ldr	r3, [fp, #-76]
21f097b0:	e353000d 	cmp	r3, #13	; 0xd
21f097b4:	da0001fc 	ble	21f09fac <NetReceive+0x848>
		return;

#if (CONFIG_COMMANDS & CFG_CMD_CDP)
	/* keep track if packet is CDP */
	iscdp = memcmp(et->et_dest, NetCDPAddr, 6) == 0;
#endif

	myvlanid = ntohs(NetOurVLAN);
21f097b8:	e59f37fc 	ldr	r3, [pc, #2044]	; 21f09fbc <.text+0x9fbc>
21f097bc:	e1d330b0 	ldrh	r3, [r3]
21f097c0:	e1a00003 	mov	r0, r3
21f097c4:	ebfffd22 	bl	21f08c54 <__fswab16>
21f097c8:	e1a03000 	mov	r3, r0
21f097cc:	e14b32b8 	strh	r3, [fp, #-40]
	if (myvlanid == (ushort)-1)
21f097d0:	e15b22b8 	ldrh	r2, [fp, #-40]
21f097d4:	e3a03cff 	mov	r3, #65280	; 0xff00
21f097d8:	e28330ff 	add	r3, r3, #255	; 0xff
21f097dc:	e1520003 	cmp	r2, r3
21f097e0:	1a000001 	bne	21f097ec <NetReceive+0x88>
		myvlanid = VLAN_NONE;
21f097e4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
21f097e8:	e14b32b8 	strh	r3, [fp, #-40]
	mynvlanid = ntohs(NetOurNativeVLAN);
21f097ec:	e59f37cc 	ldr	r3, [pc, #1996]	; 21f09fc0 <.text+0x9fc0>
21f097f0:	e1d330b0 	ldrh	r3, [r3]
21f097f4:	e1a00003 	mov	r0, r3
21f097f8:	ebfffd15 	bl	21f08c54 <__fswab16>
21f097fc:	e1a03000 	mov	r3, r0
21f09800:	e14b32b6 	strh	r3, [fp, #-38]
	if (mynvlanid == (ushort)-1)
21f09804:	e15b22b6 	ldrh	r2, [fp, #-38]
21f09808:	e3a03cff 	mov	r3, #65280	; 0xff00
21f0980c:	e28330ff 	add	r3, r3, #255	; 0xff
21f09810:	e1520003 	cmp	r2, r3
21f09814:	1a000001 	bne	21f09820 <NetReceive+0xbc>
		mynvlanid = VLAN_NONE;
21f09818:	e3e03a0f 	mvn	r3, #61440	; 0xf000
21f0981c:	e14b32b6 	strh	r3, [fp, #-38]

	x = ntohs(et->et_protlen);
21f09820:	e51b3044 	ldr	r3, [fp, #-68]
21f09824:	e1d330bc 	ldrh	r3, [r3, #12]
21f09828:	e1a00003 	mov	r0, r3
21f0982c:	ebfffd08 	bl	21f08c54 <__fswab16>
21f09830:	e1a03000 	mov	r3, r0
21f09834:	e50b3034 	str	r3, [fp, #-52]

#ifdef ET_DEBUG
	printf("packet received\n");
#endif

	if (x < 1514) {
21f09838:	e51b2034 	ldr	r2, [fp, #-52]
21f0983c:	e3a03e5e 	mov	r3, #1504	; 0x5e0
21f09840:	e2833009 	add	r3, r3, #9	; 0x9
21f09844:	e1520003 	cmp	r2, r3
21f09848:	ca00000c 	bgt	21f09880 <NetReceive+0x11c>
		/*
		 *	Got a 802 packet.  Check the other protocol field.
		 */
		x = ntohs(et->et_prot);
21f0984c:	e51b3044 	ldr	r3, [fp, #-68]
21f09850:	e1d331b4 	ldrh	r3, [r3, #20]
21f09854:	e1a00003 	mov	r0, r3
21f09858:	ebfffcfd 	bl	21f08c54 <__fswab16>
21f0985c:	e1a03000 	mov	r3, r0
21f09860:	e50b3034 	str	r3, [fp, #-52]

		ip = (IP_t *)(inpkt + E802_HDR_SIZE);
21f09864:	e51b3048 	ldr	r3, [fp, #-72]
21f09868:	e2833016 	add	r3, r3, #22	; 0x16
21f0986c:	e50b3040 	str	r3, [fp, #-64]
		len -= E802_HDR_SIZE;
21f09870:	e51b304c 	ldr	r3, [fp, #-76]
21f09874:	e2433016 	sub	r3, r3, #22	; 0x16
21f09878:	e50b304c 	str	r3, [fp, #-76]
21f0987c:	ea00002f 	b	21f09940 <NetReceive+0x1dc>

	} else if (x != PROT_VLAN) {	/* normal packet */
21f09880:	e51b3034 	ldr	r3, [fp, #-52]
21f09884:	e3530c81 	cmp	r3, #33024	; 0x8100
21f09888:	0a000006 	beq	21f098a8 <NetReceive+0x144>
		ip = (IP_t *)(inpkt + ETHER_HDR_SIZE);
21f0988c:	e51b3048 	ldr	r3, [fp, #-72]
21f09890:	e283300e 	add	r3, r3, #14	; 0xe
21f09894:	e50b3040 	str	r3, [fp, #-64]
		len -= ETHER_HDR_SIZE;
21f09898:	e51b304c 	ldr	r3, [fp, #-76]
21f0989c:	e243300e 	sub	r3, r3, #14	; 0xe
21f098a0:	e50b304c 	str	r3, [fp, #-76]
21f098a4:	ea000025 	b	21f09940 <NetReceive+0x1dc>

	} else {			/* VLAN packet */
		VLAN_Ethernet_t *vet = (VLAN_Ethernet_t *)et;
21f098a8:	e51b3044 	ldr	r3, [fp, #-68]
21f098ac:	e50b3024 	str	r3, [fp, #-36]

#ifdef ET_DEBUG
		printf("VLAN packet received\n");
#endif
		/* too small packet? */
		if (len < VLAN_ETHER_HDR_SIZE)
21f098b0:	e51b304c 	ldr	r3, [fp, #-76]
21f098b4:	e3530011 	cmp	r3, #17	; 0x11
21f098b8:	da0001bb 	ble	21f09fac <NetReceive+0x848>
			return;

		/* if no VLAN active */
		if ((ntohs(NetOurVLAN) & VLAN_IDMASK) == VLAN_NONE
21f098bc:	e59f36f8 	ldr	r3, [pc, #1784]	; 21f09fbc <.text+0x9fbc>
21f098c0:	e1d330b0 	ldrh	r3, [r3]
21f098c4:	e1a00003 	mov	r0, r3
21f098c8:	ebfffce1 	bl	21f08c54 <__fswab16>
21f098cc:	e1a03000 	mov	r3, r0
21f098d0:	e1a02a03 	mov	r2, r3, lsl #20
21f098d4:	e1a02a22 	mov	r2, r2, lsr #20
21f098d8:	e3a03eff 	mov	r3, #4080	; 0xff0
21f098dc:	e283300f 	add	r3, r3, #15	; 0xf
21f098e0:	e1520003 	cmp	r2, r3
21f098e4:	0a0001b0 	beq	21f09fac <NetReceive+0x848>
#if (CONFIG_COMMANDS & CFG_CMD_CDP)
				&& iscdp == 0
#endif
				)
			return;

		cti = ntohs(vet->vet_tag);
21f098e8:	e51b3024 	ldr	r3, [fp, #-36]
21f098ec:	e1d330be 	ldrh	r3, [r3, #14]
21f098f0:	e1a00003 	mov	r0, r3
21f098f4:	ebfffcd6 	bl	21f08c54 <__fswab16>
21f098f8:	e1a03000 	mov	r3, r0
21f098fc:	e14b32bc 	strh	r3, [fp, #-44]
		vlanid = cti & VLAN_IDMASK;
21f09900:	e15b32bc 	ldrh	r3, [fp, #-44]
21f09904:	e1a03a03 	mov	r3, r3, lsl #20
21f09908:	e1a03a23 	mov	r3, r3, lsr #20
21f0990c:	e14b32ba 	strh	r3, [fp, #-42]
		x = ntohs(vet->vet_type);
21f09910:	e51b3024 	ldr	r3, [fp, #-36]
21f09914:	e1d331b0 	ldrh	r3, [r3, #16]
21f09918:	e1a00003 	mov	r0, r3
21f0991c:	ebfffccc 	bl	21f08c54 <__fswab16>
21f09920:	e1a03000 	mov	r3, r0
21f09924:	e50b3034 	str	r3, [fp, #-52]

		ip = (IP_t *)(inpkt + VLAN_ETHER_HDR_SIZE);
21f09928:	e51b3048 	ldr	r3, [fp, #-72]
21f0992c:	e2833012 	add	r3, r3, #18	; 0x12
21f09930:	e50b3040 	str	r3, [fp, #-64]
		len -= VLAN_ETHER_HDR_SIZE;
21f09934:	e51b304c 	ldr	r3, [fp, #-76]
21f09938:	e2433012 	sub	r3, r3, #18	; 0x12
21f0993c:	e50b304c 	str	r3, [fp, #-76]
	}

#ifdef ET_DEBUG
	printf("Receive from protocol 0x%x\n", x);
#endif

#if (CONFIG_COMMANDS & CFG_CMD_CDP)
	if (iscdp) {
		CDPHandler((uchar *)ip, len);
		return;
	}
#endif

	if ((myvlanid & VLAN_IDMASK) != VLAN_NONE) {
21f09940:	e15b32b8 	ldrh	r3, [fp, #-40]
21f09944:	e1a02a03 	mov	r2, r3, lsl #20
21f09948:	e1a02a22 	mov	r2, r2, lsr #20
21f0994c:	e3a03eff 	mov	r3, #4080	; 0xff0
21f09950:	e283300f 	add	r3, r3, #15	; 0xf
21f09954:	e1520003 	cmp	r2, r3
21f09958:	0a00000e 	beq	21f09998 <NetReceive+0x234>
		if (vlanid == VLAN_NONE)
21f0995c:	e15b22ba 	ldrh	r2, [fp, #-42]
21f09960:	e3a03eff 	mov	r3, #4080	; 0xff0
21f09964:	e283300f 	add	r3, r3, #15	; 0xf
21f09968:	e1520003 	cmp	r2, r3
21f0996c:	1a000003 	bne	21f09980 <NetReceive+0x21c>
			vlanid = (mynvlanid & VLAN_IDMASK);
21f09970:	e15b32b6 	ldrh	r3, [fp, #-38]
21f09974:	e1a03a03 	mov	r3, r3, lsl #20
21f09978:	e1a03a23 	mov	r3, r3, lsr #20
21f0997c:	e14b32ba 	strh	r3, [fp, #-42]
		/* not matched? */
		if (vlanid != (myvlanid & VLAN_IDMASK))
21f09980:	e15b22ba 	ldrh	r2, [fp, #-42]
21f09984:	e15b32b8 	ldrh	r3, [fp, #-40]
21f09988:	e1a03a03 	mov	r3, r3, lsl #20
21f0998c:	e1a03a23 	mov	r3, r3, lsr #20
21f09990:	e1520003 	cmp	r2, r3
21f09994:	1a000184 	bne	21f09fac <NetReceive+0x848>
			return;
	}

	switch (x) {
21f09998:	e51b2034 	ldr	r2, [fp, #-52]
21f0999c:	e50b2054 	str	r2, [fp, #-84]
21f099a0:	e3a03b02 	mov	r3, #2048	; 0x800
21f099a4:	e2833006 	add	r3, r3, #6	; 0x6
21f099a8:	e51b2054 	ldr	r2, [fp, #-84]
21f099ac:	e1520003 	cmp	r2, r3
21f099b0:	0a000008 	beq	21f099d8 <NetReceive+0x274>
21f099b4:	e3a03902 	mov	r3, #32768	; 0x8000
21f099b8:	e2833035 	add	r3, r3, #53	; 0x35
21f099bc:	e51b2054 	ldr	r2, [fp, #-84]
21f099c0:	e1520003 	cmp	r2, r3
21f099c4:	0a0000af 	beq	21f09c88 <NetReceive+0x524>
21f099c8:	e51b3054 	ldr	r3, [fp, #-84]
21f099cc:	e3530b02 	cmp	r3, #2048	; 0x800
21f099d0:	0a0000f5 	beq	21f09dac <NetReceive+0x648>
21f099d4:	ea000174 	b	21f09fac <NetReceive+0x848>

	case PROT_ARP:
		/*
		 * We have to deal with two types of ARP packets:
		 * - REQUEST packets will be answered by sending  our
		 *   IP address - if we know it.
		 * - REPLY packates are expected only after we asked
		 *   for the TFTP server's or the gateway's ethernet
		 *   address; so if we receive such a packet, we set
		 *   the server ethernet address
		 */
#ifdef ET_DEBUG
		puts ("Got ARP\n");
#endif
		arp = (ARP_t *)ip;
21f099d8:	e51b3040 	ldr	r3, [fp, #-64]
21f099dc:	e50b303c 	str	r3, [fp, #-60]
		if (len < ARP_HDR_SIZE) {
21f099e0:	e51b304c 	ldr	r3, [fp, #-76]
21f099e4:	e353001b 	cmp	r3, #27	; 0x1b
21f099e8:	ca000004 	bgt	21f09a00 <NetReceive+0x29c>
			printf("bad length %d < %d\n", len, ARP_HDR_SIZE);
21f099ec:	e59f05d0 	ldr	r0, [pc, #1488]	; 21f09fc4 <.text+0x9fc4>
21f099f0:	e51b104c 	ldr	r1, [fp, #-76]
21f099f4:	e3a0201c 	mov	r2, #28	; 0x1c
21f099f8:	eb004823 	bl	21f1ba8c <printf>
			return;
21f099fc:	ea00016a 	b	21f09fac <NetReceive+0x848>
		}
		if (ntohs(arp->ar_hrd) != ARP_ETHER) {
21f09a00:	e51b303c 	ldr	r3, [fp, #-60]
21f09a04:	e1d330b0 	ldrh	r3, [r3]
21f09a08:	e1a00003 	mov	r0, r3
21f09a0c:	ebfffc90 	bl	21f08c54 <__fswab16>
21f09a10:	e1a03000 	mov	r3, r0
21f09a14:	e3530001 	cmp	r3, #1	; 0x1
21f09a18:	1a000163 	bne	21f09fac <NetReceive+0x848>
			return;
		}
		if (ntohs(arp->ar_pro) != PROT_IP) {
21f09a1c:	e51b303c 	ldr	r3, [fp, #-60]
21f09a20:	e1d330b2 	ldrh	r3, [r3, #2]
21f09a24:	e1a00003 	mov	r0, r3
21f09a28:	ebfffc89 	bl	21f08c54 <__fswab16>
21f09a2c:	e1a03000 	mov	r3, r0
21f09a30:	e3530b02 	cmp	r3, #2048	; 0x800
21f09a34:	1a00015c 	bne	21f09fac <NetReceive+0x848>
			return;
		}
		if (arp->ar_hln != 6) {
21f09a38:	e51b303c 	ldr	r3, [fp, #-60]
21f09a3c:	e5d33004 	ldrb	r3, [r3, #4]
21f09a40:	e3530006 	cmp	r3, #6	; 0x6
21f09a44:	1a000158 	bne	21f09fac <NetReceive+0x848>
			return;
		}
		if (arp->ar_pln != 4) {
21f09a48:	e51b303c 	ldr	r3, [fp, #-60]
21f09a4c:	e5d33005 	ldrb	r3, [r3, #5]
21f09a50:	e3530004 	cmp	r3, #4	; 0x4
21f09a54:	1a000154 	bne	21f09fac <NetReceive+0x848>
			return;
		}

		if (NetOurIP == 0) {
21f09a58:	e59f3568 	ldr	r3, [pc, #1384]	; 21f09fc8 <.text+0x9fc8>
21f09a5c:	e5933000 	ldr	r3, [r3]
21f09a60:	e3530000 	cmp	r3, #0	; 0x0
21f09a64:	0a000150 	beq	21f09fac <NetReceive+0x848>
			return;
		}

		if (NetReadIP(&arp->ar_data[16]) != NetOurIP) {
21f09a68:	e51b303c 	ldr	r3, [fp, #-60]
21f09a6c:	e2833008 	add	r3, r3, #8	; 0x8
21f09a70:	e2833010 	add	r3, r3, #16	; 0x10
21f09a74:	e1a00003 	mov	r0, r3
21f09a78:	eb000160 	bl	21f0a000 <NetReadIP>
21f09a7c:	e1a02000 	mov	r2, r0
21f09a80:	e59f3540 	ldr	r3, [pc, #1344]	; 21f09fc8 <.text+0x9fc8>
21f09a84:	e5933000 	ldr	r3, [r3]
21f09a88:	e1520003 	cmp	r2, r3
21f09a8c:	1a000146 	bne	21f09fac <NetReceive+0x848>
			return;
		}

		switch (ntohs(arp->ar_op)) {
21f09a90:	e51b303c 	ldr	r3, [fp, #-60]
21f09a94:	e1d330b6 	ldrh	r3, [r3, #6]
21f09a98:	e1a00003 	mov	r0, r3
21f09a9c:	ebfffc6c 	bl	21f08c54 <__fswab16>
21f09aa0:	e1a03000 	mov	r3, r0
21f09aa4:	e50b3050 	str	r3, [fp, #-80]
21f09aa8:	e51b2050 	ldr	r2, [fp, #-80]
21f09aac:	e3520001 	cmp	r2, #1	; 0x1
21f09ab0:	0a000003 	beq	21f09ac4 <NetReceive+0x360>
21f09ab4:	e51b3050 	ldr	r3, [fp, #-80]
21f09ab8:	e3530002 	cmp	r3, #2	; 0x2
21f09abc:	0a00003b 	beq	21f09bb0 <NetReceive+0x44c>
21f09ac0:	ea000139 	b	21f09fac <NetReceive+0x848>
		case ARPOP_REQUEST:		/* reply with our IP address	*/
#ifdef ET_DEBUG
			puts ("Got ARP REQUEST, return our IP\n");
#endif
			pkt = (uchar *)et;
21f09ac4:	e51b3044 	ldr	r3, [fp, #-68]
21f09ac8:	e50b3030 	str	r3, [fp, #-48]
			pkt += NetSetEther(pkt, et->et_src, PROT_ARP);
21f09acc:	e51b3044 	ldr	r3, [fp, #-68]
21f09ad0:	e2833006 	add	r3, r3, #6	; 0x6
21f09ad4:	e51b0030 	ldr	r0, [fp, #-48]
21f09ad8:	e1a01003 	mov	r1, r3
21f09adc:	e3a02b02 	mov	r2, #2048	; 0x800
21f09ae0:	e2822006 	add	r2, r2, #6	; 0x6
21f09ae4:	eb0001fd 	bl	21f0a2e0 <NetSetEther>
21f09ae8:	e1a03000 	mov	r3, r0
21f09aec:	e1a02003 	mov	r2, r3
21f09af0:	e51b3030 	ldr	r3, [fp, #-48]
21f09af4:	e0833002 	add	r3, r3, r2
21f09af8:	e50b3030 	str	r3, [fp, #-48]
			arp->ar_op = htons(ARPOP_REPLY);
21f09afc:	e3a00002 	mov	r0, #2	; 0x2
21f09b00:	ebfffc53 	bl	21f08c54 <__fswab16>
21f09b04:	e1a03000 	mov	r3, r0
21f09b08:	e1a02003 	mov	r2, r3
21f09b0c:	e51b303c 	ldr	r3, [fp, #-60]
21f09b10:	e1c320b6 	strh	r2, [r3, #6]
			memcpy   (&arp->ar_data[10], &arp->ar_data[0], 6);
21f09b14:	e51b303c 	ldr	r3, [fp, #-60]
21f09b18:	e2833008 	add	r3, r3, #8	; 0x8
21f09b1c:	e283200a 	add	r2, r3, #10	; 0xa
21f09b20:	e51b303c 	ldr	r3, [fp, #-60]
21f09b24:	e2833008 	add	r3, r3, #8	; 0x8
21f09b28:	e1a00002 	mov	r0, r2
21f09b2c:	e1a01003 	mov	r1, r3
21f09b30:	e3a02006 	mov	r2, #6	; 0x6
21f09b34:	eb0065a4 	bl	21f231cc <memcpy>
			NetCopyIP(&arp->ar_data[16], &arp->ar_data[6]);
21f09b38:	e51b303c 	ldr	r3, [fp, #-60]
21f09b3c:	e2833008 	add	r3, r3, #8	; 0x8
21f09b40:	e2832010 	add	r2, r3, #16	; 0x10
21f09b44:	e51b303c 	ldr	r3, [fp, #-60]
21f09b48:	e2833008 	add	r3, r3, #8	; 0x8
21f09b4c:	e2833006 	add	r3, r3, #6	; 0x6
21f09b50:	e1a00002 	mov	r0, r2
21f09b54:	e1a01003 	mov	r1, r3
21f09b58:	ebfffdf3 	bl	21f0932c <NetCopyIP>
			memcpy   (&arp->ar_data[ 0], NetOurEther, 6);
21f09b5c:	e51b303c 	ldr	r3, [fp, #-60]
21f09b60:	e2833008 	add	r3, r3, #8	; 0x8
21f09b64:	e1a00003 	mov	r0, r3
21f09b68:	e59f145c 	ldr	r1, [pc, #1116]	; 21f09fcc <.text+0x9fcc>
21f09b6c:	e3a02006 	mov	r2, #6	; 0x6
21f09b70:	eb006595 	bl	21f231cc <memcpy>
			NetCopyIP(&arp->ar_data[ 6], &NetOurIP);
21f09b74:	e51b303c 	ldr	r3, [fp, #-60]
21f09b78:	e2833008 	add	r3, r3, #8	; 0x8
21f09b7c:	e2833006 	add	r3, r3, #6	; 0x6
21f09b80:	e1a00003 	mov	r0, r3
21f09b84:	e59f143c 	ldr	r1, [pc, #1084]	; 21f09fc8 <.text+0x9fc8>
21f09b88:	ebfffde7 	bl	21f0932c <NetCopyIP>
			(void) eth_send((uchar *)et, (pkt - (uchar *)et) + ARP_HDR_SIZE);
21f09b8c:	e51b1044 	ldr	r1, [fp, #-68]
21f09b90:	e51b2030 	ldr	r2, [fp, #-48]
21f09b94:	e51b3044 	ldr	r3, [fp, #-68]
21f09b98:	e0633002 	rsb	r3, r3, r2
21f09b9c:	e283301c 	add	r3, r3, #28	; 0x1c
21f09ba0:	e1a00001 	mov	r0, r1
21f09ba4:	e1a01003 	mov	r1, r3
21f09ba8:	eb00912d 	bl	21f2e064 <eth_send>
			return;
21f09bac:	ea0000fe 	b	21f09fac <NetReceive+0x848>

		case ARPOP_REPLY:		/* arp reply */
			/* are we waiting for a reply */
			if (!NetArpWaitPacketIP || !NetArpWaitPacketMAC)
21f09bb0:	e59f3418 	ldr	r3, [pc, #1048]	; 21f09fd0 <.text+0x9fd0>
21f09bb4:	e5933000 	ldr	r3, [r3]
21f09bb8:	e3530000 	cmp	r3, #0	; 0x0
21f09bbc:	0a0000fa 	beq	21f09fac <NetReceive+0x848>
21f09bc0:	e59f340c 	ldr	r3, [pc, #1036]	; 21f09fd4 <.text+0x9fd4>
21f09bc4:	e5933000 	ldr	r3, [r3]
21f09bc8:	e3530000 	cmp	r3, #0	; 0x0
21f09bcc:	0a0000f6 	beq	21f09fac <NetReceive+0x848>
				break;
#ifdef ET_DEBUG
			printf("Got ARP REPLY, set server/gtwy eth addr (%02x:%02x:%02x:%02x:%02x:%02x)\n",
				arp->ar_data[0], arp->ar_data[1],
				arp->ar_data[2], arp->ar_data[3],
				arp->ar_data[4], arp->ar_data[5]);
#endif

			tmp = NetReadIP(&arp->ar_data[6]);
21f09bd0:	e51b303c 	ldr	r3, [fp, #-60]
21f09bd4:	e2833008 	add	r3, r3, #8	; 0x8
21f09bd8:	e2833006 	add	r3, r3, #6	; 0x6
21f09bdc:	e1a00003 	mov	r0, r3
21f09be0:	eb000106 	bl	21f0a000 <NetReadIP>
21f09be4:	e1a03000 	mov	r3, r0
21f09be8:	e50b3038 	str	r3, [fp, #-56]

			/* matched waiting packet's address */
			if (tmp == NetArpWaitReplyIP) {
21f09bec:	e59f33e4 	ldr	r3, [pc, #996]	; 21f09fd8 <.text+0x9fd8>
21f09bf0:	e5932000 	ldr	r2, [r3]
21f09bf4:	e51b3038 	ldr	r3, [fp, #-56]
21f09bf8:	e1530002 	cmp	r3, r2
21f09bfc:	1a0000ea 	bne	21f09fac <NetReceive+0x848>
#ifdef ET_DEBUG
				puts ("Got it\n");
#endif
				/* save address for later use */
				memcpy(NetArpWaitPacketMAC, &arp->ar_data[0], 6);
21f09c00:	e59f33cc 	ldr	r3, [pc, #972]	; 21f09fd4 <.text+0x9fd4>
21f09c04:	e5932000 	ldr	r2, [r3]
21f09c08:	e51b303c 	ldr	r3, [fp, #-60]
21f09c0c:	e2833008 	add	r3, r3, #8	; 0x8
21f09c10:	e1a00002 	mov	r0, r2
21f09c14:	e1a01003 	mov	r1, r3
21f09c18:	e3a02006 	mov	r2, #6	; 0x6
21f09c1c:	eb00656a 	bl	21f231cc <memcpy>

#ifdef CONFIG_NETCONSOLE
				(*packetHandler)(0,0,0,0);
#endif
				/* modify header, and transmit it */
				memcpy(((Ethernet_t *)NetArpWaitTxPacket)->et_dest, NetArpWaitPacketMAC, 6);
21f09c20:	e59f33b4 	ldr	r3, [pc, #948]	; 21f09fdc <.text+0x9fdc>
21f09c24:	e5933000 	ldr	r3, [r3]
21f09c28:	e1a02003 	mov	r2, r3
21f09c2c:	e59f33a0 	ldr	r3, [pc, #928]	; 21f09fd4 <.text+0x9fd4>
21f09c30:	e5933000 	ldr	r3, [r3]
21f09c34:	e1a00002 	mov	r0, r2
21f09c38:	e1a01003 	mov	r1, r3
21f09c3c:	e3a02006 	mov	r2, #6	; 0x6
21f09c40:	eb006561 	bl	21f231cc <memcpy>
				(void) eth_send(NetArpWaitTxPacket, NetArpWaitTxPacketSize);
21f09c44:	e59f3390 	ldr	r3, [pc, #912]	; 21f09fdc <.text+0x9fdc>
21f09c48:	e5932000 	ldr	r2, [r3]
21f09c4c:	e59f338c 	ldr	r3, [pc, #908]	; 21f09fe0 <.text+0x9fe0>
21f09c50:	e5933000 	ldr	r3, [r3]
21f09c54:	e1a00002 	mov	r0, r2
21f09c58:	e1a01003 	mov	r1, r3
21f09c5c:	eb009100 	bl	21f2e064 <eth_send>

				/* no arp request pending now */
				NetArpWaitPacketIP = 0;
21f09c60:	e59f2368 	ldr	r2, [pc, #872]	; 21f09fd0 <.text+0x9fd0>
21f09c64:	e3a03000 	mov	r3, #0	; 0x0
21f09c68:	e5823000 	str	r3, [r2]
				NetArpWaitTxPacketSize = 0;
21f09c6c:	e59f236c 	ldr	r2, [pc, #876]	; 21f09fe0 <.text+0x9fe0>
21f09c70:	e3a03000 	mov	r3, #0	; 0x0
21f09c74:	e5823000 	str	r3, [r2]
				NetArpWaitPacketMAC = NULL;
21f09c78:	e59f2354 	ldr	r2, [pc, #852]	; 21f09fd4 <.text+0x9fd4>
21f09c7c:	e3a03000 	mov	r3, #0	; 0x0
21f09c80:	e5823000 	str	r3, [r2]
21f09c84:	ea0000c8 	b	21f09fac <NetReceive+0x848>

			}
			return;
		default:
#ifdef ET_DEBUG
			printf("Unexpected ARP opcode 0x%x\n", ntohs(arp->ar_op));
#endif
			return;
		}
		break;

	case PROT_RARP:
#ifdef ET_DEBUG
		puts ("Got RARP\n");
#endif
		arp = (ARP_t *)ip;
21f09c88:	e51b3040 	ldr	r3, [fp, #-64]
21f09c8c:	e50b303c 	str	r3, [fp, #-60]
		if (len < ARP_HDR_SIZE) {
21f09c90:	e51b304c 	ldr	r3, [fp, #-76]
21f09c94:	e353001b 	cmp	r3, #27	; 0x1b
21f09c98:	ca000004 	bgt	21f09cb0 <NetReceive+0x54c>
			printf("bad length %d < %d\n", len, ARP_HDR_SIZE);
21f09c9c:	e59f0320 	ldr	r0, [pc, #800]	; 21f09fc4 <.text+0x9fc4>
21f09ca0:	e51b104c 	ldr	r1, [fp, #-76]
21f09ca4:	e3a0201c 	mov	r2, #28	; 0x1c
21f09ca8:	eb004777 	bl	21f1ba8c <printf>
			return;
21f09cac:	ea0000be 	b	21f09fac <NetReceive+0x848>
		}

		if ((ntohs(arp->ar_op) != RARPOP_REPLY) ||
21f09cb0:	e51b303c 	ldr	r3, [fp, #-60]
21f09cb4:	e1d330b6 	ldrh	r3, [r3, #6]
21f09cb8:	e1a00003 	mov	r0, r3
21f09cbc:	ebfffbe4 	bl	21f08c54 <__fswab16>
21f09cc0:	e1a03000 	mov	r3, r0
21f09cc4:	e3530004 	cmp	r3, #4	; 0x4
21f09cc8:	1a000015 	bne	21f09d24 <NetReceive+0x5c0>
21f09ccc:	e51b303c 	ldr	r3, [fp, #-60]
21f09cd0:	e1d330b0 	ldrh	r3, [r3]
21f09cd4:	e1a00003 	mov	r0, r3
21f09cd8:	ebfffbdd 	bl	21f08c54 <__fswab16>
21f09cdc:	e1a03000 	mov	r3, r0
21f09ce0:	e3530001 	cmp	r3, #1	; 0x1
21f09ce4:	1a00000e 	bne	21f09d24 <NetReceive+0x5c0>
21f09ce8:	e51b303c 	ldr	r3, [fp, #-60]
21f09cec:	e1d330b2 	ldrh	r3, [r3, #2]
21f09cf0:	e1a00003 	mov	r0, r3
21f09cf4:	ebfffbd6 	bl	21f08c54 <__fswab16>
21f09cf8:	e1a03000 	mov	r3, r0
21f09cfc:	e3530b02 	cmp	r3, #2048	; 0x800
21f09d00:	1a000007 	bne	21f09d24 <NetReceive+0x5c0>
21f09d04:	e51b303c 	ldr	r3, [fp, #-60]
21f09d08:	e5d33004 	ldrb	r3, [r3, #4]
21f09d0c:	e3530006 	cmp	r3, #6	; 0x6
21f09d10:	1a000003 	bne	21f09d24 <NetReceive+0x5c0>
21f09d14:	e51b303c 	ldr	r3, [fp, #-60]
21f09d18:	e5d33005 	ldrb	r3, [r3, #5]
21f09d1c:	e3530004 	cmp	r3, #4	; 0x4
21f09d20:	0a000002 	beq	21f09d30 <NetReceive+0x5cc>
			(ntohs(arp->ar_hrd) != ARP_ETHER)   ||
			(ntohs(arp->ar_pro) != PROT_IP)     ||
			(arp->ar_hln != 6) || (arp->ar_pln != 4)) {

			puts ("invalid RARP header\n");
21f09d24:	e59f02b8 	ldr	r0, [pc, #696]	; 21f09fe4 <.text+0x9fe4>
21f09d28:	eb004744 	bl	21f1ba40 <puts>
21f09d2c:	ea00009e 	b	21f09fac <NetReceive+0x848>
		} else {
			NetCopyIP(&NetOurIP,    &arp->ar_data[16]);
21f09d30:	e51b303c 	ldr	r3, [fp, #-60]
21f09d34:	e2833008 	add	r3, r3, #8	; 0x8
21f09d38:	e2833010 	add	r3, r3, #16	; 0x10
21f09d3c:	e59f0284 	ldr	r0, [pc, #644]	; 21f09fc8 <.text+0x9fc8>
21f09d40:	e1a01003 	mov	r1, r3
21f09d44:	ebfffd78 	bl	21f0932c <NetCopyIP>
			if (NetServerIP == 0)
21f09d48:	e59f3298 	ldr	r3, [pc, #664]	; 21f09fe8 <.text+0x9fe8>
21f09d4c:	e5933000 	ldr	r3, [r3]
21f09d50:	e3530000 	cmp	r3, #0	; 0x0
21f09d54:	1a000005 	bne	21f09d70 <NetReceive+0x60c>
				NetCopyIP(&NetServerIP, &arp->ar_data[ 6]);
21f09d58:	e51b303c 	ldr	r3, [fp, #-60]
21f09d5c:	e2833008 	add	r3, r3, #8	; 0x8
21f09d60:	e2833006 	add	r3, r3, #6	; 0x6
21f09d64:	e59f027c 	ldr	r0, [pc, #636]	; 21f09fe8 <.text+0x9fe8>
21f09d68:	e1a01003 	mov	r1, r3
21f09d6c:	ebfffd6e 	bl	21f0932c <NetCopyIP>
			memcpy (NetServerEther, &arp->ar_data[ 0], 6);
21f09d70:	e51b303c 	ldr	r3, [fp, #-60]
21f09d74:	e2833008 	add	r3, r3, #8	; 0x8
21f09d78:	e59f026c 	ldr	r0, [pc, #620]	; 21f09fec <.text+0x9fec>
21f09d7c:	e1a01003 	mov	r1, r3
21f09d80:	e3a02006 	mov	r2, #6	; 0x6
21f09d84:	eb006510 	bl	21f231cc <memcpy>

			(*packetHandler)(0,0,0,0);
21f09d88:	e59f3260 	ldr	r3, [pc, #608]	; 21f09ff0 <.text+0x9ff0>
21f09d8c:	e593c000 	ldr	ip, [r3]
21f09d90:	e3a00000 	mov	r0, #0	; 0x0
21f09d94:	e3a01000 	mov	r1, #0	; 0x0
21f09d98:	e3a02000 	mov	r2, #0	; 0x0
21f09d9c:	e3a03000 	mov	r3, #0	; 0x0
21f09da0:	e1a0e00f 	mov	lr, pc
21f09da4:	e1a0f00c 	mov	pc, ip
21f09da8:	ea00007f 	b	21f09fac <NetReceive+0x848>
		}
		break;

	case PROT_IP:
#ifdef ET_DEBUG
		puts ("Got IP\n");
#endif
		if (len < IP_HDR_SIZE) {
21f09dac:	e51b304c 	ldr	r3, [fp, #-76]
21f09db0:	e353001b 	cmp	r3, #27	; 0x1b
21f09db4:	9a00007c 	bls	21f09fac <NetReceive+0x848>
			debug ("len bad %d < %d\n", len, IP_HDR_SIZE);
			return;
		}
		if (len < ntohs(ip->ip_len)) {
21f09db8:	e51b3040 	ldr	r3, [fp, #-64]
21f09dbc:	e1d330b2 	ldrh	r3, [r3, #2]
21f09dc0:	e1a00003 	mov	r0, r3
21f09dc4:	ebfffba2 	bl	21f08c54 <__fswab16>
21f09dc8:	e1a03000 	mov	r3, r0
21f09dcc:	e1a02003 	mov	r2, r3
21f09dd0:	e51b304c 	ldr	r3, [fp, #-76]
21f09dd4:	e1520003 	cmp	r2, r3
21f09dd8:	da000009 	ble	21f09e04 <NetReceive+0x6a0>
			printf("len bad %d < %d\n", len, ntohs(ip->ip_len));
21f09ddc:	e51b3040 	ldr	r3, [fp, #-64]
21f09de0:	e1d330b2 	ldrh	r3, [r3, #2]
21f09de4:	e1a00003 	mov	r0, r3
21f09de8:	ebfffb99 	bl	21f08c54 <__fswab16>
21f09dec:	e1a03000 	mov	r3, r0
21f09df0:	e59f01fc 	ldr	r0, [pc, #508]	; 21f09ff4 <.text+0x9ff4>
21f09df4:	e51b104c 	ldr	r1, [fp, #-76]
21f09df8:	e1a02003 	mov	r2, r3
21f09dfc:	eb004722 	bl	21f1ba8c <printf>
			return;
21f09e00:	ea000069 	b	21f09fac <NetReceive+0x848>
		}
		len = ntohs(ip->ip_len);
21f09e04:	e51b3040 	ldr	r3, [fp, #-64]
21f09e08:	e1d330b2 	ldrh	r3, [r3, #2]
21f09e0c:	e1a00003 	mov	r0, r3
21f09e10:	ebfffb8f 	bl	21f08c54 <__fswab16>
21f09e14:	e1a03000 	mov	r3, r0
21f09e18:	e50b304c 	str	r3, [fp, #-76]
#ifdef ET_DEBUG
		printf("len=%d, v=%02x\n", len, ip->ip_hl_v & 0xff);
#endif
		if ((ip->ip_hl_v & 0xf0) != 0x40) {
21f09e1c:	e51b3040 	ldr	r3, [fp, #-64]
21f09e20:	e5d33000 	ldrb	r3, [r3]
21f09e24:	e20330f0 	and	r3, r3, #240	; 0xf0
21f09e28:	e3530040 	cmp	r3, #64	; 0x40
21f09e2c:	1a00005e 	bne	21f09fac <NetReceive+0x848>
			return;
		}
		if (ip->ip_off & htons(0x1fff)) { /* Can't deal w/ fragments */
21f09e30:	e51b3040 	ldr	r3, [fp, #-64]
21f09e34:	e1d340b6 	ldrh	r4, [r3, #6]
21f09e38:	e3a00d7f 	mov	r0, #8128	; 0x1fc0
21f09e3c:	e280003f 	add	r0, r0, #63	; 0x3f
21f09e40:	ebfffb83 	bl	21f08c54 <__fswab16>
21f09e44:	e1a03000 	mov	r3, r0
21f09e48:	e0043003 	and	r3, r4, r3
21f09e4c:	e1a03803 	mov	r3, r3, lsl #16
21f09e50:	e1a03823 	mov	r3, r3, lsr #16
21f09e54:	e3530000 	cmp	r3, #0	; 0x0
21f09e58:	1a000053 	bne	21f09fac <NetReceive+0x848>
			return;
		}
		if (!NetCksumOk((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2)) {
21f09e5c:	e51b3040 	ldr	r3, [fp, #-64]
21f09e60:	e1a00003 	mov	r0, r3
21f09e64:	e3a0100a 	mov	r1, #10	; 0xa
21f09e68:	eb0000b4 	bl	21f0a140 <NetCksumOk>
21f09e6c:	e1a03000 	mov	r3, r0
21f09e70:	e3530000 	cmp	r3, #0	; 0x0
21f09e74:	1a000002 	bne	21f09e84 <NetReceive+0x720>
			puts ("checksum bad\n");
21f09e78:	e59f0178 	ldr	r0, [pc, #376]	; 21f09ff8 <.text+0x9ff8>
21f09e7c:	eb0046ef 	bl	21f1ba40 <puts>
			return;
21f09e80:	ea000049 	b	21f09fac <NetReceive+0x848>
		}
		tmp = NetReadIP(&ip->ip_dst);
21f09e84:	e51b3040 	ldr	r3, [fp, #-64]
21f09e88:	e2833010 	add	r3, r3, #16	; 0x10
21f09e8c:	e1a00003 	mov	r0, r3
21f09e90:	eb00005a 	bl	21f0a000 <NetReadIP>
21f09e94:	e1a03000 	mov	r3, r0
21f09e98:	e50b3038 	str	r3, [fp, #-56]
		if (NetOurIP && tmp != NetOurIP && tmp != 0xFFFFFFFF) {
21f09e9c:	e59f3124 	ldr	r3, [pc, #292]	; 21f09fc8 <.text+0x9fc8>
21f09ea0:	e5933000 	ldr	r3, [r3]
21f09ea4:	e3530000 	cmp	r3, #0	; 0x0
21f09ea8:	0a000007 	beq	21f09ecc <NetReceive+0x768>
21f09eac:	e59f3114 	ldr	r3, [pc, #276]	; 21f09fc8 <.text+0x9fc8>
21f09eb0:	e5932000 	ldr	r2, [r3]
21f09eb4:	e51b3038 	ldr	r3, [fp, #-56]
21f09eb8:	e1530002 	cmp	r3, r2
21f09ebc:	0a000002 	beq	21f09ecc <NetReceive+0x768>
21f09ec0:	e51b3038 	ldr	r3, [fp, #-56]
21f09ec4:	e3730001 	cmn	r3, #1	; 0x1
21f09ec8:	1a000037 	bne	21f09fac <NetReceive+0x848>
			return;
		}
		/*
		 * watch for ICMP host redirects
		 *
		 * There is no real handler code (yet). We just watch
		 * for ICMP host redirect messages. In case anybody
		 * sees these messages: please contact me
		 * (wd@denx.de), or - even better - send me the
		 * necessary fixes :-)
		 *
		 * Note: in all cases where I have seen this so far
		 * it was a problem with the router configuration,
		 * for instance when a router was configured in the
		 * BOOTP reply, but the TFTP server was on the same
		 * subnet. So this is probably a warning that your
		 * configuration might be wrong. But I'm not really
		 * sure if there aren't any other situations.
		 */
		if (ip->ip_p == IPPROTO_ICMP) {
21f09ecc:	e51b3040 	ldr	r3, [fp, #-64]
21f09ed0:	e5d33009 	ldrb	r3, [r3, #9]
21f09ed4:	e3530001 	cmp	r3, #1	; 0x1
21f09ed8:	1a000014 	bne	21f09f30 <NetReceive+0x7cc>
			ICMP_t *icmph = (ICMP_t *)&(ip->udp_src);
21f09edc:	e51b3040 	ldr	r3, [fp, #-64]
21f09ee0:	e2833014 	add	r3, r3, #20	; 0x14
21f09ee4:	e50b3020 	str	r3, [fp, #-32]

			switch (icmph->type) {
21f09ee8:	e51b3020 	ldr	r3, [fp, #-32]
21f09eec:	e5d33000 	ldrb	r3, [r3]
21f09ef0:	e3530005 	cmp	r3, #5	; 0x5
21f09ef4:	0a000000 	beq	21f09efc <NetReceive+0x798>
21f09ef8:	ea00002b 	b	21f09fac <NetReceive+0x848>
			case ICMP_REDIRECT:
				if (icmph->code != ICMP_REDIR_HOST)
21f09efc:	e51b3020 	ldr	r3, [fp, #-32]
21f09f00:	e5d33001 	ldrb	r3, [r3, #1]
21f09f04:	e3530001 	cmp	r3, #1	; 0x1
21f09f08:	1a000027 	bne	21f09fac <NetReceive+0x848>
					return;
				puts (" ICMP Host Redirect to ");
21f09f0c:	e59f00e8 	ldr	r0, [pc, #232]	; 21f09ffc <.text+0x9ffc>
21f09f10:	eb0046ca 	bl	21f1ba40 <puts>
				print_IPaddr(icmph->un.gateway);
21f09f14:	e51b3020 	ldr	r3, [fp, #-32]
21f09f18:	e5933004 	ldr	r3, [r3, #4]
21f09f1c:	e1a00003 	mov	r0, r3
21f09f20:	eb0002c1 	bl	21f0aa2c <print_IPaddr>
				putc(' ');
21f09f24:	e3a00020 	mov	r0, #32	; 0x20
21f09f28:	eb0046ae 	bl	21f1b9e8 <putc>
				return;
21f09f2c:	ea00001e 	b	21f09fac <NetReceive+0x848>
#if (CONFIG_COMMANDS & CFG_CMD_PING)
			case ICMP_ECHO_REPLY:
				/*
				 *	IP header OK.  Pass the packet to the current handler.
				 */
				/* XXX point to ip packet */
				(*packetHandler)((uchar *)ip, 0, 0, 0);
				return;
#endif
			default:
				return;
			}
		} else if (ip->ip_p != IPPROTO_UDP) {	/* Only UDP packets */
21f09f30:	e51b3040 	ldr	r3, [fp, #-64]
21f09f34:	e5d33009 	ldrb	r3, [r3, #9]
21f09f38:	e3530011 	cmp	r3, #17	; 0x11
21f09f3c:	1a00001a 	bne	21f09fac <NetReceive+0x848>
			return;
		}

#ifdef CONFIG_UDP_CHECKSUM
		if (ip->udp_xsum != 0) {
			ulong   xsum;
			ushort *sumptr;
			ushort  sumlen;

			xsum  = ip->ip_p;
			xsum += (ntohs(ip->udp_len));
			xsum += (ntohl(ip->ip_src) >> 16) & 0x0000ffff;
			xsum += (ntohl(ip->ip_src) >>  0) & 0x0000ffff;
			xsum += (ntohl(ip->ip_dst) >> 16) & 0x0000ffff;
			xsum += (ntohl(ip->ip_dst) >>  0) & 0x0000ffff;

			sumlen = ntohs(ip->udp_len);
			sumptr = (ushort *) &(ip->udp_src);

			while (sumlen > 1) {
				ushort sumdata;

				sumdata = *sumptr++;
				xsum += ntohs(sumdata);
				sumlen -= 2;
			}
			if (sumlen > 0) {
				ushort sumdata;

				sumdata = *(unsigned char *) sumptr;
				sumdata = (sumdata << 8) & 0xff00;
				xsum += sumdata;
			}
			while ((xsum >> 16) != 0) {
				xsum = (xsum & 0x0000ffff) + ((xsum >> 16) & 0x0000ffff);
			}
			if ((xsum != 0x00000000) && (xsum != 0x0000ffff)) {
				printf(" UDP wrong checksum %08x %08x\n", xsum, ntohs(ip->udp_xsum));
				return;
			}
		}
#endif

#ifdef CONFIG_NETCONSOLE
		nc_input_packet((uchar *)ip +IP_HDR_SIZE,
						ntohs(ip->udp_dst),
						ntohs(ip->udp_src),
						ntohs(ip->udp_len) - 8);
#endif
		/*
		 *	IP header OK.  Pass the packet to the current handler.
		 */
		(*packetHandler)((uchar *)ip +IP_HDR_SIZE,
21f09f40:	e59f30a8 	ldr	r3, [pc, #168]	; 21f09ff0 <.text+0x9ff0>
21f09f44:	e5934000 	ldr	r4, [r3]
21f09f48:	e51b3040 	ldr	r3, [fp, #-64]
21f09f4c:	e283501c 	add	r5, r3, #28	; 0x1c
21f09f50:	e51b3040 	ldr	r3, [fp, #-64]
21f09f54:	e1d331b6 	ldrh	r3, [r3, #22]
21f09f58:	e1a00003 	mov	r0, r3
21f09f5c:	ebfffb3c 	bl	21f08c54 <__fswab16>
21f09f60:	e1a03000 	mov	r3, r0
21f09f64:	e1a06003 	mov	r6, r3
21f09f68:	e51b3040 	ldr	r3, [fp, #-64]
21f09f6c:	e1d331b4 	ldrh	r3, [r3, #20]
21f09f70:	e1a00003 	mov	r0, r3
21f09f74:	ebfffb36 	bl	21f08c54 <__fswab16>
21f09f78:	e1a03000 	mov	r3, r0
21f09f7c:	e1a07003 	mov	r7, r3
21f09f80:	e51b3040 	ldr	r3, [fp, #-64]
21f09f84:	e1d331b8 	ldrh	r3, [r3, #24]
21f09f88:	e1a00003 	mov	r0, r3
21f09f8c:	ebfffb30 	bl	21f08c54 <__fswab16>
21f09f90:	e1a03000 	mov	r3, r0
21f09f94:	e2433008 	sub	r3, r3, #8	; 0x8
21f09f98:	e1a00005 	mov	r0, r5
21f09f9c:	e1a01006 	mov	r1, r6
21f09fa0:	e1a02007 	mov	r2, r7
21f09fa4:	e1a0e00f 	mov	lr, pc
21f09fa8:	e1a0f004 	mov	pc, r4
						ntohs(ip->udp_dst),
						ntohs(ip->udp_src),
						ntohs(ip->udp_len) - 8);
		break;
	}
}
21f09fac:	e24bd01c 	sub	sp, fp, #28	; 0x1c
21f09fb0:	e89da8f0 	ldmia	sp, {r4, r5, r6, r7, fp, sp, pc}
21f09fb4:	21f64574 	mvncss	r4, r4, ror r5
21f09fb8:	21f64578 	mvncss	r4, r8, ror r5
21f09fbc:	21f331d2 	ldrcssb	r3, [r3, #18]!
21f09fc0:	21f331d4 	ldrcssb	r3, [r3, #20]!
21f09fc4:	21f2f560 	mvncss	pc, r0, ror #10
21f09fc8:	21f6455c 	mvncss	r4, ip, asr r5
21f09fcc:	21f64554 	mvncss	r4, r4, asr r5
21f09fd0:	21f66424 	mvncss	r6, r4, lsr #8
21f09fd4:	21f6642c 	mvncss	r6, ip, lsr #8
21f09fd8:	21f66428 	mvncss	r6, r8, lsr #8
21f09fdc:	21f66430 	mvncss	r6, r0, lsr r4
21f09fe0:	21f66434 	mvncss	r6, r4, lsr r4
21f09fe4:	21f2f574 	mvncss	pc, r4, ror r5
21f09fe8:	21f64560 	mvncss	r4, r0, ror #10
21f09fec:	21f6453e 	mvncss	r4, lr, lsr r5
21f09ff0:	21f66a60 	mvncss	r6, r0, ror #20
21f09ff4:	21f2f58c 	mvncss	pc, ip, lsl #11
21f09ff8:	21f2f5a0 	mvncss	pc, r0, lsr #11
21f09ffc:	21f2f5b0 	ldrcsh	pc, [r2, #80]!

21f0a000 <NetReadIP>:
 * footprint in our tests.
 */
/* return IP *in network byteorder* */
static inline IPaddr_t NetReadIP(void *from)
{
21f0a000:	e1a0c00d 	mov	ip, sp
21f0a004:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a008:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a00c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0a010:	e50b0014 	str	r0, [fp, #-20]
	IPaddr_t ip;
	memcpy((void*)&ip, from, sizeof(ip));
21f0a014:	e24b3010 	sub	r3, fp, #16	; 0x10
21f0a018:	e1a00003 	mov	r0, r3
21f0a01c:	e51b1014 	ldr	r1, [fp, #-20]
21f0a020:	e3a02004 	mov	r2, #4	; 0x4
21f0a024:	eb006468 	bl	21f231cc <memcpy>
	return ip;
21f0a028:	e51b3010 	ldr	r3, [fp, #-16]
}
21f0a02c:	e1a00003 	mov	r0, r3
21f0a030:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a034:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0a038 <net_check_prereq>:


/**********************************************************************/

static int net_check_prereq (proto_t protocol)
{
21f0a038:	e1a0c00d 	mov	ip, sp
21f0a03c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a040:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a044:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0a048:	e50b0010 	str	r0, [fp, #-16]
	switch (protocol) {
21f0a04c:	e51b3010 	ldr	r3, [fp, #-16]
21f0a050:	e3530009 	cmp	r3, #9	; 0x9
21f0a054:	8a00002c 	bhi	21f0a10c <net_check_prereq+0xd4>
21f0a058:	e3a02001 	mov	r2, #1	; 0x1
21f0a05c:	e51b3010 	ldr	r3, [fp, #-16]
21f0a060:	e1a02312 	mov	r2, r2, lsl r3
21f0a064:	e50b2018 	str	r2, [fp, #-24]
21f0a068:	e51b2018 	ldr	r2, [fp, #-24]
21f0a06c:	e3c230ec 	bic	r3, r2, #236	; 0xec
21f0a070:	e1a03b83 	mov	r3, r3, lsl #23
21f0a074:	e1a03ba3 	mov	r3, r3, lsr #23
21f0a078:	e3530000 	cmp	r3, #0	; 0x0
21f0a07c:	1a000016 	bne	21f0a0dc <net_check_prereq+0xa4>
21f0a080:	e51b2018 	ldr	r2, [fp, #-24]
21f0a084:	e2023fa2 	and	r3, r2, #648	; 0x288
21f0a088:	e3530000 	cmp	r3, #0	; 0x0
21f0a08c:	1a000000 	bne	21f0a094 <net_check_prereq+0x5c>
21f0a090:	ea00001d 	b	21f0a10c <net_check_prereq+0xd4>
		/* Fall through */
#if (CONFIG_COMMANDS & CFG_CMD_PING)
	case PING:
		if (NetPingIP == 0) {
			puts ("*** ERROR: ping address not given\n");
			return (1);
		}
		goto common;
#endif
#if (CONFIG_COMMANDS & CFG_CMD_SNTP)
	case SNTP:
		if (NetNtpServerIP == 0) {
			puts ("*** ERROR: NTP server address not given\n");
			return (1);
		}
		goto common;
#endif
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
	case NFS:
#endif
	case NETCONS:
	case TFTP:
		if (NetServerIP == 0) {
21f0a094:	e59f3088 	ldr	r3, [pc, #136]	; 21f0a124 <.text+0xa124>
21f0a098:	e5933000 	ldr	r3, [r3]
21f0a09c:	e3530000 	cmp	r3, #0	; 0x0
21f0a0a0:	1a000004 	bne	21f0a0b8 <net_check_prereq+0x80>
			puts ("*** ERROR: `serverip' not set\n");
21f0a0a4:	e59f007c 	ldr	r0, [pc, #124]	; 21f0a128 <.text+0xa128>
21f0a0a8:	eb004664 	bl	21f1ba40 <puts>
			return (1);
21f0a0ac:	e3a03001 	mov	r3, #1	; 0x1
21f0a0b0:	e50b3014 	str	r3, [fp, #-20]
21f0a0b4:	ea000016 	b	21f0a114 <net_check_prereq+0xdc>
		}
#if (CONFIG_COMMANDS & (CFG_CMD_PING | CFG_CMD_SNTP))
    common:
#endif

		if (NetOurIP == 0) {
21f0a0b8:	e59f306c 	ldr	r3, [pc, #108]	; 21f0a12c <.text+0xa12c>
21f0a0bc:	e5933000 	ldr	r3, [r3]
21f0a0c0:	e3530000 	cmp	r3, #0	; 0x0
21f0a0c4:	1a000004 	bne	21f0a0dc <net_check_prereq+0xa4>
			puts ("*** ERROR: `ipaddr' not set\n");
21f0a0c8:	e59f0060 	ldr	r0, [pc, #96]	; 21f0a130 <.text+0xa130>
21f0a0cc:	eb00465b 	bl	21f1ba40 <puts>
			return (1);
21f0a0d0:	e3a02001 	mov	r2, #1	; 0x1
21f0a0d4:	e50b2014 	str	r2, [fp, #-20]
21f0a0d8:	ea00000d 	b	21f0a114 <net_check_prereq+0xdc>
		}
		/* Fall through */

	case DHCP:
	case RARP:
	case BOOTP:
	case CDP:
		if (memcmp (NetOurEther, "\0\0\0\0\0\0", 6) == 0) {
21f0a0dc:	e59f0050 	ldr	r0, [pc, #80]	; 21f0a134 <.text+0xa134>
21f0a0e0:	e59f1050 	ldr	r1, [pc, #80]	; 21f0a138 <.text+0xa138>
21f0a0e4:	e3a02006 	mov	r2, #6	; 0x6
21f0a0e8:	eb006495 	bl	21f23344 <memcmp>
21f0a0ec:	e1a03000 	mov	r3, r0
21f0a0f0:	e3530000 	cmp	r3, #0	; 0x0
21f0a0f4:	1a000004 	bne	21f0a10c <net_check_prereq+0xd4>
#ifdef CONFIG_NET_MULTI
			extern int eth_get_dev_index (void);
			int num = eth_get_dev_index ();

			switch (num) {
			case -1:
				puts ("*** ERROR: No ethernet found.\n");
				return (1);
			case 0:
				puts ("*** ERROR: `ethaddr' not set\n");
				break;
			default:
				printf ("*** ERROR: `eth%daddr' not set\n",
					num);
				break;
			}

			NetStartAgain ();
			return (2);
#else
			puts ("*** ERROR: `ethaddr' not set\n");
21f0a0f8:	e59f003c 	ldr	r0, [pc, #60]	; 21f0a13c <.text+0xa13c>
21f0a0fc:	eb00464f 	bl	21f1ba40 <puts>
			return (1);
21f0a100:	e3a03001 	mov	r3, #1	; 0x1
21f0a104:	e50b3014 	str	r3, [fp, #-20]
21f0a108:	ea000001 	b	21f0a114 <net_check_prereq+0xdc>
#endif
		}
		/* Fall through */
	default:
		return (0);
21f0a10c:	e3a02000 	mov	r2, #0	; 0x0
21f0a110:	e50b2014 	str	r2, [fp, #-20]
21f0a114:	e51b3014 	ldr	r3, [fp, #-20]
	}
	return (0);		/* OK */
}
21f0a118:	e1a00003 	mov	r0, r3
21f0a11c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a120:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0a124:	21f64560 	mvncss	r4, r0, ror #10
21f0a128:	21f2f5c8 	mvncss	pc, r8, asr #11
21f0a12c:	21f6455c 	mvncss	r4, ip, asr r5
21f0a130:	21f2f5e8 	mvncss	pc, r8, ror #11
21f0a134:	21f64554 	mvncss	r4, r4, asr r5
21f0a138:	21f2f608 	mvncss	pc, r8, lsl #12
21f0a13c:	21f2f610 	mvncss	pc, r0, lsl r6

21f0a140 <NetCksumOk>:
/**********************************************************************/

int
NetCksumOk(uchar * ptr, int len)
{
21f0a140:	e1a0c00d 	mov	ip, sp
21f0a144:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a148:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a14c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0a150:	e50b0010 	str	r0, [fp, #-16]
21f0a154:	e50b1014 	str	r1, [fp, #-20]
	return !((NetCksum(ptr, len) + 1) & 0xfffe);
21f0a158:	e51b0010 	ldr	r0, [fp, #-16]
21f0a15c:	e51b1014 	ldr	r1, [fp, #-20]
21f0a160:	eb00000a 	bl	21f0a190 <NetCksum>
21f0a164:	e1a03000 	mov	r3, r0
21f0a168:	e2833001 	add	r3, r3, #1	; 0x1
21f0a16c:	e3c33001 	bic	r3, r3, #1	; 0x1
21f0a170:	e1a03803 	mov	r3, r3, lsl #16
21f0a174:	e1a03823 	mov	r3, r3, lsr #16
21f0a178:	e3530000 	cmp	r3, #0	; 0x0
21f0a17c:	13a03000 	movne	r3, #0	; 0x0
21f0a180:	03a03001 	moveq	r3, #1	; 0x1
}
21f0a184:	e1a00003 	mov	r0, r3
21f0a188:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a18c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0a190 <NetCksum>:


unsigned
NetCksum(uchar * ptr, int len)
{
21f0a190:	e1a0c00d 	mov	ip, sp
21f0a194:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a198:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a19c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0a1a0:	e50b0018 	str	r0, [fp, #-24]
21f0a1a4:	e50b101c 	str	r1, [fp, #-28]
	ulong	xsum;
	ushort *p = (ushort *)ptr;
21f0a1a8:	e51b3018 	ldr	r3, [fp, #-24]
21f0a1ac:	e50b3010 	str	r3, [fp, #-16]

	xsum = 0;
21f0a1b0:	e3a03000 	mov	r3, #0	; 0x0
21f0a1b4:	e50b3014 	str	r3, [fp, #-20]
	while (len-- > 0)
21f0a1b8:	ea000008 	b	21f0a1e0 <NetCksum+0x50>
		xsum += *p++;
21f0a1bc:	e51b3010 	ldr	r3, [fp, #-16]
21f0a1c0:	e1d330b0 	ldrh	r3, [r3]
21f0a1c4:	e1a02003 	mov	r2, r3
21f0a1c8:	e51b3014 	ldr	r3, [fp, #-20]
21f0a1cc:	e0833002 	add	r3, r3, r2
21f0a1d0:	e50b3014 	str	r3, [fp, #-20]
21f0a1d4:	e51b3010 	ldr	r3, [fp, #-16]
21f0a1d8:	e2833002 	add	r3, r3, #2	; 0x2
21f0a1dc:	e50b3010 	str	r3, [fp, #-16]
21f0a1e0:	e51b301c 	ldr	r3, [fp, #-28]
21f0a1e4:	e3530000 	cmp	r3, #0	; 0x0
21f0a1e8:	d3a03000 	movle	r3, #0	; 0x0
21f0a1ec:	c3a03001 	movgt	r3, #1	; 0x1
21f0a1f0:	e20320ff 	and	r2, r3, #255	; 0xff
21f0a1f4:	e51b301c 	ldr	r3, [fp, #-28]
21f0a1f8:	e2433001 	sub	r3, r3, #1	; 0x1
21f0a1fc:	e50b301c 	str	r3, [fp, #-28]
21f0a200:	e3520000 	cmp	r2, #0	; 0x0
21f0a204:	1affffec 	bne	21f0a1bc <NetCksum+0x2c>
	xsum = (xsum & 0xffff) + (xsum >> 16);
21f0a208:	e51b3014 	ldr	r3, [fp, #-20]
21f0a20c:	e1a03803 	mov	r3, r3, lsl #16
21f0a210:	e1a03823 	mov	r3, r3, lsr #16
21f0a214:	e51b2014 	ldr	r2, [fp, #-20]
21f0a218:	e1a02822 	mov	r2, r2, lsr #16
21f0a21c:	e0833002 	add	r3, r3, r2
21f0a220:	e50b3014 	str	r3, [fp, #-20]
	xsum = (xsum & 0xffff) + (xsum >> 16);
21f0a224:	e51b3014 	ldr	r3, [fp, #-20]
21f0a228:	e1a03803 	mov	r3, r3, lsl #16
21f0a22c:	e1a03823 	mov	r3, r3, lsr #16
21f0a230:	e51b2014 	ldr	r2, [fp, #-20]
21f0a234:	e1a02822 	mov	r2, r2, lsr #16
21f0a238:	e0833002 	add	r3, r3, r2
21f0a23c:	e50b3014 	str	r3, [fp, #-20]
	return (xsum & 0xffff);
21f0a240:	e51b3014 	ldr	r3, [fp, #-20]
21f0a244:	e1a03803 	mov	r3, r3, lsl #16
21f0a248:	e1a03823 	mov	r3, r3, lsr #16
}
21f0a24c:	e1a00003 	mov	r0, r3
21f0a250:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a254:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0a258 <NetEthHdrSize>:

int
NetEthHdrSize(void)
{
21f0a258:	e1a0c00d 	mov	ip, sp
21f0a25c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a260:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a264:	e24dd008 	sub	sp, sp, #8	; 0x8
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
21f0a268:	e59f306c 	ldr	r3, [pc, #108]	; 21f0a2dc <.text+0xa2dc>
21f0a26c:	e1d330b0 	ldrh	r3, [r3]
21f0a270:	e1a00003 	mov	r0, r3
21f0a274:	ebfffa76 	bl	21f08c54 <__fswab16>
21f0a278:	e1a03000 	mov	r3, r0
21f0a27c:	e14b30be 	strh	r3, [fp, #-14]
	if (myvlanid == (ushort)-1)
21f0a280:	e15b20be 	ldrh	r2, [fp, #-14]
21f0a284:	e3a03cff 	mov	r3, #65280	; 0xff00
21f0a288:	e28330ff 	add	r3, r3, #255	; 0xff
21f0a28c:	e1520003 	cmp	r2, r3
21f0a290:	1a000001 	bne	21f0a29c <NetEthHdrSize+0x44>
		myvlanid = VLAN_NONE;
21f0a294:	e3e03a0f 	mvn	r3, #61440	; 0xf000
21f0a298:	e14b30be 	strh	r3, [fp, #-14]

	return ((myvlanid & VLAN_IDMASK) == VLAN_NONE) ? ETHER_HDR_SIZE : VLAN_ETHER_HDR_SIZE;
21f0a29c:	e15b30be 	ldrh	r3, [fp, #-14]
21f0a2a0:	e1a02a03 	mov	r2, r3, lsl #20
21f0a2a4:	e1a02a22 	mov	r2, r2, lsr #20
21f0a2a8:	e3a03eff 	mov	r3, #4080	; 0xff0
21f0a2ac:	e283300f 	add	r3, r3, #15	; 0xf
21f0a2b0:	e1520003 	cmp	r2, r3
21f0a2b4:	1a000002 	bne	21f0a2c4 <NetEthHdrSize+0x6c>
21f0a2b8:	e3a0300e 	mov	r3, #14	; 0xe
21f0a2bc:	e50b3014 	str	r3, [fp, #-20]
21f0a2c0:	ea000001 	b	21f0a2cc <NetEthHdrSize+0x74>
21f0a2c4:	e3a03012 	mov	r3, #18	; 0x12
21f0a2c8:	e50b3014 	str	r3, [fp, #-20]
21f0a2cc:	e51b3014 	ldr	r3, [fp, #-20]
}
21f0a2d0:	e1a00003 	mov	r0, r3
21f0a2d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a2d8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0a2dc:	21f331d2 	ldrcssb	r3, [r3, #18]!

21f0a2e0 <NetSetEther>:

int
NetSetEther(volatile uchar * xet, uchar * addr, uint prot)
{
21f0a2e0:	e1a0c00d 	mov	ip, sp
21f0a2e4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a2e8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a2ec:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f0a2f0:	e50b001c 	str	r0, [fp, #-28]
21f0a2f4:	e50b1020 	str	r1, [fp, #-32]
21f0a2f8:	e50b2024 	str	r2, [fp, #-36]
	Ethernet_t *et = (Ethernet_t *)xet;
21f0a2fc:	e51b301c 	ldr	r3, [fp, #-28]
21f0a300:	e50b3018 	str	r3, [fp, #-24]
	ushort myvlanid;

	myvlanid = ntohs(NetOurVLAN);
21f0a304:	e59f3124 	ldr	r3, [pc, #292]	; 21f0a430 <.text+0xa430>
21f0a308:	e1d330b0 	ldrh	r3, [r3]
21f0a30c:	e1a00003 	mov	r0, r3
21f0a310:	ebfffa4f 	bl	21f08c54 <__fswab16>
21f0a314:	e1a03000 	mov	r3, r0
21f0a318:	e14b31b2 	strh	r3, [fp, #-18]
	if (myvlanid == (ushort)-1)
21f0a31c:	e15b21b2 	ldrh	r2, [fp, #-18]
21f0a320:	e3a03cff 	mov	r3, #65280	; 0xff00
21f0a324:	e28330ff 	add	r3, r3, #255	; 0xff
21f0a328:	e1520003 	cmp	r2, r3
21f0a32c:	1a000001 	bne	21f0a338 <NetSetEther+0x58>
		myvlanid = VLAN_NONE;
21f0a330:	e3e03a0f 	mvn	r3, #61440	; 0xf000
21f0a334:	e14b31b2 	strh	r3, [fp, #-18]

	memcpy (et->et_dest, addr, 6);
21f0a338:	e51b3018 	ldr	r3, [fp, #-24]
21f0a33c:	e1a00003 	mov	r0, r3
21f0a340:	e51b1020 	ldr	r1, [fp, #-32]
21f0a344:	e3a02006 	mov	r2, #6	; 0x6
21f0a348:	eb00639f 	bl	21f231cc <memcpy>
	memcpy (et->et_src, NetOurEther, 6);
21f0a34c:	e51b3018 	ldr	r3, [fp, #-24]
21f0a350:	e2833006 	add	r3, r3, #6	; 0x6
21f0a354:	e1a00003 	mov	r0, r3
21f0a358:	e59f10d4 	ldr	r1, [pc, #212]	; 21f0a434 <.text+0xa434>
21f0a35c:	e3a02006 	mov	r2, #6	; 0x6
21f0a360:	eb006399 	bl	21f231cc <memcpy>
	if ((myvlanid & VLAN_IDMASK) == VLAN_NONE) {
21f0a364:	e15b31b2 	ldrh	r3, [fp, #-18]
21f0a368:	e1a02a03 	mov	r2, r3, lsl #20
21f0a36c:	e1a02a22 	mov	r2, r2, lsr #20
21f0a370:	e3a03eff 	mov	r3, #4080	; 0xff0
21f0a374:	e283300f 	add	r3, r3, #15	; 0xf
21f0a378:	e1520003 	cmp	r2, r3
21f0a37c:	1a00000b 	bne	21f0a3b0 <NetSetEther+0xd0>
	et->et_protlen = htons(prot);
21f0a380:	e51b3024 	ldr	r3, [fp, #-36]
21f0a384:	e1a03803 	mov	r3, r3, lsl #16
21f0a388:	e1a03823 	mov	r3, r3, lsr #16
21f0a38c:	e1a00003 	mov	r0, r3
21f0a390:	ebfffa2f 	bl	21f08c54 <__fswab16>
21f0a394:	e1a03000 	mov	r3, r0
21f0a398:	e1a02003 	mov	r2, r3
21f0a39c:	e51b3018 	ldr	r3, [fp, #-24]
21f0a3a0:	e1c320bc 	strh	r2, [r3, #12]
		return ETHER_HDR_SIZE;
21f0a3a4:	e3a0300e 	mov	r3, #14	; 0xe
21f0a3a8:	e50b3028 	str	r3, [fp, #-40]
21f0a3ac:	ea00001b 	b	21f0a420 <NetSetEther+0x140>
	} else {
		VLAN_Ethernet_t *vet = (VLAN_Ethernet_t *)xet;
21f0a3b0:	e51b301c 	ldr	r3, [fp, #-28]
21f0a3b4:	e50b3010 	str	r3, [fp, #-16]

		vet->vet_vlan_type = htons(PROT_VLAN);
21f0a3b8:	e3a00c81 	mov	r0, #33024	; 0x8100
21f0a3bc:	ebfffa24 	bl	21f08c54 <__fswab16>
21f0a3c0:	e1a03000 	mov	r3, r0
21f0a3c4:	e1a02003 	mov	r2, r3
21f0a3c8:	e51b3010 	ldr	r3, [fp, #-16]
21f0a3cc:	e1c320bc 	strh	r2, [r3, #12]
		vet->vet_tag = htons((0 << 5) | (myvlanid & VLAN_IDMASK));
21f0a3d0:	e15b31b2 	ldrh	r3, [fp, #-18]
21f0a3d4:	e1a03a03 	mov	r3, r3, lsl #20
21f0a3d8:	e1a03a23 	mov	r3, r3, lsr #20
21f0a3dc:	e1a00003 	mov	r0, r3
21f0a3e0:	ebfffa1b 	bl	21f08c54 <__fswab16>
21f0a3e4:	e1a03000 	mov	r3, r0
21f0a3e8:	e1a02003 	mov	r2, r3
21f0a3ec:	e51b3010 	ldr	r3, [fp, #-16]
21f0a3f0:	e1c320be 	strh	r2, [r3, #14]
		vet->vet_type = htons(prot);
21f0a3f4:	e51b3024 	ldr	r3, [fp, #-36]
21f0a3f8:	e1a03803 	mov	r3, r3, lsl #16
21f0a3fc:	e1a03823 	mov	r3, r3, lsr #16
21f0a400:	e1a00003 	mov	r0, r3
21f0a404:	ebfffa12 	bl	21f08c54 <__fswab16>
21f0a408:	e1a03000 	mov	r3, r0
21f0a40c:	e1a02003 	mov	r2, r3
21f0a410:	e51b3010 	ldr	r3, [fp, #-16]
21f0a414:	e1c321b0 	strh	r2, [r3, #16]
		return VLAN_ETHER_HDR_SIZE;
21f0a418:	e3a03012 	mov	r3, #18	; 0x12
21f0a41c:	e50b3028 	str	r3, [fp, #-40]
21f0a420:	e51b3028 	ldr	r3, [fp, #-40]
	}
}
21f0a424:	e1a00003 	mov	r0, r3
21f0a428:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a42c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0a430:	21f331d2 	ldrcssb	r3, [r3, #18]!
21f0a434:	21f64554 	mvncss	r4, r4, asr r5

21f0a438 <NetSetIP>:

void
NetSetIP(volatile uchar * xip, IPaddr_t dest, int dport, int sport, int len)
{
21f0a438:	e1a0c00d 	mov	ip, sp
21f0a43c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a440:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a444:	e24dd014 	sub	sp, sp, #20	; 0x14
21f0a448:	e50b0014 	str	r0, [fp, #-20]
21f0a44c:	e50b1018 	str	r1, [fp, #-24]
21f0a450:	e50b201c 	str	r2, [fp, #-28]
21f0a454:	e50b3020 	str	r3, [fp, #-32]
	volatile IP_t *ip = (IP_t *)xip;
21f0a458:	e51b3014 	ldr	r3, [fp, #-20]
21f0a45c:	e50b3010 	str	r3, [fp, #-16]

	/*
	 *	If the data is an odd number of bytes, zero the
	 *	byte after the last byte so that the checksum
	 *	will work.
	 */
	if (len & 1)
21f0a460:	e59b3004 	ldr	r3, [fp, #4]
21f0a464:	e2033001 	and	r3, r3, #1	; 0x1
21f0a468:	e20330ff 	and	r3, r3, #255	; 0xff
21f0a46c:	e3530000 	cmp	r3, #0	; 0x0
21f0a470:	0a000005 	beq	21f0a48c <NetSetIP+0x54>
		xip[IP_HDR_SIZE + len] = 0;
21f0a474:	e59b2004 	ldr	r2, [fp, #4]
21f0a478:	e51b3014 	ldr	r3, [fp, #-20]
21f0a47c:	e0823003 	add	r3, r2, r3
21f0a480:	e283201c 	add	r2, r3, #28	; 0x1c
21f0a484:	e3a03000 	mov	r3, #0	; 0x0
21f0a488:	e5c23000 	strb	r3, [r2]

	/*
	 *	Construct an IP and UDP header.
	 *	(need to set no fragment bit - XXX)
	 */
	ip->ip_hl_v  = 0x45;		/* IP_HDR_SIZE / 4 (not including UDP) */
21f0a48c:	e51b2010 	ldr	r2, [fp, #-16]
21f0a490:	e3a03045 	mov	r3, #69	; 0x45
21f0a494:	e5c23000 	strb	r3, [r2]
	ip->ip_tos   = 0;
21f0a498:	e51b2010 	ldr	r2, [fp, #-16]
21f0a49c:	e3a03000 	mov	r3, #0	; 0x0
21f0a4a0:	e5c23001 	strb	r3, [r2, #1]
	ip->ip_len   = htons(IP_HDR_SIZE + len);
21f0a4a4:	e59b3004 	ldr	r3, [fp, #4]
21f0a4a8:	e1a03803 	mov	r3, r3, lsl #16
21f0a4ac:	e1a03823 	mov	r3, r3, lsr #16
21f0a4b0:	e283301c 	add	r3, r3, #28	; 0x1c
21f0a4b4:	e1a03803 	mov	r3, r3, lsl #16
21f0a4b8:	e1a03823 	mov	r3, r3, lsr #16
21f0a4bc:	e1a00003 	mov	r0, r3
21f0a4c0:	ebfff9e3 	bl	21f08c54 <__fswab16>
21f0a4c4:	e1a03000 	mov	r3, r0
21f0a4c8:	e1a02003 	mov	r2, r3
21f0a4cc:	e51b3010 	ldr	r3, [fp, #-16]
21f0a4d0:	e1c320b2 	strh	r2, [r3, #2]
	ip->ip_id    = htons(NetIPID++);
21f0a4d4:	e59f315c 	ldr	r3, [pc, #348]	; 21f0a638 <.text+0xa638>
21f0a4d8:	e5932000 	ldr	r2, [r3]
21f0a4dc:	e1a03802 	mov	r3, r2, lsl #16
21f0a4e0:	e1a03823 	mov	r3, r3, lsr #16
21f0a4e4:	e1a01003 	mov	r1, r3
21f0a4e8:	e2822001 	add	r2, r2, #1	; 0x1
21f0a4ec:	e59f3144 	ldr	r3, [pc, #324]	; 21f0a638 <.text+0xa638>
21f0a4f0:	e5832000 	str	r2, [r3]
21f0a4f4:	e1a00001 	mov	r0, r1
21f0a4f8:	ebfff9d5 	bl	21f08c54 <__fswab16>
21f0a4fc:	e1a03000 	mov	r3, r0
21f0a500:	e1a02003 	mov	r2, r3
21f0a504:	e51b3010 	ldr	r3, [fp, #-16]
21f0a508:	e1c320b4 	strh	r2, [r3, #4]
	ip->ip_off   = htons(0x4000);	/* No fragmentation */
21f0a50c:	e3a00901 	mov	r0, #16384	; 0x4000
21f0a510:	ebfff9cf 	bl	21f08c54 <__fswab16>
21f0a514:	e1a03000 	mov	r3, r0
21f0a518:	e1a02003 	mov	r2, r3
21f0a51c:	e51b3010 	ldr	r3, [fp, #-16]
21f0a520:	e1c320b6 	strh	r2, [r3, #6]
	ip->ip_ttl   = 255;
21f0a524:	e51b2010 	ldr	r2, [fp, #-16]
21f0a528:	e3e03000 	mvn	r3, #0	; 0x0
21f0a52c:	e5c23008 	strb	r3, [r2, #8]
	ip->ip_p     = 17;		/* UDP */
21f0a530:	e51b2010 	ldr	r2, [fp, #-16]
21f0a534:	e3a03011 	mov	r3, #17	; 0x11
21f0a538:	e5c23009 	strb	r3, [r2, #9]
	ip->ip_sum   = 0;
21f0a53c:	e51b2010 	ldr	r2, [fp, #-16]
21f0a540:	e3a03000 	mov	r3, #0	; 0x0
21f0a544:	e1c230ba 	strh	r3, [r2, #10]
	NetCopyIP((void*)&ip->ip_src, &NetOurIP); /* already in network byte order */
21f0a548:	e51b3010 	ldr	r3, [fp, #-16]
21f0a54c:	e283300c 	add	r3, r3, #12	; 0xc
21f0a550:	e1a00003 	mov	r0, r3
21f0a554:	e59f10e0 	ldr	r1, [pc, #224]	; 21f0a63c <.text+0xa63c>
21f0a558:	ebfffb73 	bl	21f0932c <NetCopyIP>
	NetCopyIP((void*)&ip->ip_dst, &dest);	   /* - "" - */
21f0a55c:	e51b3010 	ldr	r3, [fp, #-16]
21f0a560:	e2833010 	add	r3, r3, #16	; 0x10
21f0a564:	e24b2018 	sub	r2, fp, #24	; 0x18
21f0a568:	e1a00003 	mov	r0, r3
21f0a56c:	e1a01002 	mov	r1, r2
21f0a570:	ebfffb6d 	bl	21f0932c <NetCopyIP>
	ip->udp_src  = htons(sport);
21f0a574:	e51b3020 	ldr	r3, [fp, #-32]
21f0a578:	e1a03803 	mov	r3, r3, lsl #16
21f0a57c:	e1a03823 	mov	r3, r3, lsr #16
21f0a580:	e1a00003 	mov	r0, r3
21f0a584:	ebfff9b2 	bl	21f08c54 <__fswab16>
21f0a588:	e1a03000 	mov	r3, r0
21f0a58c:	e1a02003 	mov	r2, r3
21f0a590:	e51b3010 	ldr	r3, [fp, #-16]
21f0a594:	e1c321b4 	strh	r2, [r3, #20]
	ip->udp_dst  = htons(dport);
21f0a598:	e51b301c 	ldr	r3, [fp, #-28]
21f0a59c:	e1a03803 	mov	r3, r3, lsl #16
21f0a5a0:	e1a03823 	mov	r3, r3, lsr #16
21f0a5a4:	e1a00003 	mov	r0, r3
21f0a5a8:	ebfff9a9 	bl	21f08c54 <__fswab16>
21f0a5ac:	e1a03000 	mov	r3, r0
21f0a5b0:	e1a02003 	mov	r2, r3
21f0a5b4:	e51b3010 	ldr	r3, [fp, #-16]
21f0a5b8:	e1c321b6 	strh	r2, [r3, #22]
	ip->udp_len  = htons(8 + len);
21f0a5bc:	e59b3004 	ldr	r3, [fp, #4]
21f0a5c0:	e1a03803 	mov	r3, r3, lsl #16
21f0a5c4:	e1a03823 	mov	r3, r3, lsr #16
21f0a5c8:	e2833008 	add	r3, r3, #8	; 0x8
21f0a5cc:	e1a03803 	mov	r3, r3, lsl #16
21f0a5d0:	e1a03823 	mov	r3, r3, lsr #16
21f0a5d4:	e1a03803 	mov	r3, r3, lsl #16
21f0a5d8:	e1a03823 	mov	r3, r3, lsr #16
21f0a5dc:	e1a00003 	mov	r0, r3
21f0a5e0:	ebfff99b 	bl	21f08c54 <__fswab16>
21f0a5e4:	e1a03000 	mov	r3, r0
21f0a5e8:	e1a02003 	mov	r2, r3
21f0a5ec:	e51b3010 	ldr	r3, [fp, #-16]
21f0a5f0:	e1c321b8 	strh	r2, [r3, #24]
	ip->udp_xsum = 0;
21f0a5f4:	e51b2010 	ldr	r2, [fp, #-16]
21f0a5f8:	e3a03000 	mov	r3, #0	; 0x0
21f0a5fc:	e1c231ba 	strh	r3, [r2, #26]
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
21f0a600:	e51b3010 	ldr	r3, [fp, #-16]
21f0a604:	e1a00003 	mov	r0, r3
21f0a608:	e3a0100a 	mov	r1, #10	; 0xa
21f0a60c:	ebfffedf 	bl	21f0a190 <NetCksum>
21f0a610:	e1a03000 	mov	r3, r0
21f0a614:	e1a03803 	mov	r3, r3, lsl #16
21f0a618:	e1a03823 	mov	r3, r3, lsr #16
21f0a61c:	e1e03003 	mvn	r3, r3
21f0a620:	e1a03803 	mov	r3, r3, lsl #16
21f0a624:	e1a02823 	mov	r2, r3, lsr #16
21f0a628:	e51b3010 	ldr	r3, [fp, #-16]
21f0a62c:	e1c320ba 	strh	r2, [r3, #10]
}
21f0a630:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a634:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0a638:	21f6457c 	mvncss	r4, ip, ror r5
21f0a63c:	21f6455c 	mvncss	r4, ip, asr r5

21f0a640 <copy_filename>:

void copy_filename (char *dst, char *src, int size)
{
21f0a640:	e1a0c00d 	mov	ip, sp
21f0a644:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a648:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a64c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0a650:	e50b0010 	str	r0, [fp, #-16]
21f0a654:	e50b1014 	str	r1, [fp, #-20]
21f0a658:	e50b2018 	str	r2, [fp, #-24]
	if (*src && (*src == '"')) {
21f0a65c:	e51b3014 	ldr	r3, [fp, #-20]
21f0a660:	e5d33000 	ldrb	r3, [r3]
21f0a664:	e3530000 	cmp	r3, #0	; 0x0
21f0a668:	0a000014 	beq	21f0a6c0 <copy_filename+0x80>
21f0a66c:	e51b3014 	ldr	r3, [fp, #-20]
21f0a670:	e5d33000 	ldrb	r3, [r3]
21f0a674:	e3530022 	cmp	r3, #34	; 0x22
21f0a678:	1a000010 	bne	21f0a6c0 <copy_filename+0x80>
		++src;
21f0a67c:	e51b3014 	ldr	r3, [fp, #-20]
21f0a680:	e2833001 	add	r3, r3, #1	; 0x1
21f0a684:	e50b3014 	str	r3, [fp, #-20]
		--size;
21f0a688:	e51b3018 	ldr	r3, [fp, #-24]
21f0a68c:	e2433001 	sub	r3, r3, #1	; 0x1
21f0a690:	e50b3018 	str	r3, [fp, #-24]
21f0a694:	ea000009 	b	21f0a6c0 <copy_filename+0x80>
	}

	while ((--size > 0) && *src && (*src != '"')) {
		*dst++ = *src++;
21f0a698:	e51b3014 	ldr	r3, [fp, #-20]
21f0a69c:	e5d33000 	ldrb	r3, [r3]
21f0a6a0:	e51b2010 	ldr	r2, [fp, #-16]
21f0a6a4:	e5c23000 	strb	r3, [r2]
21f0a6a8:	e51b3010 	ldr	r3, [fp, #-16]
21f0a6ac:	e2833001 	add	r3, r3, #1	; 0x1
21f0a6b0:	e50b3010 	str	r3, [fp, #-16]
21f0a6b4:	e51b3014 	ldr	r3, [fp, #-20]
21f0a6b8:	e2833001 	add	r3, r3, #1	; 0x1
21f0a6bc:	e50b3014 	str	r3, [fp, #-20]
21f0a6c0:	e51b3018 	ldr	r3, [fp, #-24]
21f0a6c4:	e2433001 	sub	r3, r3, #1	; 0x1
21f0a6c8:	e50b3018 	str	r3, [fp, #-24]
21f0a6cc:	e51b3018 	ldr	r3, [fp, #-24]
21f0a6d0:	e3530000 	cmp	r3, #0	; 0x0
21f0a6d4:	da000007 	ble	21f0a6f8 <copy_filename+0xb8>
21f0a6d8:	e51b3014 	ldr	r3, [fp, #-20]
21f0a6dc:	e5d33000 	ldrb	r3, [r3]
21f0a6e0:	e3530000 	cmp	r3, #0	; 0x0
21f0a6e4:	0a000003 	beq	21f0a6f8 <copy_filename+0xb8>
21f0a6e8:	e51b3014 	ldr	r3, [fp, #-20]
21f0a6ec:	e5d33000 	ldrb	r3, [r3]
21f0a6f0:	e3530022 	cmp	r3, #34	; 0x22
21f0a6f4:	1affffe7 	bne	21f0a698 <copy_filename+0x58>
	}
	*dst = '\0';
21f0a6f8:	e51b3010 	ldr	r3, [fp, #-16]
21f0a6fc:	e3a02000 	mov	r2, #0	; 0x0
21f0a700:	e5c32000 	strb	r2, [r3]
}
21f0a704:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a708:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0a70c <ip_to_string>:

#endif /* CFG_CMD_NET */

void ip_to_string (IPaddr_t x, char *s)
{
21f0a70c:	e1a0c00d 	mov	ip, sp
21f0a710:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a714:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a718:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0a71c:	e50b0010 	str	r0, [fp, #-16]
21f0a720:	e50b1014 	str	r1, [fp, #-20]
	x = ntohl (x);
21f0a724:	e51b0010 	ldr	r0, [fp, #-16]
21f0a728:	eb000016 	bl	21f0a788 <__fswab32>
21f0a72c:	e1a03000 	mov	r3, r0
21f0a730:	e50b3010 	str	r3, [fp, #-16]
	sprintf (s, "%d.%d.%d.%d",
21f0a734:	e51b3010 	ldr	r3, [fp, #-16]
21f0a738:	e1a03c23 	mov	r3, r3, lsr #24
21f0a73c:	e203c0ff 	and	ip, r3, #255	; 0xff
21f0a740:	e51b3010 	ldr	r3, [fp, #-16]
21f0a744:	e1a03823 	mov	r3, r3, lsr #16
21f0a748:	e203e0ff 	and	lr, r3, #255	; 0xff
21f0a74c:	e51b3010 	ldr	r3, [fp, #-16]
21f0a750:	e1a03423 	mov	r3, r3, lsr #8
21f0a754:	e20320ff 	and	r2, r3, #255	; 0xff
21f0a758:	e51b3010 	ldr	r3, [fp, #-16]
21f0a75c:	e20330ff 	and	r3, r3, #255	; 0xff
21f0a760:	e58d2000 	str	r2, [sp]
21f0a764:	e58d3004 	str	r3, [sp, #4]
21f0a768:	e51b0014 	ldr	r0, [fp, #-20]
21f0a76c:	e59f1010 	ldr	r1, [pc, #16]	; 21f0a784 <.text+0xa784>
21f0a770:	e1a0200c 	mov	r2, ip
21f0a774:	e1a0300e 	mov	r3, lr
21f0a778:	eb0067d2 	bl	21f246c8 <sprintf>
		 (int) ((x >> 24) & 0xff),
		 (int) ((x >> 16) & 0xff),
		 (int) ((x >> 8) & 0xff), (int) ((x >> 0) & 0xff)
	);
}
21f0a77c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a780:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0a784:	21f2f630 	mvncss	pc, r0, lsr r6

21f0a788 <__fswab32>:
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
21f0a788:	e1a0c00d 	mov	ip, sp
21f0a78c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a790:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a794:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0a798:	e50b0010 	str	r0, [fp, #-16]
	return __arch__swab32(x);
21f0a79c:	e51b3010 	ldr	r3, [fp, #-16]
21f0a7a0:	e20330ff 	and	r3, r3, #255	; 0xff
21f0a7a4:	e1a02c03 	mov	r2, r3, lsl #24
21f0a7a8:	e51b3010 	ldr	r3, [fp, #-16]
21f0a7ac:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f0a7b0:	e1a03403 	mov	r3, r3, lsl #8
21f0a7b4:	e1822003 	orr	r2, r2, r3
21f0a7b8:	e51b3010 	ldr	r3, [fp, #-16]
21f0a7bc:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f0a7c0:	e1a03423 	mov	r3, r3, lsr #8
21f0a7c4:	e1822003 	orr	r2, r2, r3
21f0a7c8:	e51b3010 	ldr	r3, [fp, #-16]
21f0a7cc:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
21f0a7d0:	e1a03c23 	mov	r3, r3, lsr #24
21f0a7d4:	e1823003 	orr	r3, r2, r3
}
21f0a7d8:	e1a00003 	mov	r0, r3
21f0a7dc:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0a7e0 <string_to_ip>:

IPaddr_t string_to_ip(char *s)
{
21f0a7e0:	e1a0c00d 	mov	ip, sp
21f0a7e4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a7e8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a7ec:	e24dd020 	sub	sp, sp, #32	; 0x20
21f0a7f0:	e50b0020 	str	r0, [fp, #-32]
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
21f0a7f4:	e51b3020 	ldr	r3, [fp, #-32]
21f0a7f8:	e3530000 	cmp	r3, #0	; 0x0
21f0a7fc:	1a000002 	bne	21f0a80c <string_to_ip+0x2c>
		return(0);
21f0a800:	e3a03000 	mov	r3, #0	; 0x0
21f0a804:	e50b302c 	str	r3, [fp, #-44]
21f0a808:	ea000034 	b	21f0a8e0 <string_to_ip+0x100>

	for (addr=0, i=0; i<4; ++i) {
21f0a80c:	e3a03000 	mov	r3, #0	; 0x0
21f0a810:	e50b3018 	str	r3, [fp, #-24]
21f0a814:	e3a03000 	mov	r3, #0	; 0x0
21f0a818:	e50b3014 	str	r3, [fp, #-20]
21f0a81c:	ea000028 	b	21f0a8c4 <string_to_ip+0xe4>
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
21f0a820:	e51b3020 	ldr	r3, [fp, #-32]
21f0a824:	e3530000 	cmp	r3, #0	; 0x0
21f0a828:	0a000007 	beq	21f0a84c <string_to_ip+0x6c>
21f0a82c:	e24b301c 	sub	r3, fp, #28	; 0x1c
21f0a830:	e51b0020 	ldr	r0, [fp, #-32]
21f0a834:	e1a01003 	mov	r1, r3
21f0a838:	e3a0200a 	mov	r2, #10	; 0xa
21f0a83c:	eb006361 	bl	21f235c8 <simple_strtoul>
21f0a840:	e1a03000 	mov	r3, r0
21f0a844:	e50b3028 	str	r3, [fp, #-40]
21f0a848:	ea000001 	b	21f0a854 <string_to_ip+0x74>
21f0a84c:	e3a03000 	mov	r3, #0	; 0x0
21f0a850:	e50b3028 	str	r3, [fp, #-40]
21f0a854:	e51b3028 	ldr	r3, [fp, #-40]
21f0a858:	e50b3010 	str	r3, [fp, #-16]
		addr <<= 8;
21f0a85c:	e51b3018 	ldr	r3, [fp, #-24]
21f0a860:	e1a03403 	mov	r3, r3, lsl #8
21f0a864:	e50b3018 	str	r3, [fp, #-24]
		addr |= (val & 0xFF);
21f0a868:	e51b3010 	ldr	r3, [fp, #-16]
21f0a86c:	e20320ff 	and	r2, r3, #255	; 0xff
21f0a870:	e51b3018 	ldr	r3, [fp, #-24]
21f0a874:	e1833002 	orr	r3, r3, r2
21f0a878:	e50b3018 	str	r3, [fp, #-24]
		if (s) {
21f0a87c:	e51b3020 	ldr	r3, [fp, #-32]
21f0a880:	e3530000 	cmp	r3, #0	; 0x0
21f0a884:	0a00000b 	beq	21f0a8b8 <string_to_ip+0xd8>
			s = (*e) ? e+1 : e;
21f0a888:	e51b301c 	ldr	r3, [fp, #-28]
21f0a88c:	e5d33000 	ldrb	r3, [r3]
21f0a890:	e3530000 	cmp	r3, #0	; 0x0
21f0a894:	0a000003 	beq	21f0a8a8 <string_to_ip+0xc8>
21f0a898:	e51b301c 	ldr	r3, [fp, #-28]
21f0a89c:	e2833001 	add	r3, r3, #1	; 0x1
21f0a8a0:	e50b3024 	str	r3, [fp, #-36]
21f0a8a4:	ea000001 	b	21f0a8b0 <string_to_ip+0xd0>
21f0a8a8:	e51b301c 	ldr	r3, [fp, #-28]
21f0a8ac:	e50b3024 	str	r3, [fp, #-36]
21f0a8b0:	e51b3024 	ldr	r3, [fp, #-36]
21f0a8b4:	e50b3020 	str	r3, [fp, #-32]
21f0a8b8:	e51b3014 	ldr	r3, [fp, #-20]
21f0a8bc:	e2833001 	add	r3, r3, #1	; 0x1
21f0a8c0:	e50b3014 	str	r3, [fp, #-20]
21f0a8c4:	e51b3014 	ldr	r3, [fp, #-20]
21f0a8c8:	e3530003 	cmp	r3, #3	; 0x3
21f0a8cc:	daffffd3 	ble	21f0a820 <string_to_ip+0x40>
		}
	}

	return (htonl(addr));
21f0a8d0:	e51b0018 	ldr	r0, [fp, #-24]
21f0a8d4:	ebffffab 	bl	21f0a788 <__fswab32>
21f0a8d8:	e1a03000 	mov	r3, r0
21f0a8dc:	e50b302c 	str	r3, [fp, #-44]
21f0a8e0:	e51b302c 	ldr	r3, [fp, #-44]
}
21f0a8e4:	e1a00003 	mov	r0, r3
21f0a8e8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a8ec:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0a8f0 <VLAN_to_string>:

void VLAN_to_string(ushort x, char *s)
{
21f0a8f0:	e1a0c00d 	mov	ip, sp
21f0a8f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a8f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a8fc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0a900:	e1a03000 	mov	r3, r0
21f0a904:	e50b1014 	str	r1, [fp, #-20]
21f0a908:	e14b31b0 	strh	r3, [fp, #-16]
	x = ntohs(x);
21f0a90c:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0a910:	e1a00003 	mov	r0, r3
21f0a914:	ebfff8ce 	bl	21f08c54 <__fswab16>
21f0a918:	e1a03000 	mov	r3, r0
21f0a91c:	e14b31b0 	strh	r3, [fp, #-16]

	if (x == (ushort)-1)
21f0a920:	e15b21b0 	ldrh	r2, [fp, #-16]
21f0a924:	e3a03cff 	mov	r3, #65280	; 0xff00
21f0a928:	e28330ff 	add	r3, r3, #255	; 0xff
21f0a92c:	e1520003 	cmp	r2, r3
21f0a930:	1a000001 	bne	21f0a93c <VLAN_to_string+0x4c>
		x = VLAN_NONE;
21f0a934:	e3e03a0f 	mvn	r3, #61440	; 0xf000
21f0a938:	e14b31b0 	strh	r3, [fp, #-16]

	if (x == VLAN_NONE)
21f0a93c:	e15b21b0 	ldrh	r2, [fp, #-16]
21f0a940:	e3a03eff 	mov	r3, #4080	; 0xff0
21f0a944:	e283300f 	add	r3, r3, #15	; 0xf
21f0a948:	e1520003 	cmp	r2, r3
21f0a94c:	1a000003 	bne	21f0a960 <VLAN_to_string+0x70>
		strcpy(s, "none");
21f0a950:	e51b0014 	ldr	r0, [fp, #-20]
21f0a954:	e59f1028 	ldr	r1, [pc, #40]	; 21f0a984 <.text+0xa984>
21f0a958:	eb005f5d 	bl	21f226d4 <strcpy>
21f0a95c:	ea000006 	b	21f0a97c <VLAN_to_string+0x8c>
	else
		sprintf(s, "%d", x & VLAN_IDMASK);
21f0a960:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0a964:	e1a03a03 	mov	r3, r3, lsl #20
21f0a968:	e1a03a23 	mov	r3, r3, lsr #20
21f0a96c:	e51b0014 	ldr	r0, [fp, #-20]
21f0a970:	e59f1010 	ldr	r1, [pc, #16]	; 21f0a988 <.text+0xa988>
21f0a974:	e1a02003 	mov	r2, r3
21f0a978:	eb006752 	bl	21f246c8 <sprintf>
}
21f0a97c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0a980:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0a984:	21f2f63c 	mvncss	pc, ip, lsr r6
21f0a988:	21f2f644 	mvncss	pc, r4, asr #12

21f0a98c <string_to_VLAN>:

ushort string_to_VLAN(char *s)
{
21f0a98c:	e1a0c00d 	mov	ip, sp
21f0a990:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0a994:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0a998:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0a99c:	e50b0014 	str	r0, [fp, #-20]
	ushort id;

	if (s == NULL)
21f0a9a0:	e51b3014 	ldr	r3, [fp, #-20]
21f0a9a4:	e3530000 	cmp	r3, #0	; 0x0
21f0a9a8:	1a000005 	bne	21f0a9c4 <string_to_VLAN+0x38>
		return htons(VLAN_NONE);
21f0a9ac:	e3a00eff 	mov	r0, #4080	; 0xff0
21f0a9b0:	e280000f 	add	r0, r0, #15	; 0xf
21f0a9b4:	ebfff8a6 	bl	21f08c54 <__fswab16>
21f0a9b8:	e1a03000 	mov	r3, r0
21f0a9bc:	e50b3018 	str	r3, [fp, #-24]
21f0a9c0:	ea000015 	b	21f0aa1c <string_to_VLAN+0x90>

	if (*s < '0' || *s > '9')
21f0a9c4:	e51b3014 	ldr	r3, [fp, #-20]
21f0a9c8:	e5d33000 	ldrb	r3, [r3]
21f0a9cc:	e353002f 	cmp	r3, #47	; 0x2f
21f0a9d0:	9a000003 	bls	21f0a9e4 <string_to_VLAN+0x58>
21f0a9d4:	e51b3014 	ldr	r3, [fp, #-20]
21f0a9d8:	e5d33000 	ldrb	r3, [r3]
21f0a9dc:	e3530039 	cmp	r3, #57	; 0x39
21f0a9e0:	9a000002 	bls	21f0a9f0 <string_to_VLAN+0x64>
		id = VLAN_NONE;
21f0a9e4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
21f0a9e8:	e14b30be 	strh	r3, [fp, #-14]
21f0a9ec:	ea000005 	b	21f0aa08 <string_to_VLAN+0x7c>
	else
		id = (ushort)simple_strtoul(s, NULL, 10);
21f0a9f0:	e51b0014 	ldr	r0, [fp, #-20]
21f0a9f4:	e3a01000 	mov	r1, #0	; 0x0
21f0a9f8:	e3a0200a 	mov	r2, #10	; 0xa
21f0a9fc:	eb0062f1 	bl	21f235c8 <simple_strtoul>
21f0aa00:	e1a03000 	mov	r3, r0
21f0aa04:	e14b30be 	strh	r3, [fp, #-14]

	return htons(id);
21f0aa08:	e15b30be 	ldrh	r3, [fp, #-14]
21f0aa0c:	e1a00003 	mov	r0, r3
21f0aa10:	ebfff88f 	bl	21f08c54 <__fswab16>
21f0aa14:	e1a03000 	mov	r3, r0
21f0aa18:	e50b3018 	str	r3, [fp, #-24]
21f0aa1c:	e51b3018 	ldr	r3, [fp, #-24]
}
21f0aa20:	e1a00003 	mov	r0, r3
21f0aa24:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0aa28:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0aa2c <print_IPaddr>:

void print_IPaddr (IPaddr_t x)
{
21f0aa2c:	e1a0c00d 	mov	ip, sp
21f0aa30:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0aa34:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0aa38:	e24dd014 	sub	sp, sp, #20	; 0x14
21f0aa3c:	e50b0020 	str	r0, [fp, #-32]
	char tmp[16];

	ip_to_string (x, tmp);
21f0aa40:	e24b301c 	sub	r3, fp, #28	; 0x1c
21f0aa44:	e51b0020 	ldr	r0, [fp, #-32]
21f0aa48:	e1a01003 	mov	r1, r3
21f0aa4c:	ebffff2e 	bl	21f0a70c <ip_to_string>

	puts (tmp);
21f0aa50:	e24b301c 	sub	r3, fp, #28	; 0x1c
21f0aa54:	e1a00003 	mov	r0, r3
21f0aa58:	eb0043f8 	bl	21f1ba40 <puts>
}
21f0aa5c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0aa60:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0aa64 <getenv_IPaddr>:

IPaddr_t getenv_IPaddr (char *var)
{
21f0aa64:	e1a0c00d 	mov	ip, sp
21f0aa68:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0aa6c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0aa70:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0aa74:	e50b0010 	str	r0, [fp, #-16]
	return (string_to_ip(getenv(var)));
21f0aa78:	e51b0010 	ldr	r0, [fp, #-16]
21f0aa7c:	eb004065 	bl	21f1ac18 <getenv>
21f0aa80:	e1a03000 	mov	r3, r0
21f0aa84:	e1a00003 	mov	r0, r3
21f0aa88:	ebffff54 	bl	21f0a7e0 <string_to_ip>
21f0aa8c:	e1a03000 	mov	r3, r0
}
21f0aa90:	e1a00003 	mov	r0, r3
21f0aa94:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0aa98 <getenv_VLAN>:

ushort getenv_VLAN(char *var)
{
21f0aa98:	e1a0c00d 	mov	ip, sp
21f0aa9c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0aaa0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0aaa4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0aaa8:	e50b0010 	str	r0, [fp, #-16]
	return (string_to_VLAN(getenv(var)));
21f0aaac:	e51b0010 	ldr	r0, [fp, #-16]
21f0aab0:	eb004058 	bl	21f1ac18 <getenv>
21f0aab4:	e1a03000 	mov	r3, r0
21f0aab8:	e1a00003 	mov	r0, r3
21f0aabc:	ebffffb2 	bl	21f0a98c <string_to_VLAN>
21f0aac0:	e1a03000 	mov	r3, r0
}
21f0aac4:	e1a00003 	mov	r0, r3
21f0aac8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0aacc <TftpSend>:
/**********************************************************************/

static void
TftpSend (void)
{
21f0aacc:	e1a0c00d 	mov	ip, sp
21f0aad0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0aad4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0aad8:	e24dd014 	sub	sp, sp, #20	; 0x14
	volatile uchar *	pkt;
	volatile uchar *	xp;
	int			len = 0;
21f0aadc:	e3a03000 	mov	r3, #0	; 0x0
21f0aae0:	e50b3014 	str	r3, [fp, #-20]
	volatile ushort *s;

	/*
	 *	We will always be sending some sort of packet, so
	 *	cobble together the packet headers now.
	 */
	pkt = NetTxPacket + NetEthHdrSize() + IP_HDR_SIZE;
21f0aae4:	ebfffddb 	bl	21f0a258 <NetEthHdrSize>
21f0aae8:	e1a03000 	mov	r3, r0
21f0aaec:	e1a02003 	mov	r2, r3
21f0aaf0:	e59f3314 	ldr	r3, [pc, #788]	; 21f0ae0c <.text+0xae0c>
21f0aaf4:	e5933000 	ldr	r3, [r3]
21f0aaf8:	e0823003 	add	r3, r2, r3
21f0aafc:	e283301c 	add	r3, r3, #28	; 0x1c
21f0ab00:	e50b301c 	str	r3, [fp, #-28]

	switch (TftpState) {
21f0ab04:	e59f3304 	ldr	r3, [pc, #772]	; 21f0ae10 <.text+0xae10>
21f0ab08:	e5933000 	ldr	r3, [r3]
21f0ab0c:	e2433001 	sub	r3, r3, #1	; 0x1
21f0ab10:	e3530004 	cmp	r3, #4	; 0x4
21f0ab14:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0ab18:	ea0000ac 	b	21f0add0 <.text+0xadd0>
21f0ab1c:	21f0ab30 	mvncss	sl, r0, lsr fp
21f0ab20:	21f0ac30 	mvncss	sl, r0, lsr ip
21f0ab24:	21f0acb4 	ldrcsh	sl, [r0, #196]!
21f0ab28:	21f0ad44 	mvncss	sl, r4, asr #26
21f0ab2c:	21f0ac30 	mvncss	sl, r0, lsr ip

	case STATE_RRQ:
		xp = pkt;
21f0ab30:	e51b301c 	ldr	r3, [fp, #-28]
21f0ab34:	e50b3018 	str	r3, [fp, #-24]
		s = (ushort *)pkt;
21f0ab38:	e51b301c 	ldr	r3, [fp, #-28]
21f0ab3c:	e50b3010 	str	r3, [fp, #-16]
		*s++ = htons(TFTP_RRQ);
21f0ab40:	e3a00001 	mov	r0, #1	; 0x1
21f0ab44:	eb0000bd 	bl	21f0ae40 <__fswab16>
21f0ab48:	e1a03000 	mov	r3, r0
21f0ab4c:	e1a02003 	mov	r2, r3
21f0ab50:	e51b3010 	ldr	r3, [fp, #-16]
21f0ab54:	e1c320b0 	strh	r2, [r3]
21f0ab58:	e51b3010 	ldr	r3, [fp, #-16]
21f0ab5c:	e2833002 	add	r3, r3, #2	; 0x2
21f0ab60:	e50b3010 	str	r3, [fp, #-16]
		pkt = (uchar *)s;
21f0ab64:	e51b3010 	ldr	r3, [fp, #-16]
21f0ab68:	e50b301c 	str	r3, [fp, #-28]
		strcpy ((char *)pkt, tftp_filename);
21f0ab6c:	e51b201c 	ldr	r2, [fp, #-28]
21f0ab70:	e59f329c 	ldr	r3, [pc, #668]	; 21f0ae14 <.text+0xae14>
21f0ab74:	e5933000 	ldr	r3, [r3]
21f0ab78:	e1a00002 	mov	r0, r2
21f0ab7c:	e1a01003 	mov	r1, r3
21f0ab80:	eb005ed3 	bl	21f226d4 <strcpy>
		pkt += strlen(tftp_filename) + 1;
21f0ab84:	e59f3288 	ldr	r3, [pc, #648]	; 21f0ae14 <.text+0xae14>
21f0ab88:	e5933000 	ldr	r3, [r3]
21f0ab8c:	e1a00003 	mov	r0, r3
21f0ab90:	eb00600b 	bl	21f22bc4 <strlen>
21f0ab94:	e1a03000 	mov	r3, r0
21f0ab98:	e1a02003 	mov	r2, r3
21f0ab9c:	e51b301c 	ldr	r3, [fp, #-28]
21f0aba0:	e0823003 	add	r3, r2, r3
21f0aba4:	e2833001 	add	r3, r3, #1	; 0x1
21f0aba8:	e50b301c 	str	r3, [fp, #-28]
		strcpy ((char *)pkt, "octet");
21f0abac:	e51b301c 	ldr	r3, [fp, #-28]
21f0abb0:	e1a00003 	mov	r0, r3
21f0abb4:	e59f125c 	ldr	r1, [pc, #604]	; 21f0ae18 <.text+0xae18>
21f0abb8:	eb005ec5 	bl	21f226d4 <strcpy>
		pkt += 5 /*strlen("octet")*/ + 1;
21f0abbc:	e51b301c 	ldr	r3, [fp, #-28]
21f0abc0:	e2833006 	add	r3, r3, #6	; 0x6
21f0abc4:	e50b301c 	str	r3, [fp, #-28]
		strcpy ((char *)pkt, "timeout");
21f0abc8:	e51b301c 	ldr	r3, [fp, #-28]
21f0abcc:	e1a00003 	mov	r0, r3
21f0abd0:	e59f1244 	ldr	r1, [pc, #580]	; 21f0ae1c <.text+0xae1c>
21f0abd4:	eb005ebe 	bl	21f226d4 <strcpy>
		pkt += 7 /*strlen("timeout")*/ + 1;
21f0abd8:	e51b301c 	ldr	r3, [fp, #-28]
21f0abdc:	e2833008 	add	r3, r3, #8	; 0x8
21f0abe0:	e50b301c 	str	r3, [fp, #-28]
		sprintf((char *)pkt, "%d", TIMEOUT);
21f0abe4:	e51b301c 	ldr	r3, [fp, #-28]
21f0abe8:	e1a00003 	mov	r0, r3
21f0abec:	e59f122c 	ldr	r1, [pc, #556]	; 21f0ae20 <.text+0xae20>
21f0abf0:	e3a02005 	mov	r2, #5	; 0x5
21f0abf4:	eb0066b3 	bl	21f246c8 <sprintf>
#ifdef ET_DEBUG
		printf("send option \"timeout %s\"\n", (char *)pkt);
#endif
		pkt += strlen((char *)pkt) + 1;
21f0abf8:	e51b301c 	ldr	r3, [fp, #-28]
21f0abfc:	e1a00003 	mov	r0, r3
21f0ac00:	eb005fef 	bl	21f22bc4 <strlen>
21f0ac04:	e1a03000 	mov	r3, r0
21f0ac08:	e1a02003 	mov	r2, r3
21f0ac0c:	e51b301c 	ldr	r3, [fp, #-28]
21f0ac10:	e0823003 	add	r3, r2, r3
21f0ac14:	e2833001 	add	r3, r3, #1	; 0x1
21f0ac18:	e50b301c 	str	r3, [fp, #-28]
		len = pkt - xp;
21f0ac1c:	e51b201c 	ldr	r2, [fp, #-28]
21f0ac20:	e51b3018 	ldr	r3, [fp, #-24]
21f0ac24:	e0633002 	rsb	r3, r3, r2
21f0ac28:	e50b3014 	str	r3, [fp, #-20]
		break;
21f0ac2c:	ea000067 	b	21f0add0 <.text+0xadd0>

	case STATE_DATA:
	case STATE_OACK:
		xp = pkt;
21f0ac30:	e51b301c 	ldr	r3, [fp, #-28]
21f0ac34:	e50b3018 	str	r3, [fp, #-24]
		s = (ushort *)pkt;
21f0ac38:	e51b301c 	ldr	r3, [fp, #-28]
21f0ac3c:	e50b3010 	str	r3, [fp, #-16]
		*s++ = htons(TFTP_ACK);
21f0ac40:	e3a00004 	mov	r0, #4	; 0x4
21f0ac44:	eb00007d 	bl	21f0ae40 <__fswab16>
21f0ac48:	e1a03000 	mov	r3, r0
21f0ac4c:	e1a02003 	mov	r2, r3
21f0ac50:	e51b3010 	ldr	r3, [fp, #-16]
21f0ac54:	e1c320b0 	strh	r2, [r3]
21f0ac58:	e51b3010 	ldr	r3, [fp, #-16]
21f0ac5c:	e2833002 	add	r3, r3, #2	; 0x2
21f0ac60:	e50b3010 	str	r3, [fp, #-16]
		*s++ = htons(TftpBlock);
21f0ac64:	e59f31b8 	ldr	r3, [pc, #440]	; 21f0ae24 <.text+0xae24>
21f0ac68:	e5933000 	ldr	r3, [r3]
21f0ac6c:	e1a03803 	mov	r3, r3, lsl #16
21f0ac70:	e1a03823 	mov	r3, r3, lsr #16
21f0ac74:	e1a00003 	mov	r0, r3
21f0ac78:	eb000070 	bl	21f0ae40 <__fswab16>
21f0ac7c:	e1a03000 	mov	r3, r0
21f0ac80:	e1a02003 	mov	r2, r3
21f0ac84:	e51b3010 	ldr	r3, [fp, #-16]
21f0ac88:	e1c320b0 	strh	r2, [r3]
21f0ac8c:	e51b3010 	ldr	r3, [fp, #-16]
21f0ac90:	e2833002 	add	r3, r3, #2	; 0x2
21f0ac94:	e50b3010 	str	r3, [fp, #-16]
		pkt = (uchar *)s;
21f0ac98:	e51b3010 	ldr	r3, [fp, #-16]
21f0ac9c:	e50b301c 	str	r3, [fp, #-28]
		len = pkt - xp;
21f0aca0:	e51b201c 	ldr	r2, [fp, #-28]
21f0aca4:	e51b3018 	ldr	r3, [fp, #-24]
21f0aca8:	e0633002 	rsb	r3, r3, r2
21f0acac:	e50b3014 	str	r3, [fp, #-20]
		break;
21f0acb0:	ea000046 	b	21f0add0 <.text+0xadd0>

	case STATE_TOO_LARGE:
		xp = pkt;
21f0acb4:	e51b301c 	ldr	r3, [fp, #-28]
21f0acb8:	e50b3018 	str	r3, [fp, #-24]
		s = (ushort *)pkt;
21f0acbc:	e51b301c 	ldr	r3, [fp, #-28]
21f0acc0:	e50b3010 	str	r3, [fp, #-16]
		*s++ = htons(TFTP_ERROR);
21f0acc4:	e3a00005 	mov	r0, #5	; 0x5
21f0acc8:	eb00005c 	bl	21f0ae40 <__fswab16>
21f0accc:	e1a03000 	mov	r3, r0
21f0acd0:	e1a02003 	mov	r2, r3
21f0acd4:	e51b3010 	ldr	r3, [fp, #-16]
21f0acd8:	e1c320b0 	strh	r2, [r3]
21f0acdc:	e51b3010 	ldr	r3, [fp, #-16]
21f0ace0:	e2833002 	add	r3, r3, #2	; 0x2
21f0ace4:	e50b3010 	str	r3, [fp, #-16]
		*s++ = htons(3);
21f0ace8:	e3a00003 	mov	r0, #3	; 0x3
21f0acec:	eb000053 	bl	21f0ae40 <__fswab16>
21f0acf0:	e1a03000 	mov	r3, r0
21f0acf4:	e1a02003 	mov	r2, r3
21f0acf8:	e51b3010 	ldr	r3, [fp, #-16]
21f0acfc:	e1c320b0 	strh	r2, [r3]
21f0ad00:	e51b3010 	ldr	r3, [fp, #-16]
21f0ad04:	e2833002 	add	r3, r3, #2	; 0x2
21f0ad08:	e50b3010 	str	r3, [fp, #-16]
		pkt = (uchar *)s;
21f0ad0c:	e51b3010 	ldr	r3, [fp, #-16]
21f0ad10:	e50b301c 	str	r3, [fp, #-28]
		strcpy ((char *)pkt, "File too large");
21f0ad14:	e51b301c 	ldr	r3, [fp, #-28]
21f0ad18:	e1a00003 	mov	r0, r3
21f0ad1c:	e59f1104 	ldr	r1, [pc, #260]	; 21f0ae28 <.text+0xae28>
21f0ad20:	eb005e6b 	bl	21f226d4 <strcpy>
		pkt += 14 /*strlen("File too large")*/ + 1;
21f0ad24:	e51b301c 	ldr	r3, [fp, #-28]
21f0ad28:	e283300f 	add	r3, r3, #15	; 0xf
21f0ad2c:	e50b301c 	str	r3, [fp, #-28]
		len = pkt - xp;
21f0ad30:	e51b201c 	ldr	r2, [fp, #-28]
21f0ad34:	e51b3018 	ldr	r3, [fp, #-24]
21f0ad38:	e0633002 	rsb	r3, r3, r2
21f0ad3c:	e50b3014 	str	r3, [fp, #-20]
		break;
21f0ad40:	ea000022 	b	21f0add0 <.text+0xadd0>

	case STATE_BAD_MAGIC:
		xp = pkt;
21f0ad44:	e51b301c 	ldr	r3, [fp, #-28]
21f0ad48:	e50b3018 	str	r3, [fp, #-24]
		s = (ushort *)pkt;
21f0ad4c:	e51b301c 	ldr	r3, [fp, #-28]
21f0ad50:	e50b3010 	str	r3, [fp, #-16]
		*s++ = htons(TFTP_ERROR);
21f0ad54:	e3a00005 	mov	r0, #5	; 0x5
21f0ad58:	eb000038 	bl	21f0ae40 <__fswab16>
21f0ad5c:	e1a03000 	mov	r3, r0
21f0ad60:	e1a02003 	mov	r2, r3
21f0ad64:	e51b3010 	ldr	r3, [fp, #-16]
21f0ad68:	e1c320b0 	strh	r2, [r3]
21f0ad6c:	e51b3010 	ldr	r3, [fp, #-16]
21f0ad70:	e2833002 	add	r3, r3, #2	; 0x2
21f0ad74:	e50b3010 	str	r3, [fp, #-16]
		*s++ = htons(2);
21f0ad78:	e3a00002 	mov	r0, #2	; 0x2
21f0ad7c:	eb00002f 	bl	21f0ae40 <__fswab16>
21f0ad80:	e1a03000 	mov	r3, r0
21f0ad84:	e1a02003 	mov	r2, r3
21f0ad88:	e51b3010 	ldr	r3, [fp, #-16]
21f0ad8c:	e1c320b0 	strh	r2, [r3]
21f0ad90:	e51b3010 	ldr	r3, [fp, #-16]
21f0ad94:	e2833002 	add	r3, r3, #2	; 0x2
21f0ad98:	e50b3010 	str	r3, [fp, #-16]
		pkt = (uchar *)s;
21f0ad9c:	e51b3010 	ldr	r3, [fp, #-16]
21f0ada0:	e50b301c 	str	r3, [fp, #-28]
		strcpy ((char *)pkt, "File has bad magic");
21f0ada4:	e51b301c 	ldr	r3, [fp, #-28]
21f0ada8:	e1a00003 	mov	r0, r3
21f0adac:	e59f1078 	ldr	r1, [pc, #120]	; 21f0ae2c <.text+0xae2c>
21f0adb0:	eb005e47 	bl	21f226d4 <strcpy>
		pkt += 18 /*strlen("File has bad magic")*/ + 1;
21f0adb4:	e51b301c 	ldr	r3, [fp, #-28]
21f0adb8:	e2833013 	add	r3, r3, #19	; 0x13
21f0adbc:	e50b301c 	str	r3, [fp, #-28]
		len = pkt - xp;
21f0adc0:	e51b201c 	ldr	r2, [fp, #-28]
21f0adc4:	e51b3018 	ldr	r3, [fp, #-24]
21f0adc8:	e0633002 	rsb	r3, r3, r2
21f0adcc:	e50b3014 	str	r3, [fp, #-20]
		break;
	}

	NetSendUDPPacket(NetServerEther, NetServerIP, TftpServerPort, TftpOurPort, len);
21f0add0:	e59f3058 	ldr	r3, [pc, #88]	; 21f0ae30 <.text+0xae30>
21f0add4:	e5932000 	ldr	r2, [r3]
21f0add8:	e59f3054 	ldr	r3, [pc, #84]	; 21f0ae34 <.text+0xae34>
21f0addc:	e593c000 	ldr	ip, [r3]
21f0ade0:	e59f3050 	ldr	r3, [pc, #80]	; 21f0ae38 <.text+0xae38>
21f0ade4:	e593e000 	ldr	lr, [r3]
21f0ade8:	e51b3014 	ldr	r3, [fp, #-20]
21f0adec:	e58d3000 	str	r3, [sp]
21f0adf0:	e59f0044 	ldr	r0, [pc, #68]	; 21f0ae3c <.text+0xae3c>
21f0adf4:	e1a01002 	mov	r1, r2
21f0adf8:	e1a0200c 	mov	r2, ip
21f0adfc:	e1a0300e 	mov	r3, lr
21f0ae00:	ebfff9ce 	bl	21f09540 <NetSendUDPPacket>
}
21f0ae04:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0ae08:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0ae0c:	21f6454c 	mvncss	r4, ip, asr #10
21f0ae10:	21f66a8c 	mvncss	r6, ip, lsl #21
21f0ae14:	21f66aa0 	mvncss	r6, r0, lsr #21
21f0ae18:	21f2f648 	mvncss	pc, r8, asr #12
21f0ae1c:	21f2f650 	mvncss	pc, r0, asr r6
21f0ae20:	21f2f658 	mvncss	pc, r8, asr r6
21f0ae24:	21f66a7c 	mvncss	r6, ip, ror sl
21f0ae28:	21f2f65c 	mvncss	pc, ip, asr r6
21f0ae2c:	21f2f66c 	mvncss	pc, ip, ror #12
21f0ae30:	21f64560 	mvncss	r4, r0, ror #10
21f0ae34:	21f66a70 	mvncss	r6, r0, ror sl
21f0ae38:	21f66a74 	mvncss	r6, r4, ror sl
21f0ae3c:	21f6453e 	mvncss	r4, lr, lsr r5

21f0ae40 <__fswab16>:
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
21f0ae40:	e1a0c00d 	mov	ip, sp
21f0ae44:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ae48:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ae4c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0ae50:	e1a03000 	mov	r3, r0
21f0ae54:	e14b31b0 	strh	r3, [fp, #-16]
	return __arch__swab16(x);
21f0ae58:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0ae5c:	e20330ff 	and	r3, r3, #255	; 0xff
21f0ae60:	e1a03403 	mov	r3, r3, lsl #8
21f0ae64:	e1a03803 	mov	r3, r3, lsl #16
21f0ae68:	e1a02823 	mov	r2, r3, lsr #16
21f0ae6c:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0ae70:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f0ae74:	e1a03443 	mov	r3, r3, asr #8
21f0ae78:	e1a03803 	mov	r3, r3, lsl #16
21f0ae7c:	e1a03823 	mov	r3, r3, lsr #16
21f0ae80:	e1823003 	orr	r3, r2, r3
21f0ae84:	e1a03803 	mov	r3, r3, lsl #16
21f0ae88:	e1a03823 	mov	r3, r3, lsr #16
21f0ae8c:	e1a03803 	mov	r3, r3, lsl #16
21f0ae90:	e1a03823 	mov	r3, r3, lsr #16
}
21f0ae94:	e1a00003 	mov	r0, r3
21f0ae98:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0ae9c <TftpHandler>:


static void
TftpHandler (uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
21f0ae9c:	e1a0c00d 	mov	ip, sp
21f0aea0:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f0aea4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0aea8:	e24dd020 	sub	sp, sp, #32	; 0x20
21f0aeac:	e50b001c 	str	r0, [fp, #-28]
21f0aeb0:	e50b1020 	str	r1, [fp, #-32]
21f0aeb4:	e50b2024 	str	r2, [fp, #-36]
21f0aeb8:	e50b3028 	str	r3, [fp, #-40]
	ushort proto;
	ushort *s;

	if (dest != TftpOurPort) {
21f0aebc:	e59f3358 	ldr	r3, [pc, #856]	; 21f0b21c <.text+0xb21c>
21f0aec0:	e5933000 	ldr	r3, [r3]
21f0aec4:	e1a02003 	mov	r2, r3
21f0aec8:	e51b3020 	ldr	r3, [fp, #-32]
21f0aecc:	e1520003 	cmp	r2, r3
21f0aed0:	1a0000cf 	bne	21f0b214 <.text+0xb214>
		return;
	}
	if (TftpState != STATE_RRQ && src != TftpServerPort) {
21f0aed4:	e59f3344 	ldr	r3, [pc, #836]	; 21f0b220 <.text+0xb220>
21f0aed8:	e5933000 	ldr	r3, [r3]
21f0aedc:	e3530001 	cmp	r3, #1	; 0x1
21f0aee0:	0a000005 	beq	21f0aefc <TftpHandler+0x60>
21f0aee4:	e59f3338 	ldr	r3, [pc, #824]	; 21f0b224 <.text+0xb224>
21f0aee8:	e5933000 	ldr	r3, [r3]
21f0aeec:	e1a02003 	mov	r2, r3
21f0aef0:	e51b3024 	ldr	r3, [fp, #-36]
21f0aef4:	e1520003 	cmp	r2, r3
21f0aef8:	1a0000c5 	bne	21f0b214 <.text+0xb214>
		return;
	}

	if (len < 2) {
21f0aefc:	e51b3028 	ldr	r3, [fp, #-40]
21f0af00:	e3530001 	cmp	r3, #1	; 0x1
21f0af04:	9a0000c2 	bls	21f0b214 <.text+0xb214>
		return;
	}
	len -= 2;
21f0af08:	e51b3028 	ldr	r3, [fp, #-40]
21f0af0c:	e2433002 	sub	r3, r3, #2	; 0x2
21f0af10:	e50b3028 	str	r3, [fp, #-40]
	/* warning: don't use increment (++) in ntohs() macros!! */
	s = (ushort *)pkt;
21f0af14:	e51b301c 	ldr	r3, [fp, #-28]
21f0af18:	e50b3014 	str	r3, [fp, #-20]
	proto = *s++;
21f0af1c:	e51b3014 	ldr	r3, [fp, #-20]
21f0af20:	e1d330b0 	ldrh	r3, [r3]
21f0af24:	e14b31b6 	strh	r3, [fp, #-22]
21f0af28:	e51b3014 	ldr	r3, [fp, #-20]
21f0af2c:	e2833002 	add	r3, r3, #2	; 0x2
21f0af30:	e50b3014 	str	r3, [fp, #-20]
	pkt = (uchar *)s;
21f0af34:	e51b3014 	ldr	r3, [fp, #-20]
21f0af38:	e50b301c 	str	r3, [fp, #-28]
	switch (ntohs(proto)) {
21f0af3c:	e15b31b6 	ldrh	r3, [fp, #-22]
21f0af40:	e1a00003 	mov	r0, r3
21f0af44:	ebffffbd 	bl	21f0ae40 <__fswab16>
21f0af48:	e1a03000 	mov	r3, r0
21f0af4c:	e2433001 	sub	r3, r3, #1	; 0x1
21f0af50:	e3530005 	cmp	r3, #5	; 0x5
21f0af54:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0af58:	ea0000ad 	b	21f0b214 <.text+0xb214>
21f0af5c:	21f0b214 	mvncss	fp, r4, lsl r2
21f0af60:	21f0b214 	mvncss	fp, r4, lsl r2
21f0af64:	21f0af94 	ldrcsb	sl, [r0, #244]!
21f0af68:	21f0b214 	mvncss	fp, r4, lsl r2
21f0af6c:	21f0b1dc 	ldrcssb	fp, [r0, #28]!
21f0af70:	21f0af74 	mvncss	sl, r4, ror pc

	case TFTP_RRQ:
	case TFTP_WRQ:
	case TFTP_ACK:
		break;
	default:
		break;

	case TFTP_OACK:
#ifdef ET_DEBUG
		printf("Got OACK: %s %s\n", pkt, pkt+strlen(pkt)+1);
#endif
		TftpState = STATE_OACK;
21f0af74:	e59f22a4 	ldr	r2, [pc, #676]	; 21f0b220 <.text+0xb220>
21f0af78:	e3a03005 	mov	r3, #5	; 0x5
21f0af7c:	e5823000 	str	r3, [r2]
		TftpServerPort = src;
21f0af80:	e51b2024 	ldr	r2, [fp, #-36]
21f0af84:	e59f3298 	ldr	r3, [pc, #664]	; 21f0b224 <.text+0xb224>
21f0af88:	e5832000 	str	r2, [r3]
		TftpSend (); /* Send ACK */
21f0af8c:	ebfffece 	bl	21f0aacc <TftpSend>
		break;
21f0af90:	ea00009f 	b	21f0b214 <.text+0xb214>
	case TFTP_DATA:
		if (len < 2)
21f0af94:	e51b3028 	ldr	r3, [fp, #-40]
21f0af98:	e3530001 	cmp	r3, #1	; 0x1
21f0af9c:	9a00009c 	bls	21f0b214 <.text+0xb214>
			return;
		len -= 2;
21f0afa0:	e51b3028 	ldr	r3, [fp, #-40]
21f0afa4:	e2433002 	sub	r3, r3, #2	; 0x2
21f0afa8:	e50b3028 	str	r3, [fp, #-40]
		TftpBlock = ntohs(*(ushort *)pkt);
21f0afac:	e51b301c 	ldr	r3, [fp, #-28]
21f0afb0:	e1d330b0 	ldrh	r3, [r3]
21f0afb4:	e1a00003 	mov	r0, r3
21f0afb8:	ebffffa0 	bl	21f0ae40 <__fswab16>
21f0afbc:	e1a03000 	mov	r3, r0
21f0afc0:	e1a02003 	mov	r2, r3
21f0afc4:	e59f325c 	ldr	r3, [pc, #604]	; 21f0b228 <.text+0xb228>
21f0afc8:	e5832000 	str	r2, [r3]

		/*
		 * RFC1350 specifies that the first data packet will
		 * have sequence number 1. If we receive a sequence
		 * number of 0 this means that there was a wrap
		 * around of the (16 bit) counter.
		 */
		if (TftpBlock == 0) {
21f0afcc:	e59f3254 	ldr	r3, [pc, #596]	; 21f0b228 <.text+0xb228>
21f0afd0:	e5933000 	ldr	r3, [r3]
21f0afd4:	e3530000 	cmp	r3, #0	; 0x0
21f0afd8:	1a000010 	bne	21f0b020 <.text+0xb020>
			TftpBlockWrap++;
21f0afdc:	e59f3248 	ldr	r3, [pc, #584]	; 21f0b22c <.text+0xb22c>
21f0afe0:	e5933000 	ldr	r3, [r3]
21f0afe4:	e2832001 	add	r2, r3, #1	; 0x1
21f0afe8:	e59f323c 	ldr	r3, [pc, #572]	; 21f0b22c <.text+0xb22c>
21f0afec:	e5832000 	str	r2, [r3]
			TftpBlockWrapOffset += TFTP_BLOCK_SIZE * TFTP_SEQUENCE_SIZE;
21f0aff0:	e59f3238 	ldr	r3, [pc, #568]	; 21f0b230 <.text+0xb230>
21f0aff4:	e5933000 	ldr	r3, [r3]
21f0aff8:	e2832402 	add	r2, r3, #33554432	; 0x2000000
21f0affc:	e59f322c 	ldr	r3, [pc, #556]	; 21f0b230 <.text+0xb230>
21f0b000:	e5832000 	str	r2, [r3]
			printf ("\n\t %lu MB received\n\t ", TftpBlockWrapOffset>>20);
21f0b004:	e59f3224 	ldr	r3, [pc, #548]	; 21f0b230 <.text+0xb230>
21f0b008:	e5933000 	ldr	r3, [r3]
21f0b00c:	e1a03a23 	mov	r3, r3, lsr #20
21f0b010:	e59f021c 	ldr	r0, [pc, #540]	; 21f0b234 <.text+0xb234>
21f0b014:	e1a01003 	mov	r1, r3
21f0b018:	eb00429b 	bl	21f1ba8c <printf>
21f0b01c:	ea000029 	b	21f0b0c8 <.text+0xb0c8>
		} else {
			if (((TftpBlock - 1) % 10) == 0) {
21f0b020:	e59f3200 	ldr	r3, [pc, #512]	; 21f0b228 <.text+0xb228>
21f0b024:	e5933000 	ldr	r3, [r3]
21f0b028:	e2432001 	sub	r2, r3, #1	; 0x1
21f0b02c:	e59f3204 	ldr	r3, [pc, #516]	; 21f0b238 <.text+0xb238>
21f0b030:	e0831392 	umull	r1, r3, r2, r3
21f0b034:	e1a031a3 	mov	r3, r3, lsr #3
21f0b038:	e50b3030 	str	r3, [fp, #-48]
21f0b03c:	e51b3030 	ldr	r3, [fp, #-48]
21f0b040:	e1a03103 	mov	r3, r3, lsl #2
21f0b044:	e51b1030 	ldr	r1, [fp, #-48]
21f0b048:	e0833001 	add	r3, r3, r1
21f0b04c:	e1a03083 	mov	r3, r3, lsl #1
21f0b050:	e0632002 	rsb	r2, r3, r2
21f0b054:	e50b2030 	str	r2, [fp, #-48]
21f0b058:	e51b2030 	ldr	r2, [fp, #-48]
21f0b05c:	e3520000 	cmp	r2, #0	; 0x0
21f0b060:	1a000002 	bne	21f0b070 <.text+0xb070>
				putc ('#');
21f0b064:	e3a00023 	mov	r0, #35	; 0x23
21f0b068:	eb00425e 	bl	21f1b9e8 <putc>
21f0b06c:	ea000015 	b	21f0b0c8 <.text+0xb0c8>
			} else if ((TftpBlock % (10 * HASHES_PER_LINE)) == 0) {
21f0b070:	e59f31b0 	ldr	r3, [pc, #432]	; 21f0b228 <.text+0xb228>
21f0b074:	e5931000 	ldr	r1, [r3]
21f0b078:	e3e0338d 	mvn	r3, #872415234	; 0x34000002
21f0b07c:	e2433796 	sub	r3, r3, #39321600	; 0x2580000
21f0b080:	e2433b73 	sub	r3, r3, #117760	; 0x1cc00
21f0b084:	e0832391 	umull	r2, r3, r1, r3
21f0b088:	e1a034a3 	mov	r3, r3, lsr #9
21f0b08c:	e50b302c 	str	r3, [fp, #-44]
21f0b090:	e51b302c 	ldr	r3, [fp, #-44]
21f0b094:	e1a03103 	mov	r3, r3, lsl #2
21f0b098:	e51b202c 	ldr	r2, [fp, #-44]
21f0b09c:	e0833002 	add	r3, r3, r2
21f0b0a0:	e1a02303 	mov	r2, r3, lsl #6
21f0b0a4:	e0833002 	add	r3, r3, r2
21f0b0a8:	e1a03083 	mov	r3, r3, lsl #1
21f0b0ac:	e0631001 	rsb	r1, r3, r1
21f0b0b0:	e50b102c 	str	r1, [fp, #-44]
21f0b0b4:	e51b302c 	ldr	r3, [fp, #-44]
21f0b0b8:	e3530000 	cmp	r3, #0	; 0x0
21f0b0bc:	1a000001 	bne	21f0b0c8 <.text+0xb0c8>
				puts ("\n\t ");
21f0b0c0:	e59f0174 	ldr	r0, [pc, #372]	; 21f0b23c <.text+0xb23c>
21f0b0c4:	eb00425d 	bl	21f1ba40 <puts>
			}
		}

#ifdef ET_DEBUG
		if (TftpState == STATE_RRQ) {
			puts ("Server did not acknowledge timeout option!\n");
		}
#endif

		if (TftpState == STATE_RRQ || TftpState == STATE_OACK) {
21f0b0c8:	e59f3150 	ldr	r3, [pc, #336]	; 21f0b220 <.text+0xb220>
21f0b0cc:	e5933000 	ldr	r3, [r3]
21f0b0d0:	e3530001 	cmp	r3, #1	; 0x1
21f0b0d4:	0a000003 	beq	21f0b0e8 <.text+0xb0e8>
21f0b0d8:	e59f3140 	ldr	r3, [pc, #320]	; 21f0b220 <.text+0xb220>
21f0b0dc:	e5933000 	ldr	r3, [r3]
21f0b0e0:	e3530005 	cmp	r3, #5	; 0x5
21f0b0e4:	1a000019 	bne	21f0b150 <.text+0xb150>
			/* first block received */
			TftpState = STATE_DATA;
21f0b0e8:	e59f2130 	ldr	r2, [pc, #304]	; 21f0b220 <.text+0xb220>
21f0b0ec:	e3a03002 	mov	r3, #2	; 0x2
21f0b0f0:	e5823000 	str	r3, [r2]
			TftpServerPort = src;
21f0b0f4:	e51b2024 	ldr	r2, [fp, #-36]
21f0b0f8:	e59f3124 	ldr	r3, [pc, #292]	; 21f0b224 <.text+0xb224>
21f0b0fc:	e5832000 	str	r2, [r3]
			TftpLastBlock = 0;
21f0b100:	e59f2138 	ldr	r2, [pc, #312]	; 21f0b240 <.text+0xb240>
21f0b104:	e3a03000 	mov	r3, #0	; 0x0
21f0b108:	e5823000 	str	r3, [r2]
			TftpBlockWrap = 0;
21f0b10c:	e59f2118 	ldr	r2, [pc, #280]	; 21f0b22c <.text+0xb22c>
21f0b110:	e3a03000 	mov	r3, #0	; 0x0
21f0b114:	e5823000 	str	r3, [r2]
			TftpBlockWrapOffset = 0;
21f0b118:	e59f2110 	ldr	r2, [pc, #272]	; 21f0b230 <.text+0xb230>
21f0b11c:	e3a03000 	mov	r3, #0	; 0x0
21f0b120:	e5823000 	str	r3, [r2]

			if (TftpBlock != 1) {	/* Assertion */
21f0b124:	e59f30fc 	ldr	r3, [pc, #252]	; 21f0b228 <.text+0xb228>
21f0b128:	e5933000 	ldr	r3, [r3]
21f0b12c:	e3530001 	cmp	r3, #1	; 0x1
21f0b130:	0a000006 	beq	21f0b150 <.text+0xb150>
				printf ("\nTFTP error: "
21f0b134:	e59f30ec 	ldr	r3, [pc, #236]	; 21f0b228 <.text+0xb228>
21f0b138:	e5933000 	ldr	r3, [r3]
21f0b13c:	e59f0100 	ldr	r0, [pc, #256]	; 21f0b244 <.text+0xb244>
21f0b140:	e1a01003 	mov	r1, r3
21f0b144:	eb004250 	bl	21f1ba8c <printf>
					"First block is not block 1 (%ld)\n"
					"Starting again\n\n",
					TftpBlock);
				NetStartAgain ();
21f0b148:	ebfff895 	bl	21f093a4 <NetStartAgain>
				break;
21f0b14c:	ea000030 	b	21f0b214 <.text+0xb214>
			}
		}

		if (TftpBlock == TftpLastBlock) {
21f0b150:	e59f30d0 	ldr	r3, [pc, #208]	; 21f0b228 <.text+0xb228>
21f0b154:	e5932000 	ldr	r2, [r3]
21f0b158:	e59f30e0 	ldr	r3, [pc, #224]	; 21f0b240 <.text+0xb240>
21f0b15c:	e5933000 	ldr	r3, [r3]
21f0b160:	e1520003 	cmp	r2, r3
21f0b164:	0a00002a 	beq	21f0b214 <.text+0xb214>
			/*
			 *	Same block again; ignore it.
			 */
			break;
		}

		TftpLastBlock = TftpBlock;
21f0b168:	e59f30b8 	ldr	r3, [pc, #184]	; 21f0b228 <.text+0xb228>
21f0b16c:	e5932000 	ldr	r2, [r3]
21f0b170:	e59f30c8 	ldr	r3, [pc, #200]	; 21f0b240 <.text+0xb240>
21f0b174:	e5832000 	str	r2, [r3]
		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
21f0b178:	e3a00d4e 	mov	r0, #4992	; 0x1380
21f0b17c:	e2800008 	add	r0, r0, #8	; 0x8
21f0b180:	e59f10c0 	ldr	r1, [pc, #192]	; 21f0b248 <.text+0xb248>
21f0b184:	ebfff8c5 	bl	21f094a0 <NetSetTimeout>

		store_block (TftpBlock - 1, pkt + 2, len);
21f0b188:	e59f3098 	ldr	r3, [pc, #152]	; 21f0b228 <.text+0xb228>
21f0b18c:	e5933000 	ldr	r3, [r3]
21f0b190:	e2432001 	sub	r2, r3, #1	; 0x1
21f0b194:	e51b301c 	ldr	r3, [fp, #-28]
21f0b198:	e2833002 	add	r3, r3, #2	; 0x2
21f0b19c:	e1a00002 	mov	r0, r2
21f0b1a0:	e1a01003 	mov	r1, r3
21f0b1a4:	e51b2028 	ldr	r2, [fp, #-40]
21f0b1a8:	eb00002b 	bl	21f0b25c <store_block>

		/*
		 *	Acknoledge the block just received, which will prompt
		 *	the server for the next one.
		 */
		TftpSend ();
21f0b1ac:	ebfffe46 	bl	21f0aacc <TftpSend>

		if (len < TFTP_BLOCK_SIZE) {
21f0b1b0:	e51b2028 	ldr	r2, [fp, #-40]
21f0b1b4:	e3a03f7f 	mov	r3, #508	; 0x1fc
21f0b1b8:	e2833003 	add	r3, r3, #3	; 0x3
21f0b1bc:	e1520003 	cmp	r2, r3
21f0b1c0:	8a000013 	bhi	21f0b214 <.text+0xb214>
			/*
			 *	We received the whole thing.  Try to
			 *	run it.
			 */
			puts ("\ndone\n");
21f0b1c4:	e59f0080 	ldr	r0, [pc, #128]	; 21f0b24c <.text+0xb24c>
21f0b1c8:	eb00421c 	bl	21f1ba40 <puts>
			NetState = NETLOOP_SUCCESS;
21f0b1cc:	e59f207c 	ldr	r2, [pc, #124]	; 21f0b250 <.text+0xb250>
21f0b1d0:	e3a03003 	mov	r3, #3	; 0x3
21f0b1d4:	e5823000 	str	r3, [r2]
21f0b1d8:	ea00000d 	b	21f0b214 <.text+0xb214>
		}
		break;

	case TFTP_ERROR:
		printf ("\nTFTP error: '%s' (%d)\n",
21f0b1dc:	e51b301c 	ldr	r3, [fp, #-28]
21f0b1e0:	e2834002 	add	r4, r3, #2	; 0x2
21f0b1e4:	e51b301c 	ldr	r3, [fp, #-28]
21f0b1e8:	e1d330b0 	ldrh	r3, [r3]
21f0b1ec:	e1a00003 	mov	r0, r3
21f0b1f0:	ebffff12 	bl	21f0ae40 <__fswab16>
21f0b1f4:	e1a03000 	mov	r3, r0
21f0b1f8:	e59f0054 	ldr	r0, [pc, #84]	; 21f0b254 <.text+0xb254>
21f0b1fc:	e1a01004 	mov	r1, r4
21f0b200:	e1a02003 	mov	r2, r3
21f0b204:	eb004220 	bl	21f1ba8c <printf>
					pkt + 2, ntohs(*(ushort *)pkt));
		puts ("Starting again\n\n");
21f0b208:	e59f0048 	ldr	r0, [pc, #72]	; 21f0b258 <.text+0xb258>
21f0b20c:	eb00420b 	bl	21f1ba40 <puts>
		NetStartAgain ();
21f0b210:	ebfff863 	bl	21f093a4 <NetStartAgain>
		break;
	}
}
21f0b214:	e24bd010 	sub	sp, fp, #16	; 0x10
21f0b218:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f0b21c:	21f66a74 	mvncss	r6, r4, ror sl
21f0b220:	21f66a8c 	mvncss	r6, ip, lsl #21
21f0b224:	21f66a70 	mvncss	r6, r0, ror sl
21f0b228:	21f66a7c 	mvncss	r6, ip, ror sl
21f0b22c:	21f66a84 	mvncss	r6, r4, lsl #21
21f0b230:	21f66a88 	mvncss	r6, r8, lsl #21
21f0b234:	21f2f680 	mvncss	pc, r0, lsl #13
21f0b238:	cccccccd 	stcgtl	12, cr12, [ip], {205}
21f0b23c:	21f2f698 	ldrcsb	pc, [r2, #104]!
21f0b240:	21f66a80 	mvncss	r6, r0, lsl #21
21f0b244:	21f2f69c 	ldrcsb	pc, [r2, #108]!
21f0b248:	21f0b2f4 	ldrcssh	fp, [r0, #36]!
21f0b24c:	21f2f6dc 	ldrcssb	pc, [r2, #108]!
21f0b250:	21f64580 	mvncss	r4, r0, lsl #11
21f0b254:	21f2f6e4 	mvncss	pc, r4, ror #13
21f0b258:	21f2f6fc 	ldrcssh	pc, [r2, #108]!

21f0b25c <store_block>:
21f0b25c:	e1a0c00d 	mov	ip, sp
21f0b260:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b264:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b268:	e24dd014 	sub	sp, sp, #20	; 0x14
21f0b26c:	e50b0018 	str	r0, [fp, #-24]
21f0b270:	e50b101c 	str	r1, [fp, #-28]
21f0b274:	e50b2020 	str	r2, [fp, #-32]
21f0b278:	e51b3018 	ldr	r3, [fp, #-24]
21f0b27c:	e1a02483 	mov	r2, r3, lsl #9
21f0b280:	e59f3060 	ldr	r3, [pc, #96]	; 21f0b2e8 <.text+0xb2e8>
21f0b284:	e5933000 	ldr	r3, [r3]
21f0b288:	e0823003 	add	r3, r2, r3
21f0b28c:	e50b3014 	str	r3, [fp, #-20]
21f0b290:	e51b2014 	ldr	r2, [fp, #-20]
21f0b294:	e51b3020 	ldr	r3, [fp, #-32]
21f0b298:	e0823003 	add	r3, r2, r3
21f0b29c:	e50b3010 	str	r3, [fp, #-16]
21f0b2a0:	e59f3044 	ldr	r3, [pc, #68]	; 21f0b2ec <.text+0xb2ec>
21f0b2a4:	e5932000 	ldr	r2, [r3]
21f0b2a8:	e51b3014 	ldr	r3, [fp, #-20]
21f0b2ac:	e0823003 	add	r3, r2, r3
21f0b2b0:	e1a00003 	mov	r0, r3
21f0b2b4:	e51b101c 	ldr	r1, [fp, #-28]
21f0b2b8:	e51b2020 	ldr	r2, [fp, #-32]
21f0b2bc:	eb005fc2 	bl	21f231cc <memcpy>
21f0b2c0:	e59f3028 	ldr	r3, [pc, #40]	; 21f0b2f0 <.text+0xb2f0>
21f0b2c4:	e5932000 	ldr	r2, [r3]
21f0b2c8:	e51b3010 	ldr	r3, [fp, #-16]
21f0b2cc:	e1520003 	cmp	r2, r3
21f0b2d0:	2a000002 	bcs	21f0b2e0 <store_block+0x84>
21f0b2d4:	e59f2014 	ldr	r2, [pc, #20]	; 21f0b2f0 <.text+0xb2f0>
21f0b2d8:	e51b3010 	ldr	r3, [fp, #-16]
21f0b2dc:	e5823000 	str	r3, [r2]
21f0b2e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0b2e4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0b2e8:	21f66a88 	mvncss	r6, r8, lsl #21
21f0b2ec:	21f3322c 	mvncss	r3, ip, lsr #4
21f0b2f0:	21f64550 	mvncss	r4, r0, asr r5

21f0b2f4 <TftpTimeout>:


static void
TftpTimeout (void)
{
21f0b2f4:	e1a0c00d 	mov	ip, sp
21f0b2f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b2fc:	e24cb004 	sub	fp, ip, #4	; 0x4
	if (++TftpTimeoutCount > TIMEOUT_COUNT) {
21f0b300:	e59f304c 	ldr	r3, [pc, #76]	; 21f0b354 <.text+0xb354>
21f0b304:	e5933000 	ldr	r3, [r3]
21f0b308:	e2832001 	add	r2, r3, #1	; 0x1
21f0b30c:	e59f3040 	ldr	r3, [pc, #64]	; 21f0b354 <.text+0xb354>
21f0b310:	e5832000 	str	r2, [r3]
21f0b314:	e59f3038 	ldr	r3, [pc, #56]	; 21f0b354 <.text+0xb354>
21f0b318:	e5933000 	ldr	r3, [r3]
21f0b31c:	e3530028 	cmp	r3, #40	; 0x28
21f0b320:	da000003 	ble	21f0b334 <TftpTimeout+0x40>
		puts ("\nRetry count exceeded; starting again\n");
21f0b324:	e59f002c 	ldr	r0, [pc, #44]	; 21f0b358 <.text+0xb358>
21f0b328:	eb0041c4 	bl	21f1ba40 <puts>
		NetStartAgain ();
21f0b32c:	ebfff81c 	bl	21f093a4 <NetStartAgain>
21f0b330:	ea000006 	b	21f0b350 <TftpTimeout+0x5c>
	} else {
		puts ("T ");
21f0b334:	e59f0020 	ldr	r0, [pc, #32]	; 21f0b35c <.text+0xb35c>
21f0b338:	eb0041c0 	bl	21f1ba40 <puts>
		NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
21f0b33c:	e3a00d4e 	mov	r0, #4992	; 0x1380
21f0b340:	e2800008 	add	r0, r0, #8	; 0x8
21f0b344:	e59f1014 	ldr	r1, [pc, #20]	; 21f0b360 <.text+0xb360>
21f0b348:	ebfff854 	bl	21f094a0 <NetSetTimeout>
		TftpSend ();
21f0b34c:	ebfffdde 	bl	21f0aacc <TftpSend>
	}
}
21f0b350:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0b354:	21f66a78 	mvncss	r6, r8, ror sl
21f0b358:	21f2f710 	mvncss	pc, r0, lsl r7
21f0b35c:	21f2f738 	mvncss	pc, r8, lsr r7
21f0b360:	21f0b2f4 	ldrcssh	fp, [r0, #36]!

21f0b364 <TftpStart>:


void
TftpStart (void)
{
21f0b364:	e1a0c00d 	mov	ip, sp
21f0b368:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b36c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b370:	e24dd014 	sub	sp, sp, #20	; 0x14
#ifdef CONFIG_TFTP_PORT
	char *ep;             /* Environment pointer */
#endif

	if (BootFile[0] == '\0') {
21f0b374:	e59f3268 	ldr	r3, [pc, #616]	; 21f0b5e4 <.text+0xb5e4>
21f0b378:	e5d33000 	ldrb	r3, [r3]
21f0b37c:	e3530000 	cmp	r3, #0	; 0x0
21f0b380:	1a00001e 	bne	21f0b400 <TftpStart+0x9c>
		sprintf(default_filename, "%02lX%02lX%02lX%02lX.img",
21f0b384:	e59f325c 	ldr	r3, [pc, #604]	; 21f0b5e8 <.text+0xb5e8>
21f0b388:	e5933000 	ldr	r3, [r3]
21f0b38c:	e203c0ff 	and	ip, r3, #255	; 0xff
21f0b390:	e59f3250 	ldr	r3, [pc, #592]	; 21f0b5e8 <.text+0xb5e8>
21f0b394:	e5933000 	ldr	r3, [r3]
21f0b398:	e1a03423 	mov	r3, r3, lsr #8
21f0b39c:	e203e0ff 	and	lr, r3, #255	; 0xff
21f0b3a0:	e59f3240 	ldr	r3, [pc, #576]	; 21f0b5e8 <.text+0xb5e8>
21f0b3a4:	e5933000 	ldr	r3, [r3]
21f0b3a8:	e1a03823 	mov	r3, r3, lsr #16
21f0b3ac:	e20320ff 	and	r2, r3, #255	; 0xff
21f0b3b0:	e59f3230 	ldr	r3, [pc, #560]	; 21f0b5e8 <.text+0xb5e8>
21f0b3b4:	e5933000 	ldr	r3, [r3]
21f0b3b8:	e1a03c23 	mov	r3, r3, lsr #24
21f0b3bc:	e20330ff 	and	r3, r3, #255	; 0xff
21f0b3c0:	e58d2000 	str	r2, [sp]
21f0b3c4:	e58d3004 	str	r3, [sp, #4]
21f0b3c8:	e59f021c 	ldr	r0, [pc, #540]	; 21f0b5ec <.text+0xb5ec>
21f0b3cc:	e59f121c 	ldr	r1, [pc, #540]	; 21f0b5f0 <.text+0xb5f0>
21f0b3d0:	e1a0200c 	mov	r2, ip
21f0b3d4:	e1a0300e 	mov	r3, lr
21f0b3d8:	eb0064ba 	bl	21f246c8 <sprintf>
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF	);
		tftp_filename = default_filename;
21f0b3dc:	e59f2210 	ldr	r2, [pc, #528]	; 21f0b5f4 <.text+0xb5f4>
21f0b3e0:	e59f3204 	ldr	r3, [pc, #516]	; 21f0b5ec <.text+0xb5ec>
21f0b3e4:	e5823000 	str	r3, [r2]

		printf ("*** Warning: no boot file name; using '%s'\n",
21f0b3e8:	e59f3204 	ldr	r3, [pc, #516]	; 21f0b5f4 <.text+0xb5f4>
21f0b3ec:	e5933000 	ldr	r3, [r3]
21f0b3f0:	e59f0200 	ldr	r0, [pc, #512]	; 21f0b5f8 <.text+0xb5f8>
21f0b3f4:	e1a01003 	mov	r1, r3
21f0b3f8:	eb0041a3 	bl	21f1ba8c <printf>
21f0b3fc:	ea000002 	b	21f0b40c <TftpStart+0xa8>
			tftp_filename);
	} else {
		tftp_filename = BootFile;
21f0b400:	e59f21ec 	ldr	r2, [pc, #492]	; 21f0b5f4 <.text+0xb5f4>
21f0b404:	e59f31d8 	ldr	r3, [pc, #472]	; 21f0b5e4 <.text+0xb5e4>
21f0b408:	e5823000 	str	r3, [r2]
	}

#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif
	puts ("TFTP from server ");	print_IPaddr (NetServerIP);
21f0b40c:	e59f01e8 	ldr	r0, [pc, #488]	; 21f0b5fc <.text+0xb5fc>
21f0b410:	eb00418a 	bl	21f1ba40 <puts>
21f0b414:	e59f31e4 	ldr	r3, [pc, #484]	; 21f0b600 <.text+0xb600>
21f0b418:	e5933000 	ldr	r3, [r3]
21f0b41c:	e1a00003 	mov	r0, r3
21f0b420:	ebfffd81 	bl	21f0aa2c <print_IPaddr>
	puts ("; our IP address is ");	print_IPaddr (NetOurIP);
21f0b424:	e59f01d8 	ldr	r0, [pc, #472]	; 21f0b604 <.text+0xb604>
21f0b428:	eb004184 	bl	21f1ba40 <puts>
21f0b42c:	e59f31b4 	ldr	r3, [pc, #436]	; 21f0b5e8 <.text+0xb5e8>
21f0b430:	e5933000 	ldr	r3, [r3]
21f0b434:	e1a00003 	mov	r0, r3
21f0b438:	ebfffd7b 	bl	21f0aa2c <print_IPaddr>

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
21f0b43c:	e59f31c4 	ldr	r3, [pc, #452]	; 21f0b608 <.text+0xb608>
21f0b440:	e5933000 	ldr	r3, [r3]
21f0b444:	e3530000 	cmp	r3, #0	; 0x0
21f0b448:	0a000019 	beq	21f0b4b4 <TftpStart+0x150>
21f0b44c:	e59f31b8 	ldr	r3, [pc, #440]	; 21f0b60c <.text+0xb60c>
21f0b450:	e5933000 	ldr	r3, [r3]
21f0b454:	e3530000 	cmp	r3, #0	; 0x0
21f0b458:	0a000015 	beq	21f0b4b4 <TftpStart+0x150>
	    IPaddr_t OurNet 	= NetOurIP    & NetOurSubnetMask;
21f0b45c:	e59f3184 	ldr	r3, [pc, #388]	; 21f0b5e8 <.text+0xb5e8>
21f0b460:	e5932000 	ldr	r2, [r3]
21f0b464:	e59f31a0 	ldr	r3, [pc, #416]	; 21f0b60c <.text+0xb60c>
21f0b468:	e5933000 	ldr	r3, [r3]
21f0b46c:	e0023003 	and	r3, r2, r3
21f0b470:	e50b3014 	str	r3, [fp, #-20]
	    IPaddr_t ServerNet 	= NetServerIP & NetOurSubnetMask;
21f0b474:	e59f3184 	ldr	r3, [pc, #388]	; 21f0b600 <.text+0xb600>
21f0b478:	e5932000 	ldr	r2, [r3]
21f0b47c:	e59f3188 	ldr	r3, [pc, #392]	; 21f0b60c <.text+0xb60c>
21f0b480:	e5933000 	ldr	r3, [r3]
21f0b484:	e0023003 	and	r3, r2, r3
21f0b488:	e50b3010 	str	r3, [fp, #-16]

	    if (OurNet != ServerNet) {
21f0b48c:	e51b2014 	ldr	r2, [fp, #-20]
21f0b490:	e51b3010 	ldr	r3, [fp, #-16]
21f0b494:	e1520003 	cmp	r2, r3
21f0b498:	0a000005 	beq	21f0b4b4 <TftpStart+0x150>
		puts ("; sending through gateway ");
21f0b49c:	e59f016c 	ldr	r0, [pc, #364]	; 21f0b610 <.text+0xb610>
21f0b4a0:	eb004166 	bl	21f1ba40 <puts>
		print_IPaddr (NetOurGatewayIP) ;
21f0b4a4:	e59f315c 	ldr	r3, [pc, #348]	; 21f0b608 <.text+0xb608>
21f0b4a8:	e5933000 	ldr	r3, [r3]
21f0b4ac:	e1a00003 	mov	r0, r3
21f0b4b0:	ebfffd5d 	bl	21f0aa2c <print_IPaddr>
	    }
	}
	putc ('\n');
21f0b4b4:	e3a0000a 	mov	r0, #10	; 0xa
21f0b4b8:	eb00414a 	bl	21f1b9e8 <putc>

	printf ("Filename '%s'.", tftp_filename);
21f0b4bc:	e59f3130 	ldr	r3, [pc, #304]	; 21f0b5f4 <.text+0xb5f4>
21f0b4c0:	e5933000 	ldr	r3, [r3]
21f0b4c4:	e59f0148 	ldr	r0, [pc, #328]	; 21f0b614 <.text+0xb614>
21f0b4c8:	e1a01003 	mov	r1, r3
21f0b4cc:	eb00416e 	bl	21f1ba8c <printf>

	if (NetBootFileSize) {
21f0b4d0:	e59f3140 	ldr	r3, [pc, #320]	; 21f0b618 <.text+0xb618>
21f0b4d4:	e1d330b0 	ldrh	r3, [r3]
21f0b4d8:	e3530000 	cmp	r3, #0	; 0x0
21f0b4dc:	0a00000b 	beq	21f0b510 <TftpStart+0x1ac>
		printf (" Size is 0x%x Bytes = ", NetBootFileSize<<9);
21f0b4e0:	e59f3130 	ldr	r3, [pc, #304]	; 21f0b618 <.text+0xb618>
21f0b4e4:	e1d330b0 	ldrh	r3, [r3]
21f0b4e8:	e1a03483 	mov	r3, r3, lsl #9
21f0b4ec:	e59f0128 	ldr	r0, [pc, #296]	; 21f0b61c <.text+0xb61c>
21f0b4f0:	e1a01003 	mov	r1, r3
21f0b4f4:	eb004164 	bl	21f1ba8c <printf>
		print_size (NetBootFileSize<<9, "");
21f0b4f8:	e59f3118 	ldr	r3, [pc, #280]	; 21f0b618 <.text+0xb618>
21f0b4fc:	e1d330b0 	ldrh	r3, [r3]
21f0b500:	e1a03483 	mov	r3, r3, lsl #9
21f0b504:	e1a00003 	mov	r0, r3
21f0b508:	e59f1110 	ldr	r1, [pc, #272]	; 21f0b620 <.text+0xb620>
21f0b50c:	eb005c2b 	bl	21f225c0 <print_size>
	}

	putc ('\n');
21f0b510:	e3a0000a 	mov	r0, #10	; 0xa
21f0b514:	eb004133 	bl	21f1b9e8 <putc>

	printf ("Load address: 0x%lx\n", load_addr);
21f0b518:	e59f3104 	ldr	r3, [pc, #260]	; 21f0b624 <.text+0xb624>
21f0b51c:	e5933000 	ldr	r3, [r3]
21f0b520:	e59f0100 	ldr	r0, [pc, #256]	; 21f0b628 <.text+0xb628>
21f0b524:	e1a01003 	mov	r1, r3
21f0b528:	eb004157 	bl	21f1ba8c <printf>

	puts ("Loading: *\b");
21f0b52c:	e59f00f8 	ldr	r0, [pc, #248]	; 21f0b62c <.text+0xb62c>
21f0b530:	eb004142 	bl	21f1ba40 <puts>

	NetSetTimeout (TIMEOUT * CFG_HZ, TftpTimeout);
21f0b534:	e3a00d4e 	mov	r0, #4992	; 0x1380
21f0b538:	e2800008 	add	r0, r0, #8	; 0x8
21f0b53c:	e59f10ec 	ldr	r1, [pc, #236]	; 21f0b630 <.text+0xb630>
21f0b540:	ebfff7d6 	bl	21f094a0 <NetSetTimeout>
	NetSetHandler (TftpHandler);
21f0b544:	e59f00e8 	ldr	r0, [pc, #232]	; 21f0b634 <.text+0xb634>
21f0b548:	ebfff7ca 	bl	21f09478 <NetSetHandler>

	TftpServerPort = WELL_KNOWN_PORT;
21f0b54c:	e59f20e4 	ldr	r2, [pc, #228]	; 21f0b638 <.text+0xb638>
21f0b550:	e3a03045 	mov	r3, #69	; 0x45
21f0b554:	e5823000 	str	r3, [r2]
	TftpTimeoutCount = 0;
21f0b558:	e59f20dc 	ldr	r2, [pc, #220]	; 21f0b63c <.text+0xb63c>
21f0b55c:	e3a03000 	mov	r3, #0	; 0x0
21f0b560:	e5823000 	str	r3, [r2]
	TftpState = STATE_RRQ;
21f0b564:	e59f20d4 	ldr	r2, [pc, #212]	; 21f0b640 <.text+0xb640>
21f0b568:	e3a03001 	mov	r3, #1	; 0x1
21f0b56c:	e5823000 	str	r3, [r2]
	/* Use a pseudo-random port unless a specific port is set */
	TftpOurPort = 1024 + (get_timer(0) % 3072);
21f0b570:	e3a00000 	mov	r0, #0	; 0x0
21f0b574:	ebffd536 	bl	21f00a54 <get_timer>
21f0b578:	e1a02000 	mov	r2, r0
21f0b57c:	e59f30c0 	ldr	r3, [pc, #192]	; 21f0b644 <.text+0xb644>
21f0b580:	e0831392 	umull	r1, r3, r2, r3
21f0b584:	e1a035a3 	mov	r3, r3, lsr #11
21f0b588:	e50b3018 	str	r3, [fp, #-24]
21f0b58c:	e51b3018 	ldr	r3, [fp, #-24]
21f0b590:	e1a03083 	mov	r3, r3, lsl #1
21f0b594:	e51b1018 	ldr	r1, [fp, #-24]
21f0b598:	e0833001 	add	r3, r3, r1
21f0b59c:	e1a03503 	mov	r3, r3, lsl #10
21f0b5a0:	e0632002 	rsb	r2, r3, r2
21f0b5a4:	e50b2018 	str	r2, [fp, #-24]
21f0b5a8:	e51b2018 	ldr	r2, [fp, #-24]
21f0b5ac:	e2823b01 	add	r3, r2, #1024	; 0x400
21f0b5b0:	e1a02003 	mov	r2, r3
21f0b5b4:	e59f308c 	ldr	r3, [pc, #140]	; 21f0b648 <.text+0xb648>
21f0b5b8:	e5832000 	str	r2, [r3]
#ifdef CONFIG_TFTP_PORT
	if ((ep = getenv("tftpdstp")) != NULL) {
		TftpServerPort = simple_strtol(ep, NULL, 10);
	}
	if ((ep = getenv("tftpsrcp")) != NULL) {
		TftpOurPort= simple_strtol(ep, NULL, 10);
	}
#endif
	TftpBlock = 0;
21f0b5bc:	e59f2088 	ldr	r2, [pc, #136]	; 21f0b64c <.text+0xb64c>
21f0b5c0:	e3a03000 	mov	r3, #0	; 0x0
21f0b5c4:	e5823000 	str	r3, [r2]

	/* zero out server ether in case the server ip has changed */
	memset(NetServerEther, 0, 6);
21f0b5c8:	e59f0080 	ldr	r0, [pc, #128]	; 21f0b650 <.text+0xb650>
21f0b5cc:	e3a01000 	mov	r1, #0	; 0x0
21f0b5d0:	e3a02006 	mov	r2, #6	; 0x6
21f0b5d4:	eb005ec3 	bl	21f230e8 <memset>

	TftpSend ();
21f0b5d8:	ebfffd3b 	bl	21f0aacc <TftpSend>
}
21f0b5dc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0b5e0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0b5e4:	21f64584 	mvncss	r4, r4, lsl #11
21f0b5e8:	21f6455c 	mvncss	r4, ip, asr r5
21f0b5ec:	21f66a90 	ldrcsb	r6, [r6, #160]!
21f0b5f0:	21f2f73c 	mvncss	pc, ip, lsr r7
21f0b5f4:	21f66aa0 	mvncss	r6, r0, lsr #21
21f0b5f8:	21f2f758 	mvncss	pc, r8, asr r7
21f0b5fc:	21f2f784 	mvncss	pc, r4, lsl #15
21f0b600:	21f64560 	mvncss	r4, r0, ror #10
21f0b604:	21f2f798 	ldrcsb	pc, [r2, #120]!
21f0b608:	21f644b4 	ldrcsh	r4, [r6, #68]!
21f0b60c:	21f644b0 	ldrcsh	r4, [r6, #64]!
21f0b610:	21f2f7b0 	ldrcsh	pc, [r2, #112]!
21f0b614:	21f2f7cc 	mvncss	pc, ip, asr #15
21f0b618:	21f6453c 	mvncss	r4, ip, lsr r5
21f0b61c:	21f2f7dc 	ldrcssb	pc, [r2, #124]!
21f0b620:	21f2f7f4 	ldrcssh	pc, [r2, #116]!
21f0b624:	21f3322c 	mvncss	r3, ip, lsr #4
21f0b628:	21f2f7f8 	ldrcssh	pc, [r2, #120]!
21f0b62c:	21f2f810 	mvncss	pc, r0, lsl r8
21f0b630:	21f0b2f4 	ldrcssh	fp, [r0, #36]!
21f0b634:	21f0ae9c 	ldrcsb	sl, [r0, #236]!
21f0b638:	21f66a70 	mvncss	r6, r0, ror sl
21f0b63c:	21f66a78 	mvncss	r6, r8, ror sl
21f0b640:	21f66a8c 	mvncss	r6, ip, lsl #21
21f0b644:	aaaaaaab 	bge	209b60f8 <.text-0x1549f08>
21f0b648:	21f66a74 	mvncss	r6, r4, ror sl
21f0b64c:	21f66a7c 	mvncss	r6, ip, ror sl
21f0b650:	21f6453e 	mvncss	r4, lr, lsr r5

21f0b654 <BootpCheckPkt>:

#endif	/* CFG_CMD_DHCP */

static int BootpCheckPkt(uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
21f0b654:	e1a0c00d 	mov	ip, sp
21f0b658:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b65c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b660:	e24dd018 	sub	sp, sp, #24	; 0x18
21f0b664:	e50b0018 	str	r0, [fp, #-24]
21f0b668:	e50b101c 	str	r1, [fp, #-28]
21f0b66c:	e50b2020 	str	r2, [fp, #-32]
21f0b670:	e50b3024 	str	r3, [fp, #-36]
	Bootp_t *bp = (Bootp_t *) pkt;
21f0b674:	e51b3018 	ldr	r3, [fp, #-24]
21f0b678:	e50b3014 	str	r3, [fp, #-20]
	int retval = 0;
21f0b67c:	e3a03000 	mov	r3, #0	; 0x0
21f0b680:	e50b3010 	str	r3, [fp, #-16]

	if (dest != PORT_BOOTPC || src != PORT_BOOTPS)
21f0b684:	e51b301c 	ldr	r3, [fp, #-28]
21f0b688:	e3530044 	cmp	r3, #68	; 0x44
21f0b68c:	1a000002 	bne	21f0b69c <BootpCheckPkt+0x48>
21f0b690:	e51b3020 	ldr	r3, [fp, #-32]
21f0b694:	e3530043 	cmp	r3, #67	; 0x43
21f0b698:	0a000002 	beq	21f0b6a8 <BootpCheckPkt+0x54>
		retval = -1;
21f0b69c:	e3e03000 	mvn	r3, #0	; 0x0
21f0b6a0:	e50b3010 	str	r3, [fp, #-16]
21f0b6a4:	ea000035 	b	21f0b780 <BootpCheckPkt+0x12c>
	else if (len < sizeof (Bootp_t) - OPT_SIZE)
21f0b6a8:	e51b3024 	ldr	r3, [fp, #-36]
21f0b6ac:	e35300eb 	cmp	r3, #235	; 0xeb
21f0b6b0:	8a000002 	bhi	21f0b6c0 <BootpCheckPkt+0x6c>
		retval = -2;
21f0b6b4:	e3e03001 	mvn	r3, #1	; 0x1
21f0b6b8:	e50b3010 	str	r3, [fp, #-16]
21f0b6bc:	ea00002f 	b	21f0b780 <BootpCheckPkt+0x12c>
	else if (bp->bp_op != OP_BOOTREQUEST &&
21f0b6c0:	e51b3014 	ldr	r3, [fp, #-20]
21f0b6c4:	e5d33000 	ldrb	r3, [r3]
21f0b6c8:	e3530001 	cmp	r3, #1	; 0x1
21f0b6cc:	0a000012 	beq	21f0b71c <BootpCheckPkt+0xc8>
21f0b6d0:	e51b3014 	ldr	r3, [fp, #-20]
21f0b6d4:	e5d33000 	ldrb	r3, [r3]
21f0b6d8:	e3530002 	cmp	r3, #2	; 0x2
21f0b6dc:	0a00000e 	beq	21f0b71c <BootpCheckPkt+0xc8>
21f0b6e0:	e51b3014 	ldr	r3, [fp, #-20]
21f0b6e4:	e5d33000 	ldrb	r3, [r3]
21f0b6e8:	e3530002 	cmp	r3, #2	; 0x2
21f0b6ec:	0a00000a 	beq	21f0b71c <BootpCheckPkt+0xc8>
21f0b6f0:	e51b3014 	ldr	r3, [fp, #-20]
21f0b6f4:	e5d33000 	ldrb	r3, [r3]
21f0b6f8:	e3530005 	cmp	r3, #5	; 0x5
21f0b6fc:	0a000006 	beq	21f0b71c <BootpCheckPkt+0xc8>
21f0b700:	e51b3014 	ldr	r3, [fp, #-20]
21f0b704:	e5d33000 	ldrb	r3, [r3]
21f0b708:	e3530006 	cmp	r3, #6	; 0x6
21f0b70c:	0a000002 	beq	21f0b71c <BootpCheckPkt+0xc8>
	    bp->bp_op != OP_BOOTREPLY &&
	    bp->bp_op != DHCP_OFFER &&
	    bp->bp_op != DHCP_ACK &&
	    bp->bp_op != DHCP_NAK ) {
		retval = -3;
21f0b710:	e3e03002 	mvn	r3, #2	; 0x2
21f0b714:	e50b3010 	str	r3, [fp, #-16]
21f0b718:	ea000018 	b	21f0b780 <BootpCheckPkt+0x12c>
	}
	else if (bp->bp_htype != HWT_ETHER)
21f0b71c:	e51b3014 	ldr	r3, [fp, #-20]
21f0b720:	e5d33001 	ldrb	r3, [r3, #1]
21f0b724:	e3530001 	cmp	r3, #1	; 0x1
21f0b728:	0a000002 	beq	21f0b738 <BootpCheckPkt+0xe4>
		retval = -4;
21f0b72c:	e3e03003 	mvn	r3, #3	; 0x3
21f0b730:	e50b3010 	str	r3, [fp, #-16]
21f0b734:	ea000011 	b	21f0b780 <BootpCheckPkt+0x12c>
	else if (bp->bp_hlen != HWL_ETHER)
21f0b738:	e51b3014 	ldr	r3, [fp, #-20]
21f0b73c:	e5d33002 	ldrb	r3, [r3, #2]
21f0b740:	e3530006 	cmp	r3, #6	; 0x6
21f0b744:	0a000002 	beq	21f0b754 <BootpCheckPkt+0x100>
		retval = -5;
21f0b748:	e3e03004 	mvn	r3, #4	; 0x4
21f0b74c:	e50b3010 	str	r3, [fp, #-16]
21f0b750:	ea00000a 	b	21f0b780 <BootpCheckPkt+0x12c>
	else if (NetReadLong((ulong*)&bp->bp_id) != BootpID) {
21f0b754:	e51b3014 	ldr	r3, [fp, #-20]
21f0b758:	e2833004 	add	r3, r3, #4	; 0x4
21f0b75c:	e1a00003 	mov	r0, r3
21f0b760:	eb00000b 	bl	21f0b794 <NetReadLong>
21f0b764:	e1a02000 	mov	r2, r0
21f0b768:	e59f3020 	ldr	r3, [pc, #32]	; 21f0b790 <.text+0xb790>
21f0b76c:	e5933000 	ldr	r3, [r3]
21f0b770:	e1520003 	cmp	r2, r3
21f0b774:	0a000001 	beq	21f0b780 <BootpCheckPkt+0x12c>
		retval = -6;
21f0b778:	e3e03005 	mvn	r3, #5	; 0x5
21f0b77c:	e50b3010 	str	r3, [fp, #-16]
	}

	debug ("Filtering pkt = %d\n", retval);

	return retval;
21f0b780:	e51b3010 	ldr	r3, [fp, #-16]
}
21f0b784:	e1a00003 	mov	r0, r3
21f0b788:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0b78c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0b790:	21f66ab0 	ldrcsh	r6, [r6, #160]!

21f0b794 <NetReadLong>:
}

/* return ulong *in network byteorder* */
static inline ulong NetReadLong(ulong *from)
{
21f0b794:	e1a0c00d 	mov	ip, sp
21f0b798:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b79c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b7a0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0b7a4:	e50b0014 	str	r0, [fp, #-20]
	ulong l;
	memcpy((void*)&l, (void*)from, sizeof(l));
21f0b7a8:	e24b3010 	sub	r3, fp, #16	; 0x10
21f0b7ac:	e1a00003 	mov	r0, r3
21f0b7b0:	e51b1014 	ldr	r1, [fp, #-20]
21f0b7b4:	e3a02004 	mov	r2, #4	; 0x4
21f0b7b8:	eb005e83 	bl	21f231cc <memcpy>
	return l;
21f0b7bc:	e51b3010 	ldr	r3, [fp, #-16]
}
21f0b7c0:	e1a00003 	mov	r0, r3
21f0b7c4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0b7c8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0b7cc <BootpCopyNetParams>:

/*
 * Copy parameters of interest from BOOTP_REPLY/DHCP_OFFER packet
 */
static void BootpCopyNetParams(Bootp_t *bp)
{
21f0b7cc:	e1a0c00d 	mov	ip, sp
21f0b7d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b7d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b7d8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0b7dc:	e50b0014 	str	r0, [fp, #-20]
	IPaddr_t tmp_ip;

	NetCopyIP(&NetOurIP, &bp->bp_yiaddr);
21f0b7e0:	e51b3014 	ldr	r3, [fp, #-20]
21f0b7e4:	e2833010 	add	r3, r3, #16	; 0x10
21f0b7e8:	e59f00b0 	ldr	r0, [pc, #176]	; 21f0b8a0 <.text+0xb8a0>
21f0b7ec:	e1a01003 	mov	r1, r3
21f0b7f0:	eb000030 	bl	21f0b8b8 <NetCopyIP>
	NetCopyIP(&tmp_ip, &bp->bp_siaddr);
21f0b7f4:	e51b3014 	ldr	r3, [fp, #-20]
21f0b7f8:	e2832014 	add	r2, r3, #20	; 0x14
21f0b7fc:	e24b3010 	sub	r3, fp, #16	; 0x10
21f0b800:	e1a00003 	mov	r0, r3
21f0b804:	e1a01002 	mov	r1, r2
21f0b808:	eb00002a 	bl	21f0b8b8 <NetCopyIP>
	if (tmp_ip != 0)
21f0b80c:	e51b3010 	ldr	r3, [fp, #-16]
21f0b810:	e3530000 	cmp	r3, #0	; 0x0
21f0b814:	0a000004 	beq	21f0b82c <BootpCopyNetParams+0x60>
		NetCopyIP(&NetServerIP, &bp->bp_siaddr);
21f0b818:	e51b3014 	ldr	r3, [fp, #-20]
21f0b81c:	e2833014 	add	r3, r3, #20	; 0x14
21f0b820:	e59f007c 	ldr	r0, [pc, #124]	; 21f0b8a4 <.text+0xb8a4>
21f0b824:	e1a01003 	mov	r1, r3
21f0b828:	eb000022 	bl	21f0b8b8 <NetCopyIP>
	memcpy (NetServerEther, ((Ethernet_t *)NetRxPkt)->et_src, 6);
21f0b82c:	e59f3074 	ldr	r3, [pc, #116]	; 21f0b8a8 <.text+0xb8a8>
21f0b830:	e5933000 	ldr	r3, [r3]
21f0b834:	e2833006 	add	r3, r3, #6	; 0x6
21f0b838:	e59f006c 	ldr	r0, [pc, #108]	; 21f0b8ac <.text+0xb8ac>
21f0b83c:	e1a01003 	mov	r1, r3
21f0b840:	e3a02006 	mov	r2, #6	; 0x6
21f0b844:	eb005e60 	bl	21f231cc <memcpy>
	if (strlen(bp->bp_file) > 0)
21f0b848:	e51b3014 	ldr	r3, [fp, #-20]
21f0b84c:	e283306c 	add	r3, r3, #108	; 0x6c
21f0b850:	e1a00003 	mov	r0, r3
21f0b854:	eb005cda 	bl	21f22bc4 <strlen>
21f0b858:	e1a03000 	mov	r3, r0
21f0b85c:	e3530000 	cmp	r3, #0	; 0x0
21f0b860:	0a000005 	beq	21f0b87c <BootpCopyNetParams+0xb0>
		copy_filename (BootFile, bp->bp_file, sizeof(BootFile));
21f0b864:	e51b3014 	ldr	r3, [fp, #-20]
21f0b868:	e283306c 	add	r3, r3, #108	; 0x6c
21f0b86c:	e59f003c 	ldr	r0, [pc, #60]	; 21f0b8b0 <.text+0xb8b0>
21f0b870:	e1a01003 	mov	r1, r3
21f0b874:	e3a02080 	mov	r2, #128	; 0x80
21f0b878:	ebfffb70 	bl	21f0a640 <copy_filename>

	debug ("Bootfile: %s\n", BootFile);

	/* Propagate to environment:
	 * don't delete exising entry when BOOTP / DHCP reply does
	 * not contain a new value
	 */
	if (*BootFile) {
21f0b87c:	e59f302c 	ldr	r3, [pc, #44]	; 21f0b8b0 <.text+0xb8b0>
21f0b880:	e5d33000 	ldrb	r3, [r3]
21f0b884:	e3530000 	cmp	r3, #0	; 0x0
21f0b888:	0a000002 	beq	21f0b898 <BootpCopyNetParams+0xcc>
		setenv ("bootfile", BootFile);
21f0b88c:	e59f0020 	ldr	r0, [pc, #32]	; 21f0b8b4 <.text+0xb8b4>
21f0b890:	e59f1018 	ldr	r1, [pc, #24]	; 21f0b8b0 <.text+0xb8b0>
21f0b894:	eb003cab 	bl	21f1ab48 <setenv>
	}
}
21f0b898:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0b89c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0b8a0:	21f6455c 	mvncss	r4, ip, asr r5
21f0b8a4:	21f64560 	mvncss	r4, r0, ror #10
21f0b8a8:	21f64574 	mvncss	r4, r4, ror r5
21f0b8ac:	21f6453e 	mvncss	r4, lr, lsr r5
21f0b8b0:	21f64584 	mvncss	r4, r4, lsl #11
21f0b8b4:	21f2f81c 	mvncss	pc, ip, lsl r8

21f0b8b8 <NetCopyIP>:
}

/* copy IP */
static inline void NetCopyIP(void *to, void *from)
{
21f0b8b8:	e1a0c00d 	mov	ip, sp
21f0b8bc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b8c0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b8c4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0b8c8:	e50b0010 	str	r0, [fp, #-16]
21f0b8cc:	e50b1014 	str	r1, [fp, #-20]
	memcpy(to, from, sizeof(IPaddr_t));
21f0b8d0:	e51b0010 	ldr	r0, [fp, #-16]
21f0b8d4:	e51b1014 	ldr	r1, [fp, #-20]
21f0b8d8:	e3a02004 	mov	r2, #4	; 0x4
21f0b8dc:	eb005e3a 	bl	21f231cc <memcpy>
}
21f0b8e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0b8e4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0b8e8 <truncate_sz>:

static int truncate_sz (const char *name, int maxlen, int curlen)
{
21f0b8e8:	e1a0c00d 	mov	ip, sp
21f0b8ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b8f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b8f4:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0b8f8:	e50b0010 	str	r0, [fp, #-16]
21f0b8fc:	e50b1014 	str	r1, [fp, #-20]
21f0b900:	e50b2018 	str	r2, [fp, #-24]
	if (curlen >= maxlen) {
21f0b904:	e51b2018 	ldr	r2, [fp, #-24]
21f0b908:	e51b3014 	ldr	r3, [fp, #-20]
21f0b90c:	e1520003 	cmp	r2, r3
21f0b910:	ba000007 	blt	21f0b934 <truncate_sz+0x4c>
		printf("*** WARNING: %s is too long (%d - max: %d) - truncated\n",
21f0b914:	e59f0028 	ldr	r0, [pc, #40]	; 21f0b944 <.text+0xb944>
21f0b918:	e51b1010 	ldr	r1, [fp, #-16]
21f0b91c:	e51b2018 	ldr	r2, [fp, #-24]
21f0b920:	e51b3014 	ldr	r3, [fp, #-20]
21f0b924:	eb004058 	bl	21f1ba8c <printf>
			name, curlen, maxlen);
		curlen = maxlen - 1;
21f0b928:	e51b3014 	ldr	r3, [fp, #-20]
21f0b92c:	e2433001 	sub	r3, r3, #1	; 0x1
21f0b930:	e50b3018 	str	r3, [fp, #-24]
	}
	return (curlen);
21f0b934:	e51b3018 	ldr	r3, [fp, #-24]
}
21f0b938:	e1a00003 	mov	r0, r3
21f0b93c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0b940:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0b944:	21f2f828 	mvncss	pc, r8, lsr #16

21f0b948 <BootpTimeout>:

#if !(CONFIG_COMMANDS & CFG_CMD_DHCP)

static void BootpVendorFieldProcess (u8 * ext)
{
	int size = *(ext + 1);

	debug_ext ("[BOOTP] Processing extension %d... (%d bytes)\n", *ext,
		   *(ext + 1));

	NetBootFileSize = 0;

	switch (*ext) {
		/* Fixed length fields */
	case 1:			/* Subnet mask                                  */
		if (NetOurSubnetMask == 0)
			NetCopyIP (&NetOurSubnetMask, (IPaddr_t *) (ext + 2));
		break;
	case 2:			/* Time offset - Not yet supported              */
		break;
		/* Variable length fields */
	case 3:			/* Gateways list                                */
		if (NetOurGatewayIP == 0) {
			NetCopyIP (&NetOurGatewayIP, (IPaddr_t *) (ext + 2));
		}
		break;
	case 4:			/* Time server - Not yet supported              */
		break;
	case 5:			/* IEN-116 name server - Not yet supported      */
		break;
	case 6:
		if (NetOurDNSIP == 0) {
			NetCopyIP (&NetOurDNSIP, (IPaddr_t *) (ext + 2));
		}
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_DNS2)
		if ((NetOurDNS2IP == 0) && (size > 4)) {
			NetCopyIP (&NetOurDNS2IP, (IPaddr_t *) (ext + 2 + 4));
		}
#endif
		break;
	case 7:			/* Log server - Not yet supported               */
		break;
	case 8:			/* Cookie/Quote server - Not yet supported      */
		break;
	case 9:			/* LPR server - Not yet supported               */
		break;
	case 10:		/* Impress server - Not yet supported           */
		break;
	case 11:		/* RPL server - Not yet supported               */
		break;
	case 12:		/* Host name                                    */
		if (NetOurHostName[0] == 0) {
			size = truncate_sz ("Host Name", sizeof (NetOurHostName), size);
			memcpy (&NetOurHostName, ext + 2, size);
			NetOurHostName[size] = 0;
		}
		break;
	case 13:		/* Boot file size                               */
		if (size == 2)
			NetBootFileSize = ntohs (*(ushort *) (ext + 2));
		else if (size == 4)
			NetBootFileSize = ntohl (*(ulong *) (ext + 2));
		break;
	case 14:		/* Merit dump file - Not yet supported          */
		break;
	case 15:		/* Domain name - Not yet supported              */
		break;
	case 16:		/* Swap server - Not yet supported              */
		break;
	case 17:		/* Root path                                    */
		if (NetOurRootPath[0] == 0) {
			size = truncate_sz ("Root Path", sizeof (NetOurRootPath), size);
			memcpy (&NetOurRootPath, ext + 2, size);
			NetOurRootPath[size] = 0;
		}
		break;
	case 18:		/* Extension path - Not yet supported           */
		/*
		 * This can be used to send the information of the
		 * vendor area in another file that the client can
		 * access via TFTP.
		 */
		break;
		/* IP host layer fields */
	case 40:		/* NIS Domain name                              */
		if (NetOurNISDomain[0] == 0) {
			size = truncate_sz ("NIS Domain Name", sizeof (NetOurNISDomain), size);
			memcpy (&NetOurNISDomain, ext + 2, size);
			NetOurNISDomain[size] = 0;
		}
		break;
		/* Application layer fields */
	case 43:		/* Vendor specific info - Not yet supported     */
		/*
		 * Binary information to exchange specific
		 * product information.
		 */
		break;
		/* Reserved (custom) fields (128..254) */
	}
}

static void BootpVendorProcess (u8 * ext, int size)
{
	u8 *end = ext + size;

	debug_ext ("[BOOTP] Checking extension (%d bytes)...\n", size);

	while ((ext < end) && (*ext != 0xff)) {
		if (*ext == 0) {
			ext++;
		} else {
			u8 *opt = ext;

			ext += ext[1] + 2;
			if (ext <= end)
				BootpVendorFieldProcess (opt);
		}
	}

#ifdef DEBUG_BOOTP_EXT
	puts ("[BOOTP] Received fields: \n");
	if (NetOurSubnetMask) {
		puts ("NetOurSubnetMask : ");
		print_IPaddr (NetOurSubnetMask);
		putc ('\n');
	}

	if (NetOurGatewayIP) {
		puts ("NetOurGatewayIP	: ");
		print_IPaddr (NetOurGatewayIP);
		putc ('\n');
	}

	if (NetBootFileSize) {
		printf ("NetBootFileSize : %d\n", NetBootFileSize);
	}

	if (NetOurHostName[0]) {
		printf ("NetOurHostName  : %s\n", NetOurHostName);
	}

	if (NetOurRootPath[0]) {
		printf ("NetOurRootPath  : %s\n", NetOurRootPath);
	}

	if (NetOurNISDomain[0]) {
		printf ("NetOurNISDomain : %s\n", NetOurNISDomain);
	}

	if (NetBootFileSize) {
		printf ("NetBootFileSize: %d\n", NetBootFileSize);
	}
#endif /* DEBUG_BOOTP_EXT */
}
/*
 *	Handle a BOOTP received packet.
 */
static void
BootpHandler(uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
	Bootp_t *bp;
	char	*s;

	debug ("got BOOTP packet (src=%d, dst=%d, len=%d want_len=%d)\n",
		src, dest, len, sizeof (Bootp_t));

	bp = (Bootp_t *)pkt;

	if (BootpCheckPkt(pkt, dest, src, len)) /* Filter out pkts we don't want */
		return;

	/*
	 *	Got a good BOOTP reply.	 Copy the data into our variables.
	 */
#ifdef CONFIG_STATUS_LED
	status_led_set (STATUS_LED_BOOT, STATUS_LED_OFF);
#endif

	BootpCopyNetParams(bp);		/* Store net parameters from reply */

	/* Retrieve extended information (we must parse the vendor area) */
	if (NetReadLong((ulong*)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
		BootpVendorProcess((uchar *)&bp->bp_vend[4], len);

	NetSetTimeout(0, (thand_f *)0);

	debug ("Got good BOOTP\n");

	if ((s = getenv("autoload")) != NULL) {
		if (*s == 'n') {
			/*
			 * Just use BOOTP to configure system;
			 * Do not use TFTP to load the bootfile.
			 */
			NetState = NETLOOP_SUCCESS;
			return;
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
		} else if (strcmp(s, "NFS") == 0) {
			/*
			 * Use NFS to load the bootfile.
			 */
			NfsStart();
			return;
#endif
		}
	}

	TftpStart();
}
#endif	/* !CFG_CMD_DHCP */

/*
 *	Timeout on BOOTP/DHCP request.
 */
static void
BootpTimeout(void)
{
21f0b948:	e1a0c00d 	mov	ip, sp
21f0b94c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b950:	e24cb004 	sub	fp, ip, #4	; 0x4
	if (BootpTry >= TIMEOUT_COUNT) {
21f0b954:	e59f3030 	ldr	r3, [pc, #48]	; 21f0b98c <.text+0xb98c>
21f0b958:	e5933000 	ldr	r3, [r3]
21f0b95c:	e3530013 	cmp	r3, #19	; 0x13
21f0b960:	da000003 	ble	21f0b974 <BootpTimeout+0x2c>
		puts ("\nRetry count exceeded; starting again\n");
21f0b964:	e59f0024 	ldr	r0, [pc, #36]	; 21f0b990 <.text+0xb990>
21f0b968:	eb004034 	bl	21f1ba40 <puts>
		NetStartAgain ();
21f0b96c:	ebfff68c 	bl	21f093a4 <NetStartAgain>
21f0b970:	ea000004 	b	21f0b988 <BootpTimeout+0x40>
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, BootpTimeout);
21f0b974:	e3a00d4e 	mov	r0, #4992	; 0x1380
21f0b978:	e2800008 	add	r0, r0, #8	; 0x8
21f0b97c:	e59f1010 	ldr	r1, [pc, #16]	; 21f0b994 <.text+0xb994>
21f0b980:	ebfff6c6 	bl	21f094a0 <NetSetTimeout>
		BootpRequest ();
21f0b984:	eb00012c 	bl	21f0be3c <BootpRequest>
	}
}
21f0b988:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0b98c:	21f66ab4 	ldrcsh	r6, [r6, #164]!
21f0b990:	21f2f860 	mvncss	pc, r0, ror #16
21f0b994:	21f0b948 	mvncss	fp, r8, asr #18

21f0b998 <DhcpExtended>:

/*
 *	Initialize BOOTP extension fields in the request.
 */
#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
static int DhcpExtended (u8 * e, int message_type, IPaddr_t ServerID, IPaddr_t RequestedIP)
{
21f0b998:	e1a0c00d 	mov	ip, sp
21f0b99c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0b9a0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0b9a4:	e24dd020 	sub	sp, sp, #32	; 0x20
21f0b9a8:	e50b0020 	str	r0, [fp, #-32]
21f0b9ac:	e50b1024 	str	r1, [fp, #-36]
21f0b9b0:	e50b2028 	str	r2, [fp, #-40]
21f0b9b4:	e50b302c 	str	r3, [fp, #-44]
	u8 *start = e;
21f0b9b8:	e51b3020 	ldr	r3, [fp, #-32]
21f0b9bc:	e50b301c 	str	r3, [fp, #-28]
	u8 *cnt;

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_VENDOREX)
	u8 *x;
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_SEND_HOSTNAME)
	char *hostname;
#endif

	*e++ = 99;		/* RFC1048 Magic Cookie */
21f0b9c0:	e51b2020 	ldr	r2, [fp, #-32]
21f0b9c4:	e3a03063 	mov	r3, #99	; 0x63
21f0b9c8:	e5c23000 	strb	r3, [r2]
21f0b9cc:	e51b3020 	ldr	r3, [fp, #-32]
21f0b9d0:	e2833001 	add	r3, r3, #1	; 0x1
21f0b9d4:	e50b3020 	str	r3, [fp, #-32]
	*e++ = 130;
21f0b9d8:	e51b2020 	ldr	r2, [fp, #-32]
21f0b9dc:	e3e0307d 	mvn	r3, #125	; 0x7d
21f0b9e0:	e5c23000 	strb	r3, [r2]
21f0b9e4:	e51b3020 	ldr	r3, [fp, #-32]
21f0b9e8:	e2833001 	add	r3, r3, #1	; 0x1
21f0b9ec:	e50b3020 	str	r3, [fp, #-32]
	*e++ = 83;
21f0b9f0:	e51b2020 	ldr	r2, [fp, #-32]
21f0b9f4:	e3a03053 	mov	r3, #83	; 0x53
21f0b9f8:	e5c23000 	strb	r3, [r2]
21f0b9fc:	e51b3020 	ldr	r3, [fp, #-32]
21f0ba00:	e2833001 	add	r3, r3, #1	; 0x1
21f0ba04:	e50b3020 	str	r3, [fp, #-32]
	*e++ = 99;
21f0ba08:	e51b2020 	ldr	r2, [fp, #-32]
21f0ba0c:	e3a03063 	mov	r3, #99	; 0x63
21f0ba10:	e5c23000 	strb	r3, [r2]
21f0ba14:	e51b3020 	ldr	r3, [fp, #-32]
21f0ba18:	e2833001 	add	r3, r3, #1	; 0x1
21f0ba1c:	e50b3020 	str	r3, [fp, #-32]

	*e++ = 53;		/* DHCP Message Type */
21f0ba20:	e51b2020 	ldr	r2, [fp, #-32]
21f0ba24:	e3a03035 	mov	r3, #53	; 0x35
21f0ba28:	e5c23000 	strb	r3, [r2]
21f0ba2c:	e51b3020 	ldr	r3, [fp, #-32]
21f0ba30:	e2833001 	add	r3, r3, #1	; 0x1
21f0ba34:	e50b3020 	str	r3, [fp, #-32]
	*e++ = 1;
21f0ba38:	e51b2020 	ldr	r2, [fp, #-32]
21f0ba3c:	e3a03001 	mov	r3, #1	; 0x1
21f0ba40:	e5c23000 	strb	r3, [r2]
21f0ba44:	e51b3020 	ldr	r3, [fp, #-32]
21f0ba48:	e2833001 	add	r3, r3, #1	; 0x1
21f0ba4c:	e50b3020 	str	r3, [fp, #-32]
	*e++ = message_type;
21f0ba50:	e51b3024 	ldr	r3, [fp, #-36]
21f0ba54:	e20330ff 	and	r3, r3, #255	; 0xff
21f0ba58:	e51b2020 	ldr	r2, [fp, #-32]
21f0ba5c:	e5c23000 	strb	r3, [r2]
21f0ba60:	e51b3020 	ldr	r3, [fp, #-32]
21f0ba64:	e2833001 	add	r3, r3, #1	; 0x1
21f0ba68:	e50b3020 	str	r3, [fp, #-32]

	*e++ = 57;		/* Maximum DHCP Message Size */
21f0ba6c:	e51b2020 	ldr	r2, [fp, #-32]
21f0ba70:	e3a03039 	mov	r3, #57	; 0x39
21f0ba74:	e5c23000 	strb	r3, [r2]
21f0ba78:	e51b3020 	ldr	r3, [fp, #-32]
21f0ba7c:	e2833001 	add	r3, r3, #1	; 0x1
21f0ba80:	e50b3020 	str	r3, [fp, #-32]
	*e++ = 2;
21f0ba84:	e51b2020 	ldr	r2, [fp, #-32]
21f0ba88:	e3a03002 	mov	r3, #2	; 0x2
21f0ba8c:	e5c23000 	strb	r3, [r2]
21f0ba90:	e51b3020 	ldr	r3, [fp, #-32]
21f0ba94:	e2833001 	add	r3, r3, #1	; 0x1
21f0ba98:	e50b3020 	str	r3, [fp, #-32]
	*e++ = (576 - 312 + OPT_SIZE) >> 8;
21f0ba9c:	e51b2020 	ldr	r2, [fp, #-32]
21f0baa0:	e3a03002 	mov	r3, #2	; 0x2
21f0baa4:	e5c23000 	strb	r3, [r2]
21f0baa8:	e51b3020 	ldr	r3, [fp, #-32]
21f0baac:	e2833001 	add	r3, r3, #1	; 0x1
21f0bab0:	e50b3020 	str	r3, [fp, #-32]
	*e++ = (576 - 312 + OPT_SIZE) & 0xff;
21f0bab4:	e51b2020 	ldr	r2, [fp, #-32]
21f0bab8:	e3a03040 	mov	r3, #64	; 0x40
21f0babc:	e5c23000 	strb	r3, [r2]
21f0bac0:	e51b3020 	ldr	r3, [fp, #-32]
21f0bac4:	e2833001 	add	r3, r3, #1	; 0x1
21f0bac8:	e50b3020 	str	r3, [fp, #-32]

	if (ServerID) {
21f0bacc:	e51b3028 	ldr	r3, [fp, #-40]
21f0bad0:	e3530000 	cmp	r3, #0	; 0x0
21f0bad4:	0a000032 	beq	21f0bba4 <DhcpExtended+0x20c>
		int tmp = ntohl (ServerID);
21f0bad8:	e51b0028 	ldr	r0, [fp, #-40]
21f0badc:	eb0000c0 	bl	21f0bde4 <__fswab32>
21f0bae0:	e1a03000 	mov	r3, r0
21f0bae4:	e50b3014 	str	r3, [fp, #-20]

		*e++ = 54;	/* ServerID */
21f0bae8:	e51b2020 	ldr	r2, [fp, #-32]
21f0baec:	e3a03036 	mov	r3, #54	; 0x36
21f0baf0:	e5c23000 	strb	r3, [r2]
21f0baf4:	e51b3020 	ldr	r3, [fp, #-32]
21f0baf8:	e2833001 	add	r3, r3, #1	; 0x1
21f0bafc:	e50b3020 	str	r3, [fp, #-32]
		*e++ = 4;
21f0bb00:	e51b2020 	ldr	r2, [fp, #-32]
21f0bb04:	e3a03004 	mov	r3, #4	; 0x4
21f0bb08:	e5c23000 	strb	r3, [r2]
21f0bb0c:	e51b3020 	ldr	r3, [fp, #-32]
21f0bb10:	e2833001 	add	r3, r3, #1	; 0x1
21f0bb14:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp >> 24;
21f0bb18:	e51b3014 	ldr	r3, [fp, #-20]
21f0bb1c:	e1a03c43 	mov	r3, r3, asr #24
21f0bb20:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bb24:	e51b2020 	ldr	r2, [fp, #-32]
21f0bb28:	e5c23000 	strb	r3, [r2]
21f0bb2c:	e51b3020 	ldr	r3, [fp, #-32]
21f0bb30:	e2833001 	add	r3, r3, #1	; 0x1
21f0bb34:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp >> 16;
21f0bb38:	e51b3014 	ldr	r3, [fp, #-20]
21f0bb3c:	e1a03843 	mov	r3, r3, asr #16
21f0bb40:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bb44:	e51b2020 	ldr	r2, [fp, #-32]
21f0bb48:	e5c23000 	strb	r3, [r2]
21f0bb4c:	e51b3020 	ldr	r3, [fp, #-32]
21f0bb50:	e2833001 	add	r3, r3, #1	; 0x1
21f0bb54:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp >> 8;
21f0bb58:	e51b3014 	ldr	r3, [fp, #-20]
21f0bb5c:	e1a03443 	mov	r3, r3, asr #8
21f0bb60:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bb64:	e51b2020 	ldr	r2, [fp, #-32]
21f0bb68:	e5c23000 	strb	r3, [r2]
21f0bb6c:	e51b3020 	ldr	r3, [fp, #-32]
21f0bb70:	e2833001 	add	r3, r3, #1	; 0x1
21f0bb74:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp & 0xff;
21f0bb78:	e51b3014 	ldr	r3, [fp, #-20]
21f0bb7c:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bb80:	e20320ff 	and	r2, r3, #255	; 0xff
21f0bb84:	e3a030ff 	mov	r3, #255	; 0xff
21f0bb88:	e0023003 	and	r3, r2, r3
21f0bb8c:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bb90:	e51b2020 	ldr	r2, [fp, #-32]
21f0bb94:	e5c23000 	strb	r3, [r2]
21f0bb98:	e51b3020 	ldr	r3, [fp, #-32]
21f0bb9c:	e2833001 	add	r3, r3, #1	; 0x1
21f0bba0:	e50b3020 	str	r3, [fp, #-32]
	}

	if (RequestedIP) {
21f0bba4:	e51b302c 	ldr	r3, [fp, #-44]
21f0bba8:	e3530000 	cmp	r3, #0	; 0x0
21f0bbac:	0a000032 	beq	21f0bc7c <DhcpExtended+0x2e4>
		int tmp = ntohl (RequestedIP);
21f0bbb0:	e51b002c 	ldr	r0, [fp, #-44]
21f0bbb4:	eb00008a 	bl	21f0bde4 <__fswab32>
21f0bbb8:	e1a03000 	mov	r3, r0
21f0bbbc:	e50b3010 	str	r3, [fp, #-16]

		*e++ = 50;	/* Requested IP */
21f0bbc0:	e51b2020 	ldr	r2, [fp, #-32]
21f0bbc4:	e3a03032 	mov	r3, #50	; 0x32
21f0bbc8:	e5c23000 	strb	r3, [r2]
21f0bbcc:	e51b3020 	ldr	r3, [fp, #-32]
21f0bbd0:	e2833001 	add	r3, r3, #1	; 0x1
21f0bbd4:	e50b3020 	str	r3, [fp, #-32]
		*e++ = 4;
21f0bbd8:	e51b2020 	ldr	r2, [fp, #-32]
21f0bbdc:	e3a03004 	mov	r3, #4	; 0x4
21f0bbe0:	e5c23000 	strb	r3, [r2]
21f0bbe4:	e51b3020 	ldr	r3, [fp, #-32]
21f0bbe8:	e2833001 	add	r3, r3, #1	; 0x1
21f0bbec:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp >> 24;
21f0bbf0:	e51b3010 	ldr	r3, [fp, #-16]
21f0bbf4:	e1a03c43 	mov	r3, r3, asr #24
21f0bbf8:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bbfc:	e51b2020 	ldr	r2, [fp, #-32]
21f0bc00:	e5c23000 	strb	r3, [r2]
21f0bc04:	e51b3020 	ldr	r3, [fp, #-32]
21f0bc08:	e2833001 	add	r3, r3, #1	; 0x1
21f0bc0c:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp >> 16;
21f0bc10:	e51b3010 	ldr	r3, [fp, #-16]
21f0bc14:	e1a03843 	mov	r3, r3, asr #16
21f0bc18:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bc1c:	e51b2020 	ldr	r2, [fp, #-32]
21f0bc20:	e5c23000 	strb	r3, [r2]
21f0bc24:	e51b3020 	ldr	r3, [fp, #-32]
21f0bc28:	e2833001 	add	r3, r3, #1	; 0x1
21f0bc2c:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp >> 8;
21f0bc30:	e51b3010 	ldr	r3, [fp, #-16]
21f0bc34:	e1a03443 	mov	r3, r3, asr #8
21f0bc38:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bc3c:	e51b2020 	ldr	r2, [fp, #-32]
21f0bc40:	e5c23000 	strb	r3, [r2]
21f0bc44:	e51b3020 	ldr	r3, [fp, #-32]
21f0bc48:	e2833001 	add	r3, r3, #1	; 0x1
21f0bc4c:	e50b3020 	str	r3, [fp, #-32]
		*e++ = tmp & 0xff;
21f0bc50:	e51b3010 	ldr	r3, [fp, #-16]
21f0bc54:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bc58:	e20320ff 	and	r2, r3, #255	; 0xff
21f0bc5c:	e3a030ff 	mov	r3, #255	; 0xff
21f0bc60:	e0023003 	and	r3, r2, r3
21f0bc64:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bc68:	e51b2020 	ldr	r2, [fp, #-32]
21f0bc6c:	e5c23000 	strb	r3, [r2]
21f0bc70:	e51b3020 	ldr	r3, [fp, #-32]
21f0bc74:	e2833001 	add	r3, r3, #1	; 0x1
21f0bc78:	e50b3020 	str	r3, [fp, #-32]
	}
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_SEND_HOSTNAME)
	if ((hostname = getenv ("hostname"))) {
		int hostnamelen = strlen (hostname);

		*e++ = 12;	/* Hostname */
		*e++ = hostnamelen;
		memcpy (e, hostname, hostnamelen);
		e += hostnamelen;
	}
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_VENDOREX)
	if ((x = dhcp_vendorex_prep (e)))
		return x - start;
#endif

	*e++ = 55;		/* Parameter Request List */
21f0bc7c:	e51b2020 	ldr	r2, [fp, #-32]
21f0bc80:	e3a03037 	mov	r3, #55	; 0x37
21f0bc84:	e5c23000 	strb	r3, [r2]
21f0bc88:	e51b3020 	ldr	r3, [fp, #-32]
21f0bc8c:	e2833001 	add	r3, r3, #1	; 0x1
21f0bc90:	e50b3020 	str	r3, [fp, #-32]
	 cnt = e++;		/* Pointer to count of requested items */
21f0bc94:	e51b3020 	ldr	r3, [fp, #-32]
21f0bc98:	e50b3018 	str	r3, [fp, #-24]
21f0bc9c:	e51b3020 	ldr	r3, [fp, #-32]
21f0bca0:	e2833001 	add	r3, r3, #1	; 0x1
21f0bca4:	e50b3020 	str	r3, [fp, #-32]
	*cnt = 0;
21f0bca8:	e51b2018 	ldr	r2, [fp, #-24]
21f0bcac:	e3a03000 	mov	r3, #0	; 0x0
21f0bcb0:	e5c23000 	strb	r3, [r2]
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_SUBNETMASK)
	*e++  = 1;		/* Subnet Mask */
21f0bcb4:	e51b2020 	ldr	r2, [fp, #-32]
21f0bcb8:	e3a03001 	mov	r3, #1	; 0x1
21f0bcbc:	e5c23000 	strb	r3, [r2]
21f0bcc0:	e51b3020 	ldr	r3, [fp, #-32]
21f0bcc4:	e2833001 	add	r3, r3, #1	; 0x1
21f0bcc8:	e50b3020 	str	r3, [fp, #-32]
	*cnt += 1;
21f0bccc:	e51b3018 	ldr	r3, [fp, #-24]
21f0bcd0:	e5d33000 	ldrb	r3, [r3]
21f0bcd4:	e2833001 	add	r3, r3, #1	; 0x1
21f0bcd8:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bcdc:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bce0:	e51b2018 	ldr	r2, [fp, #-24]
21f0bce4:	e5c23000 	strb	r3, [r2]
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_TIMEOFFSET)
	*e++  = 2;
	*cnt += 1;
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_GATEWAY)
	*e++  = 3;		/* Router Option */
21f0bce8:	e51b2020 	ldr	r2, [fp, #-32]
21f0bcec:	e3a03003 	mov	r3, #3	; 0x3
21f0bcf0:	e5c23000 	strb	r3, [r2]
21f0bcf4:	e51b3020 	ldr	r3, [fp, #-32]
21f0bcf8:	e2833001 	add	r3, r3, #1	; 0x1
21f0bcfc:	e50b3020 	str	r3, [fp, #-32]
	*cnt += 1;
21f0bd00:	e51b3018 	ldr	r3, [fp, #-24]
21f0bd04:	e5d33000 	ldrb	r3, [r3]
21f0bd08:	e2833001 	add	r3, r3, #1	; 0x1
21f0bd0c:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bd10:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bd14:	e51b2018 	ldr	r2, [fp, #-24]
21f0bd18:	e5c23000 	strb	r3, [r2]
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_DNS)
	*e++  = 6;		/* DNS Server(s) */
	*cnt += 1;
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_HOSTNAME)
	*e++  = 12;		/* Hostname */
21f0bd1c:	e51b2020 	ldr	r2, [fp, #-32]
21f0bd20:	e3a0300c 	mov	r3, #12	; 0xc
21f0bd24:	e5c23000 	strb	r3, [r2]
21f0bd28:	e51b3020 	ldr	r3, [fp, #-32]
21f0bd2c:	e2833001 	add	r3, r3, #1	; 0x1
21f0bd30:	e50b3020 	str	r3, [fp, #-32]
	*cnt += 1;
21f0bd34:	e51b3018 	ldr	r3, [fp, #-24]
21f0bd38:	e5d33000 	ldrb	r3, [r3]
21f0bd3c:	e2833001 	add	r3, r3, #1	; 0x1
21f0bd40:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bd44:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bd48:	e51b2018 	ldr	r2, [fp, #-24]
21f0bd4c:	e5c23000 	strb	r3, [r2]
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_BOOTFILESIZE)
	*e++  = 13;		/* Boot File Size */
	*cnt += 1;
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_BOOTPATH)
	*e++  = 17;		/* Boot path */
21f0bd50:	e51b2020 	ldr	r2, [fp, #-32]
21f0bd54:	e3a03011 	mov	r3, #17	; 0x11
21f0bd58:	e5c23000 	strb	r3, [r2]
21f0bd5c:	e51b3020 	ldr	r3, [fp, #-32]
21f0bd60:	e2833001 	add	r3, r3, #1	; 0x1
21f0bd64:	e50b3020 	str	r3, [fp, #-32]
	*cnt += 1;
21f0bd68:	e51b3018 	ldr	r3, [fp, #-24]
21f0bd6c:	e5d33000 	ldrb	r3, [r3]
21f0bd70:	e2833001 	add	r3, r3, #1	; 0x1
21f0bd74:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bd78:	e20330ff 	and	r3, r3, #255	; 0xff
21f0bd7c:	e51b2018 	ldr	r2, [fp, #-24]
21f0bd80:	e5c23000 	strb	r3, [r2]
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_NISDOMAIN)
	*e++  = 40;		/* NIS Domain name request */
	*cnt += 1;
#endif
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_NTPSERVER)
	*e++  = 42;
	*cnt += 1;
#endif
	*e++  = 255;		/* End of the list */
21f0bd84:	e51b2020 	ldr	r2, [fp, #-32]
21f0bd88:	e3e03000 	mvn	r3, #0	; 0x0
21f0bd8c:	e5c23000 	strb	r3, [r2]
21f0bd90:	e51b3020 	ldr	r3, [fp, #-32]
21f0bd94:	e2833001 	add	r3, r3, #1	; 0x1
21f0bd98:	e50b3020 	str	r3, [fp, #-32]

	/* Pad to minimal length */
#ifdef	CONFIG_DHCP_MIN_EXT_LEN
	while ((e - start) <= CONFIG_DHCP_MIN_EXT_LEN)
21f0bd9c:	ea000005 	b	21f0bdb8 <DhcpExtended+0x420>
		*e++ = 0;
21f0bda0:	e51b2020 	ldr	r2, [fp, #-32]
21f0bda4:	e3a03000 	mov	r3, #0	; 0x0
21f0bda8:	e5c23000 	strb	r3, [r2]
21f0bdac:	e51b3020 	ldr	r3, [fp, #-32]
21f0bdb0:	e2833001 	add	r3, r3, #1	; 0x1
21f0bdb4:	e50b3020 	str	r3, [fp, #-32]
21f0bdb8:	e51b3020 	ldr	r3, [fp, #-32]
21f0bdbc:	e51b201c 	ldr	r2, [fp, #-28]
21f0bdc0:	e0623003 	rsb	r3, r2, r3
21f0bdc4:	e3530040 	cmp	r3, #64	; 0x40
21f0bdc8:	dafffff4 	ble	21f0bda0 <DhcpExtended+0x408>
#endif

	return e - start;
21f0bdcc:	e51b2020 	ldr	r2, [fp, #-32]
21f0bdd0:	e51b301c 	ldr	r3, [fp, #-28]
21f0bdd4:	e0633002 	rsb	r3, r3, r2
}
21f0bdd8:	e1a00003 	mov	r0, r3
21f0bddc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0bde0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0bde4 <__fswab32>:
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
21f0bde4:	e1a0c00d 	mov	ip, sp
21f0bde8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0bdec:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0bdf0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0bdf4:	e50b0010 	str	r0, [fp, #-16]
	return __arch__swab32(x);
21f0bdf8:	e51b3010 	ldr	r3, [fp, #-16]
21f0bdfc:	e20330ff 	and	r3, r3, #255	; 0xff
21f0be00:	e1a02c03 	mov	r2, r3, lsl #24
21f0be04:	e51b3010 	ldr	r3, [fp, #-16]
21f0be08:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f0be0c:	e1a03403 	mov	r3, r3, lsl #8
21f0be10:	e1822003 	orr	r2, r2, r3
21f0be14:	e51b3010 	ldr	r3, [fp, #-16]
21f0be18:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f0be1c:	e1a03423 	mov	r3, r3, lsr #8
21f0be20:	e1822003 	orr	r2, r2, r3
21f0be24:	e51b3010 	ldr	r3, [fp, #-16]
21f0be28:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
21f0be2c:	e1a03c23 	mov	r3, r3, lsr #24
21f0be30:	e1823003 	orr	r3, r2, r3
}
21f0be34:	e1a00003 	mov	r0, r3
21f0be38:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0be3c <BootpRequest>:

#else	/* CFG_CMD_DHCP */
/*
 *	Warning: no field size check - change CONFIG_BOOTP_MASK at your own risk!
 */
static int BootpExtended (u8 * e)
{
	u8 *start = e;

	*e++ = 99;		/* RFC1048 Magic Cookie */
	*e++ = 130;
	*e++ = 83;
	*e++ = 99;

#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
	*e++ = 53;		/* DHCP Message Type */
	*e++ = 1;
	*e++ = DHCP_DISCOVER;

	*e++ = 57;		/* Maximum DHCP Message Size */
	*e++ = 2;
	*e++ = (576 - 312 + OPT_SIZE) >> 16;
	*e++ = (576 - 312 + OPT_SIZE) & 0xff;
#endif /* CFG_CMD_DHCP */

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_SUBNETMASK)
	*e++ = 1;		/* Subnet mask request */
	*e++ = 4;
	e   += 4;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_GATEWAY)
	*e++ = 3;		/* Default gateway request */
	*e++ = 4;
	e   += 4;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_DNS)
	*e++ = 6;		/* Domain Name Server */
	*e++ = 4;
	e   += 4;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_HOSTNAME)
	*e++ = 12;		/* Host name request */
	*e++ = 32;
	e   += 32;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_BOOTFILESIZE)
	*e++ = 13;		/* Boot file size */
	*e++ = 2;
	e   += 2;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_BOOTPATH)
	*e++ = 17;		/* Boot path */
	*e++ = 32;
	e   += 32;
#endif

#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_NISDOMAIN)
	*e++ = 40;		/* NIS Domain name request */
	*e++ = 32;
	e   += 32;
#endif

	*e++ = 255;		/* End of the list */

	return e - start;
}
#endif	/* CFG_CMD_DHCP */

void
BootpRequest (void)
{
21f0be3c:	e1a0c00d 	mov	ip, sp
21f0be40:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0be44:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0be48:	e24dd01c 	sub	sp, sp, #28	; 0x1c
	volatile uchar *pkt, *iphdr;
	Bootp_t *bp;
	int ext_len, pktlen, iplen;

#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
	dhcp_state = INIT;
21f0be4c:	e59f22a4 	ldr	r2, [pc, #676]	; 21f0c0f8 <.text+0xc0f8>
21f0be50:	e3a03000 	mov	r3, #0	; 0x0
21f0be54:	e5823000 	str	r3, [r2]
#endif

#ifdef CONFIG_BOOTP_RANDOM_DELAY		/* Random BOOTP delay */
	unsigned char bi_enetaddr[6];
	int   reg;
	char  *e,*s;
	char tmp[64];
	ulong tst1, tst2, sum, m_mask, m_value = 0;

	if (BootpTry ==0) {
		/* get our mac */
		reg = getenv_r ("ethaddr", tmp, sizeof(tmp));
		s = (reg > 0) ? tmp : NULL;

		for (reg=0; reg<6; ++reg) {
			bi_enetaddr[reg] = s ? simple_strtoul(s, &e, 16) : 0;
			if (s) {
				s = (*e) ? e+1 : e;
			}
		}
#ifdef DEBUG
		puts ("BootpRequest => Our Mac: ");
		for (reg=0; reg<6; reg++) {
			printf ("%x%c",
				bi_enetaddr[reg],
				reg==5 ? '\n' : ':');
		}
#endif /* DEBUG */

		/* Mac-Manipulation 2 get seed1 */
		tst1=0;
		tst2=0;
		for (reg=2; reg<6; reg++) {
			tst1 = tst1 << 8;
			tst1 = tst1 | bi_enetaddr[reg];
		}
		for (reg=0; reg<2; reg++) {
			tst2 = tst2 | bi_enetaddr[reg];
			tst2 = tst2 << 8;
		}

		seed1 = tst1^tst2;

		/* Mirror seed1*/
		m_mask=0x1;
		for (reg=1;reg<=32;reg++) {
			m_value |= (m_mask & seed1);
			seed1 = seed1 >> 1;
			m_value = m_value << 1;
		}
		seed1 = m_value;
		seed2 = 0xB78D0945;
	}

	/* Random Number Generator */

	for (reg=0;reg<=0;reg++) {
		sum = seed1 + seed2;
		if (sum < seed1 || sum < seed2)
			sum++;
		seed2 = seed1;
		seed1 = sum;

		if (BootpTry<=2) {	/* Start with max 1024 * 1ms */
			sum = sum >> (22-BootpTry);
		} else {		/*After 3rd BOOTP request max 8192 * 1ms */
			sum = sum >> 19;
		}
	}

	printf ("Random delay: %ld ms...\n", sum);
	for (reg=0; reg <sum; reg++) {
		udelay(1000); /*Wait 1ms*/
	}
#endif	/* CONFIG_BOOTP_RANDOM_DELAY */

	printf("BOOTP broadcast %d\n", ++BootpTry);
21f0be58:	e59f329c 	ldr	r3, [pc, #668]	; 21f0c0fc <.text+0xc0fc>
21f0be5c:	e5933000 	ldr	r3, [r3]
21f0be60:	e2832001 	add	r2, r3, #1	; 0x1
21f0be64:	e59f3290 	ldr	r3, [pc, #656]	; 21f0c0fc <.text+0xc0fc>
21f0be68:	e5832000 	str	r2, [r3]
21f0be6c:	e59f3288 	ldr	r3, [pc, #648]	; 21f0c0fc <.text+0xc0fc>
21f0be70:	e5933000 	ldr	r3, [r3]
21f0be74:	e59f0284 	ldr	r0, [pc, #644]	; 21f0c100 <.text+0xc100>
21f0be78:	e1a01003 	mov	r1, r3
21f0be7c:	eb003f02 	bl	21f1ba8c <printf>
	pkt = NetTxPacket;
21f0be80:	e59f327c 	ldr	r3, [pc, #636]	; 21f0c104 <.text+0xc104>
21f0be84:	e5933000 	ldr	r3, [r3]
21f0be88:	e50b3024 	str	r3, [fp, #-36]
	memset ((void*)pkt, 0, PKTSIZE);
21f0be8c:	e51b0024 	ldr	r0, [fp, #-36]
21f0be90:	e3a01000 	mov	r1, #0	; 0x0
21f0be94:	e3a02e5e 	mov	r2, #1504	; 0x5e0
21f0be98:	e282200e 	add	r2, r2, #14	; 0xe
21f0be9c:	eb005c91 	bl	21f230e8 <memset>

	pkt += NetSetEther(pkt, NetBcastAddr, PROT_IP);
21f0bea0:	e51b0024 	ldr	r0, [fp, #-36]
21f0bea4:	e59f125c 	ldr	r1, [pc, #604]	; 21f0c108 <.text+0xc108>
21f0bea8:	e3a02b02 	mov	r2, #2048	; 0x800
21f0beac:	ebfff90b 	bl	21f0a2e0 <NetSetEther>
21f0beb0:	e1a03000 	mov	r3, r0
21f0beb4:	e1a02003 	mov	r2, r3
21f0beb8:	e51b3024 	ldr	r3, [fp, #-36]
21f0bebc:	e0833002 	add	r3, r3, r2
21f0bec0:	e50b3024 	str	r3, [fp, #-36]

	/*
	 * Next line results in incorrect packet size being transmitted, resulting
	 * in errors in some DHCP servers, reporting missing bytes.  Size must be
	 * set in packet header after extension length has been determined.
	 * C. Hallinan, DS4.COM, Inc.
	 */
	/* NetSetIP(pkt, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, sizeof (Bootp_t)); */
	iphdr = pkt;	/* We need this later for NetSetIP() */
21f0bec4:	e51b3024 	ldr	r3, [fp, #-36]
21f0bec8:	e50b3020 	str	r3, [fp, #-32]
	pkt += IP_HDR_SIZE;
21f0becc:	e51b3024 	ldr	r3, [fp, #-36]
21f0bed0:	e283301c 	add	r3, r3, #28	; 0x1c
21f0bed4:	e50b3024 	str	r3, [fp, #-36]

	bp = (Bootp_t *)pkt;
21f0bed8:	e51b3024 	ldr	r3, [fp, #-36]
21f0bedc:	e50b301c 	str	r3, [fp, #-28]
	bp->bp_op = OP_BOOTREQUEST;
21f0bee0:	e51b201c 	ldr	r2, [fp, #-28]
21f0bee4:	e3a03001 	mov	r3, #1	; 0x1
21f0bee8:	e5c23000 	strb	r3, [r2]
	bp->bp_htype = HWT_ETHER;
21f0beec:	e51b201c 	ldr	r2, [fp, #-28]
21f0bef0:	e3a03001 	mov	r3, #1	; 0x1
21f0bef4:	e5c23001 	strb	r3, [r2, #1]
	bp->bp_hlen = HWL_ETHER;
21f0bef8:	e51b201c 	ldr	r2, [fp, #-28]
21f0befc:	e3a03006 	mov	r3, #6	; 0x6
21f0bf00:	e5c23002 	strb	r3, [r2, #2]
	bp->bp_hops = 0;
21f0bf04:	e51b201c 	ldr	r2, [fp, #-28]
21f0bf08:	e3a03000 	mov	r3, #0	; 0x0
21f0bf0c:	e5c23003 	strb	r3, [r2, #3]
	bp->bp_secs = htons(get_timer(0) / CFG_HZ);
21f0bf10:	e3a00000 	mov	r0, #0	; 0x0
21f0bf14:	ebffd2ce 	bl	21f00a54 <get_timer>
21f0bf18:	e1a02000 	mov	r2, r0
21f0bf1c:	e59f31e8 	ldr	r3, [pc, #488]	; 21f0c10c <.text+0xc10c>
21f0bf20:	e0831392 	umull	r1, r3, r2, r3
21f0bf24:	e1a03323 	mov	r3, r3, lsr #6
21f0bf28:	e1a03803 	mov	r3, r3, lsl #16
21f0bf2c:	e1a03823 	mov	r3, r3, lsr #16
21f0bf30:	e1a00003 	mov	r0, r3
21f0bf34:	eb000093 	bl	21f0c188 <__fswab16>
21f0bf38:	e1a03000 	mov	r3, r0
21f0bf3c:	e1a02003 	mov	r2, r3
21f0bf40:	e51b301c 	ldr	r3, [fp, #-28]
21f0bf44:	e1c320b8 	strh	r2, [r3, #8]
	NetWriteIP(&bp->bp_ciaddr, 0);
21f0bf48:	e51b301c 	ldr	r3, [fp, #-28]
21f0bf4c:	e283300c 	add	r3, r3, #12	; 0xc
21f0bf50:	e1a00003 	mov	r0, r3
21f0bf54:	e3a01000 	mov	r1, #0	; 0x0
21f0bf58:	eb00007d 	bl	21f0c154 <NetWriteIP>
	NetWriteIP(&bp->bp_yiaddr, 0);
21f0bf5c:	e51b301c 	ldr	r3, [fp, #-28]
21f0bf60:	e2833010 	add	r3, r3, #16	; 0x10
21f0bf64:	e1a00003 	mov	r0, r3
21f0bf68:	e3a01000 	mov	r1, #0	; 0x0
21f0bf6c:	eb000078 	bl	21f0c154 <NetWriteIP>
	NetWriteIP(&bp->bp_siaddr, 0);
21f0bf70:	e51b301c 	ldr	r3, [fp, #-28]
21f0bf74:	e2833014 	add	r3, r3, #20	; 0x14
21f0bf78:	e1a00003 	mov	r0, r3
21f0bf7c:	e3a01000 	mov	r1, #0	; 0x0
21f0bf80:	eb000073 	bl	21f0c154 <NetWriteIP>
	NetWriteIP(&bp->bp_giaddr, 0);
21f0bf84:	e51b301c 	ldr	r3, [fp, #-28]
21f0bf88:	e2833018 	add	r3, r3, #24	; 0x18
21f0bf8c:	e1a00003 	mov	r0, r3
21f0bf90:	e3a01000 	mov	r1, #0	; 0x0
21f0bf94:	eb00006e 	bl	21f0c154 <NetWriteIP>
	memcpy (bp->bp_chaddr, NetOurEther, 6);
21f0bf98:	e51b301c 	ldr	r3, [fp, #-28]
21f0bf9c:	e283301c 	add	r3, r3, #28	; 0x1c
21f0bfa0:	e1a00003 	mov	r0, r3
21f0bfa4:	e59f1164 	ldr	r1, [pc, #356]	; 21f0c110 <.text+0xc110>
21f0bfa8:	e3a02006 	mov	r2, #6	; 0x6
21f0bfac:	eb005c86 	bl	21f231cc <memcpy>
	copy_filename (bp->bp_file, BootFile, sizeof(bp->bp_file));
21f0bfb0:	e51b301c 	ldr	r3, [fp, #-28]
21f0bfb4:	e283306c 	add	r3, r3, #108	; 0x6c
21f0bfb8:	e1a00003 	mov	r0, r3
21f0bfbc:	e59f1150 	ldr	r1, [pc, #336]	; 21f0c114 <.text+0xc114>
21f0bfc0:	e3a02080 	mov	r2, #128	; 0x80
21f0bfc4:	ebfff99d 	bl	21f0a640 <copy_filename>

	/* Request additional information from the BOOTP/DHCP server */
#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
	ext_len = DhcpExtended((u8 *)bp->bp_vend, DHCP_DISCOVER, 0, 0);
21f0bfc8:	e51b301c 	ldr	r3, [fp, #-28]
21f0bfcc:	e28330ec 	add	r3, r3, #236	; 0xec
21f0bfd0:	e1a00003 	mov	r0, r3
21f0bfd4:	e3a01001 	mov	r1, #1	; 0x1
21f0bfd8:	e3a02000 	mov	r2, #0	; 0x0
21f0bfdc:	e3a03000 	mov	r3, #0	; 0x0
21f0bfe0:	ebfffe6c 	bl	21f0b998 <DhcpExtended>
21f0bfe4:	e1a03000 	mov	r3, r0
21f0bfe8:	e50b3018 	str	r3, [fp, #-24]
#else
	ext_len = BootpExtended((u8 *)bp->bp_vend);
#endif	/* CFG_CMD_DHCP */

	/*
	 *	Bootp ID is the lower 4 bytes of our ethernet address
	 *	plus the current time in HZ.
	 */
	BootpID = ((ulong)NetOurEther[2] << 24)
21f0bfec:	e59f311c 	ldr	r3, [pc, #284]	; 21f0c110 <.text+0xc110>
21f0bff0:	e5d33002 	ldrb	r3, [r3, #2]
21f0bff4:	e1a02c03 	mov	r2, r3, lsl #24
21f0bff8:	e59f3110 	ldr	r3, [pc, #272]	; 21f0c110 <.text+0xc110>
21f0bffc:	e5d33003 	ldrb	r3, [r3, #3]
21f0c000:	e1a03803 	mov	r3, r3, lsl #16
21f0c004:	e1822003 	orr	r2, r2, r3
21f0c008:	e59f3100 	ldr	r3, [pc, #256]	; 21f0c110 <.text+0xc110>
21f0c00c:	e5d33004 	ldrb	r3, [r3, #4]
21f0c010:	e1a03403 	mov	r3, r3, lsl #8
21f0c014:	e1822003 	orr	r2, r2, r3
21f0c018:	e59f30f0 	ldr	r3, [pc, #240]	; 21f0c110 <.text+0xc110>
21f0c01c:	e5d33005 	ldrb	r3, [r3, #5]
21f0c020:	e1822003 	orr	r2, r2, r3
21f0c024:	e59f30ec 	ldr	r3, [pc, #236]	; 21f0c118 <.text+0xc118>
21f0c028:	e5832000 	str	r2, [r3]
		| ((ulong)NetOurEther[3] << 16)
		| ((ulong)NetOurEther[4] << 8)
		| (ulong)NetOurEther[5];
	BootpID += get_timer(0);
21f0c02c:	e3a00000 	mov	r0, #0	; 0x0
21f0c030:	ebffd287 	bl	21f00a54 <get_timer>
21f0c034:	e1a02000 	mov	r2, r0
21f0c038:	e59f30d8 	ldr	r3, [pc, #216]	; 21f0c118 <.text+0xc118>
21f0c03c:	e5933000 	ldr	r3, [r3]
21f0c040:	e0822003 	add	r2, r2, r3
21f0c044:	e59f30cc 	ldr	r3, [pc, #204]	; 21f0c118 <.text+0xc118>
21f0c048:	e5832000 	str	r2, [r3]
	BootpID	 = htonl(BootpID);
21f0c04c:	e59f30c4 	ldr	r3, [pc, #196]	; 21f0c118 <.text+0xc118>
21f0c050:	e5933000 	ldr	r3, [r3]
21f0c054:	e1a00003 	mov	r0, r3
21f0c058:	ebffff61 	bl	21f0bde4 <__fswab32>
21f0c05c:	e1a03000 	mov	r3, r0
21f0c060:	e1a02003 	mov	r2, r3
21f0c064:	e59f30ac 	ldr	r3, [pc, #172]	; 21f0c118 <.text+0xc118>
21f0c068:	e5832000 	str	r2, [r3]
	NetCopyLong(&bp->bp_id, &BootpID);
21f0c06c:	e51b301c 	ldr	r3, [fp, #-28]
21f0c070:	e2833004 	add	r3, r3, #4	; 0x4
21f0c074:	e1a00003 	mov	r0, r3
21f0c078:	e59f1098 	ldr	r1, [pc, #152]	; 21f0c118 <.text+0xc118>
21f0c07c:	eb000028 	bl	21f0c124 <NetCopyLong>

	/*
	 * Calculate proper packet lengths taking into account the
	 * variable size of the options field
	 */
	pktlen = BOOTP_SIZE - sizeof(bp->bp_vend) + ext_len;
21f0c080:	e51b3018 	ldr	r3, [fp, #-24]
21f0c084:	e2833f45 	add	r3, r3, #276	; 0x114
21f0c088:	e2833002 	add	r3, r3, #2	; 0x2
21f0c08c:	e50b3014 	str	r3, [fp, #-20]
	iplen = BOOTP_HDR_SIZE - sizeof(bp->bp_vend) + ext_len;
21f0c090:	e51b3018 	ldr	r3, [fp, #-24]
21f0c094:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c098:	e50b3010 	str	r3, [fp, #-16]
	NetSetIP(iphdr, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, iplen);
21f0c09c:	e51b3010 	ldr	r3, [fp, #-16]
21f0c0a0:	e58d3000 	str	r3, [sp]
21f0c0a4:	e51b0020 	ldr	r0, [fp, #-32]
21f0c0a8:	e3e01000 	mvn	r1, #0	; 0x0
21f0c0ac:	e3a02043 	mov	r2, #67	; 0x43
21f0c0b0:	e3a03044 	mov	r3, #68	; 0x44
21f0c0b4:	ebfff8df 	bl	21f0a438 <NetSetIP>
	NetSetTimeout(SELECT_TIMEOUT * CFG_HZ, BootpTimeout);
21f0c0b8:	e3a00ebb 	mov	r0, #2992	; 0xbb0
21f0c0bc:	e2800008 	add	r0, r0, #8	; 0x8
21f0c0c0:	e59f1054 	ldr	r1, [pc, #84]	; 21f0c11c <.text+0xc11c>
21f0c0c4:	ebfff4f5 	bl	21f094a0 <NetSetTimeout>

#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
	dhcp_state = SELECTING;
21f0c0c8:	e59f2028 	ldr	r2, [pc, #40]	; 21f0c0f8 <.text+0xc0f8>
21f0c0cc:	e3a03003 	mov	r3, #3	; 0x3
21f0c0d0:	e5823000 	str	r3, [r2]
	NetSetHandler(DhcpHandler);
21f0c0d4:	e59f0044 	ldr	r0, [pc, #68]	; 21f0c120 <.text+0xc120>
21f0c0d8:	ebfff4e6 	bl	21f09478 <NetSetHandler>
#else
	NetSetHandler(BootpHandler);
#endif	/* CFG_CMD_DHCP */
	NetSendPacket(NetTxPacket, pktlen);
21f0c0dc:	e59f3020 	ldr	r3, [pc, #32]	; 21f0c104 <.text+0xc104>
21f0c0e0:	e5933000 	ldr	r3, [r3]
21f0c0e4:	e1a00003 	mov	r0, r3
21f0c0e8:	e51b1014 	ldr	r1, [fp, #-20]
21f0c0ec:	ebfff508 	bl	21f09514 <NetSendPacket>
}
21f0c0f0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0c0f4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0c0f8:	21f66aa4 	mvncss	r6, r4, lsr #21
21f0c0fc:	21f66ab4 	ldrcsh	r6, [r6, #164]!
21f0c100:	21f2f888 	mvncss	pc, r8, lsl #17
21f0c104:	21f6454c 	mvncss	r4, ip, asr #10
21f0c108:	21f331cc 	mvncss	r3, ip, asr #3
21f0c10c:	10624dd3 	ldrned	r4, [r2], #-211
21f0c110:	21f64554 	mvncss	r4, r4, asr r5
21f0c114:	21f64584 	mvncss	r4, r4, lsl #11
21f0c118:	21f66ab0 	ldrcsh	r6, [r6, #160]!
21f0c11c:	21f0b948 	mvncss	fp, r8, asr #18
21f0c120:	21f0c82c 	mvncss	ip, ip, lsr #16

21f0c124 <NetCopyLong>:
}

/* copy ulong */
static inline void NetCopyLong(ulong *to, ulong *from)
{
21f0c124:	e1a0c00d 	mov	ip, sp
21f0c128:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0c12c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0c130:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0c134:	e50b0010 	str	r0, [fp, #-16]
21f0c138:	e50b1014 	str	r1, [fp, #-20]
	memcpy((void*)to, (void*)from, sizeof(ulong));
21f0c13c:	e51b0010 	ldr	r0, [fp, #-16]
21f0c140:	e51b1014 	ldr	r1, [fp, #-20]
21f0c144:	e3a02004 	mov	r2, #4	; 0x4
21f0c148:	eb005c1f 	bl	21f231cc <memcpy>
}
21f0c14c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0c150:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0c154 <NetWriteIP>:
21f0c154:	e1a0c00d 	mov	ip, sp
21f0c158:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0c15c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0c160:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0c164:	e50b0010 	str	r0, [fp, #-16]
21f0c168:	e50b1014 	str	r1, [fp, #-20]
21f0c16c:	e24b3014 	sub	r3, fp, #20	; 0x14
21f0c170:	e51b0010 	ldr	r0, [fp, #-16]
21f0c174:	e1a01003 	mov	r1, r3
21f0c178:	e3a02004 	mov	r2, #4	; 0x4
21f0c17c:	eb005c12 	bl	21f231cc <memcpy>
21f0c180:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0c184:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0c188 <__fswab16>:
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
21f0c188:	e1a0c00d 	mov	ip, sp
21f0c18c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0c190:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0c194:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0c198:	e1a03000 	mov	r3, r0
21f0c19c:	e14b31b0 	strh	r3, [fp, #-16]
	return __arch__swab16(x);
21f0c1a0:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0c1a4:	e20330ff 	and	r3, r3, #255	; 0xff
21f0c1a8:	e1a03403 	mov	r3, r3, lsl #8
21f0c1ac:	e1a03803 	mov	r3, r3, lsl #16
21f0c1b0:	e1a02823 	mov	r2, r3, lsr #16
21f0c1b4:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0c1b8:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f0c1bc:	e1a03443 	mov	r3, r3, asr #8
21f0c1c0:	e1a03803 	mov	r3, r3, lsl #16
21f0c1c4:	e1a03823 	mov	r3, r3, lsr #16
21f0c1c8:	e1823003 	orr	r3, r2, r3
21f0c1cc:	e1a03803 	mov	r3, r3, lsl #16
21f0c1d0:	e1a03823 	mov	r3, r3, lsr #16
21f0c1d4:	e1a03803 	mov	r3, r3, lsl #16
21f0c1d8:	e1a03823 	mov	r3, r3, lsr #16
}
21f0c1dc:	e1a00003 	mov	r0, r3
21f0c1e0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0c1e4 <DhcpOptionsProcess>:

#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
static void DhcpOptionsProcess (uchar * popt, Bootp_t *bp)
{
21f0c1e4:	e1a0c00d 	mov	ip, sp
21f0c1e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0c1ec:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0c1f0:	e24dd014 	sub	sp, sp, #20	; 0x14
21f0c1f4:	e50b001c 	str	r0, [fp, #-28]
21f0c1f8:	e50b1020 	str	r1, [fp, #-32]
	uchar *end = popt + BOOTP_HDR_SIZE;
21f0c1fc:	e51b301c 	ldr	r3, [fp, #-28]
21f0c200:	e2833f89 	add	r3, r3, #548	; 0x224
21f0c204:	e50b3018 	str	r3, [fp, #-24]
	int oplen, size;

	while (popt < end && *popt != 0xff) {
21f0c208:	ea0000b5 	b	21f0c4e4 <.text+0xc4e4>
		oplen = *(popt + 1);
21f0c20c:	e51b301c 	ldr	r3, [fp, #-28]
21f0c210:	e2833001 	add	r3, r3, #1	; 0x1
21f0c214:	e5d33000 	ldrb	r3, [r3]
21f0c218:	e50b3014 	str	r3, [fp, #-20]
		switch (*popt) {
21f0c21c:	e51b301c 	ldr	r3, [fp, #-28]
21f0c220:	e5d33000 	ldrb	r3, [r3]
21f0c224:	e2433001 	sub	r3, r3, #1	; 0x1
21f0c228:	e3530042 	cmp	r3, #66	; 0x42
21f0c22c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0c230:	ea0000a1 	b	21f0c4bc <.text+0xc4bc>
21f0c234:	21f0c340 	mvncss	ip, r0, asr #6
21f0c238:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c23c:	21f0c358 	mvncss	ip, r8, asr r3
21f0c240:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c244:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c248:	21f0c370 	mvncss	ip, r0, ror r3
21f0c24c:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c250:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c254:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c258:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c25c:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c260:	21f0c388 	mvncss	ip, r8, lsl #7
21f0c264:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c268:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c26c:	21f0c4d0 	ldrcssb	ip, [r0, #64]!
21f0c270:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c274:	21f0c3cc 	mvncss	ip, ip, asr #7
21f0c278:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c27c:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c280:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c284:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c288:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c28c:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c290:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c294:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c298:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c29c:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2a0:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2a4:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2a8:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2ac:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2b0:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2b4:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2b8:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2bc:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2c0:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2c4:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2c8:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2cc:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2d0:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2d4:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2d8:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2dc:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2e0:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2e4:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2e8:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2ec:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2f0:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2f4:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2f8:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c2fc:	21f0c410 	mvncss	ip, r0, lsl r4
21f0c300:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c304:	21f0c4d0 	ldrcssb	ip, [r0, #64]!
21f0c308:	21f0c428 	mvncss	ip, r8, lsr #8
21f0c30c:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c310:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c314:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c318:	21f0c4d0 	ldrcssb	ip, [r0, #64]!
21f0c31c:	21f0c4d0 	ldrcssb	ip, [r0, #64]!
21f0c320:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c324:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c328:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c32c:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c330:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c334:	21f0c4bc 	ldrcsh	ip, [r0, #76]!
21f0c338:	21f0c4d0 	ldrcssb	ip, [r0, #64]!
21f0c33c:	21f0c440 	mvncss	ip, r0, asr #8
		case 1:
			NetCopyIP (&NetOurSubnetMask, (popt + 2));
21f0c340:	e51b301c 	ldr	r3, [fp, #-28]
21f0c344:	e2833002 	add	r3, r3, #2	; 0x2
21f0c348:	e59f01bc 	ldr	r0, [pc, #444]	; 21f0c50c <.text+0xc50c>
21f0c34c:	e1a01003 	mov	r1, r3
21f0c350:	ebfffd58 	bl	21f0b8b8 <NetCopyIP>
			break;
21f0c354:	ea00005d 	b	21f0c4d0 <.text+0xc4d0>
#if (CONFIG_COMMANDS & CFG_CMD_SNTP) && (CONFIG_BOOTP_MASK & CONFIG_BOOTP_TIMEOFFSET)
		case 2:		/* Time offset	*/
			NetCopyLong (&NetTimeOffset, (ulong *) (popt + 2));
			NetTimeOffset = ntohl (NetTimeOffset);
			break;
#endif
		case 3:
			NetCopyIP (&NetOurGatewayIP, (popt + 2));
21f0c358:	e51b301c 	ldr	r3, [fp, #-28]
21f0c35c:	e2833002 	add	r3, r3, #2	; 0x2
21f0c360:	e59f01a8 	ldr	r0, [pc, #424]	; 21f0c510 <.text+0xc510>
21f0c364:	e1a01003 	mov	r1, r3
21f0c368:	ebfffd52 	bl	21f0b8b8 <NetCopyIP>
			break;
21f0c36c:	ea000057 	b	21f0c4d0 <.text+0xc4d0>
		case 6:
			NetCopyIP (&NetOurDNSIP, (popt + 2));
21f0c370:	e51b301c 	ldr	r3, [fp, #-28]
21f0c374:	e2833002 	add	r3, r3, #2	; 0x2
21f0c378:	e59f0194 	ldr	r0, [pc, #404]	; 21f0c514 <.text+0xc514>
21f0c37c:	e1a01003 	mov	r1, r3
21f0c380:	ebfffd4c 	bl	21f0b8b8 <NetCopyIP>
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_DNS2)
			if (*(popt + 1) > 4) {
				NetCopyIP (&NetOurDNS2IP, (popt + 2 + 4));
			}
#endif
			break;
21f0c384:	ea000051 	b	21f0c4d0 <.text+0xc4d0>
		case 12:
			size = truncate_sz ("Host Name", sizeof (NetOurHostName), oplen);
21f0c388:	e59f0188 	ldr	r0, [pc, #392]	; 21f0c518 <.text+0xc518>
21f0c38c:	e3a01020 	mov	r1, #32	; 0x20
21f0c390:	e51b2014 	ldr	r2, [fp, #-20]
21f0c394:	ebfffd53 	bl	21f0b8e8 <truncate_sz>
21f0c398:	e1a03000 	mov	r3, r0
21f0c39c:	e50b3010 	str	r3, [fp, #-16]
			memcpy (&NetOurHostName, popt + 2, size);
21f0c3a0:	e51b301c 	ldr	r3, [fp, #-28]
21f0c3a4:	e2833002 	add	r3, r3, #2	; 0x2
21f0c3a8:	e51b2010 	ldr	r2, [fp, #-16]
21f0c3ac:	e59f0168 	ldr	r0, [pc, #360]	; 21f0c51c <.text+0xc51c>
21f0c3b0:	e1a01003 	mov	r1, r3
21f0c3b4:	eb005b84 	bl	21f231cc <memcpy>
			NetOurHostName[size] = 0;
21f0c3b8:	e51b1010 	ldr	r1, [fp, #-16]
21f0c3bc:	e59f2158 	ldr	r2, [pc, #344]	; 21f0c51c <.text+0xc51c>
21f0c3c0:	e3a03000 	mov	r3, #0	; 0x0
21f0c3c4:	e7c23001 	strb	r3, [r2, r1]
			break;
21f0c3c8:	ea000040 	b	21f0c4d0 <.text+0xc4d0>
		case 15:	/* Ignore Domain Name Option */
			break;
		case 17:
			size = truncate_sz ("Root Path", sizeof (NetOurRootPath), oplen);
21f0c3cc:	e59f014c 	ldr	r0, [pc, #332]	; 21f0c520 <.text+0xc520>
21f0c3d0:	e3a01040 	mov	r1, #64	; 0x40
21f0c3d4:	e51b2014 	ldr	r2, [fp, #-20]
21f0c3d8:	ebfffd42 	bl	21f0b8e8 <truncate_sz>
21f0c3dc:	e1a03000 	mov	r3, r0
21f0c3e0:	e50b3010 	str	r3, [fp, #-16]
			memcpy (&NetOurRootPath, popt + 2, size);
21f0c3e4:	e51b301c 	ldr	r3, [fp, #-28]
21f0c3e8:	e2833002 	add	r3, r3, #2	; 0x2
21f0c3ec:	e51b2010 	ldr	r2, [fp, #-16]
21f0c3f0:	e59f012c 	ldr	r0, [pc, #300]	; 21f0c524 <.text+0xc524>
21f0c3f4:	e1a01003 	mov	r1, r3
21f0c3f8:	eb005b73 	bl	21f231cc <memcpy>
			NetOurRootPath[size] = 0;
21f0c3fc:	e51b1010 	ldr	r1, [fp, #-16]
21f0c400:	e59f211c 	ldr	r2, [pc, #284]	; 21f0c524 <.text+0xc524>
21f0c404:	e3a03000 	mov	r3, #0	; 0x0
21f0c408:	e7c23001 	strb	r3, [r2, r1]
			break;
21f0c40c:	ea00002f 	b	21f0c4d0 <.text+0xc4d0>
#if (CONFIG_COMMANDS & CFG_CMD_SNTP) && (CONFIG_BOOTP_MASK & CONFIG_BOOTP_NTPSERVER)
		case 42:	/* NTP server IP */
			NetCopyIP (&NetNtpServerIP, (popt + 2));
			break;
#endif
		case 51:
			NetCopyLong (&dhcp_leasetime, (ulong *) (popt + 2));
21f0c410:	e51b301c 	ldr	r3, [fp, #-28]
21f0c414:	e2833002 	add	r3, r3, #2	; 0x2
21f0c418:	e59f0108 	ldr	r0, [pc, #264]	; 21f0c528 <.text+0xc528>
21f0c41c:	e1a01003 	mov	r1, r3
21f0c420:	ebffff3f 	bl	21f0c124 <NetCopyLong>
			break;
21f0c424:	ea000029 	b	21f0c4d0 <.text+0xc4d0>
		case 53:	/* Ignore Message Type Option */
			break;
		case 54:
			NetCopyIP (&NetDHCPServerIP, (popt + 2));
21f0c428:	e51b301c 	ldr	r3, [fp, #-28]
21f0c42c:	e2833002 	add	r3, r3, #2	; 0x2
21f0c430:	e59f00f4 	ldr	r0, [pc, #244]	; 21f0c52c <.text+0xc52c>
21f0c434:	e1a01003 	mov	r1, r3
21f0c438:	ebfffd1e 	bl	21f0b8b8 <NetCopyIP>
			break;
21f0c43c:	ea000023 	b	21f0c4d0 <.text+0xc4d0>
		case 58:	/* Ignore Renewal Time Option */
			break;
		case 59:	/* Ignore Rebinding Time Option */
			break;
		case 66:	/* Ignore TFTP server name */
			break;
		case 67:	/* vendor opt bootfile */
			/*
			 * I can't use dhcp_vendorex_proc here because I need
			 * to write into the bootp packet - even then I had to
			 * pass the bootp packet pointer into here as the
			 * second arg
			 */
			size = truncate_sz ("Opt Boot File",
21f0c440:	e59f00e8 	ldr	r0, [pc, #232]	; 21f0c530 <.text+0xc530>
21f0c444:	e3a01080 	mov	r1, #128	; 0x80
21f0c448:	e51b2014 	ldr	r2, [fp, #-20]
21f0c44c:	ebfffd25 	bl	21f0b8e8 <truncate_sz>
21f0c450:	e1a03000 	mov	r3, r0
21f0c454:	e50b3010 	str	r3, [fp, #-16]
					    sizeof(bp->bp_file),
					    oplen);
			if (bp->bp_file[0] == '\0' && size > 0) {
21f0c458:	e51b3020 	ldr	r3, [fp, #-32]
21f0c45c:	e5d3306c 	ldrb	r3, [r3, #108]
21f0c460:	e3530000 	cmp	r3, #0	; 0x0
21f0c464:	1a000019 	bne	21f0c4d0 <.text+0xc4d0>
21f0c468:	e51b3010 	ldr	r3, [fp, #-16]
21f0c46c:	e3530000 	cmp	r3, #0	; 0x0
21f0c470:	da000016 	ble	21f0c4d0 <.text+0xc4d0>
				/*
				 * only use vendor boot file if we didn't
				 * receive a boot file in the main non-vendor
				 * part of the packet - god only knows why
				 * some vendors chose not to use this perfectly
				 * good spot to store the boot file (join on
				 * Tru64 Unix) it seems mind bogglingly crazy
				 * to me
				 */
				printf("*** WARNING: using vendor "
21f0c474:	e59f00b8 	ldr	r0, [pc, #184]	; 21f0c534 <.text+0xc534>
21f0c478:	eb003d83 	bl	21f1ba8c <printf>
					"optional boot file\n");
				memcpy(bp->bp_file, popt + 2, size);
21f0c47c:	e51b3020 	ldr	r3, [fp, #-32]
21f0c480:	e283106c 	add	r1, r3, #108	; 0x6c
21f0c484:	e51b301c 	ldr	r3, [fp, #-28]
21f0c488:	e2833002 	add	r3, r3, #2	; 0x2
21f0c48c:	e51b2010 	ldr	r2, [fp, #-16]
21f0c490:	e1a00001 	mov	r0, r1
21f0c494:	e1a01003 	mov	r1, r3
21f0c498:	eb005b4b 	bl	21f231cc <memcpy>
				bp->bp_file[size] = '\0';
21f0c49c:	e51b1010 	ldr	r1, [fp, #-16]
21f0c4a0:	e51b3020 	ldr	r3, [fp, #-32]
21f0c4a4:	e3a0206c 	mov	r2, #108	; 0x6c
21f0c4a8:	e0813003 	add	r3, r1, r3
21f0c4ac:	e0832002 	add	r2, r3, r2
21f0c4b0:	e3a03000 	mov	r3, #0	; 0x0
21f0c4b4:	e5c23000 	strb	r3, [r2]
21f0c4b8:	ea000004 	b	21f0c4d0 <.text+0xc4d0>
			}
			break;
		default:
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_VENDOREX)
			if (dhcp_vendorex_proc (popt))
				break;
#endif
			printf ("*** Unhandled DHCP Option in OFFER/ACK: %d\n", *popt);
21f0c4bc:	e51b301c 	ldr	r3, [fp, #-28]
21f0c4c0:	e5d33000 	ldrb	r3, [r3]
21f0c4c4:	e59f006c 	ldr	r0, [pc, #108]	; 21f0c538 <.text+0xc538>
21f0c4c8:	e1a01003 	mov	r1, r3
21f0c4cc:	eb003d6e 	bl	21f1ba8c <printf>
			break;
		}
		popt += oplen + 2;	/* Process next option */
21f0c4d0:	e51b2014 	ldr	r2, [fp, #-20]
21f0c4d4:	e51b301c 	ldr	r3, [fp, #-28]
21f0c4d8:	e0823003 	add	r3, r2, r3
21f0c4dc:	e2833002 	add	r3, r3, #2	; 0x2
21f0c4e0:	e50b301c 	str	r3, [fp, #-28]
21f0c4e4:	e51b201c 	ldr	r2, [fp, #-28]
21f0c4e8:	e51b3018 	ldr	r3, [fp, #-24]
21f0c4ec:	e1520003 	cmp	r2, r3
21f0c4f0:	2a000003 	bcs	21f0c504 <.text+0xc504>
21f0c4f4:	e51b301c 	ldr	r3, [fp, #-28]
21f0c4f8:	e5d33000 	ldrb	r3, [r3]
21f0c4fc:	e35300ff 	cmp	r3, #255	; 0xff
21f0c500:	1affff41 	bne	21f0c20c <DhcpOptionsProcess+0x28>
	}
}
21f0c504:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0c508:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0c50c:	21f644b0 	ldrcsh	r4, [r6, #64]!
21f0c510:	21f644b4 	ldrcsh	r4, [r6, #68]!
21f0c514:	21f644b8 	ldrcsh	r4, [r6, #72]!
21f0c518:	21f2f89c 	ldrcsb	pc, [r2, #140]!
21f0c51c:	21f644dc 	ldrcssb	r4, [r6, #76]!
21f0c520:	21f2f8a8 	mvncss	pc, r8, lsr #17
21f0c524:	21f644fc 	ldrcssh	r4, [r6, #76]!
21f0c528:	21f66aa8 	mvncss	r6, r8, lsr #21
21f0c52c:	21f66aac 	mvncss	r6, ip, lsr #21
21f0c530:	21f2f8b4 	ldrcsh	pc, [r2, #132]!
21f0c534:	21f2f8c4 	mvncss	pc, r4, asr #17
21f0c538:	21f2f8f4 	ldrcssh	pc, [r2, #132]!

21f0c53c <DhcpMessageType>:

static int DhcpMessageType(unsigned char *popt)
{
21f0c53c:	e1a0c00d 	mov	ip, sp
21f0c540:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f0c544:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0c548:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0c54c:	e50b0014 	str	r0, [fp, #-20]
	if (NetReadLong((ulong*)popt) != htonl(BOOTP_VENDOR_MAGIC))
21f0c550:	e51b3014 	ldr	r3, [fp, #-20]
21f0c554:	e1a00003 	mov	r0, r3
21f0c558:	ebfffc8d 	bl	21f0b794 <NetReadLong>
21f0c55c:	e1a04000 	mov	r4, r0
21f0c560:	e59f0094 	ldr	r0, [pc, #148]	; 21f0c5fc <.text+0xc5fc>
21f0c564:	ebfffe1e 	bl	21f0bde4 <__fswab32>
21f0c568:	e1a03000 	mov	r3, r0
21f0c56c:	e1540003 	cmp	r4, r3
21f0c570:	0a000002 	beq	21f0c580 <DhcpMessageType+0x44>
		return -1;
21f0c574:	e3e03000 	mvn	r3, #0	; 0x0
21f0c578:	e50b3018 	str	r3, [fp, #-24]
21f0c57c:	ea00001a 	b	21f0c5ec <DhcpMessageType+0xb0>

	popt += 4;
21f0c580:	e51b3014 	ldr	r3, [fp, #-20]
21f0c584:	e2833004 	add	r3, r3, #4	; 0x4
21f0c588:	e50b3014 	str	r3, [fp, #-20]
	while ( *popt != 0xff ) {
21f0c58c:	ea000010 	b	21f0c5d4 <DhcpMessageType+0x98>
		if ( *popt == 53 )	/* DHCP Message Type */
21f0c590:	e51b3014 	ldr	r3, [fp, #-20]
21f0c594:	e5d33000 	ldrb	r3, [r3]
21f0c598:	e3530035 	cmp	r3, #53	; 0x35
21f0c59c:	1a000004 	bne	21f0c5b4 <DhcpMessageType+0x78>
			return *(popt + 2);
21f0c5a0:	e51b3014 	ldr	r3, [fp, #-20]
21f0c5a4:	e2833002 	add	r3, r3, #2	; 0x2
21f0c5a8:	e5d33000 	ldrb	r3, [r3]
21f0c5ac:	e50b3018 	str	r3, [fp, #-24]
21f0c5b0:	ea00000d 	b	21f0c5ec <DhcpMessageType+0xb0>
		popt += *(popt + 1) + 2;	/* Scan through all options */
21f0c5b4:	e51b3014 	ldr	r3, [fp, #-20]
21f0c5b8:	e2833001 	add	r3, r3, #1	; 0x1
21f0c5bc:	e5d33000 	ldrb	r3, [r3]
21f0c5c0:	e1a02003 	mov	r2, r3
21f0c5c4:	e51b3014 	ldr	r3, [fp, #-20]
21f0c5c8:	e0823003 	add	r3, r2, r3
21f0c5cc:	e2833002 	add	r3, r3, #2	; 0x2
21f0c5d0:	e50b3014 	str	r3, [fp, #-20]
21f0c5d4:	e51b3014 	ldr	r3, [fp, #-20]
21f0c5d8:	e5d33000 	ldrb	r3, [r3]
21f0c5dc:	e35300ff 	cmp	r3, #255	; 0xff
21f0c5e0:	1affffea 	bne	21f0c590 <DhcpMessageType+0x54>
	}
	return -1;
21f0c5e4:	e3e03000 	mvn	r3, #0	; 0x0
21f0c5e8:	e50b3018 	str	r3, [fp, #-24]
21f0c5ec:	e51b3018 	ldr	r3, [fp, #-24]
}
21f0c5f0:	e1a00003 	mov	r0, r3
21f0c5f4:	e24bd010 	sub	sp, fp, #16	; 0x10
21f0c5f8:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f0c5fc:	63825363 	orrvs	r5, r2, #-1946157055	; 0x8c000001

21f0c600 <DhcpSendRequestPkt>:

static void DhcpSendRequestPkt(Bootp_t *bp_offer)
{
21f0c600:	e1a0c00d 	mov	ip, sp
21f0c604:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0c608:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0c60c:	e24dd024 	sub	sp, sp, #36	; 0x24
21f0c610:	e50b002c 	str	r0, [fp, #-44]
	volatile uchar *pkt, *iphdr;
	Bootp_t *bp;
	int pktlen, iplen, extlen;
	IPaddr_t OfferedIP;

	debug ("DhcpSendRequestPkt: Sending DHCPREQUEST\n");
	pkt = NetTxPacket;
21f0c614:	e59f31fc 	ldr	r3, [pc, #508]	; 21f0c818 <.text+0xc818>
21f0c618:	e5933000 	ldr	r3, [r3]
21f0c61c:	e50b3024 	str	r3, [fp, #-36]
	memset ((void*)pkt, 0, PKTSIZE);
21f0c620:	e51b0024 	ldr	r0, [fp, #-36]
21f0c624:	e3a01000 	mov	r1, #0	; 0x0
21f0c628:	e3a02e5e 	mov	r2, #1504	; 0x5e0
21f0c62c:	e282200e 	add	r2, r2, #14	; 0xe
21f0c630:	eb005aac 	bl	21f230e8 <memset>

	pkt += NetSetEther(pkt, NetBcastAddr, PROT_IP);
21f0c634:	e51b0024 	ldr	r0, [fp, #-36]
21f0c638:	e59f11dc 	ldr	r1, [pc, #476]	; 21f0c81c <.text+0xc81c>
21f0c63c:	e3a02b02 	mov	r2, #2048	; 0x800
21f0c640:	ebfff726 	bl	21f0a2e0 <NetSetEther>
21f0c644:	e1a03000 	mov	r3, r0
21f0c648:	e1a02003 	mov	r2, r3
21f0c64c:	e51b3024 	ldr	r3, [fp, #-36]
21f0c650:	e0833002 	add	r3, r3, r2
21f0c654:	e50b3024 	str	r3, [fp, #-36]

	iphdr = pkt;		/* We'll need this later to set proper pkt size */
21f0c658:	e51b3024 	ldr	r3, [fp, #-36]
21f0c65c:	e50b3020 	str	r3, [fp, #-32]
	pkt += IP_HDR_SIZE;
21f0c660:	e51b3024 	ldr	r3, [fp, #-36]
21f0c664:	e283301c 	add	r3, r3, #28	; 0x1c
21f0c668:	e50b3024 	str	r3, [fp, #-36]

	bp = (Bootp_t *)pkt;
21f0c66c:	e51b3024 	ldr	r3, [fp, #-36]
21f0c670:	e50b301c 	str	r3, [fp, #-28]
	bp->bp_op = OP_BOOTREQUEST;
21f0c674:	e51b201c 	ldr	r2, [fp, #-28]
21f0c678:	e3a03001 	mov	r3, #1	; 0x1
21f0c67c:	e5c23000 	strb	r3, [r2]
	bp->bp_htype = HWT_ETHER;
21f0c680:	e51b201c 	ldr	r2, [fp, #-28]
21f0c684:	e3a03001 	mov	r3, #1	; 0x1
21f0c688:	e5c23001 	strb	r3, [r2, #1]
	bp->bp_hlen = HWL_ETHER;
21f0c68c:	e51b201c 	ldr	r2, [fp, #-28]
21f0c690:	e3a03006 	mov	r3, #6	; 0x6
21f0c694:	e5c23002 	strb	r3, [r2, #2]
	bp->bp_hops = 0;
21f0c698:	e51b201c 	ldr	r2, [fp, #-28]
21f0c69c:	e3a03000 	mov	r3, #0	; 0x0
21f0c6a0:	e5c23003 	strb	r3, [r2, #3]
	bp->bp_secs = htons(get_timer(0) / CFG_HZ);
21f0c6a4:	e3a00000 	mov	r0, #0	; 0x0
21f0c6a8:	ebffd0e9 	bl	21f00a54 <get_timer>
21f0c6ac:	e1a02000 	mov	r2, r0
21f0c6b0:	e59f3168 	ldr	r3, [pc, #360]	; 21f0c820 <.text+0xc820>
21f0c6b4:	e0831392 	umull	r1, r3, r2, r3
21f0c6b8:	e1a03323 	mov	r3, r3, lsr #6
21f0c6bc:	e1a03803 	mov	r3, r3, lsl #16
21f0c6c0:	e1a03823 	mov	r3, r3, lsr #16
21f0c6c4:	e1a00003 	mov	r0, r3
21f0c6c8:	ebfffeae 	bl	21f0c188 <__fswab16>
21f0c6cc:	e1a03000 	mov	r3, r0
21f0c6d0:	e1a02003 	mov	r2, r3
21f0c6d4:	e51b301c 	ldr	r3, [fp, #-28]
21f0c6d8:	e1c320b8 	strh	r2, [r3, #8]
	NetCopyIP(&bp->bp_ciaddr, &bp_offer->bp_ciaddr); /* both in network byte order */
21f0c6dc:	e51b301c 	ldr	r3, [fp, #-28]
21f0c6e0:	e283200c 	add	r2, r3, #12	; 0xc
21f0c6e4:	e51b302c 	ldr	r3, [fp, #-44]
21f0c6e8:	e283300c 	add	r3, r3, #12	; 0xc
21f0c6ec:	e1a00002 	mov	r0, r2
21f0c6f0:	e1a01003 	mov	r1, r3
21f0c6f4:	ebfffc6f 	bl	21f0b8b8 <NetCopyIP>
	NetCopyIP(&bp->bp_yiaddr, &bp_offer->bp_yiaddr);
21f0c6f8:	e51b301c 	ldr	r3, [fp, #-28]
21f0c6fc:	e2832010 	add	r2, r3, #16	; 0x10
21f0c700:	e51b302c 	ldr	r3, [fp, #-44]
21f0c704:	e2833010 	add	r3, r3, #16	; 0x10
21f0c708:	e1a00002 	mov	r0, r2
21f0c70c:	e1a01003 	mov	r1, r3
21f0c710:	ebfffc68 	bl	21f0b8b8 <NetCopyIP>
	NetCopyIP(&bp->bp_siaddr, &bp_offer->bp_siaddr);
21f0c714:	e51b301c 	ldr	r3, [fp, #-28]
21f0c718:	e2832014 	add	r2, r3, #20	; 0x14
21f0c71c:	e51b302c 	ldr	r3, [fp, #-44]
21f0c720:	e2833014 	add	r3, r3, #20	; 0x14
21f0c724:	e1a00002 	mov	r0, r2
21f0c728:	e1a01003 	mov	r1, r3
21f0c72c:	ebfffc61 	bl	21f0b8b8 <NetCopyIP>
	/*
	 * RFC3046 requires Relay Agents to discard packets with
	 * nonzero and offered giaddr
	 */
	NetWriteIP(&bp->bp_giaddr, 0);
21f0c730:	e51b301c 	ldr	r3, [fp, #-28]
21f0c734:	e2833018 	add	r3, r3, #24	; 0x18
21f0c738:	e1a00003 	mov	r0, r3
21f0c73c:	e3a01000 	mov	r1, #0	; 0x0
21f0c740:	ebfffe83 	bl	21f0c154 <NetWriteIP>

	memcpy (bp->bp_chaddr, NetOurEther, 6);
21f0c744:	e51b301c 	ldr	r3, [fp, #-28]
21f0c748:	e283301c 	add	r3, r3, #28	; 0x1c
21f0c74c:	e1a00003 	mov	r0, r3
21f0c750:	e59f10cc 	ldr	r1, [pc, #204]	; 21f0c824 <.text+0xc824>
21f0c754:	e3a02006 	mov	r2, #6	; 0x6
21f0c758:	eb005a9b 	bl	21f231cc <memcpy>

	/*
	 * ID is the id of the OFFER packet
	 */

	NetCopyLong(&bp->bp_id, &bp_offer->bp_id);
21f0c75c:	e51b301c 	ldr	r3, [fp, #-28]
21f0c760:	e2832004 	add	r2, r3, #4	; 0x4
21f0c764:	e51b302c 	ldr	r3, [fp, #-44]
21f0c768:	e2833004 	add	r3, r3, #4	; 0x4
21f0c76c:	e1a00002 	mov	r0, r2
21f0c770:	e1a01003 	mov	r1, r3
21f0c774:	ebfffe6a 	bl	21f0c124 <NetCopyLong>

	/*
	 * Copy options from OFFER packet if present
	 */
	NetCopyIP(&OfferedIP, &bp->bp_yiaddr);
21f0c778:	e51b301c 	ldr	r3, [fp, #-28]
21f0c77c:	e2832010 	add	r2, r3, #16	; 0x10
21f0c780:	e24b3028 	sub	r3, fp, #40	; 0x28
21f0c784:	e1a00003 	mov	r0, r3
21f0c788:	e1a01002 	mov	r1, r2
21f0c78c:	ebfffc49 	bl	21f0b8b8 <NetCopyIP>
	extlen = DhcpExtended((u8 *)bp->bp_vend, DHCP_REQUEST, NetDHCPServerIP, OfferedIP);
21f0c790:	e51b301c 	ldr	r3, [fp, #-28]
21f0c794:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c798:	e1a02003 	mov	r2, r3
21f0c79c:	e59f3084 	ldr	r3, [pc, #132]	; 21f0c828 <.text+0xc828>
21f0c7a0:	e5933000 	ldr	r3, [r3]
21f0c7a4:	e51bc028 	ldr	ip, [fp, #-40]
21f0c7a8:	e1a00002 	mov	r0, r2
21f0c7ac:	e3a01003 	mov	r1, #3	; 0x3
21f0c7b0:	e1a02003 	mov	r2, r3
21f0c7b4:	e1a0300c 	mov	r3, ip
21f0c7b8:	ebfffc76 	bl	21f0b998 <DhcpExtended>
21f0c7bc:	e1a03000 	mov	r3, r0
21f0c7c0:	e50b3010 	str	r3, [fp, #-16]

	pktlen = BOOTP_SIZE - sizeof(bp->bp_vend) + extlen;
21f0c7c4:	e51b3010 	ldr	r3, [fp, #-16]
21f0c7c8:	e2833f45 	add	r3, r3, #276	; 0x114
21f0c7cc:	e2833002 	add	r3, r3, #2	; 0x2
21f0c7d0:	e50b3018 	str	r3, [fp, #-24]
	iplen = BOOTP_HDR_SIZE - sizeof(bp->bp_vend) + extlen;
21f0c7d4:	e51b3010 	ldr	r3, [fp, #-16]
21f0c7d8:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c7dc:	e50b3014 	str	r3, [fp, #-20]
	NetSetIP(iphdr, 0xFFFFFFFFL, PORT_BOOTPS, PORT_BOOTPC, iplen);
21f0c7e0:	e51b3014 	ldr	r3, [fp, #-20]
21f0c7e4:	e58d3000 	str	r3, [sp]
21f0c7e8:	e51b0020 	ldr	r0, [fp, #-32]
21f0c7ec:	e3e01000 	mvn	r1, #0	; 0x0
21f0c7f0:	e3a02043 	mov	r2, #67	; 0x43
21f0c7f4:	e3a03044 	mov	r3, #68	; 0x44
21f0c7f8:	ebfff70e 	bl	21f0a438 <NetSetIP>

	debug ("Transmitting DHCPREQUEST packet: len = %d\n", pktlen);
	NetSendPacket(NetTxPacket, pktlen);
21f0c7fc:	e59f3014 	ldr	r3, [pc, #20]	; 21f0c818 <.text+0xc818>
21f0c800:	e5933000 	ldr	r3, [r3]
21f0c804:	e1a00003 	mov	r0, r3
21f0c808:	e51b1018 	ldr	r1, [fp, #-24]
21f0c80c:	ebfff340 	bl	21f09514 <NetSendPacket>
}
21f0c810:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0c814:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0c818:	21f6454c 	mvncss	r4, ip, asr #10
21f0c81c:	21f331cc 	mvncss	r3, ip, asr #3
21f0c820:	10624dd3 	ldrned	r4, [r2], #-211
21f0c824:	21f64554 	mvncss	r4, r4, asr r5
21f0c828:	21f66aac 	mvncss	r6, ip, lsr #21

21f0c82c <DhcpHandler>:

/*
 *	Handle DHCP received packets.
 */
static void
DhcpHandler(uchar * pkt, unsigned dest, unsigned src, unsigned len)
{
21f0c82c:	e1a0c00d 	mov	ip, sp
21f0c830:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f0c834:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0c838:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f0c83c:	e50b001c 	str	r0, [fp, #-28]
21f0c840:	e50b1020 	str	r1, [fp, #-32]
21f0c844:	e50b2024 	str	r2, [fp, #-36]
21f0c848:	e50b3028 	str	r3, [fp, #-40]
	Bootp_t *bp = (Bootp_t *)pkt;
21f0c84c:	e51b301c 	ldr	r3, [fp, #-28]
21f0c850:	e50b3018 	str	r3, [fp, #-24]

	debug ("DHCPHandler: got packet: (src=%d, dst=%d, len=%d) state: %d\n",
		src, dest, len, dhcp_state);

	if (BootpCheckPkt(pkt, dest, src, len)) /* Filter out pkts we don't want */
21f0c854:	e51b001c 	ldr	r0, [fp, #-28]
21f0c858:	e51b1020 	ldr	r1, [fp, #-32]
21f0c85c:	e51b2024 	ldr	r2, [fp, #-36]
21f0c860:	e51b3028 	ldr	r3, [fp, #-40]
21f0c864:	ebfffb7a 	bl	21f0b654 <BootpCheckPkt>
21f0c868:	e1a03000 	mov	r3, r0
21f0c86c:	e3530000 	cmp	r3, #0	; 0x0
21f0c870:	1a000064 	bne	21f0ca08 <DhcpHandler+0x1dc>
		return;

	debug ("DHCPHandler: got DHCP packet: (src=%d, dst=%d, len=%d) state: %d\n",
		src, dest, len, dhcp_state);

	switch (dhcp_state) {
21f0c874:	e59f3194 	ldr	r3, [pc, #404]	; 21f0ca10 <.text+0xca10>
21f0c878:	e5933000 	ldr	r3, [r3]
21f0c87c:	e50b302c 	str	r3, [fp, #-44]
21f0c880:	e51b302c 	ldr	r3, [fp, #-44]
21f0c884:	e3530003 	cmp	r3, #3	; 0x3
21f0c888:	0a000003 	beq	21f0c89c <DhcpHandler+0x70>
21f0c88c:	e51b302c 	ldr	r3, [fp, #-44]
21f0c890:	e3530004 	cmp	r3, #4	; 0x4
21f0c894:	0a00001c 	beq	21f0c90c <DhcpHandler+0xe0>
21f0c898:	ea000058 	b	21f0ca00 <DhcpHandler+0x1d4>
	case SELECTING:
		/*
		 * Wait an appropriate time for any potential DHCPOFFER packets
		 * to arrive.  Then select one, and generate DHCPREQUEST response.
		 * If filename is in format we recognize, assume it is a valid
		 * OFFER from a server we want.
		 */
		debug ("DHCP: state=SELECTING bp_file: \"%s\"\n", bp->bp_file);
#ifdef CFG_BOOTFILE_PREFIX
		if (strncmp(bp->bp_file,
			    CFG_BOOTFILE_PREFIX,
			    strlen(CFG_BOOTFILE_PREFIX)) == 0 ) {
#endif	/* CFG_BOOTFILE_PREFIX */

			debug ("TRANSITIONING TO REQUESTING STATE\n");
			dhcp_state = REQUESTING;
21f0c89c:	e59f216c 	ldr	r2, [pc, #364]	; 21f0ca10 <.text+0xca10>
21f0c8a0:	e3a03004 	mov	r3, #4	; 0x4
21f0c8a4:	e5823000 	str	r3, [r2]

			if (NetReadLong((ulong*)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
21f0c8a8:	e51b3018 	ldr	r3, [fp, #-24]
21f0c8ac:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c8b0:	e1a00003 	mov	r0, r3
21f0c8b4:	ebfffbb6 	bl	21f0b794 <NetReadLong>
21f0c8b8:	e1a04000 	mov	r4, r0
21f0c8bc:	e59f0150 	ldr	r0, [pc, #336]	; 21f0ca14 <.text+0xca14>
21f0c8c0:	ebfffd47 	bl	21f0bde4 <__fswab32>
21f0c8c4:	e1a03000 	mov	r3, r0
21f0c8c8:	e1540003 	cmp	r4, r3
21f0c8cc:	1a000005 	bne	21f0c8e8 <DhcpHandler+0xbc>
				DhcpOptionsProcess((u8 *)&bp->bp_vend[4], bp);
21f0c8d0:	e51b3018 	ldr	r3, [fp, #-24]
21f0c8d4:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c8d8:	e2833004 	add	r3, r3, #4	; 0x4
21f0c8dc:	e1a00003 	mov	r0, r3
21f0c8e0:	e51b1018 	ldr	r1, [fp, #-24]
21f0c8e4:	ebfffe3e 	bl	21f0c1e4 <DhcpOptionsProcess>

			BootpCopyNetParams(bp); /* Store net params from reply */
21f0c8e8:	e51b0018 	ldr	r0, [fp, #-24]
21f0c8ec:	ebfffbb6 	bl	21f0b7cc <BootpCopyNetParams>

			NetSetTimeout(TIMEOUT * CFG_HZ, BootpTimeout);
21f0c8f0:	e3a00d4e 	mov	r0, #4992	; 0x1380
21f0c8f4:	e2800008 	add	r0, r0, #8	; 0x8
21f0c8f8:	e59f1118 	ldr	r1, [pc, #280]	; 21f0ca18 <.text+0xca18>
21f0c8fc:	ebfff2e7 	bl	21f094a0 <NetSetTimeout>
			DhcpSendRequestPkt(bp);
21f0c900:	e51b0018 	ldr	r0, [fp, #-24]
21f0c904:	ebffff3d 	bl	21f0c600 <DhcpSendRequestPkt>
#ifdef CFG_BOOTFILE_PREFIX
		}
#endif	/* CFG_BOOTFILE_PREFIX */

		return;
21f0c908:	ea00003e 	b	21f0ca08 <DhcpHandler+0x1dc>
		break;
	case REQUESTING:
		debug ("DHCP State: REQUESTING\n");

		if ( DhcpMessageType((u8 *)bp->bp_vend) == DHCP_ACK ) {
21f0c90c:	e51b3018 	ldr	r3, [fp, #-24]
21f0c910:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c914:	e1a00003 	mov	r0, r3
21f0c918:	ebffff07 	bl	21f0c53c <DhcpMessageType>
21f0c91c:	e1a03000 	mov	r3, r0
21f0c920:	e3530005 	cmp	r3, #5	; 0x5
21f0c924:	1a000037 	bne	21f0ca08 <DhcpHandler+0x1dc>
			char *s;

			if (NetReadLong((ulong*)&bp->bp_vend[0]) == htonl(BOOTP_VENDOR_MAGIC))
21f0c928:	e51b3018 	ldr	r3, [fp, #-24]
21f0c92c:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c930:	e1a00003 	mov	r0, r3
21f0c934:	ebfffb96 	bl	21f0b794 <NetReadLong>
21f0c938:	e1a04000 	mov	r4, r0
21f0c93c:	e59f00d0 	ldr	r0, [pc, #208]	; 21f0ca14 <.text+0xca14>
21f0c940:	ebfffd27 	bl	21f0bde4 <__fswab32>
21f0c944:	e1a03000 	mov	r3, r0
21f0c948:	e1540003 	cmp	r4, r3
21f0c94c:	1a000005 	bne	21f0c968 <DhcpHandler+0x13c>
				DhcpOptionsProcess((u8 *)&bp->bp_vend[4], bp);
21f0c950:	e51b3018 	ldr	r3, [fp, #-24]
21f0c954:	e28330ec 	add	r3, r3, #236	; 0xec
21f0c958:	e2833004 	add	r3, r3, #4	; 0x4
21f0c95c:	e1a00003 	mov	r0, r3
21f0c960:	e51b1018 	ldr	r1, [fp, #-24]
21f0c964:	ebfffe1e 	bl	21f0c1e4 <DhcpOptionsProcess>
			BootpCopyNetParams(bp); /* Store net params from reply */
21f0c968:	e51b0018 	ldr	r0, [fp, #-24]
21f0c96c:	ebfffb96 	bl	21f0b7cc <BootpCopyNetParams>
			dhcp_state = BOUND;
21f0c970:	e59f2098 	ldr	r2, [pc, #152]	; 21f0ca10 <.text+0xca10>
21f0c974:	e3a03006 	mov	r3, #6	; 0x6
21f0c978:	e5823000 	str	r3, [r2]
			puts ("DHCP client bound to address ");
21f0c97c:	e59f0098 	ldr	r0, [pc, #152]	; 21f0ca1c <.text+0xca1c>
21f0c980:	eb003c2e 	bl	21f1ba40 <puts>
			print_IPaddr(NetOurIP);
21f0c984:	e59f3094 	ldr	r3, [pc, #148]	; 21f0ca20 <.text+0xca20>
21f0c988:	e5933000 	ldr	r3, [r3]
21f0c98c:	e1a00003 	mov	r0, r3
21f0c990:	ebfff825 	bl	21f0aa2c <print_IPaddr>
			putc ('\n');
21f0c994:	e3a0000a 	mov	r0, #10	; 0xa
21f0c998:	eb003c12 	bl	21f1b9e8 <putc>

			/* Obey the 'autoload' setting */
			if ((s = getenv("autoload")) != NULL) {
21f0c99c:	e59f0080 	ldr	r0, [pc, #128]	; 21f0ca24 <.text+0xca24>
21f0c9a0:	eb00389c 	bl	21f1ac18 <getenv>
21f0c9a4:	e1a03000 	mov	r3, r0
21f0c9a8:	e50b3014 	str	r3, [fp, #-20]
21f0c9ac:	e51b3014 	ldr	r3, [fp, #-20]
21f0c9b0:	e3530000 	cmp	r3, #0	; 0x0
21f0c9b4:	0a00000f 	beq	21f0c9f8 <DhcpHandler+0x1cc>
				if (*s == 'n') {
21f0c9b8:	e51b3014 	ldr	r3, [fp, #-20]
21f0c9bc:	e5d33000 	ldrb	r3, [r3]
21f0c9c0:	e353006e 	cmp	r3, #110	; 0x6e
21f0c9c4:	1a000003 	bne	21f0c9d8 <DhcpHandler+0x1ac>
					/*
					 * Just use BOOTP to configure system;
					 * Do not use TFTP to load the bootfile.
					 */
					NetState = NETLOOP_SUCCESS;
21f0c9c8:	e59f2058 	ldr	r2, [pc, #88]	; 21f0ca28 <.text+0xca28>
21f0c9cc:	e3a03003 	mov	r3, #3	; 0x3
21f0c9d0:	e5823000 	str	r3, [r2]
					return;
21f0c9d4:	ea00000b 	b	21f0ca08 <DhcpHandler+0x1dc>
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
				} else if (strcmp(s, "NFS") == 0) {
21f0c9d8:	e51b0014 	ldr	r0, [fp, #-20]
21f0c9dc:	e59f1048 	ldr	r1, [pc, #72]	; 21f0ca2c <.text+0xca2c>
21f0c9e0:	eb0057d9 	bl	21f2294c <strcmp>
21f0c9e4:	e1a03000 	mov	r3, r0
21f0c9e8:	e3530000 	cmp	r3, #0	; 0x0
21f0c9ec:	1a000001 	bne	21f0c9f8 <DhcpHandler+0x1cc>
					/*
					 * Use NFS to load the bootfile.
					 */
					NfsStart();
21f0c9f0:	eb0006c7 	bl	21f0e514 <NfsStart>
					return;
21f0c9f4:	ea000003 	b	21f0ca08 <DhcpHandler+0x1dc>
#endif
				}
			}
			TftpStart();
21f0c9f8:	ebfffa59 	bl	21f0b364 <TftpStart>
			return;
21f0c9fc:	ea000001 	b	21f0ca08 <DhcpHandler+0x1dc>
		}
		break;
	default:
		puts ("DHCP: INVALID STATE\n");
21f0ca00:	e59f0028 	ldr	r0, [pc, #40]	; 21f0ca30 <.text+0xca30>
21f0ca04:	eb003c0d 	bl	21f1ba40 <puts>
		break;
	}

}
21f0ca08:	e24bd010 	sub	sp, fp, #16	; 0x10
21f0ca0c:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f0ca10:	21f66aa4 	mvncss	r6, r4, lsr #21
21f0ca14:	63825363 	orrvs	r5, r2, #-1946157055	; 0x8c000001
21f0ca18:	21f0b948 	mvncss	fp, r8, asr #18
21f0ca1c:	21f2f920 	mvncss	pc, r0, lsr #18
21f0ca20:	21f6455c 	mvncss	r4, ip, asr r5
21f0ca24:	21f2f940 	mvncss	pc, r0, asr #18
21f0ca28:	21f64580 	mvncss	r4, r0, lsl #11
21f0ca2c:	21f2f94c 	mvncss	pc, ip, asr #18
21f0ca30:	21f2f950 	mvncss	pc, r0, asr r9

21f0ca34 <DhcpRequest>:

void DhcpRequest(void)
{
21f0ca34:	e1a0c00d 	mov	ip, sp
21f0ca38:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ca3c:	e24cb004 	sub	fp, ip, #4	; 0x4
	BootpRequest();
21f0ca40:	ebfffcfd 	bl	21f0be3c <BootpRequest>
}
21f0ca44:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0ca48 <RarpHandler>:
 *	Handle a RARP received packet.
 */
static void
RarpHandler(uchar * dummi0, unsigned dummi1, unsigned dummi2, unsigned dummi3)
{
21f0ca48:	e1a0c00d 	mov	ip, sp
21f0ca4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ca50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ca54:	e24dd014 	sub	sp, sp, #20	; 0x14
21f0ca58:	e50b0014 	str	r0, [fp, #-20]
21f0ca5c:	e50b1018 	str	r1, [fp, #-24]
21f0ca60:	e50b201c 	str	r2, [fp, #-28]
21f0ca64:	e50b3020 	str	r3, [fp, #-32]
	char *s;
#ifdef	DEBUG
	puts ("Got good RARP\n");
#endif
	if ((s = getenv("autoload")) != NULL) {
21f0ca68:	e59f006c 	ldr	r0, [pc, #108]	; 21f0cadc <.text+0xcadc>
21f0ca6c:	eb003869 	bl	21f1ac18 <getenv>
21f0ca70:	e1a03000 	mov	r3, r0
21f0ca74:	e50b3010 	str	r3, [fp, #-16]
21f0ca78:	e51b3010 	ldr	r3, [fp, #-16]
21f0ca7c:	e3530000 	cmp	r3, #0	; 0x0
21f0ca80:	0a000012 	beq	21f0cad0 <RarpHandler+0x88>
		if (*s == 'n') {
21f0ca84:	e51b3010 	ldr	r3, [fp, #-16]
21f0ca88:	e5d33000 	ldrb	r3, [r3]
21f0ca8c:	e353006e 	cmp	r3, #110	; 0x6e
21f0ca90:	1a000003 	bne	21f0caa4 <RarpHandler+0x5c>
			/*
			 * Just use RARP to configure system;
			 * Do not use TFTP/NFS to to load the bootfile.
			 */
			NetState = NETLOOP_SUCCESS;
21f0ca94:	e59f2044 	ldr	r2, [pc, #68]	; 21f0cae0 <.text+0xcae0>
21f0ca98:	e3a03003 	mov	r3, #3	; 0x3
21f0ca9c:	e5823000 	str	r3, [r2]
			return;
21f0caa0:	ea00000b 	b	21f0cad4 <RarpHandler+0x8c>
#if (CONFIG_COMMANDS & CFG_CMD_NFS)
		} else if ((s != NULL) && !strcmp(s, "NFS")) {
21f0caa4:	e51b3010 	ldr	r3, [fp, #-16]
21f0caa8:	e3530000 	cmp	r3, #0	; 0x0
21f0caac:	0a000007 	beq	21f0cad0 <RarpHandler+0x88>
21f0cab0:	e51b0010 	ldr	r0, [fp, #-16]
21f0cab4:	e59f1028 	ldr	r1, [pc, #40]	; 21f0cae4 <.text+0xcae4>
21f0cab8:	eb0057a3 	bl	21f2294c <strcmp>
21f0cabc:	e1a03000 	mov	r3, r0
21f0cac0:	e3530000 	cmp	r3, #0	; 0x0
21f0cac4:	1a000001 	bne	21f0cad0 <RarpHandler+0x88>
			NfsStart();
21f0cac8:	eb000691 	bl	21f0e514 <NfsStart>
			return;
21f0cacc:	ea000000 	b	21f0cad4 <RarpHandler+0x8c>
#endif
		}
	}
	TftpStart ();
21f0cad0:	ebfffa23 	bl	21f0b364 <TftpStart>
}
21f0cad4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0cad8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0cadc:	21f2f968 	mvncss	pc, r8, ror #18
21f0cae0:	21f64580 	mvncss	r4, r0, lsl #11
21f0cae4:	21f2f974 	mvncss	pc, r4, ror r9

21f0cae8 <RarpTimeout>:


/*
 *	Timeout on BOOTP request.
 */
static void
RarpTimeout(void)
{
21f0cae8:	e1a0c00d 	mov	ip, sp
21f0caec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0caf0:	e24cb004 	sub	fp, ip, #4	; 0x4
	if (RarpTry >= TIMEOUT_COUNT) {
21f0caf4:	e59f3030 	ldr	r3, [pc, #48]	; 21f0cb2c <.text+0xcb2c>
21f0caf8:	e5933000 	ldr	r3, [r3]
21f0cafc:	e3530013 	cmp	r3, #19	; 0x13
21f0cb00:	da000003 	ble	21f0cb14 <RarpTimeout+0x2c>
		puts ("\nRetry count exceeded; starting again\n");
21f0cb04:	e59f0024 	ldr	r0, [pc, #36]	; 21f0cb30 <.text+0xcb30>
21f0cb08:	eb003bcc 	bl	21f1ba40 <puts>
		NetStartAgain ();
21f0cb0c:	ebfff224 	bl	21f093a4 <NetStartAgain>
21f0cb10:	ea000004 	b	21f0cb28 <RarpTimeout+0x40>
	} else {
		NetSetTimeout (TIMEOUT * CFG_HZ, RarpTimeout);
21f0cb14:	e3a00d4e 	mov	r0, #4992	; 0x1380
21f0cb18:	e2800008 	add	r0, r0, #8	; 0x8
21f0cb1c:	e59f1010 	ldr	r1, [pc, #16]	; 21f0cb34 <.text+0xcb34>
21f0cb20:	ebfff25e 	bl	21f094a0 <NetSetTimeout>
		RarpRequest ();
21f0cb24:	eb000003 	bl	21f0cb38 <RarpRequest>
	}
}
21f0cb28:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0cb2c:	21f66ab8 	ldrcsh	r6, [r6, #168]!
21f0cb30:	21f2f978 	mvncss	pc, r8, ror r9
21f0cb34:	21f0cae8 	mvncss	ip, r8, ror #21

21f0cb38 <RarpRequest>:


void
RarpRequest (void)
{
21f0cb38:	e1a0c00d 	mov	ip, sp
21f0cb3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0cb40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0cb44:	e24dd00c 	sub	sp, sp, #12	; 0xc
	int i;
	volatile uchar *pkt;
	ARP_t *	rarp;

	printf("RARP broadcast %d\n", ++RarpTry);
21f0cb48:	e59f3198 	ldr	r3, [pc, #408]	; 21f0cce8 <.text+0xcce8>
21f0cb4c:	e5933000 	ldr	r3, [r3]
21f0cb50:	e2832001 	add	r2, r3, #1	; 0x1
21f0cb54:	e59f318c 	ldr	r3, [pc, #396]	; 21f0cce8 <.text+0xcce8>
21f0cb58:	e5832000 	str	r2, [r3]
21f0cb5c:	e59f3184 	ldr	r3, [pc, #388]	; 21f0cce8 <.text+0xcce8>
21f0cb60:	e5933000 	ldr	r3, [r3]
21f0cb64:	e59f0180 	ldr	r0, [pc, #384]	; 21f0ccec <.text+0xccec>
21f0cb68:	e1a01003 	mov	r1, r3
21f0cb6c:	eb003bc6 	bl	21f1ba8c <printf>
	pkt = NetTxPacket;
21f0cb70:	e59f3178 	ldr	r3, [pc, #376]	; 21f0ccf0 <.text+0xccf0>
21f0cb74:	e5933000 	ldr	r3, [r3]
21f0cb78:	e50b3014 	str	r3, [fp, #-20]

	pkt += NetSetEther(pkt, NetBcastAddr, PROT_RARP);
21f0cb7c:	e51b0014 	ldr	r0, [fp, #-20]
21f0cb80:	e59f116c 	ldr	r1, [pc, #364]	; 21f0ccf4 <.text+0xccf4>
21f0cb84:	e3a02902 	mov	r2, #32768	; 0x8000
21f0cb88:	e2822035 	add	r2, r2, #53	; 0x35
21f0cb8c:	ebfff5d3 	bl	21f0a2e0 <NetSetEther>
21f0cb90:	e1a03000 	mov	r3, r0
21f0cb94:	e1a02003 	mov	r2, r3
21f0cb98:	e51b3014 	ldr	r3, [fp, #-20]
21f0cb9c:	e0833002 	add	r3, r3, r2
21f0cba0:	e50b3014 	str	r3, [fp, #-20]

	rarp = (ARP_t *)pkt;
21f0cba4:	e51b3014 	ldr	r3, [fp, #-20]
21f0cba8:	e50b3010 	str	r3, [fp, #-16]

	rarp->ar_hrd = htons (ARP_ETHER);
21f0cbac:	e3a00001 	mov	r0, #1	; 0x1
21f0cbb0:	eb000054 	bl	21f0cd08 <__fswab16>
21f0cbb4:	e1a03000 	mov	r3, r0
21f0cbb8:	e1a02003 	mov	r2, r3
21f0cbbc:	e51b3010 	ldr	r3, [fp, #-16]
21f0cbc0:	e1c320b0 	strh	r2, [r3]
	rarp->ar_pro = htons (PROT_IP);
21f0cbc4:	e3a00b02 	mov	r0, #2048	; 0x800
21f0cbc8:	eb00004e 	bl	21f0cd08 <__fswab16>
21f0cbcc:	e1a03000 	mov	r3, r0
21f0cbd0:	e1a02003 	mov	r2, r3
21f0cbd4:	e51b3010 	ldr	r3, [fp, #-16]
21f0cbd8:	e1c320b2 	strh	r2, [r3, #2]
	rarp->ar_hln = 6;
21f0cbdc:	e51b2010 	ldr	r2, [fp, #-16]
21f0cbe0:	e3a03006 	mov	r3, #6	; 0x6
21f0cbe4:	e5c23004 	strb	r3, [r2, #4]
	rarp->ar_pln = 4;
21f0cbe8:	e51b2010 	ldr	r2, [fp, #-16]
21f0cbec:	e3a03004 	mov	r3, #4	; 0x4
21f0cbf0:	e5c23005 	strb	r3, [r2, #5]
	rarp->ar_op  = htons (RARPOP_REQUEST);
21f0cbf4:	e3a00003 	mov	r0, #3	; 0x3
21f0cbf8:	eb000042 	bl	21f0cd08 <__fswab16>
21f0cbfc:	e1a03000 	mov	r3, r0
21f0cc00:	e1a02003 	mov	r2, r3
21f0cc04:	e51b3010 	ldr	r3, [fp, #-16]
21f0cc08:	e1c320b6 	strh	r2, [r3, #6]
	memcpy (&rarp->ar_data[0],  NetOurEther, 6);	/* source ET addr */
21f0cc0c:	e51b3010 	ldr	r3, [fp, #-16]
21f0cc10:	e2833008 	add	r3, r3, #8	; 0x8
21f0cc14:	e1a00003 	mov	r0, r3
21f0cc18:	e59f10d8 	ldr	r1, [pc, #216]	; 21f0ccf8 <.text+0xccf8>
21f0cc1c:	e3a02006 	mov	r2, #6	; 0x6
21f0cc20:	eb005969 	bl	21f231cc <memcpy>
	memcpy (&rarp->ar_data[6],  &NetOurIP,   4);	/* source IP addr */
21f0cc24:	e51b3010 	ldr	r3, [fp, #-16]
21f0cc28:	e2833008 	add	r3, r3, #8	; 0x8
21f0cc2c:	e2833006 	add	r3, r3, #6	; 0x6
21f0cc30:	e1a00003 	mov	r0, r3
21f0cc34:	e59f10c0 	ldr	r1, [pc, #192]	; 21f0ccfc <.text+0xccfc>
21f0cc38:	e3a02004 	mov	r2, #4	; 0x4
21f0cc3c:	eb005962 	bl	21f231cc <memcpy>
	memcpy (&rarp->ar_data[10], NetOurEther, 6);	/* dest ET addr = source ET addr ??*/
21f0cc40:	e51b3010 	ldr	r3, [fp, #-16]
21f0cc44:	e2833008 	add	r3, r3, #8	; 0x8
21f0cc48:	e283300a 	add	r3, r3, #10	; 0xa
21f0cc4c:	e1a00003 	mov	r0, r3
21f0cc50:	e59f10a0 	ldr	r1, [pc, #160]	; 21f0ccf8 <.text+0xccf8>
21f0cc54:	e3a02006 	mov	r2, #6	; 0x6
21f0cc58:	eb00595b 	bl	21f231cc <memcpy>
	/* dest. IP addr set to broadcast */
	for (i = 0; i <= 3; i++) {
21f0cc5c:	e3a03000 	mov	r3, #0	; 0x0
21f0cc60:	e50b3018 	str	r3, [fp, #-24]
21f0cc64:	ea00000a 	b	21f0cc94 <RarpRequest+0x15c>
		rarp->ar_data[16 + i] = 0xff;
21f0cc68:	e51b3018 	ldr	r3, [fp, #-24]
21f0cc6c:	e2831010 	add	r1, r3, #16	; 0x10
21f0cc70:	e51b3010 	ldr	r3, [fp, #-16]
21f0cc74:	e3a02008 	mov	r2, #8	; 0x8
21f0cc78:	e0813003 	add	r3, r1, r3
21f0cc7c:	e0832002 	add	r2, r3, r2
21f0cc80:	e3e03000 	mvn	r3, #0	; 0x0
21f0cc84:	e5c23000 	strb	r3, [r2]
21f0cc88:	e51b3018 	ldr	r3, [fp, #-24]
21f0cc8c:	e2833001 	add	r3, r3, #1	; 0x1
21f0cc90:	e50b3018 	str	r3, [fp, #-24]
21f0cc94:	e51b3018 	ldr	r3, [fp, #-24]
21f0cc98:	e3530003 	cmp	r3, #3	; 0x3
21f0cc9c:	dafffff1 	ble	21f0cc68 <RarpRequest+0x130>
	}

	NetSendPacket(NetTxPacket, (pkt - NetTxPacket) + ARP_HDR_SIZE);
21f0cca0:	e59f3048 	ldr	r3, [pc, #72]	; 21f0ccf0 <.text+0xccf0>
21f0cca4:	e5931000 	ldr	r1, [r3]
21f0cca8:	e51b2014 	ldr	r2, [fp, #-20]
21f0ccac:	e59f303c 	ldr	r3, [pc, #60]	; 21f0ccf0 <.text+0xccf0>
21f0ccb0:	e5933000 	ldr	r3, [r3]
21f0ccb4:	e0633002 	rsb	r3, r3, r2
21f0ccb8:	e283301c 	add	r3, r3, #28	; 0x1c
21f0ccbc:	e1a00001 	mov	r0, r1
21f0ccc0:	e1a01003 	mov	r1, r3
21f0ccc4:	ebfff212 	bl	21f09514 <NetSendPacket>

	NetSetTimeout(TIMEOUT * CFG_HZ, RarpTimeout);
21f0ccc8:	e3a00d4e 	mov	r0, #4992	; 0x1380
21f0cccc:	e2800008 	add	r0, r0, #8	; 0x8
21f0ccd0:	e59f1028 	ldr	r1, [pc, #40]	; 21f0cd00 <.text+0xcd00>
21f0ccd4:	ebfff1f1 	bl	21f094a0 <NetSetTimeout>
	NetSetHandler(RarpHandler);
21f0ccd8:	e59f0024 	ldr	r0, [pc, #36]	; 21f0cd04 <.text+0xcd04>
21f0ccdc:	ebfff1e5 	bl	21f09478 <NetSetHandler>
}
21f0cce0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0cce4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0cce8:	21f66ab8 	ldrcsh	r6, [r6, #168]!
21f0ccec:	21f2f9a0 	mvncss	pc, r0, lsr #19
21f0ccf0:	21f6454c 	mvncss	r4, ip, asr #10
21f0ccf4:	21f331cc 	mvncss	r3, ip, asr #3
21f0ccf8:	21f64554 	mvncss	r4, r4, asr r5
21f0ccfc:	21f6455c 	mvncss	r4, ip, asr r5
21f0cd00:	21f0cae8 	mvncss	ip, r8, ror #21
21f0cd04:	21f0ca48 	mvncss	ip, r8, asr #20

21f0cd08 <__fswab16>:
#endif /* OPTIMIZE */


static __inline__ __attribute__((const)) __u16 __fswab16(__u16 x)
{
21f0cd08:	e1a0c00d 	mov	ip, sp
21f0cd0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0cd10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0cd14:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0cd18:	e1a03000 	mov	r3, r0
21f0cd1c:	e14b31b0 	strh	r3, [fp, #-16]
	return __arch__swab16(x);
21f0cd20:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0cd24:	e20330ff 	and	r3, r3, #255	; 0xff
21f0cd28:	e1a03403 	mov	r3, r3, lsl #8
21f0cd2c:	e1a03803 	mov	r3, r3, lsl #16
21f0cd30:	e1a02823 	mov	r2, r3, lsr #16
21f0cd34:	e15b31b0 	ldrh	r3, [fp, #-16]
21f0cd38:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f0cd3c:	e1a03443 	mov	r3, r3, asr #8
21f0cd40:	e1a03803 	mov	r3, r3, lsl #16
21f0cd44:	e1a03823 	mov	r3, r3, lsr #16
21f0cd48:	e1823003 	orr	r3, r2, r3
21f0cd4c:	e1a03803 	mov	r3, r3, lsl #16
21f0cd50:	e1a03823 	mov	r3, r3, lsr #16
21f0cd54:	e1a03803 	mov	r3, r3, lsl #16
21f0cd58:	e1a03823 	mov	r3, r3, lsr #16
}
21f0cd5c:	e1a00003 	mov	r0, r3
21f0cd60:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0cd64 <eth_initialize>:
extern int mcf52x2_miiphy_initialize(bd_t *bis);
extern int ns7520_miiphy_initialize(bd_t *bis);

int eth_initialize(bd_t *bis)
{
21f0cd64:	e1a0c00d 	mov	ip, sp
21f0cd68:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0cd6c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0cd70:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0cd74:	e50b0010 	str	r0, [fp, #-16]
#if defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII)
	miiphy_init();
21f0cd78:	eb004d33 	bl	21f2024c <miiphy_init>
#endif

#if defined(CONFIG_AT91RM9200)
	at91rm9200_miiphy_initialize(bis);
21f0cd7c:	e51b0010 	ldr	r0, [fp, #-16]
21f0cd80:	eb008563 	bl	21f2e314 <at91rm9200_miiphy_initialize>
#endif
#if defined(CONFIG_4xx) && !defined(CONFIG_IOP480) \
	&& !defined(CONFIG_AP1000) && !defined(CONFIG_405)
	emac4xx_miiphy_initialize(bis);
#endif
#if defined(CONFIG_MCF52x2)
	mcf52x2_miiphy_initialize(bis);
#endif
#if defined(CONFIG_NETARM)
	ns7520_miiphy_initialize(bis);
#endif
	return 0;
21f0cd84:	e3a03000 	mov	r3, #0	; 0x0
}
21f0cd88:	e1a00003 	mov	r0, r3
21f0cd8c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0cd90 <basename>:
}

static char*
basename (char *path)
{
21f0cd90:	e1a0c00d 	mov	ip, sp
21f0cd94:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0cd98:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0cd9c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0cda0:	e50b0014 	str	r0, [fp, #-20]
	char *fname;

	fname = path + strlen(path) - 1;
21f0cda4:	e51b0014 	ldr	r0, [fp, #-20]
21f0cda8:	eb005785 	bl	21f22bc4 <strlen>
21f0cdac:	e1a03000 	mov	r3, r0
21f0cdb0:	e1a02003 	mov	r2, r3
21f0cdb4:	e51b3014 	ldr	r3, [fp, #-20]
21f0cdb8:	e0823003 	add	r3, r2, r3
21f0cdbc:	e2433001 	sub	r3, r3, #1	; 0x1
21f0cdc0:	e50b3010 	str	r3, [fp, #-16]
	while (fname >= path) {
21f0cdc4:	ea00000a 	b	21f0cdf4 <basename+0x64>
		if (*fname == '/') {
21f0cdc8:	e51b3010 	ldr	r3, [fp, #-16]
21f0cdcc:	e5d33000 	ldrb	r3, [r3]
21f0cdd0:	e353002f 	cmp	r3, #47	; 0x2f
21f0cdd4:	1a000003 	bne	21f0cde8 <basename+0x58>
			fname++;
21f0cdd8:	e51b3010 	ldr	r3, [fp, #-16]
21f0cddc:	e2833001 	add	r3, r3, #1	; 0x1
21f0cde0:	e50b3010 	str	r3, [fp, #-16]
			break;
21f0cde4:	ea000006 	b	21f0ce04 <basename+0x74>
		}
		fname--;
21f0cde8:	e51b3010 	ldr	r3, [fp, #-16]
21f0cdec:	e2433001 	sub	r3, r3, #1	; 0x1
21f0cdf0:	e50b3010 	str	r3, [fp, #-16]
21f0cdf4:	e51b2010 	ldr	r2, [fp, #-16]
21f0cdf8:	e51b3014 	ldr	r3, [fp, #-20]
21f0cdfc:	e1520003 	cmp	r2, r3
21f0ce00:	2afffff0 	bcs	21f0cdc8 <basename+0x38>
	}
	return fname;
21f0ce04:	e51b3010 	ldr	r3, [fp, #-16]
}
21f0ce08:	e1a00003 	mov	r0, r3
21f0ce0c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0ce10:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0ce14 <dirname>:

static char*
dirname (char *path)
{
21f0ce14:	e1a0c00d 	mov	ip, sp
21f0ce18:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ce1c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ce20:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0ce24:	e50b0014 	str	r0, [fp, #-20]
	char *fname;

	fname = basename (path);
21f0ce28:	e51b0014 	ldr	r0, [fp, #-20]
21f0ce2c:	ebffffd7 	bl	21f0cd90 <basename>
21f0ce30:	e1a03000 	mov	r3, r0
21f0ce34:	e50b3010 	str	r3, [fp, #-16]
	--fname;
21f0ce38:	e51b3010 	ldr	r3, [fp, #-16]
21f0ce3c:	e2433001 	sub	r3, r3, #1	; 0x1
21f0ce40:	e50b3010 	str	r3, [fp, #-16]
	*fname = '\0';
21f0ce44:	e51b2010 	ldr	r2, [fp, #-16]
21f0ce48:	e3a03000 	mov	r3, #0	; 0x0
21f0ce4c:	e5c23000 	strb	r3, [r2]
	return path;
21f0ce50:	e51b3014 	ldr	r3, [fp, #-20]
}
21f0ce54:	e1a00003 	mov	r0, r3
21f0ce58:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0ce5c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0ce60 <rpc_add_credentials>:

/**************************************************************************
RPC_ADD_CREDENTIALS - Add RPC authentication/verifier entries
**************************************************************************/
static long *rpc_add_credentials (long *p)
{
21f0ce60:	e1a0c00d 	mov	ip, sp
21f0ce64:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ce68:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ce6c:	e24ddf43 	sub	sp, sp, #268	; 0x10c
21f0ce70:	e50b0118 	str	r0, [fp, #-280]
	int hl;
	int hostnamelen;
	char hostname[256];

	strcpy (hostname, "");
21f0ce74:	e24b3f45 	sub	r3, fp, #276	; 0x114
21f0ce78:	e1a00003 	mov	r0, r3
21f0ce7c:	e59f11c0 	ldr	r1, [pc, #448]	; 21f0d044 <.text+0xd044>
21f0ce80:	eb005613 	bl	21f226d4 <strcpy>
	hostnamelen=strlen (hostname);
21f0ce84:	e24b3f45 	sub	r3, fp, #276	; 0x114
21f0ce88:	e1a00003 	mov	r0, r3
21f0ce8c:	eb00574c 	bl	21f22bc4 <strlen>
21f0ce90:	e1a03000 	mov	r3, r0
21f0ce94:	e50b3010 	str	r3, [fp, #-16]

	/* Here's the executive summary on authentication requirements of the
	 * various NFS server implementations:	Linux accepts both AUTH_NONE
	 * and AUTH_UNIX authentication (also accepts an empty hostname field
	 * in the AUTH_UNIX scheme).  *BSD refuses AUTH_NONE, but accepts
	 * AUTH_UNIX (also accepts an empty hostname field in the AUTH_UNIX
	 * scheme).  To be safe, use AUTH_UNIX and pass the hostname if we have
	 * it (if the BOOTP/DHCP reply didn't give one, just use an empty
	 * hostname).  */

	hl = (hostnamelen + 3) & ~3;
21f0ce98:	e51b3010 	ldr	r3, [fp, #-16]
21f0ce9c:	e2833003 	add	r3, r3, #3	; 0x3
21f0cea0:	e3c33003 	bic	r3, r3, #3	; 0x3
21f0cea4:	e50b3014 	str	r3, [fp, #-20]

	/* Provide an AUTH_UNIX credential.  */
	*p++ = htonl(1);		/* AUTH_UNIX */
21f0cea8:	e3a00001 	mov	r0, #1	; 0x1
21f0ceac:	eb000065 	bl	21f0d048 <__fswab32>
21f0ceb0:	e1a03000 	mov	r3, r0
21f0ceb4:	e1a02003 	mov	r2, r3
21f0ceb8:	e51b3118 	ldr	r3, [fp, #-280]
21f0cebc:	e5832000 	str	r2, [r3]
21f0cec0:	e51b3118 	ldr	r3, [fp, #-280]
21f0cec4:	e2833004 	add	r3, r3, #4	; 0x4
21f0cec8:	e50b3118 	str	r3, [fp, #-280]
	*p++ = htonl(hl+20);		/* auth length */
21f0cecc:	e51b3014 	ldr	r3, [fp, #-20]
21f0ced0:	e2833014 	add	r3, r3, #20	; 0x14
21f0ced4:	e1a00003 	mov	r0, r3
21f0ced8:	eb00005a 	bl	21f0d048 <__fswab32>
21f0cedc:	e1a03000 	mov	r3, r0
21f0cee0:	e1a02003 	mov	r2, r3
21f0cee4:	e51b3118 	ldr	r3, [fp, #-280]
21f0cee8:	e5832000 	str	r2, [r3]
21f0ceec:	e51b3118 	ldr	r3, [fp, #-280]
21f0cef0:	e2833004 	add	r3, r3, #4	; 0x4
21f0cef4:	e50b3118 	str	r3, [fp, #-280]
	*p++ = htonl(0);		/* stamp */
21f0cef8:	e3a00000 	mov	r0, #0	; 0x0
21f0cefc:	eb000051 	bl	21f0d048 <__fswab32>
21f0cf00:	e1a03000 	mov	r3, r0
21f0cf04:	e1a02003 	mov	r2, r3
21f0cf08:	e51b3118 	ldr	r3, [fp, #-280]
21f0cf0c:	e5832000 	str	r2, [r3]
21f0cf10:	e51b3118 	ldr	r3, [fp, #-280]
21f0cf14:	e2833004 	add	r3, r3, #4	; 0x4
21f0cf18:	e50b3118 	str	r3, [fp, #-280]
	*p++ = htonl(hostnamelen);	/* hostname string */
21f0cf1c:	e51b3010 	ldr	r3, [fp, #-16]
21f0cf20:	e1a00003 	mov	r0, r3
21f0cf24:	eb000047 	bl	21f0d048 <__fswab32>
21f0cf28:	e1a03000 	mov	r3, r0
21f0cf2c:	e1a02003 	mov	r2, r3
21f0cf30:	e51b3118 	ldr	r3, [fp, #-280]
21f0cf34:	e5832000 	str	r2, [r3]
21f0cf38:	e51b3118 	ldr	r3, [fp, #-280]
21f0cf3c:	e2833004 	add	r3, r3, #4	; 0x4
21f0cf40:	e50b3118 	str	r3, [fp, #-280]
	if (hostnamelen & 3) {
21f0cf44:	e51b3010 	ldr	r3, [fp, #-16]
21f0cf48:	e2033003 	and	r3, r3, #3	; 0x3
21f0cf4c:	e3530000 	cmp	r3, #0	; 0x0
21f0cf50:	0a00000a 	beq	21f0cf80 <rpc_add_credentials+0x120>
		*(p + hostnamelen / 4) = 0; /* add zero padding */
21f0cf54:	e51b3010 	ldr	r3, [fp, #-16]
21f0cf58:	e2832003 	add	r2, r3, #3	; 0x3
21f0cf5c:	e3530000 	cmp	r3, #0	; 0x0
21f0cf60:	b1a03002 	movlt	r3, r2
21f0cf64:	e1a03143 	mov	r3, r3, asr #2
21f0cf68:	e1a03103 	mov	r3, r3, lsl #2
21f0cf6c:	e1a02003 	mov	r2, r3
21f0cf70:	e51b3118 	ldr	r3, [fp, #-280]
21f0cf74:	e0822003 	add	r2, r2, r3
21f0cf78:	e3a03000 	mov	r3, #0	; 0x0
21f0cf7c:	e5823000 	str	r3, [r2]
	}
	memcpy (p, hostname, hostnamelen);
21f0cf80:	e51b2010 	ldr	r2, [fp, #-16]
21f0cf84:	e24b3f45 	sub	r3, fp, #276	; 0x114
21f0cf88:	e51b0118 	ldr	r0, [fp, #-280]
21f0cf8c:	e1a01003 	mov	r1, r3
21f0cf90:	eb00588d 	bl	21f231cc <memcpy>
	p += hl / 4;
21f0cf94:	e51b3014 	ldr	r3, [fp, #-20]
21f0cf98:	e2832003 	add	r2, r3, #3	; 0x3
21f0cf9c:	e3530000 	cmp	r3, #0	; 0x0
21f0cfa0:	b1a03002 	movlt	r3, r2
21f0cfa4:	e1a03143 	mov	r3, r3, asr #2
21f0cfa8:	e1a03103 	mov	r3, r3, lsl #2
21f0cfac:	e1a02003 	mov	r2, r3
21f0cfb0:	e51b3118 	ldr	r3, [fp, #-280]
21f0cfb4:	e0833002 	add	r3, r3, r2
21f0cfb8:	e50b3118 	str	r3, [fp, #-280]
	*p++ = 0;			/* uid */
21f0cfbc:	e51b2118 	ldr	r2, [fp, #-280]
21f0cfc0:	e3a03000 	mov	r3, #0	; 0x0
21f0cfc4:	e5823000 	str	r3, [r2]
21f0cfc8:	e51b3118 	ldr	r3, [fp, #-280]
21f0cfcc:	e2833004 	add	r3, r3, #4	; 0x4
21f0cfd0:	e50b3118 	str	r3, [fp, #-280]
	*p++ = 0;			/* gid */
21f0cfd4:	e51b2118 	ldr	r2, [fp, #-280]
21f0cfd8:	e3a03000 	mov	r3, #0	; 0x0
21f0cfdc:	e5823000 	str	r3, [r2]
21f0cfe0:	e51b3118 	ldr	r3, [fp, #-280]
21f0cfe4:	e2833004 	add	r3, r3, #4	; 0x4
21f0cfe8:	e50b3118 	str	r3, [fp, #-280]
	*p++ = 0;			/* auxiliary gid list */
21f0cfec:	e51b2118 	ldr	r2, [fp, #-280]
21f0cff0:	e3a03000 	mov	r3, #0	; 0x0
21f0cff4:	e5823000 	str	r3, [r2]
21f0cff8:	e51b3118 	ldr	r3, [fp, #-280]
21f0cffc:	e2833004 	add	r3, r3, #4	; 0x4
21f0d000:	e50b3118 	str	r3, [fp, #-280]

	/* Provide an AUTH_NONE verifier.  */
	*p++ = 0;			/* AUTH_NONE */
21f0d004:	e51b2118 	ldr	r2, [fp, #-280]
21f0d008:	e3a03000 	mov	r3, #0	; 0x0
21f0d00c:	e5823000 	str	r3, [r2]
21f0d010:	e51b3118 	ldr	r3, [fp, #-280]
21f0d014:	e2833004 	add	r3, r3, #4	; 0x4
21f0d018:	e50b3118 	str	r3, [fp, #-280]
	*p++ = 0;			/* auth length */
21f0d01c:	e51b2118 	ldr	r2, [fp, #-280]
21f0d020:	e3a03000 	mov	r3, #0	; 0x0
21f0d024:	e5823000 	str	r3, [r2]
21f0d028:	e51b3118 	ldr	r3, [fp, #-280]
21f0d02c:	e2833004 	add	r3, r3, #4	; 0x4
21f0d030:	e50b3118 	str	r3, [fp, #-280]

	return p;
21f0d034:	e51b3118 	ldr	r3, [fp, #-280]
}
21f0d038:	e1a00003 	mov	r0, r3
21f0d03c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d040:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0d044:	21f2f9b4 	ldrcsh	pc, [r2, #148]!

21f0d048 <__fswab32>:
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
21f0d048:	e1a0c00d 	mov	ip, sp
21f0d04c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d050:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d054:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0d058:	e50b0010 	str	r0, [fp, #-16]
	return __arch__swab32(x);
21f0d05c:	e51b3010 	ldr	r3, [fp, #-16]
21f0d060:	e20330ff 	and	r3, r3, #255	; 0xff
21f0d064:	e1a02c03 	mov	r2, r3, lsl #24
21f0d068:	e51b3010 	ldr	r3, [fp, #-16]
21f0d06c:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f0d070:	e1a03403 	mov	r3, r3, lsl #8
21f0d074:	e1822003 	orr	r2, r2, r3
21f0d078:	e51b3010 	ldr	r3, [fp, #-16]
21f0d07c:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f0d080:	e1a03423 	mov	r3, r3, lsr #8
21f0d084:	e1822003 	orr	r2, r2, r3
21f0d088:	e51b3010 	ldr	r3, [fp, #-16]
21f0d08c:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
21f0d090:	e1a03c23 	mov	r3, r3, lsr #24
21f0d094:	e1823003 	orr	r3, r2, r3
}
21f0d098:	e1a00003 	mov	r0, r3
21f0d09c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0d0a0 <rpc_req>:

/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_req (int rpc_prog, int rpc_proc, uint32_t *data, int datalen)
{
21f0d0a0:	e1a0c00d 	mov	ip, sp
21f0d0a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d0a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d0ac:	e24dde82 	sub	sp, sp, #2080	; 0x820
21f0d0b0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0d0b4:	e50b0820 	str	r0, [fp, #-2080]
21f0d0b8:	e50b1824 	str	r1, [fp, #-2084]
21f0d0bc:	e50b2828 	str	r2, [fp, #-2088]
21f0d0c0:	e50b382c 	str	r3, [fp, #-2092]
	struct rpc_t pkt;
	unsigned long id;
	uint32_t *p;
	int pktlen;
	int sport;

	id = ++rpc_id;
21f0d0c4:	e59f31a0 	ldr	r3, [pc, #416]	; 21f0d26c <.text+0xd26c>
21f0d0c8:	e5933000 	ldr	r3, [r3]
21f0d0cc:	e2832001 	add	r2, r3, #1	; 0x1
21f0d0d0:	e59f3194 	ldr	r3, [pc, #404]	; 21f0d26c <.text+0xd26c>
21f0d0d4:	e5832000 	str	r2, [r3]
21f0d0d8:	e59f318c 	ldr	r3, [pc, #396]	; 21f0d26c <.text+0xd26c>
21f0d0dc:	e5933000 	ldr	r3, [r3]
21f0d0e0:	e50b301c 	str	r3, [fp, #-28]
	pkt.u.call.id = htonl(id);
21f0d0e4:	e51b001c 	ldr	r0, [fp, #-28]
21f0d0e8:	ebffffd6 	bl	21f0d048 <__fswab32>
21f0d0ec:	e1a03000 	mov	r3, r0
21f0d0f0:	e50b381c 	str	r3, [fp, #-2076]
	pkt.u.call.type = htonl(MSG_CALL);
21f0d0f4:	e3a00000 	mov	r0, #0	; 0x0
21f0d0f8:	ebffffd2 	bl	21f0d048 <__fswab32>
21f0d0fc:	e1a03000 	mov	r3, r0
21f0d100:	e50b3818 	str	r3, [fp, #-2072]
	pkt.u.call.rpcvers = htonl(2);	/* use RPC version 2 */
21f0d104:	e3a00002 	mov	r0, #2	; 0x2
21f0d108:	ebffffce 	bl	21f0d048 <__fswab32>
21f0d10c:	e1a03000 	mov	r3, r0
21f0d110:	e50b3814 	str	r3, [fp, #-2068]
	pkt.u.call.prog = htonl(rpc_prog);
21f0d114:	e51b3820 	ldr	r3, [fp, #-2080]
21f0d118:	e1a00003 	mov	r0, r3
21f0d11c:	ebffffc9 	bl	21f0d048 <__fswab32>
21f0d120:	e1a03000 	mov	r3, r0
21f0d124:	e50b3810 	str	r3, [fp, #-2064]
	pkt.u.call.vers = htonl(2);	/* portmapper is version 2 */
21f0d128:	e3a00002 	mov	r0, #2	; 0x2
21f0d12c:	ebffffc5 	bl	21f0d048 <__fswab32>
21f0d130:	e1a03000 	mov	r3, r0
21f0d134:	e50b380c 	str	r3, [fp, #-2060]
	pkt.u.call.proc = htonl(rpc_proc);
21f0d138:	e51b3824 	ldr	r3, [fp, #-2084]
21f0d13c:	e1a00003 	mov	r0, r3
21f0d140:	ebffffc0 	bl	21f0d048 <__fswab32>
21f0d144:	e1a03000 	mov	r3, r0
21f0d148:	e50b3808 	str	r3, [fp, #-2056]
	p = (uint32_t *)&(pkt.u.call.data);
21f0d14c:	e24b3e81 	sub	r3, fp, #2064	; 0x810
21f0d150:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d154:	e2833018 	add	r3, r3, #24	; 0x18
21f0d158:	e50b3018 	str	r3, [fp, #-24]

	if (datalen)
21f0d15c:	e51b382c 	ldr	r3, [fp, #-2092]
21f0d160:	e3530000 	cmp	r3, #0	; 0x0
21f0d164:	0a000006 	beq	21f0d184 <rpc_req+0xe4>
		memcpy ((char *)p, (char *)data, datalen*sizeof(uint32_t));
21f0d168:	e51b2018 	ldr	r2, [fp, #-24]
21f0d16c:	e51b1828 	ldr	r1, [fp, #-2088]
21f0d170:	e51b382c 	ldr	r3, [fp, #-2092]
21f0d174:	e1a03103 	mov	r3, r3, lsl #2
21f0d178:	e1a00002 	mov	r0, r2
21f0d17c:	e1a02003 	mov	r2, r3
21f0d180:	eb005811 	bl	21f231cc <memcpy>

	pktlen = (char *)p + datalen*sizeof(uint32_t) - (char *)&pkt;
21f0d184:	e51b382c 	ldr	r3, [fp, #-2092]
21f0d188:	e1a03103 	mov	r3, r3, lsl #2
21f0d18c:	e1a02003 	mov	r2, r3
21f0d190:	e51b3018 	ldr	r3, [fp, #-24]
21f0d194:	e0823003 	add	r3, r2, r3
21f0d198:	e1a02003 	mov	r2, r3
21f0d19c:	e24b3e81 	sub	r3, fp, #2064	; 0x810
21f0d1a0:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d1a4:	e0633002 	rsb	r3, r3, r2
21f0d1a8:	e50b3014 	str	r3, [fp, #-20]

	memcpy ((char *)NetTxPacket + NetEthHdrSize() + IP_HDR_SIZE, (char *)&pkt, pktlen);
21f0d1ac:	ebfff429 	bl	21f0a258 <NetEthHdrSize>
21f0d1b0:	e1a03000 	mov	r3, r0
21f0d1b4:	e1a02003 	mov	r2, r3
21f0d1b8:	e59f30b0 	ldr	r3, [pc, #176]	; 21f0d270 <.text+0xd270>
21f0d1bc:	e5933000 	ldr	r3, [r3]
21f0d1c0:	e0823003 	add	r3, r2, r3
21f0d1c4:	e283301c 	add	r3, r3, #28	; 0x1c
21f0d1c8:	e24b2e81 	sub	r2, fp, #2064	; 0x810
21f0d1cc:	e242200c 	sub	r2, r2, #12	; 0xc
21f0d1d0:	e51bc014 	ldr	ip, [fp, #-20]
21f0d1d4:	e1a00003 	mov	r0, r3
21f0d1d8:	e1a01002 	mov	r1, r2
21f0d1dc:	e1a0200c 	mov	r2, ip
21f0d1e0:	eb0057f9 	bl	21f231cc <memcpy>

	if (rpc_prog == PROG_PORTMAP)
21f0d1e4:	e51b2820 	ldr	r2, [fp, #-2080]
21f0d1e8:	e3a03b61 	mov	r3, #99328	; 0x18400
21f0d1ec:	e2833e2a 	add	r3, r3, #672	; 0x2a0
21f0d1f0:	e1520003 	cmp	r2, r3
21f0d1f4:	1a000002 	bne	21f0d204 <rpc_req+0x164>
		sport = SUNRPC_PORT;
21f0d1f8:	e3a0306f 	mov	r3, #111	; 0x6f
21f0d1fc:	e50b3010 	str	r3, [fp, #-16]
21f0d200:	ea00000c 	b	21f0d238 <rpc_req+0x198>
	else if (rpc_prog == PROG_MOUNT)
21f0d204:	e51b2820 	ldr	r2, [fp, #-2080]
21f0d208:	e3a03b61 	mov	r3, #99328	; 0x18400
21f0d20c:	e2833fa9 	add	r3, r3, #676	; 0x2a4
21f0d210:	e2833001 	add	r3, r3, #1	; 0x1
21f0d214:	e1520003 	cmp	r2, r3
21f0d218:	1a000003 	bne	21f0d22c <rpc_req+0x18c>
		sport = NfsSrvMountPort;
21f0d21c:	e59f3050 	ldr	r3, [pc, #80]	; 21f0d274 <.text+0xd274>
21f0d220:	e5933000 	ldr	r3, [r3]
21f0d224:	e50b3010 	str	r3, [fp, #-16]
21f0d228:	ea000002 	b	21f0d238 <rpc_req+0x198>
	else
		sport = NfsSrvNfsPort;
21f0d22c:	e59f3044 	ldr	r3, [pc, #68]	; 21f0d278 <.text+0xd278>
21f0d230:	e5933000 	ldr	r3, [r3]
21f0d234:	e50b3010 	str	r3, [fp, #-16]

	NetSendUDPPacket (NetServerEther, NfsServerIP, sport, NfsOurPort, pktlen);
21f0d238:	e59f303c 	ldr	r3, [pc, #60]	; 21f0d27c <.text+0xd27c>
21f0d23c:	e5932000 	ldr	r2, [r3]
21f0d240:	e59f3038 	ldr	r3, [pc, #56]	; 21f0d280 <.text+0xd280>
21f0d244:	e593c000 	ldr	ip, [r3]
21f0d248:	e51b3014 	ldr	r3, [fp, #-20]
21f0d24c:	e58d3000 	str	r3, [sp]
21f0d250:	e59f002c 	ldr	r0, [pc, #44]	; 21f0d284 <.text+0xd284>
21f0d254:	e1a01002 	mov	r1, r2
21f0d258:	e51b2010 	ldr	r2, [fp, #-16]
21f0d25c:	e1a0300c 	mov	r3, ip
21f0d260:	ebfff0b6 	bl	21f09540 <NetSendUDPPacket>
}
21f0d264:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d268:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0d26c:	21f66ac0 	mvncss	r6, r0, asr #21
21f0d270:	21f6454c 	mvncss	r4, ip, asr #10
21f0d274:	21f66b10 	mvncss	r6, r0, lsl fp
21f0d278:	21f66b14 	mvncss	r6, r4, lsl fp
21f0d27c:	21f66b0c 	mvncss	r6, ip, lsl #22
21f0d280:	21f66b18 	mvncss	r6, r8, lsl fp
21f0d284:	21f6453e 	mvncss	r4, lr, lsr r5

21f0d288 <rpc_lookup_req>:

/**************************************************************************
RPC_LOOKUP - Lookup RPC Port numbers
**************************************************************************/
static void
rpc_lookup_req (int prog, int ver)
{
21f0d288:	e1a0c00d 	mov	ip, sp
21f0d28c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d290:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d294:	e24dd048 	sub	sp, sp, #72	; 0x48
21f0d298:	e50b0050 	str	r0, [fp, #-80]
21f0d29c:	e50b1054 	str	r1, [fp, #-84]
	uint32_t data[16];

	data[0] = 0; data[1] = 0;	/* auth credential */
21f0d2a0:	e3a03000 	mov	r3, #0	; 0x0
21f0d2a4:	e50b304c 	str	r3, [fp, #-76]
21f0d2a8:	e3a03000 	mov	r3, #0	; 0x0
21f0d2ac:	e50b3048 	str	r3, [fp, #-72]
	data[2] = 0; data[3] = 0;	/* auth verifier */
21f0d2b0:	e3a03000 	mov	r3, #0	; 0x0
21f0d2b4:	e50b3044 	str	r3, [fp, #-68]
21f0d2b8:	e3a03000 	mov	r3, #0	; 0x0
21f0d2bc:	e50b3040 	str	r3, [fp, #-64]
	data[4] = htonl(prog);
21f0d2c0:	e51b3050 	ldr	r3, [fp, #-80]
21f0d2c4:	e1a00003 	mov	r0, r3
21f0d2c8:	ebffff5e 	bl	21f0d048 <__fswab32>
21f0d2cc:	e1a03000 	mov	r3, r0
21f0d2d0:	e50b303c 	str	r3, [fp, #-60]
	data[5] = htonl(ver);
21f0d2d4:	e51b3054 	ldr	r3, [fp, #-84]
21f0d2d8:	e1a00003 	mov	r0, r3
21f0d2dc:	ebffff59 	bl	21f0d048 <__fswab32>
21f0d2e0:	e1a03000 	mov	r3, r0
21f0d2e4:	e50b3038 	str	r3, [fp, #-56]
	data[6] = htonl(17);	/* IP_UDP */
21f0d2e8:	e3a00011 	mov	r0, #17	; 0x11
21f0d2ec:	ebffff55 	bl	21f0d048 <__fswab32>
21f0d2f0:	e1a03000 	mov	r3, r0
21f0d2f4:	e50b3034 	str	r3, [fp, #-52]
	data[7] = 0;
21f0d2f8:	e3a03000 	mov	r3, #0	; 0x0
21f0d2fc:	e50b3030 	str	r3, [fp, #-48]

	rpc_req (PROG_PORTMAP, PORTMAP_GETPORT, data, 8);
21f0d300:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f0d304:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d308:	e2800e2a 	add	r0, r0, #672	; 0x2a0
21f0d30c:	e3a01003 	mov	r1, #3	; 0x3
21f0d310:	e1a02003 	mov	r2, r3
21f0d314:	e3a03008 	mov	r3, #8	; 0x8
21f0d318:	ebffff60 	bl	21f0d0a0 <rpc_req>
}
21f0d31c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d320:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0d324 <nfs_mount_req>:

/**************************************************************************
NFS_MOUNT - Mount an NFS Filesystem
**************************************************************************/
static void
nfs_mount_req (char *path)
{
21f0d324:	e1a0c00d 	mov	ip, sp
21f0d328:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d32c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d330:	e24dda01 	sub	sp, sp, #4096	; 0x1000
21f0d334:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0d338:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d33c:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d340:	e24b200c 	sub	r2, fp, #12	; 0xc
21f0d344:	e7820003 	str	r0, [r2, r3]
	uint32_t data[1024];
	uint32_t *p;
	int len;
	int pathlen;

	pathlen = strlen (path);
21f0d348:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d34c:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d350:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f0d354:	e79c0003 	ldr	r0, [ip, r3]
21f0d358:	eb005619 	bl	21f22bc4 <strlen>
21f0d35c:	e1a03000 	mov	r3, r0
21f0d360:	e50b3010 	str	r3, [fp, #-16]

	p = &(data[0]);
21f0d364:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d368:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d36c:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d370:	e50b3018 	str	r3, [fp, #-24]
	p = (uint32_t *)rpc_add_credentials((long *)p);
21f0d374:	e51b3018 	ldr	r3, [fp, #-24]
21f0d378:	e1a00003 	mov	r0, r3
21f0d37c:	ebfffeb7 	bl	21f0ce60 <rpc_add_credentials>
21f0d380:	e1a03000 	mov	r3, r0
21f0d384:	e50b3018 	str	r3, [fp, #-24]

	*p++ = htonl(pathlen);
21f0d388:	e51b3010 	ldr	r3, [fp, #-16]
21f0d38c:	e1a00003 	mov	r0, r3
21f0d390:	ebffff2c 	bl	21f0d048 <__fswab32>
21f0d394:	e1a03000 	mov	r3, r0
21f0d398:	e1a02003 	mov	r2, r3
21f0d39c:	e51b3018 	ldr	r3, [fp, #-24]
21f0d3a0:	e5832000 	str	r2, [r3]
21f0d3a4:	e51b3018 	ldr	r3, [fp, #-24]
21f0d3a8:	e2833004 	add	r3, r3, #4	; 0x4
21f0d3ac:	e50b3018 	str	r3, [fp, #-24]
	if (pathlen & 3) *(p + pathlen / 4) = 0;
21f0d3b0:	e51b3010 	ldr	r3, [fp, #-16]
21f0d3b4:	e2033003 	and	r3, r3, #3	; 0x3
21f0d3b8:	e3530000 	cmp	r3, #0	; 0x0
21f0d3bc:	0a00000a 	beq	21f0d3ec <nfs_mount_req+0xc8>
21f0d3c0:	e51b3010 	ldr	r3, [fp, #-16]
21f0d3c4:	e2832003 	add	r2, r3, #3	; 0x3
21f0d3c8:	e3530000 	cmp	r3, #0	; 0x0
21f0d3cc:	b1a03002 	movlt	r3, r2
21f0d3d0:	e1a03143 	mov	r3, r3, asr #2
21f0d3d4:	e1a03103 	mov	r3, r3, lsl #2
21f0d3d8:	e1a02003 	mov	r2, r3
21f0d3dc:	e51b3018 	ldr	r3, [fp, #-24]
21f0d3e0:	e0822003 	add	r2, r2, r3
21f0d3e4:	e3a03000 	mov	r3, #0	; 0x0
21f0d3e8:	e5823000 	str	r3, [r2]
	memcpy (p, path, pathlen);
21f0d3ec:	e51b2010 	ldr	r2, [fp, #-16]
21f0d3f0:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d3f4:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d3f8:	e51b0018 	ldr	r0, [fp, #-24]
21f0d3fc:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f0d400:	e79c1003 	ldr	r1, [ip, r3]
21f0d404:	eb005770 	bl	21f231cc <memcpy>
	p += (pathlen + 3) / 4;
21f0d408:	e51b3010 	ldr	r3, [fp, #-16]
21f0d40c:	e2833003 	add	r3, r3, #3	; 0x3
21f0d410:	e2832003 	add	r2, r3, #3	; 0x3
21f0d414:	e3530000 	cmp	r3, #0	; 0x0
21f0d418:	b1a03002 	movlt	r3, r2
21f0d41c:	e1a03143 	mov	r3, r3, asr #2
21f0d420:	e1a03103 	mov	r3, r3, lsl #2
21f0d424:	e1a02003 	mov	r2, r3
21f0d428:	e51b3018 	ldr	r3, [fp, #-24]
21f0d42c:	e0833002 	add	r3, r3, r2
21f0d430:	e50b3018 	str	r3, [fp, #-24]

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
21f0d434:	e51b2018 	ldr	r2, [fp, #-24]
21f0d438:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d43c:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d440:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d444:	e0633002 	rsb	r3, r3, r2
21f0d448:	e1a03143 	mov	r3, r3, asr #2
21f0d44c:	e50b3014 	str	r3, [fp, #-20]

	rpc_req (PROG_MOUNT, MOUNT_ADDENTRY, data, len);
21f0d450:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d454:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d458:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d45c:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d460:	e2800fa9 	add	r0, r0, #676	; 0x2a4
21f0d464:	e2800001 	add	r0, r0, #1	; 0x1
21f0d468:	e3a01001 	mov	r1, #1	; 0x1
21f0d46c:	e1a02003 	mov	r2, r3
21f0d470:	e51b3014 	ldr	r3, [fp, #-20]
21f0d474:	ebffff09 	bl	21f0d0a0 <rpc_req>
}
21f0d478:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d47c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0d480 <nfs_umountall_req>:

/**************************************************************************
NFS_UMOUNTALL - Unmount all our NFS Filesystems on the Server
**************************************************************************/
static void
nfs_umountall_req (void)
{
21f0d480:	e1a0c00d 	mov	ip, sp
21f0d484:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d488:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d48c:	e24dda01 	sub	sp, sp, #4096	; 0x1000
21f0d490:	e24dd008 	sub	sp, sp, #8	; 0x8
	uint32_t data[1024];
	uint32_t *p;
	int len;

	if ((NfsSrvMountPort == -1) || (!fs_mounted)) {
21f0d494:	e59f3088 	ldr	r3, [pc, #136]	; 21f0d524 <.text+0xd524>
21f0d498:	e5933000 	ldr	r3, [r3]
21f0d49c:	e3730001 	cmn	r3, #1	; 0x1
21f0d4a0:	0a00001d 	beq	21f0d51c <nfs_umountall_req+0x9c>
21f0d4a4:	e59f307c 	ldr	r3, [pc, #124]	; 21f0d528 <.text+0xd528>
21f0d4a8:	e5933000 	ldr	r3, [r3]
21f0d4ac:	e3530000 	cmp	r3, #0	; 0x0
21f0d4b0:	0a000019 	beq	21f0d51c <nfs_umountall_req+0x9c>
		/* Nothing mounted, nothing to umount */
		return;
	}

	p = &(data[0]);
21f0d4b4:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d4b8:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d4bc:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d4c0:	e50b3014 	str	r3, [fp, #-20]
	p = (uint32_t *)rpc_add_credentials ((long *)p);
21f0d4c4:	e51b3014 	ldr	r3, [fp, #-20]
21f0d4c8:	e1a00003 	mov	r0, r3
21f0d4cc:	ebfffe63 	bl	21f0ce60 <rpc_add_credentials>
21f0d4d0:	e1a03000 	mov	r3, r0
21f0d4d4:	e50b3014 	str	r3, [fp, #-20]

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
21f0d4d8:	e51b2014 	ldr	r2, [fp, #-20]
21f0d4dc:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d4e0:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d4e4:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d4e8:	e0633002 	rsb	r3, r3, r2
21f0d4ec:	e1a03143 	mov	r3, r3, asr #2
21f0d4f0:	e50b3010 	str	r3, [fp, #-16]

	rpc_req (PROG_MOUNT, MOUNT_UMOUNTALL, data, len);
21f0d4f4:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d4f8:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d4fc:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d500:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d504:	e2800fa9 	add	r0, r0, #676	; 0x2a4
21f0d508:	e2800001 	add	r0, r0, #1	; 0x1
21f0d50c:	e3a01004 	mov	r1, #4	; 0x4
21f0d510:	e1a02003 	mov	r2, r3
21f0d514:	e51b3010 	ldr	r3, [fp, #-16]
21f0d518:	ebfffee0 	bl	21f0d0a0 <rpc_req>
}
21f0d51c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d520:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0d524:	21f66b10 	mvncss	r6, r0, lsl fp
21f0d528:	21f66abc 	ldrcsh	r6, [r6, #172]!

21f0d52c <nfs_readlink_req>:

/***************************************************************************
 * NFS_READLINK (AH 2003-07-14)
 * This procedure is called when read of the first block fails -
 * this probably happens when it's a directory or a symlink
 * In case of successful readlink(), the dirname is manipulated,
 * so that inside the nfs() function a recursion can be done.
 **************************************************************************/
static void
nfs_readlink_req (void)
{
21f0d52c:	e1a0c00d 	mov	ip, sp
21f0d530:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d534:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d538:	e24dda01 	sub	sp, sp, #4096	; 0x1000
21f0d53c:	e24dd008 	sub	sp, sp, #8	; 0x8
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
21f0d540:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d544:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d548:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d54c:	e50b3014 	str	r3, [fp, #-20]
	p = (uint32_t *)rpc_add_credentials ((long *)p);
21f0d550:	e51b3014 	ldr	r3, [fp, #-20]
21f0d554:	e1a00003 	mov	r0, r3
21f0d558:	ebfffe40 	bl	21f0ce60 <rpc_add_credentials>
21f0d55c:	e1a03000 	mov	r3, r0
21f0d560:	e50b3014 	str	r3, [fp, #-20]

	memcpy (p, filefh, NFS_FHSIZE);
21f0d564:	e51b0014 	ldr	r0, [fp, #-20]
21f0d568:	e59f105c 	ldr	r1, [pc, #92]	; 21f0d5cc <.text+0xd5cc>
21f0d56c:	e3a02020 	mov	r2, #32	; 0x20
21f0d570:	eb005715 	bl	21f231cc <memcpy>
	p += (NFS_FHSIZE / 4);
21f0d574:	e51b3014 	ldr	r3, [fp, #-20]
21f0d578:	e2833020 	add	r3, r3, #32	; 0x20
21f0d57c:	e50b3014 	str	r3, [fp, #-20]

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
21f0d580:	e51b2014 	ldr	r2, [fp, #-20]
21f0d584:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d588:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d58c:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d590:	e0633002 	rsb	r3, r3, r2
21f0d594:	e1a03143 	mov	r3, r3, asr #2
21f0d598:	e50b3010 	str	r3, [fp, #-16]

	rpc_req (PROG_NFS, NFS_READLINK, data, len);
21f0d59c:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d5a0:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d5a4:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d5a8:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d5ac:	e2800e2a 	add	r0, r0, #672	; 0x2a0
21f0d5b0:	e2800003 	add	r0, r0, #3	; 0x3
21f0d5b4:	e3a01005 	mov	r1, #5	; 0x5
21f0d5b8:	e1a02003 	mov	r2, r3
21f0d5bc:	e51b3010 	ldr	r3, [fp, #-16]
21f0d5c0:	ebfffeb6 	bl	21f0d0a0 <rpc_req>
}
21f0d5c4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d5c8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0d5cc:	21f66ae8 	mvncss	r6, r8, ror #21

21f0d5d0 <nfs_lookup_req>:

/**************************************************************************
NFS_LOOKUP - Lookup Pathname
**************************************************************************/
static void
nfs_lookup_req (char *fname)
{
21f0d5d0:	e1a0c00d 	mov	ip, sp
21f0d5d4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d5d8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d5dc:	e24dda01 	sub	sp, sp, #4096	; 0x1000
21f0d5e0:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0d5e4:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d5e8:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d5ec:	e24b200c 	sub	r2, fp, #12	; 0xc
21f0d5f0:	e7820003 	str	r0, [r2, r3]
	uint32_t data[1024];
	uint32_t *p;
	int len;
	int fnamelen;

	fnamelen = strlen (fname);
21f0d5f4:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d5f8:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d5fc:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f0d600:	e79c0003 	ldr	r0, [ip, r3]
21f0d604:	eb00556e 	bl	21f22bc4 <strlen>
21f0d608:	e1a03000 	mov	r3, r0
21f0d60c:	e50b3010 	str	r3, [fp, #-16]

	p = &(data[0]);
21f0d610:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d614:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d618:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d61c:	e50b3018 	str	r3, [fp, #-24]
	p = (uint32_t *)rpc_add_credentials ((long *)p);
21f0d620:	e51b3018 	ldr	r3, [fp, #-24]
21f0d624:	e1a00003 	mov	r0, r3
21f0d628:	ebfffe0c 	bl	21f0ce60 <rpc_add_credentials>
21f0d62c:	e1a03000 	mov	r3, r0
21f0d630:	e50b3018 	str	r3, [fp, #-24]

	memcpy (p, dirfh, NFS_FHSIZE);
21f0d634:	e51b0018 	ldr	r0, [fp, #-24]
21f0d638:	e59f1108 	ldr	r1, [pc, #264]	; 21f0d748 <.text+0xd748>
21f0d63c:	e3a02020 	mov	r2, #32	; 0x20
21f0d640:	eb0056e1 	bl	21f231cc <memcpy>
	p += (NFS_FHSIZE / 4);
21f0d644:	e51b3018 	ldr	r3, [fp, #-24]
21f0d648:	e2833020 	add	r3, r3, #32	; 0x20
21f0d64c:	e50b3018 	str	r3, [fp, #-24]
	*p++ = htonl(fnamelen);
21f0d650:	e51b3010 	ldr	r3, [fp, #-16]
21f0d654:	e1a00003 	mov	r0, r3
21f0d658:	ebfffe7a 	bl	21f0d048 <__fswab32>
21f0d65c:	e1a03000 	mov	r3, r0
21f0d660:	e1a02003 	mov	r2, r3
21f0d664:	e51b3018 	ldr	r3, [fp, #-24]
21f0d668:	e5832000 	str	r2, [r3]
21f0d66c:	e51b3018 	ldr	r3, [fp, #-24]
21f0d670:	e2833004 	add	r3, r3, #4	; 0x4
21f0d674:	e50b3018 	str	r3, [fp, #-24]
	if (fnamelen & 3) *(p + fnamelen / 4) = 0;
21f0d678:	e51b3010 	ldr	r3, [fp, #-16]
21f0d67c:	e2033003 	and	r3, r3, #3	; 0x3
21f0d680:	e3530000 	cmp	r3, #0	; 0x0
21f0d684:	0a00000a 	beq	21f0d6b4 <nfs_lookup_req+0xe4>
21f0d688:	e51b3010 	ldr	r3, [fp, #-16]
21f0d68c:	e2832003 	add	r2, r3, #3	; 0x3
21f0d690:	e3530000 	cmp	r3, #0	; 0x0
21f0d694:	b1a03002 	movlt	r3, r2
21f0d698:	e1a03143 	mov	r3, r3, asr #2
21f0d69c:	e1a03103 	mov	r3, r3, lsl #2
21f0d6a0:	e1a02003 	mov	r2, r3
21f0d6a4:	e51b3018 	ldr	r3, [fp, #-24]
21f0d6a8:	e0822003 	add	r2, r2, r3
21f0d6ac:	e3a03000 	mov	r3, #0	; 0x0
21f0d6b0:	e5823000 	str	r3, [r2]
	memcpy (p, fname, fnamelen);
21f0d6b4:	e51b2010 	ldr	r2, [fp, #-16]
21f0d6b8:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d6bc:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d6c0:	e51b0018 	ldr	r0, [fp, #-24]
21f0d6c4:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f0d6c8:	e79c1003 	ldr	r1, [ip, r3]
21f0d6cc:	eb0056be 	bl	21f231cc <memcpy>
	p += (fnamelen + 3) / 4;
21f0d6d0:	e51b3010 	ldr	r3, [fp, #-16]
21f0d6d4:	e2833003 	add	r3, r3, #3	; 0x3
21f0d6d8:	e2832003 	add	r2, r3, #3	; 0x3
21f0d6dc:	e3530000 	cmp	r3, #0	; 0x0
21f0d6e0:	b1a03002 	movlt	r3, r2
21f0d6e4:	e1a03143 	mov	r3, r3, asr #2
21f0d6e8:	e1a03103 	mov	r3, r3, lsl #2
21f0d6ec:	e1a02003 	mov	r2, r3
21f0d6f0:	e51b3018 	ldr	r3, [fp, #-24]
21f0d6f4:	e0833002 	add	r3, r3, r2
21f0d6f8:	e50b3018 	str	r3, [fp, #-24]

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
21f0d6fc:	e51b2018 	ldr	r2, [fp, #-24]
21f0d700:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d704:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d708:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d70c:	e0633002 	rsb	r3, r3, r2
21f0d710:	e1a03143 	mov	r3, r3, asr #2
21f0d714:	e50b3014 	str	r3, [fp, #-20]

	rpc_req (PROG_NFS, NFS_LOOKUP, data, len);
21f0d718:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d71c:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d720:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d724:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d728:	e2800e2a 	add	r0, r0, #672	; 0x2a0
21f0d72c:	e2800003 	add	r0, r0, #3	; 0x3
21f0d730:	e3a01004 	mov	r1, #4	; 0x4
21f0d734:	e1a02003 	mov	r2, r3
21f0d738:	e51b3014 	ldr	r3, [fp, #-20]
21f0d73c:	ebfffe57 	bl	21f0d0a0 <rpc_req>
}
21f0d740:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d744:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0d748:	21f66ac8 	mvncss	r6, r8, asr #21

21f0d74c <nfs_read_req>:

/**************************************************************************
NFS_READ - Read File on NFS Server
**************************************************************************/
static void
nfs_read_req (int offset, int readlen)
{
21f0d74c:	e1a0c00d 	mov	ip, sp
21f0d750:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d754:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d758:	e24dda01 	sub	sp, sp, #4096	; 0x1000
21f0d75c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0d760:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d764:	e243300b 	sub	r3, r3, #11	; 0xb
21f0d768:	e24b200c 	sub	r2, fp, #12	; 0xc
21f0d76c:	e7820003 	str	r0, [r2, r3]
21f0d770:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d774:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d778:	e24b200c 	sub	r2, fp, #12	; 0xc
21f0d77c:	e7821003 	str	r1, [r2, r3]
	uint32_t data[1024];
	uint32_t *p;
	int len;

	p = &(data[0]);
21f0d780:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d784:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d788:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d78c:	e50b3014 	str	r3, [fp, #-20]
	p = (uint32_t *)rpc_add_credentials ((long *)p);
21f0d790:	e51b3014 	ldr	r3, [fp, #-20]
21f0d794:	e1a00003 	mov	r0, r3
21f0d798:	ebfffdb0 	bl	21f0ce60 <rpc_add_credentials>
21f0d79c:	e1a03000 	mov	r3, r0
21f0d7a0:	e50b3014 	str	r3, [fp, #-20]

	memcpy (p, filefh, NFS_FHSIZE);
21f0d7a4:	e51b0014 	ldr	r0, [fp, #-20]
21f0d7a8:	e59f10dc 	ldr	r1, [pc, #220]	; 21f0d88c <.text+0xd88c>
21f0d7ac:	e3a02020 	mov	r2, #32	; 0x20
21f0d7b0:	eb005685 	bl	21f231cc <memcpy>
	p += (NFS_FHSIZE / 4);
21f0d7b4:	e51b3014 	ldr	r3, [fp, #-20]
21f0d7b8:	e2833020 	add	r3, r3, #32	; 0x20
21f0d7bc:	e50b3014 	str	r3, [fp, #-20]
	*p++ = htonl(offset);
21f0d7c0:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d7c4:	e243300b 	sub	r3, r3, #11	; 0xb
21f0d7c8:	e24b200c 	sub	r2, fp, #12	; 0xc
21f0d7cc:	e7923003 	ldr	r3, [r2, r3]
21f0d7d0:	e1a00003 	mov	r0, r3
21f0d7d4:	ebfffe1b 	bl	21f0d048 <__fswab32>
21f0d7d8:	e1a03000 	mov	r3, r0
21f0d7dc:	e1a02003 	mov	r2, r3
21f0d7e0:	e51b3014 	ldr	r3, [fp, #-20]
21f0d7e4:	e5832000 	str	r2, [r3]
21f0d7e8:	e51b3014 	ldr	r3, [fp, #-20]
21f0d7ec:	e2833004 	add	r3, r3, #4	; 0x4
21f0d7f0:	e50b3014 	str	r3, [fp, #-20]
	*p++ = htonl(readlen);
21f0d7f4:	e3e03a01 	mvn	r3, #4096	; 0x1000
21f0d7f8:	e243300f 	sub	r3, r3, #15	; 0xf
21f0d7fc:	e24b200c 	sub	r2, fp, #12	; 0xc
21f0d800:	e7923003 	ldr	r3, [r2, r3]
21f0d804:	e1a00003 	mov	r0, r3
21f0d808:	ebfffe0e 	bl	21f0d048 <__fswab32>
21f0d80c:	e1a03000 	mov	r3, r0
21f0d810:	e1a02003 	mov	r2, r3
21f0d814:	e51b3014 	ldr	r3, [fp, #-20]
21f0d818:	e5832000 	str	r2, [r3]
21f0d81c:	e51b3014 	ldr	r3, [fp, #-20]
21f0d820:	e2833004 	add	r3, r3, #4	; 0x4
21f0d824:	e50b3014 	str	r3, [fp, #-20]
	*p++ = 0;
21f0d828:	e51b2014 	ldr	r2, [fp, #-20]
21f0d82c:	e3a03000 	mov	r3, #0	; 0x0
21f0d830:	e5823000 	str	r3, [r2]
21f0d834:	e51b3014 	ldr	r3, [fp, #-20]
21f0d838:	e2833004 	add	r3, r3, #4	; 0x4
21f0d83c:	e50b3014 	str	r3, [fp, #-20]

	len = (uint32_t *)p - (uint32_t *)&(data[0]);
21f0d840:	e51b2014 	ldr	r2, [fp, #-20]
21f0d844:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d848:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d84c:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d850:	e0633002 	rsb	r3, r3, r2
21f0d854:	e1a03143 	mov	r3, r3, asr #2
21f0d858:	e50b3010 	str	r3, [fp, #-16]

	rpc_req (PROG_NFS, NFS_READ, data, len);
21f0d85c:	e24b3a01 	sub	r3, fp, #4096	; 0x1000
21f0d860:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d864:	e2433008 	sub	r3, r3, #8	; 0x8
21f0d868:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d86c:	e2800e2a 	add	r0, r0, #672	; 0x2a0
21f0d870:	e2800003 	add	r0, r0, #3	; 0x3
21f0d874:	e3a01006 	mov	r1, #6	; 0x6
21f0d878:	e1a02003 	mov	r2, r3
21f0d87c:	e51b3010 	ldr	r3, [fp, #-16]
21f0d880:	ebfffe06 	bl	21f0d0a0 <rpc_req>
}
21f0d884:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0d888:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0d88c:	21f66ae8 	mvncss	r6, r8, ror #21

21f0d890 <NfsSend>:

/**************************************************************************
RPC request dispatcher
**************************************************************************/

static void
NfsSend (void)
{
21f0d890:	e1a0c00d 	mov	ip, sp
21f0d894:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d898:	e24cb004 	sub	fp, ip, #4	; 0x4
#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif

	switch (NfsState) {
21f0d89c:	e59f30b4 	ldr	r3, [pc, #180]	; 21f0d958 <.text+0xd958>
21f0d8a0:	e5933000 	ldr	r3, [r3]
21f0d8a4:	e2433001 	sub	r3, r3, #1	; 0x1
21f0d8a8:	e3530006 	cmp	r3, #6	; 0x6
21f0d8ac:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0d8b0:	ea000027 	b	21f0d954 <.text+0xd954>
21f0d8b4:	21f0d8d0 	ldrcssb	sp, [r0, #128]!
21f0d8b8:	21f0d8e8 	mvncss	sp, r8, ror #17
21f0d8bc:	21f0d900 	mvncss	sp, r0, lsl #18
21f0d8c0:	21f0d914 	mvncss	sp, r4, lsl r9
21f0d8c4:	21f0d91c 	mvncss	sp, ip, lsl r9
21f0d8c8:	21f0d930 	mvncss	sp, r0, lsr r9
21f0d8cc:	21f0d950 	mvncss	sp, r0, asr r9
	case STATE_PRCLOOKUP_PROG_MOUNT_REQ:
		rpc_lookup_req (PROG_MOUNT, 1);
21f0d8d0:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d8d4:	e2800fa9 	add	r0, r0, #676	; 0x2a4
21f0d8d8:	e2800001 	add	r0, r0, #1	; 0x1
21f0d8dc:	e3a01001 	mov	r1, #1	; 0x1
21f0d8e0:	ebfffe68 	bl	21f0d288 <rpc_lookup_req>
		break;
21f0d8e4:	ea00001a 	b	21f0d954 <.text+0xd954>
	case STATE_PRCLOOKUP_PROG_NFS_REQ:
		rpc_lookup_req (PROG_NFS, 2);
21f0d8e8:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0d8ec:	e2800e2a 	add	r0, r0, #672	; 0x2a0
21f0d8f0:	e2800003 	add	r0, r0, #3	; 0x3
21f0d8f4:	e3a01002 	mov	r1, #2	; 0x2
21f0d8f8:	ebfffe62 	bl	21f0d288 <rpc_lookup_req>
		break;
21f0d8fc:	ea000014 	b	21f0d954 <.text+0xd954>
	case STATE_MOUNT_REQ:
		nfs_mount_req (nfs_path);
21f0d900:	e59f3054 	ldr	r3, [pc, #84]	; 21f0d95c <.text+0xd95c>
21f0d904:	e5933000 	ldr	r3, [r3]
21f0d908:	e1a00003 	mov	r0, r3
21f0d90c:	ebfffe84 	bl	21f0d324 <nfs_mount_req>
		break;
21f0d910:	ea00000f 	b	21f0d954 <.text+0xd954>
	case STATE_UMOUNT_REQ:
		nfs_umountall_req ();
21f0d914:	ebfffed9 	bl	21f0d480 <nfs_umountall_req>
		break;
21f0d918:	ea00000d 	b	21f0d954 <.text+0xd954>
	case STATE_LOOKUP_REQ:
		nfs_lookup_req (nfs_filename);
21f0d91c:	e59f303c 	ldr	r3, [pc, #60]	; 21f0d960 <.text+0xd960>
21f0d920:	e5933000 	ldr	r3, [r3]
21f0d924:	e1a00003 	mov	r0, r3
21f0d928:	ebffff28 	bl	21f0d5d0 <nfs_lookup_req>
		break;
21f0d92c:	ea000008 	b	21f0d954 <.text+0xd954>
	case STATE_READ_REQ:
		nfs_read_req (nfs_offset, nfs_len);
21f0d930:	e59f302c 	ldr	r3, [pc, #44]	; 21f0d964 <.text+0xd964>
21f0d934:	e5932000 	ldr	r2, [r3]
21f0d938:	e59f3028 	ldr	r3, [pc, #40]	; 21f0d968 <.text+0xd968>
21f0d93c:	e5933000 	ldr	r3, [r3]
21f0d940:	e1a00002 	mov	r0, r2
21f0d944:	e1a01003 	mov	r1, r3
21f0d948:	ebffff7f 	bl	21f0d74c <nfs_read_req>
		break;
21f0d94c:	ea000000 	b	21f0d954 <.text+0xd954>
	case STATE_READLINK_REQ:
		nfs_readlink_req ();
21f0d950:	ebfffef5 	bl	21f0d52c <nfs_readlink_req>
		break;
	}
}
21f0d954:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0d958:	21f66b20 	mvncss	r6, r0, lsr #22
21f0d95c:	21f66b68 	mvncss	r6, r8, ror #22
21f0d960:	21f66b64 	mvncss	r6, r4, ror #22
21f0d964:	21f331d8 	ldrcssb	r3, [r3, #24]!
21f0d968:	21f66ac4 	mvncss	r6, r4, asr #21

21f0d96c <rpc_lookup_reply>:

/**************************************************************************
Handlers for the reply from server
**************************************************************************/

static int
rpc_lookup_reply (int prog, uchar *pkt, unsigned len)
{
21f0d96c:	e1a0c00d 	mov	ip, sp
21f0d970:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0d974:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0d978:	e24dde81 	sub	sp, sp, #2064	; 0x810
21f0d97c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0d980:	e50b0810 	str	r0, [fp, #-2064]
21f0d984:	e50b1814 	str	r1, [fp, #-2068]
21f0d988:	e50b2818 	str	r2, [fp, #-2072]
	struct rpc_t rpc_pkt;

	memcpy ((unsigned char *)&rpc_pkt, pkt, len);
21f0d98c:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0d990:	e243300c 	sub	r3, r3, #12	; 0xc
21f0d994:	e1a00003 	mov	r0, r3
21f0d998:	e51b1814 	ldr	r1, [fp, #-2068]
21f0d99c:	e51b2818 	ldr	r2, [fp, #-2072]
21f0d9a0:	eb005609 	bl	21f231cc <memcpy>

#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
21f0d9a4:	e51b380c 	ldr	r3, [fp, #-2060]
21f0d9a8:	e1a00003 	mov	r0, r3
21f0d9ac:	ebfffda5 	bl	21f0d048 <__fswab32>
21f0d9b0:	e1a03000 	mov	r3, r0
21f0d9b4:	e1a02003 	mov	r2, r3
21f0d9b8:	e59f30e0 	ldr	r3, [pc, #224]	; 21f0daa0 <.text+0xdaa0>
21f0d9bc:	e5933000 	ldr	r3, [r3]
21f0d9c0:	e1520003 	cmp	r2, r3
21f0d9c4:	0a000002 	beq	21f0d9d4 <rpc_lookup_reply+0x68>
		return -1;
21f0d9c8:	e3e02000 	mvn	r2, #0	; 0x0
21f0d9cc:	e50b281c 	str	r2, [fp, #-2076]
21f0d9d0:	ea00002e 	b	21f0da90 <rpc_lookup_reply+0x124>

	if (rpc_pkt.u.reply.rstatus  ||
21f0d9d4:	e51b3804 	ldr	r3, [fp, #-2052]
21f0d9d8:	e3530000 	cmp	r3, #0	; 0x0
21f0d9dc:	1a000008 	bne	21f0da04 <rpc_lookup_reply+0x98>
21f0d9e0:	e51b3800 	ldr	r3, [fp, #-2048]
21f0d9e4:	e3530000 	cmp	r3, #0	; 0x0
21f0d9e8:	1a000005 	bne	21f0da04 <rpc_lookup_reply+0x98>
21f0d9ec:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0d9f0:	e3530000 	cmp	r3, #0	; 0x0
21f0d9f4:	1a000002 	bne	21f0da04 <rpc_lookup_reply+0x98>
21f0d9f8:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0d9fc:	e3530000 	cmp	r3, #0	; 0x0
21f0da00:	0a000002 	beq	21f0da10 <rpc_lookup_reply+0xa4>
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.astatus) {
		return -1;
21f0da04:	e3e03000 	mvn	r3, #0	; 0x0
21f0da08:	e50b381c 	str	r3, [fp, #-2076]
21f0da0c:	ea00001f 	b	21f0da90 <rpc_lookup_reply+0x124>
	}

	switch (prog) {
21f0da10:	e51b2810 	ldr	r2, [fp, #-2064]
21f0da14:	e50b2820 	str	r2, [fp, #-2080]
21f0da18:	e3a03b61 	mov	r3, #99328	; 0x18400
21f0da1c:	e2833e2a 	add	r3, r3, #672	; 0x2a0
21f0da20:	e2833003 	add	r3, r3, #3	; 0x3
21f0da24:	e51b2820 	ldr	r2, [fp, #-2080]
21f0da28:	e1520003 	cmp	r2, r3
21f0da2c:	0a00000e 	beq	21f0da6c <rpc_lookup_reply+0x100>
21f0da30:	e3a03b61 	mov	r3, #99328	; 0x18400
21f0da34:	e2833fa9 	add	r3, r3, #676	; 0x2a4
21f0da38:	e2833001 	add	r3, r3, #1	; 0x1
21f0da3c:	e51b2820 	ldr	r2, [fp, #-2080]
21f0da40:	e1520003 	cmp	r2, r3
21f0da44:	0a000000 	beq	21f0da4c <rpc_lookup_reply+0xe0>
21f0da48:	ea00000e 	b	21f0da88 <rpc_lookup_reply+0x11c>
	case PROG_MOUNT:
		NfsSrvMountPort = ntohl(rpc_pkt.u.reply.data[0]);
21f0da4c:	e51b37f4 	ldr	r3, [fp, #-2036]
21f0da50:	e1a00003 	mov	r0, r3
21f0da54:	ebfffd7b 	bl	21f0d048 <__fswab32>
21f0da58:	e1a03000 	mov	r3, r0
21f0da5c:	e1a02003 	mov	r2, r3
21f0da60:	e59f303c 	ldr	r3, [pc, #60]	; 21f0daa4 <.text+0xdaa4>
21f0da64:	e5832000 	str	r2, [r3]
		break;
21f0da68:	ea000006 	b	21f0da88 <rpc_lookup_reply+0x11c>
	case PROG_NFS:
		NfsSrvNfsPort = ntohl(rpc_pkt.u.reply.data[0]);
21f0da6c:	e51b37f4 	ldr	r3, [fp, #-2036]
21f0da70:	e1a00003 	mov	r0, r3
21f0da74:	ebfffd73 	bl	21f0d048 <__fswab32>
21f0da78:	e1a03000 	mov	r3, r0
21f0da7c:	e1a02003 	mov	r2, r3
21f0da80:	e59f3020 	ldr	r3, [pc, #32]	; 21f0daa8 <.text+0xdaa8>
21f0da84:	e5832000 	str	r2, [r3]
		break;
	}

	return 0;
21f0da88:	e3a03000 	mov	r3, #0	; 0x0
21f0da8c:	e50b381c 	str	r3, [fp, #-2076]
21f0da90:	e51b381c 	ldr	r3, [fp, #-2076]
}
21f0da94:	e1a00003 	mov	r0, r3
21f0da98:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0da9c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0daa0:	21f66ac0 	mvncss	r6, r0, asr #21
21f0daa4:	21f66b10 	mvncss	r6, r0, lsl fp
21f0daa8:	21f66b14 	mvncss	r6, r4, lsl fp

21f0daac <nfs_mount_reply>:

static int
nfs_mount_reply (uchar *pkt, unsigned len)
{
21f0daac:	e1a0c00d 	mov	ip, sp
21f0dab0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0dab4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0dab8:	e24ddb02 	sub	sp, sp, #2048	; 0x800
21f0dabc:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0dac0:	e50b0810 	str	r0, [fp, #-2064]
21f0dac4:	e50b1814 	str	r1, [fp, #-2068]
	struct rpc_t rpc_pkt;

#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif

	memcpy ((unsigned char *)&rpc_pkt, pkt, len);
21f0dac8:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0dacc:	e243300c 	sub	r3, r3, #12	; 0xc
21f0dad0:	e1a00003 	mov	r0, r3
21f0dad4:	e51b1810 	ldr	r1, [fp, #-2064]
21f0dad8:	e51b2814 	ldr	r2, [fp, #-2068]
21f0dadc:	eb0055ba 	bl	21f231cc <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
21f0dae0:	e51b380c 	ldr	r3, [fp, #-2060]
21f0dae4:	e1a00003 	mov	r0, r3
21f0dae8:	ebfffd56 	bl	21f0d048 <__fswab32>
21f0daec:	e1a03000 	mov	r3, r0
21f0daf0:	e1a02003 	mov	r2, r3
21f0daf4:	e59f3090 	ldr	r3, [pc, #144]	; 21f0db8c <.text+0xdb8c>
21f0daf8:	e5933000 	ldr	r3, [r3]
21f0dafc:	e1520003 	cmp	r2, r3
21f0db00:	0a000002 	beq	21f0db10 <nfs_mount_reply+0x64>
		return -1;
21f0db04:	e3e03000 	mvn	r3, #0	; 0x0
21f0db08:	e50b3818 	str	r3, [fp, #-2072]
21f0db0c:	ea00001a 	b	21f0db7c <nfs_mount_reply+0xd0>

	if (rpc_pkt.u.reply.rstatus  ||
21f0db10:	e51b3804 	ldr	r3, [fp, #-2052]
21f0db14:	e3530000 	cmp	r3, #0	; 0x0
21f0db18:	1a000008 	bne	21f0db40 <nfs_mount_reply+0x94>
21f0db1c:	e51b3800 	ldr	r3, [fp, #-2048]
21f0db20:	e3530000 	cmp	r3, #0	; 0x0
21f0db24:	1a000005 	bne	21f0db40 <nfs_mount_reply+0x94>
21f0db28:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0db2c:	e3530000 	cmp	r3, #0	; 0x0
21f0db30:	1a000002 	bne	21f0db40 <nfs_mount_reply+0x94>
21f0db34:	e51b37f4 	ldr	r3, [fp, #-2036]
21f0db38:	e3530000 	cmp	r3, #0	; 0x0
21f0db3c:	0a000002 	beq	21f0db4c <nfs_mount_reply+0xa0>
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.data[0]) {
		return -1;
21f0db40:	e3e03000 	mvn	r3, #0	; 0x0
21f0db44:	e50b3818 	str	r3, [fp, #-2072]
21f0db48:	ea00000b 	b	21f0db7c <nfs_mount_reply+0xd0>
	}

	fs_mounted = 1;
21f0db4c:	e59f203c 	ldr	r2, [pc, #60]	; 21f0db90 <.text+0xdb90>
21f0db50:	e3a03001 	mov	r3, #1	; 0x1
21f0db54:	e5823000 	str	r3, [r2]
	memcpy (dirfh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);
21f0db58:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0db5c:	e243300c 	sub	r3, r3, #12	; 0xc
21f0db60:	e283301c 	add	r3, r3, #28	; 0x1c
21f0db64:	e59f0028 	ldr	r0, [pc, #40]	; 21f0db94 <.text+0xdb94>
21f0db68:	e1a01003 	mov	r1, r3
21f0db6c:	e3a02020 	mov	r2, #32	; 0x20
21f0db70:	eb005595 	bl	21f231cc <memcpy>

	return 0;
21f0db74:	e3a03000 	mov	r3, #0	; 0x0
21f0db78:	e50b3818 	str	r3, [fp, #-2072]
21f0db7c:	e51b3818 	ldr	r3, [fp, #-2072]
}
21f0db80:	e1a00003 	mov	r0, r3
21f0db84:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0db88:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0db8c:	21f66ac0 	mvncss	r6, r0, asr #21
21f0db90:	21f66abc 	ldrcsh	r6, [r6, #172]!
21f0db94:	21f66ac8 	mvncss	r6, r8, asr #21

21f0db98 <nfs_umountall_reply>:

static int
nfs_umountall_reply (uchar *pkt, unsigned len)
{
21f0db98:	e1a0c00d 	mov	ip, sp
21f0db9c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0dba0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0dba4:	e24ddb02 	sub	sp, sp, #2048	; 0x800
21f0dba8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0dbac:	e50b0810 	str	r0, [fp, #-2064]
21f0dbb0:	e50b1814 	str	r1, [fp, #-2068]
	struct rpc_t rpc_pkt;

#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif

	memcpy ((unsigned char *)&rpc_pkt, pkt, len);
21f0dbb4:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0dbb8:	e243300c 	sub	r3, r3, #12	; 0xc
21f0dbbc:	e1a00003 	mov	r0, r3
21f0dbc0:	e51b1810 	ldr	r1, [fp, #-2064]
21f0dbc4:	e51b2814 	ldr	r2, [fp, #-2068]
21f0dbc8:	eb00557f 	bl	21f231cc <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
21f0dbcc:	e51b380c 	ldr	r3, [fp, #-2060]
21f0dbd0:	e1a00003 	mov	r0, r3
21f0dbd4:	ebfffd1b 	bl	21f0d048 <__fswab32>
21f0dbd8:	e1a03000 	mov	r3, r0
21f0dbdc:	e1a02003 	mov	r2, r3
21f0dbe0:	e59f3078 	ldr	r3, [pc, #120]	; 21f0dc60 <.text+0xdc60>
21f0dbe4:	e5933000 	ldr	r3, [r3]
21f0dbe8:	e1520003 	cmp	r2, r3
21f0dbec:	0a000002 	beq	21f0dbfc <nfs_umountall_reply+0x64>
		return -1;
21f0dbf0:	e3e03000 	mvn	r3, #0	; 0x0
21f0dbf4:	e50b3818 	str	r3, [fp, #-2072]
21f0dbf8:	ea000014 	b	21f0dc50 <nfs_umountall_reply+0xb8>

	if (rpc_pkt.u.reply.rstatus  ||
21f0dbfc:	e51b3804 	ldr	r3, [fp, #-2052]
21f0dc00:	e3530000 	cmp	r3, #0	; 0x0
21f0dc04:	1a000005 	bne	21f0dc20 <nfs_umountall_reply+0x88>
21f0dc08:	e51b3800 	ldr	r3, [fp, #-2048]
21f0dc0c:	e3530000 	cmp	r3, #0	; 0x0
21f0dc10:	1a000002 	bne	21f0dc20 <nfs_umountall_reply+0x88>
21f0dc14:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0dc18:	e3530000 	cmp	r3, #0	; 0x0
21f0dc1c:	0a000002 	beq	21f0dc2c <nfs_umountall_reply+0x94>
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus) {
		return -1;
21f0dc20:	e3e03000 	mvn	r3, #0	; 0x0
21f0dc24:	e50b3818 	str	r3, [fp, #-2072]
21f0dc28:	ea000008 	b	21f0dc50 <nfs_umountall_reply+0xb8>
	}

	fs_mounted = 0;
21f0dc2c:	e59f2030 	ldr	r2, [pc, #48]	; 21f0dc64 <.text+0xdc64>
21f0dc30:	e3a03000 	mov	r3, #0	; 0x0
21f0dc34:	e5823000 	str	r3, [r2]
	memset (dirfh, 0, sizeof(dirfh));
21f0dc38:	e59f0028 	ldr	r0, [pc, #40]	; 21f0dc68 <.text+0xdc68>
21f0dc3c:	e3a01000 	mov	r1, #0	; 0x0
21f0dc40:	e3a02020 	mov	r2, #32	; 0x20
21f0dc44:	eb005527 	bl	21f230e8 <memset>

	return 0;
21f0dc48:	e3a03000 	mov	r3, #0	; 0x0
21f0dc4c:	e50b3818 	str	r3, [fp, #-2072]
21f0dc50:	e51b3818 	ldr	r3, [fp, #-2072]
}
21f0dc54:	e1a00003 	mov	r0, r3
21f0dc58:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0dc5c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0dc60:	21f66ac0 	mvncss	r6, r0, asr #21
21f0dc64:	21f66abc 	ldrcsh	r6, [r6, #172]!
21f0dc68:	21f66ac8 	mvncss	r6, r8, asr #21

21f0dc6c <nfs_lookup_reply>:

static int
nfs_lookup_reply (uchar *pkt, unsigned len)
{
21f0dc6c:	e1a0c00d 	mov	ip, sp
21f0dc70:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0dc74:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0dc78:	e24ddb02 	sub	sp, sp, #2048	; 0x800
21f0dc7c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f0dc80:	e50b0810 	str	r0, [fp, #-2064]
21f0dc84:	e50b1814 	str	r1, [fp, #-2068]
	struct rpc_t rpc_pkt;

#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif

	memcpy ((unsigned char *)&rpc_pkt, pkt, len);
21f0dc88:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0dc8c:	e243300c 	sub	r3, r3, #12	; 0xc
21f0dc90:	e1a00003 	mov	r0, r3
21f0dc94:	e51b1810 	ldr	r1, [fp, #-2064]
21f0dc98:	e51b2814 	ldr	r2, [fp, #-2068]
21f0dc9c:	eb00554a 	bl	21f231cc <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
21f0dca0:	e51b380c 	ldr	r3, [fp, #-2060]
21f0dca4:	e1a00003 	mov	r0, r3
21f0dca8:	ebfffce6 	bl	21f0d048 <__fswab32>
21f0dcac:	e1a03000 	mov	r3, r0
21f0dcb0:	e1a02003 	mov	r2, r3
21f0dcb4:	e59f3084 	ldr	r3, [pc, #132]	; 21f0dd40 <.text+0xdd40>
21f0dcb8:	e5933000 	ldr	r3, [r3]
21f0dcbc:	e1520003 	cmp	r2, r3
21f0dcc0:	0a000002 	beq	21f0dcd0 <nfs_lookup_reply+0x64>
		return -1;
21f0dcc4:	e3e03000 	mvn	r3, #0	; 0x0
21f0dcc8:	e50b3818 	str	r3, [fp, #-2072]
21f0dccc:	ea000017 	b	21f0dd30 <nfs_lookup_reply+0xc4>

	if (rpc_pkt.u.reply.rstatus  ||
21f0dcd0:	e51b3804 	ldr	r3, [fp, #-2052]
21f0dcd4:	e3530000 	cmp	r3, #0	; 0x0
21f0dcd8:	1a000008 	bne	21f0dd00 <nfs_lookup_reply+0x94>
21f0dcdc:	e51b3800 	ldr	r3, [fp, #-2048]
21f0dce0:	e3530000 	cmp	r3, #0	; 0x0
21f0dce4:	1a000005 	bne	21f0dd00 <nfs_lookup_reply+0x94>
21f0dce8:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0dcec:	e3530000 	cmp	r3, #0	; 0x0
21f0dcf0:	1a000002 	bne	21f0dd00 <nfs_lookup_reply+0x94>
21f0dcf4:	e51b37f4 	ldr	r3, [fp, #-2036]
21f0dcf8:	e3530000 	cmp	r3, #0	; 0x0
21f0dcfc:	0a000002 	beq	21f0dd0c <nfs_lookup_reply+0xa0>
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.data[0]) {
		return -1;
21f0dd00:	e3e03000 	mvn	r3, #0	; 0x0
21f0dd04:	e50b3818 	str	r3, [fp, #-2072]
21f0dd08:	ea000008 	b	21f0dd30 <nfs_lookup_reply+0xc4>
	}

	memcpy (filefh, rpc_pkt.u.reply.data + 1, NFS_FHSIZE);
21f0dd0c:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0dd10:	e243300c 	sub	r3, r3, #12	; 0xc
21f0dd14:	e283301c 	add	r3, r3, #28	; 0x1c
21f0dd18:	e59f0024 	ldr	r0, [pc, #36]	; 21f0dd44 <.text+0xdd44>
21f0dd1c:	e1a01003 	mov	r1, r3
21f0dd20:	e3a02020 	mov	r2, #32	; 0x20
21f0dd24:	eb005528 	bl	21f231cc <memcpy>

	return 0;
21f0dd28:	e3a03000 	mov	r3, #0	; 0x0
21f0dd2c:	e50b3818 	str	r3, [fp, #-2072]
21f0dd30:	e51b3818 	ldr	r3, [fp, #-2072]
}
21f0dd34:	e1a00003 	mov	r0, r3
21f0dd38:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0dd3c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0dd40:	21f66ac0 	mvncss	r6, r0, asr #21
21f0dd44:	21f66ae8 	mvncss	r6, r8, ror #21

21f0dd48 <nfs_readlink_reply>:

static int
nfs_readlink_reply (uchar *pkt, unsigned len)
{
21f0dd48:	e1a0c00d 	mov	ip, sp
21f0dd4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0dd50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0dd54:	e24dde81 	sub	sp, sp, #2064	; 0x810
21f0dd58:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0dd5c:	e50b0818 	str	r0, [fp, #-2072]
21f0dd60:	e50b181c 	str	r1, [fp, #-2076]
	struct rpc_t rpc_pkt;
	int rlen;

#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif

	memcpy ((unsigned char *)&rpc_pkt, pkt, len);
21f0dd64:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0dd68:	e243300c 	sub	r3, r3, #12	; 0xc
21f0dd6c:	e2433008 	sub	r3, r3, #8	; 0x8
21f0dd70:	e1a00003 	mov	r0, r3
21f0dd74:	e51b1818 	ldr	r1, [fp, #-2072]
21f0dd78:	e51b281c 	ldr	r2, [fp, #-2076]
21f0dd7c:	eb005512 	bl	21f231cc <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
21f0dd80:	e51b3814 	ldr	r3, [fp, #-2068]
21f0dd84:	e1a00003 	mov	r0, r3
21f0dd88:	ebfffcae 	bl	21f0d048 <__fswab32>
21f0dd8c:	e1a03000 	mov	r3, r0
21f0dd90:	e1a02003 	mov	r2, r3
21f0dd94:	e59f315c 	ldr	r3, [pc, #348]	; 21f0def8 <.text+0xdef8>
21f0dd98:	e5933000 	ldr	r3, [r3]
21f0dd9c:	e1520003 	cmp	r2, r3
21f0dda0:	0a000002 	beq	21f0ddb0 <nfs_readlink_reply+0x68>
		return -1;
21f0dda4:	e3e03000 	mvn	r3, #0	; 0x0
21f0dda8:	e50b3820 	str	r3, [fp, #-2080]
21f0ddac:	ea00004d 	b	21f0dee8 <nfs_readlink_reply+0x1a0>

	if (rpc_pkt.u.reply.rstatus  ||
21f0ddb0:	e51b380c 	ldr	r3, [fp, #-2060]
21f0ddb4:	e3530000 	cmp	r3, #0	; 0x0
21f0ddb8:	1a000008 	bne	21f0dde0 <nfs_readlink_reply+0x98>
21f0ddbc:	e51b3808 	ldr	r3, [fp, #-2056]
21f0ddc0:	e3530000 	cmp	r3, #0	; 0x0
21f0ddc4:	1a000005 	bne	21f0dde0 <nfs_readlink_reply+0x98>
21f0ddc8:	e51b3800 	ldr	r3, [fp, #-2048]
21f0ddcc:	e3530000 	cmp	r3, #0	; 0x0
21f0ddd0:	1a000002 	bne	21f0dde0 <nfs_readlink_reply+0x98>
21f0ddd4:	e51b37fc 	ldr	r3, [fp, #-2044]
21f0ddd8:	e3530000 	cmp	r3, #0	; 0x0
21f0dddc:	0a000002 	beq	21f0ddec <nfs_readlink_reply+0xa4>
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.data[0]) {
		return -1;
21f0dde0:	e3e03000 	mvn	r3, #0	; 0x0
21f0dde4:	e50b3820 	str	r3, [fp, #-2080]
21f0dde8:	ea00003e 	b	21f0dee8 <nfs_readlink_reply+0x1a0>
	}

	rlen = ntohl (rpc_pkt.u.reply.data[1]); /* new path length */
21f0ddec:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0ddf0:	e1a00003 	mov	r0, r3
21f0ddf4:	ebfffc93 	bl	21f0d048 <__fswab32>
21f0ddf8:	e1a03000 	mov	r3, r0
21f0ddfc:	e50b3014 	str	r3, [fp, #-20]

	if (*((char *)&(rpc_pkt.u.reply.data[2])) != '/') {
21f0de00:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0de04:	e243300c 	sub	r3, r3, #12	; 0xc
21f0de08:	e2433008 	sub	r3, r3, #8	; 0x8
21f0de0c:	e2833020 	add	r3, r3, #32	; 0x20
21f0de10:	e5d33000 	ldrb	r3, [r3]
21f0de14:	e353002f 	cmp	r3, #47	; 0x2f
21f0de18:	0a000020 	beq	21f0dea0 <nfs_readlink_reply+0x158>
		int pathlen;
		strcat (nfs_path, "/");
21f0de1c:	e59f30d8 	ldr	r3, [pc, #216]	; 21f0defc <.text+0xdefc>
21f0de20:	e5933000 	ldr	r3, [r3]
21f0de24:	e1a00003 	mov	r0, r3
21f0de28:	e59f10d0 	ldr	r1, [pc, #208]	; 21f0df00 <.text+0xdf00>
21f0de2c:	eb00526b 	bl	21f227e0 <strcat>
		pathlen = strlen(nfs_path);
21f0de30:	e59f30c4 	ldr	r3, [pc, #196]	; 21f0defc <.text+0xdefc>
21f0de34:	e5933000 	ldr	r3, [r3]
21f0de38:	e1a00003 	mov	r0, r3
21f0de3c:	eb005360 	bl	21f22bc4 <strlen>
21f0de40:	e1a03000 	mov	r3, r0
21f0de44:	e50b3010 	str	r3, [fp, #-16]
		memcpy (nfs_path+pathlen, (uchar *)&(rpc_pkt.u.reply.data[2]), rlen);
21f0de48:	e59f30ac 	ldr	r3, [pc, #172]	; 21f0defc <.text+0xdefc>
21f0de4c:	e5932000 	ldr	r2, [r3]
21f0de50:	e51b3010 	ldr	r3, [fp, #-16]
21f0de54:	e0821003 	add	r1, r2, r3
21f0de58:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0de5c:	e243300c 	sub	r3, r3, #12	; 0xc
21f0de60:	e2433008 	sub	r3, r3, #8	; 0x8
21f0de64:	e2833020 	add	r3, r3, #32	; 0x20
21f0de68:	e51b2014 	ldr	r2, [fp, #-20]
21f0de6c:	e1a00001 	mov	r0, r1
21f0de70:	e1a01003 	mov	r1, r3
21f0de74:	eb0054d4 	bl	21f231cc <memcpy>
		nfs_path[pathlen+rlen+1] = 0;
21f0de78:	e59f307c 	ldr	r3, [pc, #124]	; 21f0defc <.text+0xdefc>
21f0de7c:	e5931000 	ldr	r1, [r3]
21f0de80:	e51b2010 	ldr	r2, [fp, #-16]
21f0de84:	e51b3014 	ldr	r3, [fp, #-20]
21f0de88:	e0823003 	add	r3, r2, r3
21f0de8c:	e0813003 	add	r3, r1, r3
21f0de90:	e2832001 	add	r2, r3, #1	; 0x1
21f0de94:	e3a03000 	mov	r3, #0	; 0x0
21f0de98:	e5c23000 	strb	r3, [r2]
21f0de9c:	ea00000f 	b	21f0dee0 <nfs_readlink_reply+0x198>
	} else {
		memcpy (nfs_path, (uchar *)&(rpc_pkt.u.reply.data[2]), rlen);
21f0dea0:	e59f3054 	ldr	r3, [pc, #84]	; 21f0defc <.text+0xdefc>
21f0dea4:	e5931000 	ldr	r1, [r3]
21f0dea8:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0deac:	e243300c 	sub	r3, r3, #12	; 0xc
21f0deb0:	e2433008 	sub	r3, r3, #8	; 0x8
21f0deb4:	e2833020 	add	r3, r3, #32	; 0x20
21f0deb8:	e51b2014 	ldr	r2, [fp, #-20]
21f0debc:	e1a00001 	mov	r0, r1
21f0dec0:	e1a01003 	mov	r1, r3
21f0dec4:	eb0054c0 	bl	21f231cc <memcpy>
		nfs_path[rlen] = 0;
21f0dec8:	e59f302c 	ldr	r3, [pc, #44]	; 21f0defc <.text+0xdefc>
21f0decc:	e5932000 	ldr	r2, [r3]
21f0ded0:	e51b3014 	ldr	r3, [fp, #-20]
21f0ded4:	e0822003 	add	r2, r2, r3
21f0ded8:	e3a03000 	mov	r3, #0	; 0x0
21f0dedc:	e5c23000 	strb	r3, [r2]
	}
	return 0;
21f0dee0:	e3a03000 	mov	r3, #0	; 0x0
21f0dee4:	e50b3820 	str	r3, [fp, #-2080]
21f0dee8:	e51b3820 	ldr	r3, [fp, #-2080]
}
21f0deec:	e1a00003 	mov	r0, r3
21f0def0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0def4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0def8:	21f66ac0 	mvncss	r6, r0, asr #21
21f0defc:	21f66b68 	mvncss	r6, r8, ror #22
21f0df00:	21f2f9b8 	ldrcsh	pc, [r2, #152]!

21f0df04 <nfs_read_reply>:

static int
nfs_read_reply (uchar *pkt, unsigned len)
{
21f0df04:	e1a0c00d 	mov	ip, sp
21f0df08:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0df0c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0df10:	e24dde81 	sub	sp, sp, #2064	; 0x810
21f0df14:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0df18:	e50b0814 	str	r0, [fp, #-2068]
21f0df1c:	e50b1818 	str	r1, [fp, #-2072]
	struct rpc_t rpc_pkt;
	int rlen;

#ifdef NFS_DEBUG_nop
	printf ("%s\n", __FUNCTION__);
#endif

	memcpy ((uchar *)&rpc_pkt, pkt, sizeof(rpc_pkt.u.reply));
21f0df20:	e24b3b02 	sub	r3, fp, #2048	; 0x800
21f0df24:	e243300c 	sub	r3, r3, #12	; 0xc
21f0df28:	e2433004 	sub	r3, r3, #4	; 0x4
21f0df2c:	e1a00003 	mov	r0, r3
21f0df30:	e51b1814 	ldr	r1, [fp, #-2068]
21f0df34:	e3a02064 	mov	r2, #100	; 0x64
21f0df38:	eb0054a3 	bl	21f231cc <memcpy>

	if (ntohl(rpc_pkt.u.reply.id) != rpc_id)
21f0df3c:	e51b3810 	ldr	r3, [fp, #-2064]
21f0df40:	e1a00003 	mov	r0, r3
21f0df44:	ebfffc3f 	bl	21f0d048 <__fswab32>
21f0df48:	e1a03000 	mov	r3, r0
21f0df4c:	e1a02003 	mov	r2, r3
21f0df50:	e59f31d8 	ldr	r3, [pc, #472]	; 21f0e130 <.text+0xe130>
21f0df54:	e5933000 	ldr	r3, [r3]
21f0df58:	e1520003 	cmp	r2, r3
21f0df5c:	0a000002 	beq	21f0df6c <nfs_read_reply+0x68>
		return -1;
21f0df60:	e3e02000 	mvn	r2, #0	; 0x0
21f0df64:	e50b2824 	str	r2, [fp, #-2084]
21f0df68:	ea00006c 	b	21f0e120 <nfs_read_reply+0x21c>

	if (rpc_pkt.u.reply.rstatus  ||
21f0df6c:	e51b3808 	ldr	r3, [fp, #-2056]
21f0df70:	e3530000 	cmp	r3, #0	; 0x0
21f0df74:	1a000008 	bne	21f0df9c <nfs_read_reply+0x98>
21f0df78:	e51b3804 	ldr	r3, [fp, #-2052]
21f0df7c:	e3530000 	cmp	r3, #0	; 0x0
21f0df80:	1a000005 	bne	21f0df9c <nfs_read_reply+0x98>
21f0df84:	e51b37fc 	ldr	r3, [fp, #-2044]
21f0df88:	e3530000 	cmp	r3, #0	; 0x0
21f0df8c:	1a000002 	bne	21f0df9c <nfs_read_reply+0x98>
21f0df90:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0df94:	e3530000 	cmp	r3, #0	; 0x0
21f0df98:	0a000018 	beq	21f0e000 <nfs_read_reply+0xfc>
	    rpc_pkt.u.reply.verifier ||
	    rpc_pkt.u.reply.astatus  ||
	    rpc_pkt.u.reply.data[0]) {
		if (rpc_pkt.u.reply.rstatus) {
21f0df9c:	e51b3808 	ldr	r3, [fp, #-2056]
21f0dfa0:	e3530000 	cmp	r3, #0	; 0x0
21f0dfa4:	0a000005 	beq	21f0dfc0 <nfs_read_reply+0xbc>
			return -9999;
21f0dfa8:	e3e03c27 	mvn	r3, #9984	; 0x2700
21f0dfac:	e50b3824 	str	r3, [fp, #-2084]
21f0dfb0:	e51b2824 	ldr	r2, [fp, #-2084]
21f0dfb4:	e242200e 	sub	r2, r2, #14	; 0xe
21f0dfb8:	e50b2824 	str	r2, [fp, #-2084]
21f0dfbc:	ea000057 	b	21f0e120 <nfs_read_reply+0x21c>
		}
		if (rpc_pkt.u.reply.astatus) {
21f0dfc0:	e51b37fc 	ldr	r3, [fp, #-2044]
21f0dfc4:	e3530000 	cmp	r3, #0	; 0x0
21f0dfc8:	0a000005 	beq	21f0dfe4 <nfs_read_reply+0xe0>
			return -9999;
21f0dfcc:	e3e03c27 	mvn	r3, #9984	; 0x2700
21f0dfd0:	e50b3824 	str	r3, [fp, #-2084]
21f0dfd4:	e51b2824 	ldr	r2, [fp, #-2084]
21f0dfd8:	e242200e 	sub	r2, r2, #14	; 0xe
21f0dfdc:	e50b2824 	str	r2, [fp, #-2084]
21f0dfe0:	ea00004e 	b	21f0e120 <nfs_read_reply+0x21c>
		}
		return -ntohl(rpc_pkt.u.reply.data[0]);;
21f0dfe4:	e51b37f8 	ldr	r3, [fp, #-2040]
21f0dfe8:	e1a00003 	mov	r0, r3
21f0dfec:	ebfffc15 	bl	21f0d048 <__fswab32>
21f0dff0:	e1a03000 	mov	r3, r0
21f0dff4:	e2633000 	rsb	r3, r3, #0	; 0x0
21f0dff8:	e50b3824 	str	r3, [fp, #-2084]
21f0dffc:	ea000047 	b	21f0e120 <nfs_read_reply+0x21c>
	}

	if ((nfs_offset!=0) && !((nfs_offset) % (NFS_READ_SIZE/2*10*HASHES_PER_LINE))) {
21f0e000:	e59f312c 	ldr	r3, [pc, #300]	; 21f0e134 <.text+0xe134>
21f0e004:	e5933000 	ldr	r3, [r3]
21f0e008:	e3530000 	cmp	r3, #0	; 0x0
21f0e00c:	0a000017 	beq	21f0e070 <nfs_read_reply+0x16c>
21f0e010:	e59f311c 	ldr	r3, [pc, #284]	; 21f0e134 <.text+0xe134>
21f0e014:	e5931000 	ldr	r1, [r3]
21f0e018:	e3e0349b 	mvn	r3, #-1694498816	; 0x9b000000
21f0e01c:	e24339b3 	sub	r3, r3, #2932736	; 0x2cc000
21f0e020:	e2433c26 	sub	r3, r3, #9728	; 0x2600
21f0e024:	e0c32391 	smull	r2, r3, r1, r3
21f0e028:	e1a028c3 	mov	r2, r3, asr #17
21f0e02c:	e1a03fc1 	mov	r3, r1, asr #31
21f0e030:	e0632002 	rsb	r2, r3, r2
21f0e034:	e50b2820 	str	r2, [fp, #-2080]
21f0e038:	e51b3820 	ldr	r3, [fp, #-2080]
21f0e03c:	e1a03103 	mov	r3, r3, lsl #2
21f0e040:	e51b2820 	ldr	r2, [fp, #-2080]
21f0e044:	e0833002 	add	r3, r3, r2
21f0e048:	e1a02303 	mov	r2, r3, lsl #6
21f0e04c:	e0833002 	add	r3, r3, r2
21f0e050:	e1a03503 	mov	r3, r3, lsl #10
21f0e054:	e0631001 	rsb	r1, r3, r1
21f0e058:	e50b1820 	str	r1, [fp, #-2080]
21f0e05c:	e51b3820 	ldr	r3, [fp, #-2080]
21f0e060:	e3530000 	cmp	r3, #0	; 0x0
21f0e064:	1a000001 	bne	21f0e070 <nfs_read_reply+0x16c>
		puts ("\n\t ");
21f0e068:	e59f00c8 	ldr	r0, [pc, #200]	; 21f0e138 <.text+0xe138>
21f0e06c:	eb003673 	bl	21f1ba40 <puts>
	}
	if (!(nfs_offset % ((NFS_READ_SIZE/2)*10))) {
21f0e070:	e59f30bc 	ldr	r3, [pc, #188]	; 21f0e134 <.text+0xe134>
21f0e074:	e5931000 	ldr	r1, [r3]
21f0e078:	e59f30bc 	ldr	r3, [pc, #188]	; 21f0e13c <.text+0xe13c>
21f0e07c:	e0c32391 	smull	r2, r3, r1, r3
21f0e080:	e1a025c3 	mov	r2, r3, asr #11
21f0e084:	e1a03fc1 	mov	r3, r1, asr #31
21f0e088:	e0632002 	rsb	r2, r3, r2
21f0e08c:	e50b281c 	str	r2, [fp, #-2076]
21f0e090:	e51b381c 	ldr	r3, [fp, #-2076]
21f0e094:	e1a03103 	mov	r3, r3, lsl #2
21f0e098:	e51b281c 	ldr	r2, [fp, #-2076]
21f0e09c:	e0833002 	add	r3, r3, r2
21f0e0a0:	e1a03503 	mov	r3, r3, lsl #10
21f0e0a4:	e0631001 	rsb	r1, r3, r1
21f0e0a8:	e50b181c 	str	r1, [fp, #-2076]
21f0e0ac:	e51b381c 	ldr	r3, [fp, #-2076]
21f0e0b0:	e3530000 	cmp	r3, #0	; 0x0
21f0e0b4:	1a000001 	bne	21f0e0c0 <nfs_read_reply+0x1bc>
		putc ('#');
21f0e0b8:	e3a00023 	mov	r0, #35	; 0x23
21f0e0bc:	eb003649 	bl	21f1b9e8 <putc>
	}

	rlen = ntohl(rpc_pkt.u.reply.data[18]);
21f0e0c0:	e51b37b0 	ldr	r3, [fp, #-1968]
21f0e0c4:	e1a00003 	mov	r0, r3
21f0e0c8:	ebfffbde 	bl	21f0d048 <__fswab32>
21f0e0cc:	e1a03000 	mov	r3, r0
21f0e0d0:	e50b3010 	str	r3, [fp, #-16]
	if ( store_block ((uchar *)pkt+sizeof(rpc_pkt.u.reply), nfs_offset, rlen) )
21f0e0d4:	e51b3814 	ldr	r3, [fp, #-2068]
21f0e0d8:	e2831064 	add	r1, r3, #100	; 0x64
21f0e0dc:	e59f3050 	ldr	r3, [pc, #80]	; 21f0e134 <.text+0xe134>
21f0e0e0:	e5933000 	ldr	r3, [r3]
21f0e0e4:	e51b2010 	ldr	r2, [fp, #-16]
21f0e0e8:	e1a00001 	mov	r0, r1
21f0e0ec:	e1a01003 	mov	r1, r3
21f0e0f0:	eb000012 	bl	21f0e140 <store_block>
21f0e0f4:	e1a03000 	mov	r3, r0
21f0e0f8:	e3530000 	cmp	r3, #0	; 0x0
21f0e0fc:	0a000005 	beq	21f0e118 <nfs_read_reply+0x214>
		return -9999;
21f0e100:	e3e02c27 	mvn	r2, #9984	; 0x2700
21f0e104:	e50b2824 	str	r2, [fp, #-2084]
21f0e108:	e51b3824 	ldr	r3, [fp, #-2084]
21f0e10c:	e243300e 	sub	r3, r3, #14	; 0xe
21f0e110:	e50b3824 	str	r3, [fp, #-2084]
21f0e114:	ea000001 	b	21f0e120 <nfs_read_reply+0x21c>

	return rlen;
21f0e118:	e51b2010 	ldr	r2, [fp, #-16]
21f0e11c:	e50b2824 	str	r2, [fp, #-2084]
21f0e120:	e51b3824 	ldr	r3, [fp, #-2084]
}
21f0e124:	e1a00003 	mov	r0, r3
21f0e128:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0e12c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0e130:	21f66ac0 	mvncss	r6, r0, asr #21
21f0e134:	21f331d8 	ldrcssb	r3, [r3, #24]!
21f0e138:	21f2f9bc 	ldrcsh	pc, [r2, #156]!
21f0e13c:	66666667 	strvsbt	r6, [r6], -r7, ror #12

21f0e140 <store_block>:
21f0e140:	e1a0c00d 	mov	ip, sp
21f0e144:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0e148:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0e14c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0e150:	e50b0014 	str	r0, [fp, #-20]
21f0e154:	e50b1018 	str	r1, [fp, #-24]
21f0e158:	e50b201c 	str	r2, [fp, #-28]
21f0e15c:	e51b2018 	ldr	r2, [fp, #-24]
21f0e160:	e51b301c 	ldr	r3, [fp, #-28]
21f0e164:	e0823003 	add	r3, r2, r3
21f0e168:	e50b3010 	str	r3, [fp, #-16]
21f0e16c:	e59f3050 	ldr	r3, [pc, #80]	; 21f0e1c4 <.text+0xe1c4>
21f0e170:	e5932000 	ldr	r2, [r3]
21f0e174:	e51b3018 	ldr	r3, [fp, #-24]
21f0e178:	e0823003 	add	r3, r2, r3
21f0e17c:	e1a00003 	mov	r0, r3
21f0e180:	e51b1014 	ldr	r1, [fp, #-20]
21f0e184:	e51b201c 	ldr	r2, [fp, #-28]
21f0e188:	eb00540f 	bl	21f231cc <memcpy>
21f0e18c:	e51b2018 	ldr	r2, [fp, #-24]
21f0e190:	e51b301c 	ldr	r3, [fp, #-28]
21f0e194:	e0822003 	add	r2, r2, r3
21f0e198:	e59f3028 	ldr	r3, [pc, #40]	; 21f0e1c8 <.text+0xe1c8>
21f0e19c:	e5933000 	ldr	r3, [r3]
21f0e1a0:	e1520003 	cmp	r2, r3
21f0e1a4:	9a000002 	bls	21f0e1b4 <store_block+0x74>
21f0e1a8:	e59f2018 	ldr	r2, [pc, #24]	; 21f0e1c8 <.text+0xe1c8>
21f0e1ac:	e51b3010 	ldr	r3, [fp, #-16]
21f0e1b0:	e5823000 	str	r3, [r2]
21f0e1b4:	e3a03000 	mov	r3, #0	; 0x0
21f0e1b8:	e1a00003 	mov	r0, r3
21f0e1bc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0e1c0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0e1c4:	21f3322c 	mvncss	r3, ip, lsr #4
21f0e1c8:	21f64550 	mvncss	r4, r0, asr r5

21f0e1cc <NfsTimeout>:

/**************************************************************************
Interfaces of U-BOOT
**************************************************************************/

static void
NfsTimeout (void)
{
21f0e1cc:	e1a0c00d 	mov	ip, sp
21f0e1d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0e1d4:	e24cb004 	sub	fp, ip, #4	; 0x4
	puts ("Timeout\n");
21f0e1d8:	e59f0010 	ldr	r0, [pc, #16]	; 21f0e1f0 <.text+0xe1f0>
21f0e1dc:	eb003617 	bl	21f1ba40 <puts>
	NetState = NETLOOP_FAIL;
21f0e1e0:	e59f200c 	ldr	r2, [pc, #12]	; 21f0e1f4 <.text+0xe1f4>
21f0e1e4:	e3a03004 	mov	r3, #4	; 0x4
21f0e1e8:	e5823000 	str	r3, [r2]
	return;
}
21f0e1ec:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0e1f0:	21f2f9c0 	mvncss	pc, r0, asr #19
21f0e1f4:	21f64580 	mvncss	r4, r0, lsl #11

21f0e1f8 <NfsHandler>:

static void
NfsHandler (uchar *pkt, unsigned dest, unsigned src, unsigned len)
{
21f0e1f8:	e1a0c00d 	mov	ip, sp
21f0e1fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0e200:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0e204:	e24dd014 	sub	sp, sp, #20	; 0x14
21f0e208:	e50b0014 	str	r0, [fp, #-20]
21f0e20c:	e50b1018 	str	r1, [fp, #-24]
21f0e210:	e50b201c 	str	r2, [fp, #-28]
21f0e214:	e50b3020 	str	r3, [fp, #-32]
	int rlen;

#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif

	if (dest != NfsOurPort) return;
21f0e218:	e59f32bc 	ldr	r3, [pc, #700]	; 21f0e4dc <.text+0xe4dc>
21f0e21c:	e5933000 	ldr	r3, [r3]
21f0e220:	e1a02003 	mov	r2, r3
21f0e224:	e51b3018 	ldr	r3, [fp, #-24]
21f0e228:	e1520003 	cmp	r2, r3
21f0e22c:	1a0000a8 	bne	21f0e4d4 <.text+0xe4d4>

	switch (NfsState) {
21f0e230:	e59f32a8 	ldr	r3, [pc, #680]	; 21f0e4e0 <.text+0xe4e0>
21f0e234:	e5933000 	ldr	r3, [r3]
21f0e238:	e2433001 	sub	r3, r3, #1	; 0x1
21f0e23c:	e3530006 	cmp	r3, #6	; 0x6
21f0e240:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0e244:	ea0000a2 	b	21f0e4d4 <.text+0xe4d4>
21f0e248:	21f0e264 	mvncss	lr, r4, ror #4
21f0e24c:	21f0e290 	ldrcsb	lr, [r0, #32]!
21f0e250:	21f0e2bc 	ldrcsh	lr, [r0, #44]!
21f0e254:	21f0e304 	mvncss	lr, r4, lsl #6
21f0e258:	21f0e350 	mvncss	lr, r0, asr r3
21f0e25c:	21f0e430 	mvncss	lr, r0, lsr r4
21f0e260:	21f0e3b0 	ldrcsh	lr, [r0, #48]!
	case STATE_PRCLOOKUP_PROG_MOUNT_REQ:
		rpc_lookup_reply (PROG_MOUNT, pkt, len);
21f0e264:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0e268:	e2800fa9 	add	r0, r0, #676	; 0x2a4
21f0e26c:	e2800001 	add	r0, r0, #1	; 0x1
21f0e270:	e51b1014 	ldr	r1, [fp, #-20]
21f0e274:	e51b2020 	ldr	r2, [fp, #-32]
21f0e278:	ebfffdbb 	bl	21f0d96c <rpc_lookup_reply>
		NfsState = STATE_PRCLOOKUP_PROG_NFS_REQ;
21f0e27c:	e59f225c 	ldr	r2, [pc, #604]	; 21f0e4e0 <.text+0xe4e0>
21f0e280:	e3a03002 	mov	r3, #2	; 0x2
21f0e284:	e5823000 	str	r3, [r2]
		NfsSend ();
21f0e288:	ebfffd80 	bl	21f0d890 <NfsSend>
		break;
21f0e28c:	ea000090 	b	21f0e4d4 <.text+0xe4d4>

	case STATE_PRCLOOKUP_PROG_NFS_REQ:
		rpc_lookup_reply (PROG_NFS, pkt, len);
21f0e290:	e3a00b61 	mov	r0, #99328	; 0x18400
21f0e294:	e2800e2a 	add	r0, r0, #672	; 0x2a0
21f0e298:	e2800003 	add	r0, r0, #3	; 0x3
21f0e29c:	e51b1014 	ldr	r1, [fp, #-20]
21f0e2a0:	e51b2020 	ldr	r2, [fp, #-32]
21f0e2a4:	ebfffdb0 	bl	21f0d96c <rpc_lookup_reply>
		NfsState = STATE_MOUNT_REQ;
21f0e2a8:	e59f2230 	ldr	r2, [pc, #560]	; 21f0e4e0 <.text+0xe4e0>
21f0e2ac:	e3a03003 	mov	r3, #3	; 0x3
21f0e2b0:	e5823000 	str	r3, [r2]
		NfsSend ();
21f0e2b4:	ebfffd75 	bl	21f0d890 <NfsSend>
		break;
21f0e2b8:	ea000085 	b	21f0e4d4 <.text+0xe4d4>

	case STATE_MOUNT_REQ:
		if (nfs_mount_reply(pkt, len)) {
21f0e2bc:	e51b0014 	ldr	r0, [fp, #-20]
21f0e2c0:	e51b1020 	ldr	r1, [fp, #-32]
21f0e2c4:	ebfffdf8 	bl	21f0daac <nfs_mount_reply>
21f0e2c8:	e1a03000 	mov	r3, r0
21f0e2cc:	e3530000 	cmp	r3, #0	; 0x0
21f0e2d0:	0a000006 	beq	21f0e2f0 <.text+0xe2f0>
			puts ("*** ERROR: Cannot mount\n");
21f0e2d4:	e59f0208 	ldr	r0, [pc, #520]	; 21f0e4e4 <.text+0xe4e4>
21f0e2d8:	eb0035d8 	bl	21f1ba40 <puts>
			/* just to be sure... */
			NfsState = STATE_UMOUNT_REQ;
21f0e2dc:	e59f21fc 	ldr	r2, [pc, #508]	; 21f0e4e0 <.text+0xe4e0>
21f0e2e0:	e3a03004 	mov	r3, #4	; 0x4
21f0e2e4:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e2e8:	ebfffd68 	bl	21f0d890 <NfsSend>
21f0e2ec:	ea000078 	b	21f0e4d4 <.text+0xe4d4>
		} else {
			NfsState = STATE_LOOKUP_REQ;
21f0e2f0:	e59f21e8 	ldr	r2, [pc, #488]	; 21f0e4e0 <.text+0xe4e0>
21f0e2f4:	e3a03005 	mov	r3, #5	; 0x5
21f0e2f8:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e2fc:	ebfffd63 	bl	21f0d890 <NfsSend>
21f0e300:	ea000073 	b	21f0e4d4 <.text+0xe4d4>
		}
		break;

	case STATE_UMOUNT_REQ:
		if (nfs_umountall_reply(pkt, len)) {
21f0e304:	e51b0014 	ldr	r0, [fp, #-20]
21f0e308:	e51b1020 	ldr	r1, [fp, #-32]
21f0e30c:	ebfffe21 	bl	21f0db98 <nfs_umountall_reply>
21f0e310:	e1a03000 	mov	r3, r0
21f0e314:	e3530000 	cmp	r3, #0	; 0x0
21f0e318:	0a000005 	beq	21f0e334 <.text+0xe334>
			puts ("*** ERROR: Cannot umount\n");
21f0e31c:	e59f01c4 	ldr	r0, [pc, #452]	; 21f0e4e8 <.text+0xe4e8>
21f0e320:	eb0035c6 	bl	21f1ba40 <puts>
			NetState = NETLOOP_FAIL;
21f0e324:	e59f21c0 	ldr	r2, [pc, #448]	; 21f0e4ec <.text+0xe4ec>
21f0e328:	e3a03004 	mov	r3, #4	; 0x4
21f0e32c:	e5823000 	str	r3, [r2]
21f0e330:	ea000067 	b	21f0e4d4 <.text+0xe4d4>
		} else {
			puts ("\ndone\n");
21f0e334:	e59f01b4 	ldr	r0, [pc, #436]	; 21f0e4f0 <.text+0xe4f0>
21f0e338:	eb0035c0 	bl	21f1ba40 <puts>
			NetState = NfsDownloadState;
21f0e33c:	e59f31b0 	ldr	r3, [pc, #432]	; 21f0e4f4 <.text+0xe4f4>
21f0e340:	e5932000 	ldr	r2, [r3]
21f0e344:	e59f31a0 	ldr	r3, [pc, #416]	; 21f0e4ec <.text+0xe4ec>
21f0e348:	e5832000 	str	r2, [r3]
21f0e34c:	ea000060 	b	21f0e4d4 <.text+0xe4d4>
		}
		break;

	case STATE_LOOKUP_REQ:
		if (nfs_lookup_reply(pkt, len)) {
21f0e350:	e51b0014 	ldr	r0, [fp, #-20]
21f0e354:	e51b1020 	ldr	r1, [fp, #-32]
21f0e358:	ebfffe43 	bl	21f0dc6c <nfs_lookup_reply>
21f0e35c:	e1a03000 	mov	r3, r0
21f0e360:	e3530000 	cmp	r3, #0	; 0x0
21f0e364:	0a000006 	beq	21f0e384 <.text+0xe384>
			puts ("*** ERROR: File lookup fail\n");
21f0e368:	e59f0188 	ldr	r0, [pc, #392]	; 21f0e4f8 <.text+0xe4f8>
21f0e36c:	eb0035b3 	bl	21f1ba40 <puts>
			NfsState = STATE_UMOUNT_REQ;
21f0e370:	e59f2168 	ldr	r2, [pc, #360]	; 21f0e4e0 <.text+0xe4e0>
21f0e374:	e3a03004 	mov	r3, #4	; 0x4
21f0e378:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e37c:	ebfffd43 	bl	21f0d890 <NfsSend>
21f0e380:	ea000053 	b	21f0e4d4 <.text+0xe4d4>
		} else {
			NfsState = STATE_READ_REQ;
21f0e384:	e59f2154 	ldr	r2, [pc, #340]	; 21f0e4e0 <.text+0xe4e0>
21f0e388:	e3a03006 	mov	r3, #6	; 0x6
21f0e38c:	e5823000 	str	r3, [r2]
			nfs_offset = 0;
21f0e390:	e59f2164 	ldr	r2, [pc, #356]	; 21f0e4fc <.text+0xe4fc>
21f0e394:	e3a03000 	mov	r3, #0	; 0x0
21f0e398:	e5823000 	str	r3, [r2]
			nfs_len = NFS_READ_SIZE;
21f0e39c:	e59f215c 	ldr	r2, [pc, #348]	; 21f0e500 <.text+0xe500>
21f0e3a0:	e3a03b01 	mov	r3, #1024	; 0x400
21f0e3a4:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e3a8:	ebfffd38 	bl	21f0d890 <NfsSend>
21f0e3ac:	ea000048 	b	21f0e4d4 <.text+0xe4d4>
		}
		break;

	case STATE_READLINK_REQ:
		if (nfs_readlink_reply(pkt, len)) {
21f0e3b0:	e51b0014 	ldr	r0, [fp, #-20]
21f0e3b4:	e51b1020 	ldr	r1, [fp, #-32]
21f0e3b8:	ebfffe62 	bl	21f0dd48 <nfs_readlink_reply>
21f0e3bc:	e1a03000 	mov	r3, r0
21f0e3c0:	e3530000 	cmp	r3, #0	; 0x0
21f0e3c4:	0a000006 	beq	21f0e3e4 <.text+0xe3e4>
			puts ("*** ERROR: Symlink fail\n");
21f0e3c8:	e59f0134 	ldr	r0, [pc, #308]	; 21f0e504 <.text+0xe504>
21f0e3cc:	eb00359b 	bl	21f1ba40 <puts>
			NfsState = STATE_UMOUNT_REQ;
21f0e3d0:	e59f2108 	ldr	r2, [pc, #264]	; 21f0e4e0 <.text+0xe4e0>
21f0e3d4:	e3a03004 	mov	r3, #4	; 0x4
21f0e3d8:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e3dc:	ebfffd2b 	bl	21f0d890 <NfsSend>
21f0e3e0:	ea00003b 	b	21f0e4d4 <.text+0xe4d4>
		} else {
#ifdef NFS_DEBUG
			printf ("Symlink --> %s\n", nfs_path);
#endif
			nfs_filename = basename (nfs_path);
21f0e3e4:	e59f311c 	ldr	r3, [pc, #284]	; 21f0e508 <.text+0xe508>
21f0e3e8:	e5933000 	ldr	r3, [r3]
21f0e3ec:	e1a00003 	mov	r0, r3
21f0e3f0:	ebfffa66 	bl	21f0cd90 <basename>
21f0e3f4:	e1a02000 	mov	r2, r0
21f0e3f8:	e59f310c 	ldr	r3, [pc, #268]	; 21f0e50c <.text+0xe50c>
21f0e3fc:	e5832000 	str	r2, [r3]
			nfs_path     = dirname (nfs_path);
21f0e400:	e59f3100 	ldr	r3, [pc, #256]	; 21f0e508 <.text+0xe508>
21f0e404:	e5933000 	ldr	r3, [r3]
21f0e408:	e1a00003 	mov	r0, r3
21f0e40c:	ebfffa80 	bl	21f0ce14 <dirname>
21f0e410:	e1a02000 	mov	r2, r0
21f0e414:	e59f30ec 	ldr	r3, [pc, #236]	; 21f0e508 <.text+0xe508>
21f0e418:	e5832000 	str	r2, [r3]

			NfsState = STATE_MOUNT_REQ;
21f0e41c:	e59f20bc 	ldr	r2, [pc, #188]	; 21f0e4e0 <.text+0xe4e0>
21f0e420:	e3a03003 	mov	r3, #3	; 0x3
21f0e424:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e428:	ebfffd18 	bl	21f0d890 <NfsSend>
21f0e42c:	ea000028 	b	21f0e4d4 <.text+0xe4d4>
		}
		break;

	case STATE_READ_REQ:
		rlen = nfs_read_reply (pkt, len);
21f0e430:	e51b0014 	ldr	r0, [fp, #-20]
21f0e434:	e51b1020 	ldr	r1, [fp, #-32]
21f0e438:	ebfffeb1 	bl	21f0df04 <nfs_read_reply>
21f0e43c:	e1a03000 	mov	r3, r0
21f0e440:	e50b3010 	str	r3, [fp, #-16]
		NetSetTimeout (NFS_TIMEOUT * CFG_HZ, NfsTimeout);
21f0e444:	e3a00cea 	mov	r0, #59904	; 0xea00
21f0e448:	e2800060 	add	r0, r0, #96	; 0x60
21f0e44c:	e59f10bc 	ldr	r1, [pc, #188]	; 21f0e510 <.text+0xe510>
21f0e450:	ebffec12 	bl	21f094a0 <NetSetTimeout>
		if (rlen > 0) {
21f0e454:	e51b3010 	ldr	r3, [fp, #-16]
21f0e458:	e3530000 	cmp	r3, #0	; 0x0
21f0e45c:	da000007 	ble	21f0e480 <.text+0xe480>
			nfs_offset += rlen;
21f0e460:	e59f3094 	ldr	r3, [pc, #148]	; 21f0e4fc <.text+0xe4fc>
21f0e464:	e5932000 	ldr	r2, [r3]
21f0e468:	e51b3010 	ldr	r3, [fp, #-16]
21f0e46c:	e0822003 	add	r2, r2, r3
21f0e470:	e59f3084 	ldr	r3, [pc, #132]	; 21f0e4fc <.text+0xe4fc>
21f0e474:	e5832000 	str	r2, [r3]
			NfsSend ();
21f0e478:	ebfffd04 	bl	21f0d890 <NfsSend>
21f0e47c:	ea000014 	b	21f0e4d4 <.text+0xe4d4>
		}
		else if ((rlen == -NFSERR_ISDIR)||(rlen == -NFSERR_INVAL)) {
21f0e480:	e51b3010 	ldr	r3, [fp, #-16]
21f0e484:	e3730015 	cmn	r3, #21	; 0x15
21f0e488:	0a000002 	beq	21f0e498 <.text+0xe498>
21f0e48c:	e51b3010 	ldr	r3, [fp, #-16]
21f0e490:	e3730016 	cmn	r3, #22	; 0x16
21f0e494:	1a000004 	bne	21f0e4ac <.text+0xe4ac>
			/* symbolic link */
			NfsState = STATE_READLINK_REQ;
21f0e498:	e59f2040 	ldr	r2, [pc, #64]	; 21f0e4e0 <.text+0xe4e0>
21f0e49c:	e3a03007 	mov	r3, #7	; 0x7
21f0e4a0:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e4a4:	ebfffcf9 	bl	21f0d890 <NfsSend>
21f0e4a8:	ea000009 	b	21f0e4d4 <.text+0xe4d4>
		} else {
			if ( ! rlen ) NfsDownloadState = NETLOOP_SUCCESS;
21f0e4ac:	e51b3010 	ldr	r3, [fp, #-16]
21f0e4b0:	e3530000 	cmp	r3, #0	; 0x0
21f0e4b4:	1a000002 	bne	21f0e4c4 <.text+0xe4c4>
21f0e4b8:	e59f2034 	ldr	r2, [pc, #52]	; 21f0e4f4 <.text+0xe4f4>
21f0e4bc:	e3a03003 	mov	r3, #3	; 0x3
21f0e4c0:	e5823000 	str	r3, [r2]
			NfsState = STATE_UMOUNT_REQ;
21f0e4c4:	e59f2014 	ldr	r2, [pc, #20]	; 21f0e4e0 <.text+0xe4e0>
21f0e4c8:	e3a03004 	mov	r3, #4	; 0x4
21f0e4cc:	e5823000 	str	r3, [r2]
			NfsSend ();
21f0e4d0:	ebfffcee 	bl	21f0d890 <NfsSend>
		}
		break;
	}
}
21f0e4d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0e4d8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0e4dc:	21f66b18 	mvncss	r6, r8, lsl fp
21f0e4e0:	21f66b20 	mvncss	r6, r0, lsr #22
21f0e4e4:	21f2f9cc 	mvncss	pc, ip, asr #19
21f0e4e8:	21f2f9e8 	mvncss	pc, r8, ror #19
21f0e4ec:	21f64580 	mvncss	r4, r0, lsl #11
21f0e4f0:	21f2fa04 	mvncss	pc, r4, lsl #20
21f0e4f4:	21f66b08 	mvncss	r6, r8, lsl #22
21f0e4f8:	21f2fa0c 	mvncss	pc, ip, lsl #20
21f0e4fc:	21f331d8 	ldrcssb	r3, [r3, #24]!
21f0e500:	21f66ac4 	mvncss	r6, r4, asr #21
21f0e504:	21f2fa2c 	mvncss	pc, ip, lsr #20
21f0e508:	21f66b68 	mvncss	r6, r8, ror #22
21f0e50c:	21f66b64 	mvncss	r6, r4, ror #22
21f0e510:	21f0e1cc 	mvncss	lr, ip, asr #3

21f0e514 <NfsStart>:


void
NfsStart (void)
{
21f0e514:	e1a0c00d 	mov	ip, sp
21f0e518:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0e51c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0e520:	e24dd014 	sub	sp, sp, #20	; 0x14
#ifdef NFS_DEBUG
	printf ("%s\n", __FUNCTION__);
#endif
	NfsDownloadState = NETLOOP_FAIL;
21f0e524:	e59f22fc 	ldr	r2, [pc, #764]	; 21f0e828 <.text+0xe828>
21f0e528:	e3a03004 	mov	r3, #4	; 0x4
21f0e52c:	e5823000 	str	r3, [r2]

	NfsServerIP = NetServerIP;
21f0e530:	e59f32f4 	ldr	r3, [pc, #756]	; 21f0e82c <.text+0xe82c>
21f0e534:	e5932000 	ldr	r2, [r3]
21f0e538:	e59f32f0 	ldr	r3, [pc, #752]	; 21f0e830 <.text+0xe830>
21f0e53c:	e5832000 	str	r2, [r3]
	nfs_path = (char *)nfs_path_buff;
21f0e540:	e59f22ec 	ldr	r2, [pc, #748]	; 21f0e834 <.text+0xe834>
21f0e544:	e59f32ec 	ldr	r3, [pc, #748]	; 21f0e838 <.text+0xe838>
21f0e548:	e5823000 	str	r3, [r2]

	if (nfs_path == NULL) {
21f0e54c:	e59f32e0 	ldr	r3, [pc, #736]	; 21f0e834 <.text+0xe834>
21f0e550:	e5933000 	ldr	r3, [r3]
21f0e554:	e3530000 	cmp	r3, #0	; 0x0
21f0e558:	1a000005 	bne	21f0e574 <NfsStart+0x60>
		NetState = NETLOOP_FAIL;
21f0e55c:	e59f22d8 	ldr	r2, [pc, #728]	; 21f0e83c <.text+0xe83c>
21f0e560:	e3a03004 	mov	r3, #4	; 0x4
21f0e564:	e5823000 	str	r3, [r2]
		puts ("*** ERROR: Fail allocate memory\n");
21f0e568:	e59f02d0 	ldr	r0, [pc, #720]	; 21f0e840 <.text+0xe840>
21f0e56c:	eb003533 	bl	21f1ba40 <puts>
		return;
21f0e570:	ea0000aa 	b	21f0e820 <NfsStart+0x30c>
	}

	if (BootFile[0] == '\0') {
21f0e574:	e59f32c8 	ldr	r3, [pc, #712]	; 21f0e844 <.text+0xe844>
21f0e578:	e5d33000 	ldrb	r3, [r3]
21f0e57c:	e3530000 	cmp	r3, #0	; 0x0
21f0e580:	1a000020 	bne	21f0e608 <NfsStart+0xf4>
		sprintf (default_filename, "/nfsroot/%02lX%02lX%02lX%02lX.img",
21f0e584:	e59f32bc 	ldr	r3, [pc, #700]	; 21f0e848 <.text+0xe848>
21f0e588:	e5933000 	ldr	r3, [r3]
21f0e58c:	e203c0ff 	and	ip, r3, #255	; 0xff
21f0e590:	e59f32b0 	ldr	r3, [pc, #688]	; 21f0e848 <.text+0xe848>
21f0e594:	e5933000 	ldr	r3, [r3]
21f0e598:	e1a03423 	mov	r3, r3, lsr #8
21f0e59c:	e203e0ff 	and	lr, r3, #255	; 0xff
21f0e5a0:	e59f32a0 	ldr	r3, [pc, #672]	; 21f0e848 <.text+0xe848>
21f0e5a4:	e5933000 	ldr	r3, [r3]
21f0e5a8:	e1a03823 	mov	r3, r3, lsr #16
21f0e5ac:	e20320ff 	and	r2, r3, #255	; 0xff
21f0e5b0:	e59f3290 	ldr	r3, [pc, #656]	; 21f0e848 <.text+0xe848>
21f0e5b4:	e5933000 	ldr	r3, [r3]
21f0e5b8:	e1a03c23 	mov	r3, r3, lsr #24
21f0e5bc:	e20330ff 	and	r3, r3, #255	; 0xff
21f0e5c0:	e58d2000 	str	r2, [sp]
21f0e5c4:	e58d3004 	str	r3, [sp, #4]
21f0e5c8:	e59f027c 	ldr	r0, [pc, #636]	; 21f0e84c <.text+0xe84c>
21f0e5cc:	e59f127c 	ldr	r1, [pc, #636]	; 21f0e850 <.text+0xe850>
21f0e5d0:	e1a0200c 	mov	r2, ip
21f0e5d4:	e1a0300e 	mov	r3, lr
21f0e5d8:	eb00583a 	bl	21f246c8 <sprintf>
			NetOurIP & 0xFF,
			(NetOurIP >>  8) & 0xFF,
			(NetOurIP >> 16) & 0xFF,
			(NetOurIP >> 24) & 0xFF	);
		strcpy (nfs_path, default_filename);
21f0e5dc:	e59f3250 	ldr	r3, [pc, #592]	; 21f0e834 <.text+0xe834>
21f0e5e0:	e5933000 	ldr	r3, [r3]
21f0e5e4:	e1a00003 	mov	r0, r3
21f0e5e8:	e59f125c 	ldr	r1, [pc, #604]	; 21f0e84c <.text+0xe84c>
21f0e5ec:	eb005038 	bl	21f226d4 <strcpy>

		printf ("*** Warning: no boot file name; using '%s'\n",
21f0e5f0:	e59f323c 	ldr	r3, [pc, #572]	; 21f0e834 <.text+0xe834>
21f0e5f4:	e5933000 	ldr	r3, [r3]
21f0e5f8:	e59f0254 	ldr	r0, [pc, #596]	; 21f0e854 <.text+0xe854>
21f0e5fc:	e1a01003 	mov	r1, r3
21f0e600:	eb003521 	bl	21f1ba8c <printf>
21f0e604:	ea00001c 	b	21f0e67c <NfsStart+0x168>
			nfs_path);
	} else {
		char *p=BootFile;
21f0e608:	e59f3234 	ldr	r3, [pc, #564]	; 21f0e844 <.text+0xe844>
21f0e60c:	e50b3018 	str	r3, [fp, #-24]

		p = strchr (p, ':');
21f0e610:	e51b0018 	ldr	r0, [fp, #-24]
21f0e614:	e3a0103a 	mov	r1, #58	; 0x3a
21f0e618:	eb005129 	bl	21f22ac4 <strchr>
21f0e61c:	e1a03000 	mov	r3, r0
21f0e620:	e50b3018 	str	r3, [fp, #-24]

		if (p != NULL) {
21f0e624:	e51b3018 	ldr	r3, [fp, #-24]
21f0e628:	e3530000 	cmp	r3, #0	; 0x0
21f0e62c:	0a00000d 	beq	21f0e668 <NfsStart+0x154>
			NfsServerIP = string_to_ip (BootFile);
21f0e630:	e59f020c 	ldr	r0, [pc, #524]	; 21f0e844 <.text+0xe844>
21f0e634:	ebfff069 	bl	21f0a7e0 <string_to_ip>
21f0e638:	e1a02000 	mov	r2, r0
21f0e63c:	e59f31ec 	ldr	r3, [pc, #492]	; 21f0e830 <.text+0xe830>
21f0e640:	e5832000 	str	r2, [r3]
			++p;
21f0e644:	e51b3018 	ldr	r3, [fp, #-24]
21f0e648:	e2833001 	add	r3, r3, #1	; 0x1
21f0e64c:	e50b3018 	str	r3, [fp, #-24]
			strcpy (nfs_path, p);
21f0e650:	e59f31dc 	ldr	r3, [pc, #476]	; 21f0e834 <.text+0xe834>
21f0e654:	e5933000 	ldr	r3, [r3]
21f0e658:	e1a00003 	mov	r0, r3
21f0e65c:	e51b1018 	ldr	r1, [fp, #-24]
21f0e660:	eb00501b 	bl	21f226d4 <strcpy>
21f0e664:	ea000004 	b	21f0e67c <NfsStart+0x168>
		} else {
			strcpy (nfs_path, BootFile);
21f0e668:	e59f31c4 	ldr	r3, [pc, #452]	; 21f0e834 <.text+0xe834>
21f0e66c:	e5933000 	ldr	r3, [r3]
21f0e670:	e1a00003 	mov	r0, r3
21f0e674:	e59f11c8 	ldr	r1, [pc, #456]	; 21f0e844 <.text+0xe844>
21f0e678:	eb005015 	bl	21f226d4 <strcpy>
		}
	}

	nfs_filename = basename (nfs_path);
21f0e67c:	e59f31b0 	ldr	r3, [pc, #432]	; 21f0e834 <.text+0xe834>
21f0e680:	e5933000 	ldr	r3, [r3]
21f0e684:	e1a00003 	mov	r0, r3
21f0e688:	ebfff9c0 	bl	21f0cd90 <basename>
21f0e68c:	e1a02000 	mov	r2, r0
21f0e690:	e59f31c0 	ldr	r3, [pc, #448]	; 21f0e858 <.text+0xe858>
21f0e694:	e5832000 	str	r2, [r3]
	nfs_path     = dirname (nfs_path);
21f0e698:	e59f3194 	ldr	r3, [pc, #404]	; 21f0e834 <.text+0xe834>
21f0e69c:	e5933000 	ldr	r3, [r3]
21f0e6a0:	e1a00003 	mov	r0, r3
21f0e6a4:	ebfff9da 	bl	21f0ce14 <dirname>
21f0e6a8:	e1a02000 	mov	r2, r0
21f0e6ac:	e59f3180 	ldr	r3, [pc, #384]	; 21f0e834 <.text+0xe834>
21f0e6b0:	e5832000 	str	r2, [r3]

#if defined(CONFIG_NET_MULTI)
	printf ("Using %s device\n", eth_get_name());
#endif

	puts ("File transfer via NFS from server "); print_IPaddr (NfsServerIP);
21f0e6b4:	e59f01a0 	ldr	r0, [pc, #416]	; 21f0e85c <.text+0xe85c>
21f0e6b8:	eb0034e0 	bl	21f1ba40 <puts>
21f0e6bc:	e59f316c 	ldr	r3, [pc, #364]	; 21f0e830 <.text+0xe830>
21f0e6c0:	e5933000 	ldr	r3, [r3]
21f0e6c4:	e1a00003 	mov	r0, r3
21f0e6c8:	ebfff0d7 	bl	21f0aa2c <print_IPaddr>
	puts ("; our IP address is ");		    print_IPaddr (NetOurIP);
21f0e6cc:	e59f018c 	ldr	r0, [pc, #396]	; 21f0e860 <.text+0xe860>
21f0e6d0:	eb0034da 	bl	21f1ba40 <puts>
21f0e6d4:	e59f316c 	ldr	r3, [pc, #364]	; 21f0e848 <.text+0xe848>
21f0e6d8:	e5933000 	ldr	r3, [r3]
21f0e6dc:	e1a00003 	mov	r0, r3
21f0e6e0:	ebfff0d1 	bl	21f0aa2c <print_IPaddr>

	/* Check if we need to send across this subnet */
	if (NetOurGatewayIP && NetOurSubnetMask) {
21f0e6e4:	e59f3178 	ldr	r3, [pc, #376]	; 21f0e864 <.text+0xe864>
21f0e6e8:	e5933000 	ldr	r3, [r3]
21f0e6ec:	e3530000 	cmp	r3, #0	; 0x0
21f0e6f0:	0a000019 	beq	21f0e75c <NfsStart+0x248>
21f0e6f4:	e59f316c 	ldr	r3, [pc, #364]	; 21f0e868 <.text+0xe868>
21f0e6f8:	e5933000 	ldr	r3, [r3]
21f0e6fc:	e3530000 	cmp	r3, #0	; 0x0
21f0e700:	0a000015 	beq	21f0e75c <NfsStart+0x248>
		IPaddr_t OurNet	    = NetOurIP	  & NetOurSubnetMask;
21f0e704:	e59f313c 	ldr	r3, [pc, #316]	; 21f0e848 <.text+0xe848>
21f0e708:	e5932000 	ldr	r2, [r3]
21f0e70c:	e59f3154 	ldr	r3, [pc, #340]	; 21f0e868 <.text+0xe868>
21f0e710:	e5933000 	ldr	r3, [r3]
21f0e714:	e0023003 	and	r3, r2, r3
21f0e718:	e50b3014 	str	r3, [fp, #-20]
		IPaddr_t ServerNet  = NetServerIP & NetOurSubnetMask;
21f0e71c:	e59f3108 	ldr	r3, [pc, #264]	; 21f0e82c <.text+0xe82c>
21f0e720:	e5932000 	ldr	r2, [r3]
21f0e724:	e59f313c 	ldr	r3, [pc, #316]	; 21f0e868 <.text+0xe868>
21f0e728:	e5933000 	ldr	r3, [r3]
21f0e72c:	e0023003 	and	r3, r2, r3
21f0e730:	e50b3010 	str	r3, [fp, #-16]

		if (OurNet != ServerNet) {
21f0e734:	e51b2014 	ldr	r2, [fp, #-20]
21f0e738:	e51b3010 	ldr	r3, [fp, #-16]
21f0e73c:	e1520003 	cmp	r2, r3
21f0e740:	0a000005 	beq	21f0e75c <NfsStart+0x248>
			puts ("; sending through gateway ");
21f0e744:	e59f0120 	ldr	r0, [pc, #288]	; 21f0e86c <.text+0xe86c>
21f0e748:	eb0034bc 	bl	21f1ba40 <puts>
			print_IPaddr (NetOurGatewayIP) ;
21f0e74c:	e59f3110 	ldr	r3, [pc, #272]	; 21f0e864 <.text+0xe864>
21f0e750:	e5933000 	ldr	r3, [r3]
21f0e754:	e1a00003 	mov	r0, r3
21f0e758:	ebfff0b3 	bl	21f0aa2c <print_IPaddr>
		}
	}
	printf ("\nFilename '%s/%s'.", nfs_path, nfs_filename);
21f0e75c:	e59f30d0 	ldr	r3, [pc, #208]	; 21f0e834 <.text+0xe834>
21f0e760:	e5932000 	ldr	r2, [r3]
21f0e764:	e59f30ec 	ldr	r3, [pc, #236]	; 21f0e858 <.text+0xe858>
21f0e768:	e5933000 	ldr	r3, [r3]
21f0e76c:	e59f00fc 	ldr	r0, [pc, #252]	; 21f0e870 <.text+0xe870>
21f0e770:	e1a01002 	mov	r1, r2
21f0e774:	e1a02003 	mov	r2, r3
21f0e778:	eb0034c3 	bl	21f1ba8c <printf>

	if (NetBootFileSize) {
21f0e77c:	e59f30f0 	ldr	r3, [pc, #240]	; 21f0e874 <.text+0xe874>
21f0e780:	e1d330b0 	ldrh	r3, [r3]
21f0e784:	e3530000 	cmp	r3, #0	; 0x0
21f0e788:	0a00000b 	beq	21f0e7bc <NfsStart+0x2a8>
		printf (" Size is 0x%x Bytes = ", NetBootFileSize<<9);
21f0e78c:	e59f30e0 	ldr	r3, [pc, #224]	; 21f0e874 <.text+0xe874>
21f0e790:	e1d330b0 	ldrh	r3, [r3]
21f0e794:	e1a03483 	mov	r3, r3, lsl #9
21f0e798:	e59f00d8 	ldr	r0, [pc, #216]	; 21f0e878 <.text+0xe878>
21f0e79c:	e1a01003 	mov	r1, r3
21f0e7a0:	eb0034b9 	bl	21f1ba8c <printf>
		print_size (NetBootFileSize<<9, "");
21f0e7a4:	e59f30c8 	ldr	r3, [pc, #200]	; 21f0e874 <.text+0xe874>
21f0e7a8:	e1d330b0 	ldrh	r3, [r3]
21f0e7ac:	e1a03483 	mov	r3, r3, lsl #9
21f0e7b0:	e1a00003 	mov	r0, r3
21f0e7b4:	e59f10c0 	ldr	r1, [pc, #192]	; 21f0e87c <.text+0xe87c>
21f0e7b8:	eb004f80 	bl	21f225c0 <print_size>
	}
	printf ("\nLoad address: 0x%lx\n"
21f0e7bc:	e59f30bc 	ldr	r3, [pc, #188]	; 21f0e880 <.text+0xe880>
21f0e7c0:	e5933000 	ldr	r3, [r3]
21f0e7c4:	e59f00b8 	ldr	r0, [pc, #184]	; 21f0e884 <.text+0xe884>
21f0e7c8:	e1a01003 	mov	r1, r3
21f0e7cc:	eb0034ae 	bl	21f1ba8c <printf>
		"Loading: *\b", load_addr);

	NetSetTimeout (NFS_TIMEOUT * CFG_HZ, NfsTimeout);
21f0e7d0:	e3a00cea 	mov	r0, #59904	; 0xea00
21f0e7d4:	e2800060 	add	r0, r0, #96	; 0x60
21f0e7d8:	e59f10a8 	ldr	r1, [pc, #168]	; 21f0e888 <.text+0xe888>
21f0e7dc:	ebffeb2f 	bl	21f094a0 <NetSetTimeout>
	NetSetHandler (NfsHandler);
21f0e7e0:	e59f00a4 	ldr	r0, [pc, #164]	; 21f0e88c <.text+0xe88c>
21f0e7e4:	ebffeb23 	bl	21f09478 <NetSetHandler>

	NfsTimeoutCount = 0;
21f0e7e8:	e59f20a0 	ldr	r2, [pc, #160]	; 21f0e890 <.text+0xe890>
21f0e7ec:	e3a03000 	mov	r3, #0	; 0x0
21f0e7f0:	e5823000 	str	r3, [r2]
	NfsState = STATE_PRCLOOKUP_PROG_MOUNT_REQ;
21f0e7f4:	e59f2098 	ldr	r2, [pc, #152]	; 21f0e894 <.text+0xe894>
21f0e7f8:	e3a03001 	mov	r3, #1	; 0x1
21f0e7fc:	e5823000 	str	r3, [r2]

	/*NfsOurPort = 4096 + (get_ticks() % 3072);*/
	/*FIX ME !!!*/
	NfsOurPort = 1000;
21f0e800:	e59f2090 	ldr	r2, [pc, #144]	; 21f0e898 <.text+0xe898>
21f0e804:	e3a03ffa 	mov	r3, #1000	; 0x3e8
21f0e808:	e5823000 	str	r3, [r2]

	/* zero out server ether in case the server ip has changed */
	memset (NetServerEther, 0, 6);
21f0e80c:	e59f0088 	ldr	r0, [pc, #136]	; 21f0e89c <.text+0xe89c>
21f0e810:	e3a01000 	mov	r1, #0	; 0x0
21f0e814:	e3a02006 	mov	r2, #6	; 0x6
21f0e818:	eb005232 	bl	21f230e8 <memset>

	NfsSend ();
21f0e81c:	ebfffc1b 	bl	21f0d890 <NfsSend>
}
21f0e820:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0e824:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0e828:	21f66b08 	mvncss	r6, r8, lsl #22
21f0e82c:	21f64560 	mvncss	r4, r0, ror #10
21f0e830:	21f66b0c 	mvncss	r6, ip, lsl #22
21f0e834:	21f66b68 	mvncss	r6, r8, ror #22
21f0e838:	21f66b6c 	mvncss	r6, ip, ror #22
21f0e83c:	21f64580 	mvncss	r4, r0, lsl #11
21f0e840:	21f2fa48 	mvncss	pc, r8, asr #20
21f0e844:	21f64584 	mvncss	r4, r4, lsl #11
21f0e848:	21f6455c 	mvncss	r4, ip, asr r5
21f0e84c:	21f66b24 	mvncss	r6, r4, lsr #22
21f0e850:	21f2fa6c 	mvncss	pc, ip, ror #20
21f0e854:	21f2fa90 	ldrcsb	pc, [r2, #160]!
21f0e858:	21f66b64 	mvncss	r6, r4, ror #22
21f0e85c:	21f2fabc 	ldrcsh	pc, [r2, #172]!
21f0e860:	21f2fae0 	mvncss	pc, r0, ror #21
21f0e864:	21f644b4 	ldrcsh	r4, [r6, #68]!
21f0e868:	21f644b0 	ldrcsh	r4, [r6, #64]!
21f0e86c:	21f2faf8 	ldrcssh	pc, [r2, #168]!
21f0e870:	21f2fb14 	mvncss	pc, r4, lsl fp
21f0e874:	21f6453c 	mvncss	r4, ip, lsr r5
21f0e878:	21f2fb28 	mvncss	pc, r8, lsr #22
21f0e87c:	21f2f9b4 	ldrcsh	pc, [r2, #148]!
21f0e880:	21f3322c 	mvncss	r3, ip, lsr #4
21f0e884:	21f2fb40 	mvncss	pc, r0, asr #22
21f0e888:	21f0e1cc 	mvncss	lr, ip, asr #3
21f0e88c:	21f0e1f8 	ldrcssh	lr, [r0, #24]!
21f0e890:	21f66b1c 	mvncss	r6, ip, lsl fp
21f0e894:	21f66b20 	mvncss	r6, r0, lsr #22
21f0e898:	21f66b18 	mvncss	r6, r8, lsl fp
21f0e89c:	21f6453e 	mvncss	r4, lr, lsr r5

21f0e8a0 <dev_print>:
/*
 * reports device info to the user
 */
void dev_print (block_dev_desc_t *dev_desc)
{
21f0e8a0:	e1a0c00d 	mov	ip, sp
21f0e8a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0e8a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0e8ac:	e24dd030 	sub	sp, sp, #48	; 0x30
21f0e8b0:	e50b0030 	str	r0, [fp, #-48]
#ifdef CONFIG_LBA48
	uint64_t lba512; /* number of blocks if 512bytes block size */
#else
	lbaint_t lba512;
#endif

	if (dev_desc->type==DEV_TYPE_UNKNOWN) {
21f0e8b4:	e51b3030 	ldr	r3, [fp, #-48]
21f0e8b8:	e5d3300b 	ldrb	r3, [r3, #11]
21f0e8bc:	e35300ff 	cmp	r3, #255	; 0xff
21f0e8c0:	1a000002 	bne	21f0e8d0 <dev_print+0x30>
		puts ("not available\n");
21f0e8c4:	e59f0250 	ldr	r0, [pc, #592]	; 21f0eb1c <.text+0xeb1c>
21f0e8c8:	eb00345c 	bl	21f1ba40 <puts>
		return;
21f0e8cc:	ea000090 	b	21f0eb14 <.text+0xeb14>
	}
	if (dev_desc->if_type==IF_TYPE_SCSI)  {
21f0e8d0:	e51b3030 	ldr	r3, [fp, #-48]
21f0e8d4:	e5933000 	ldr	r3, [r3]
21f0e8d8:	e3530002 	cmp	r3, #2	; 0x2
21f0e8dc:	1a000008 	bne	21f0e904 <dev_print+0x64>
		printf ("(%d:%d) ", dev_desc->target,dev_desc->lun);
21f0e8e0:	e51b3030 	ldr	r3, [fp, #-48]
21f0e8e4:	e5d33009 	ldrb	r3, [r3, #9]
21f0e8e8:	e1a02003 	mov	r2, r3
21f0e8ec:	e51b3030 	ldr	r3, [fp, #-48]
21f0e8f0:	e5d3300a 	ldrb	r3, [r3, #10]
21f0e8f4:	e59f0224 	ldr	r0, [pc, #548]	; 21f0eb20 <.text+0xeb20>
21f0e8f8:	e1a01002 	mov	r1, r2
21f0e8fc:	e1a02003 	mov	r2, r3
21f0e900:	eb003461 	bl	21f1ba8c <printf>
	}
	if (dev_desc->if_type==IF_TYPE_IDE) {
21f0e904:	e51b3030 	ldr	r3, [fp, #-48]
21f0e908:	e5933000 	ldr	r3, [r3]
21f0e90c:	e3530001 	cmp	r3, #1	; 0x1
21f0e910:	1a000008 	bne	21f0e938 <dev_print+0x98>
		printf ("Model: %s Firm: %s Ser#: %s\n",
21f0e914:	e51b3030 	ldr	r3, [fp, #-48]
21f0e918:	e2831018 	add	r1, r3, #24	; 0x18
21f0e91c:	e51b3030 	ldr	r3, [fp, #-48]
21f0e920:	e2832056 	add	r2, r3, #86	; 0x56
21f0e924:	e51b3030 	ldr	r3, [fp, #-48]
21f0e928:	e2833041 	add	r3, r3, #65	; 0x41
21f0e92c:	e59f01f0 	ldr	r0, [pc, #496]	; 21f0eb24 <.text+0xeb24>
21f0e930:	eb003455 	bl	21f1ba8c <printf>
21f0e934:	ea000007 	b	21f0e958 <dev_print+0xb8>
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
	} else {
		printf ("Vendor: %s Prod.: %s Rev: %s\n",
21f0e938:	e51b3030 	ldr	r3, [fp, #-48]
21f0e93c:	e2831018 	add	r1, r3, #24	; 0x18
21f0e940:	e51b3030 	ldr	r3, [fp, #-48]
21f0e944:	e2832041 	add	r2, r3, #65	; 0x41
21f0e948:	e51b3030 	ldr	r3, [fp, #-48]
21f0e94c:	e2833056 	add	r3, r3, #86	; 0x56
21f0e950:	e59f01d0 	ldr	r0, [pc, #464]	; 21f0eb28 <.text+0xeb28>
21f0e954:	eb00344c 	bl	21f1ba8c <printf>
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
	}
	puts ("            Type: ");
21f0e958:	e59f01cc 	ldr	r0, [pc, #460]	; 21f0eb2c <.text+0xeb2c>
21f0e95c:	eb003437 	bl	21f1ba40 <puts>
	if (dev_desc->removable)
21f0e960:	e51b3030 	ldr	r3, [fp, #-48]
21f0e964:	e5d3300c 	ldrb	r3, [r3, #12]
21f0e968:	e3530000 	cmp	r3, #0	; 0x0
21f0e96c:	0a000001 	beq	21f0e978 <dev_print+0xd8>
		puts ("Removable ");
21f0e970:	e59f01b8 	ldr	r0, [pc, #440]	; 21f0eb30 <.text+0xeb30>
21f0e974:	eb003431 	bl	21f1ba40 <puts>
	switch (dev_desc->type & 0x1F) {
21f0e978:	e51b3030 	ldr	r3, [fp, #-48]
21f0e97c:	e5d3300b 	ldrb	r3, [r3, #11]
21f0e980:	e203301f 	and	r3, r3, #31	; 0x1f
21f0e984:	e3530007 	cmp	r3, #7	; 0x7
21f0e988:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0e98c:	ea000013 	b	21f0e9e0 <.text+0xe9e0>
21f0e990:	21f0e9b0 	ldrcsh	lr, [r0, #144]!
21f0e994:	21f0e9d4 	ldrcssb	lr, [r0, #148]!
21f0e998:	21f0e9e0 	mvncss	lr, r0, ror #19
21f0e99c:	21f0e9e0 	mvncss	lr, r0, ror #19
21f0e9a0:	21f0e9e0 	mvncss	lr, r0, ror #19
21f0e9a4:	21f0e9bc 	ldrcsh	lr, [r0, #156]!
21f0e9a8:	21f0e9e0 	mvncss	lr, r0, ror #19
21f0e9ac:	21f0e9c8 	mvncss	lr, r8, asr #19
		case DEV_TYPE_HARDDISK: puts ("Hard Disk");
21f0e9b0:	e59f017c 	ldr	r0, [pc, #380]	; 21f0eb34 <.text+0xeb34>
21f0e9b4:	eb003421 	bl	21f1ba40 <puts>
					break;
21f0e9b8:	ea00000e 	b	21f0e9f8 <.text+0xe9f8>
		case DEV_TYPE_CDROM: 	puts ("CD ROM");
21f0e9bc:	e59f0174 	ldr	r0, [pc, #372]	; 21f0eb38 <.text+0xeb38>
21f0e9c0:	eb00341e 	bl	21f1ba40 <puts>
					break;
21f0e9c4:	ea00000b 	b	21f0e9f8 <.text+0xe9f8>
		case DEV_TYPE_OPDISK: 	puts ("Optical Device");
21f0e9c8:	e59f016c 	ldr	r0, [pc, #364]	; 21f0eb3c <.text+0xeb3c>
21f0e9cc:	eb00341b 	bl	21f1ba40 <puts>
					break;
21f0e9d0:	ea000008 	b	21f0e9f8 <.text+0xe9f8>
		case DEV_TYPE_TAPE: 	puts ("Tape");
21f0e9d4:	e59f0164 	ldr	r0, [pc, #356]	; 21f0eb40 <.text+0xeb40>
21f0e9d8:	eb003418 	bl	21f1ba40 <puts>
					break;
21f0e9dc:	ea000005 	b	21f0e9f8 <.text+0xe9f8>
		default:		printf ("# %02X #", dev_desc->type & 0x1F);
21f0e9e0:	e51b3030 	ldr	r3, [fp, #-48]
21f0e9e4:	e5d3300b 	ldrb	r3, [r3, #11]
21f0e9e8:	e203301f 	and	r3, r3, #31	; 0x1f
21f0e9ec:	e59f0150 	ldr	r0, [pc, #336]	; 21f0eb44 <.text+0xeb44>
21f0e9f0:	e1a01003 	mov	r1, r3
21f0e9f4:	eb003424 	bl	21f1ba8c <printf>
					break;
	}
	puts ("\n");
21f0e9f8:	e59f0148 	ldr	r0, [pc, #328]	; 21f0eb48 <.text+0xeb48>
21f0e9fc:	eb00340f 	bl	21f1ba40 <puts>
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
21f0ea00:	e51b3030 	ldr	r3, [fp, #-48]
21f0ea04:	e5932010 	ldr	r2, [r3, #16]
21f0ea08:	e51b3030 	ldr	r3, [fp, #-48]
21f0ea0c:	e5933014 	ldr	r3, [r3, #20]
21f0ea10:	e0030392 	mul	r3, r2, r3
21f0ea14:	e3530000 	cmp	r3, #0	; 0x0
21f0ea18:	0a00003b 	beq	21f0eb0c <.text+0xeb0c>
		ulong mb, mb_quot, mb_rem, gb, gb_quot, gb_rem;
		lbaint_t lba;

		lba = dev_desc->lba;
21f0ea1c:	e51b3030 	ldr	r3, [fp, #-48]
21f0ea20:	e5933010 	ldr	r3, [r3, #16]
21f0ea24:	e50b3010 	str	r3, [fp, #-16]

		lba512 = (lba * (dev_desc->blksz/512));
21f0ea28:	e51b3030 	ldr	r3, [fp, #-48]
21f0ea2c:	e5933014 	ldr	r3, [r3, #20]
21f0ea30:	e1a024a3 	mov	r2, r3, lsr #9
21f0ea34:	e51b3010 	ldr	r3, [fp, #-16]
21f0ea38:	e0030392 	mul	r3, r2, r3
21f0ea3c:	e50b302c 	str	r3, [fp, #-44]
		mb = (10 * lba512) / 2048;	/* 2048 = (1024 * 1024) / 512 MB */
21f0ea40:	e51b202c 	ldr	r2, [fp, #-44]
21f0ea44:	e1a03002 	mov	r3, r2
21f0ea48:	e1a03103 	mov	r3, r3, lsl #2
21f0ea4c:	e0833002 	add	r3, r3, r2
21f0ea50:	e1a03083 	mov	r3, r3, lsl #1
21f0ea54:	e1a035a3 	mov	r3, r3, lsr #11
21f0ea58:	e50b3028 	str	r3, [fp, #-40]
		/* round to 1 digit */
		mb_quot	= mb / 10;
21f0ea5c:	e51b2028 	ldr	r2, [fp, #-40]
21f0ea60:	e59f30e4 	ldr	r3, [pc, #228]	; 21f0eb4c <.text+0xeb4c>
21f0ea64:	e0831392 	umull	r1, r3, r2, r3
21f0ea68:	e1a031a3 	mov	r3, r3, lsr #3
21f0ea6c:	e50b3024 	str	r3, [fp, #-36]
		mb_rem	= mb - (10 * mb_quot);
21f0ea70:	e51b2024 	ldr	r2, [fp, #-36]
21f0ea74:	e1a03002 	mov	r3, r2
21f0ea78:	e1a03103 	mov	r3, r3, lsl #2
21f0ea7c:	e0833002 	add	r3, r3, r2
21f0ea80:	e1a03083 	mov	r3, r3, lsl #1
21f0ea84:	e1a02003 	mov	r2, r3
21f0ea88:	e51b3028 	ldr	r3, [fp, #-40]
21f0ea8c:	e0623003 	rsb	r3, r2, r3
21f0ea90:	e50b3020 	str	r3, [fp, #-32]

		gb = mb / 1024;
21f0ea94:	e51b3028 	ldr	r3, [fp, #-40]
21f0ea98:	e1a03523 	mov	r3, r3, lsr #10
21f0ea9c:	e50b301c 	str	r3, [fp, #-28]
		gb_quot	= gb / 10;
21f0eaa0:	e51b201c 	ldr	r2, [fp, #-28]
21f0eaa4:	e59f30a0 	ldr	r3, [pc, #160]	; 21f0eb4c <.text+0xeb4c>
21f0eaa8:	e0831392 	umull	r1, r3, r2, r3
21f0eaac:	e1a031a3 	mov	r3, r3, lsr #3
21f0eab0:	e50b3018 	str	r3, [fp, #-24]
		gb_rem	= gb - (10 * gb_quot);
21f0eab4:	e51b2018 	ldr	r2, [fp, #-24]
21f0eab8:	e1a03002 	mov	r3, r2
21f0eabc:	e1a03103 	mov	r3, r3, lsl #2
21f0eac0:	e0833002 	add	r3, r3, r2
21f0eac4:	e1a03083 	mov	r3, r3, lsl #1
21f0eac8:	e1a02003 	mov	r2, r3
21f0eacc:	e51b301c 	ldr	r3, [fp, #-28]
21f0ead0:	e0623003 	rsb	r3, r2, r3
21f0ead4:	e50b3014 	str	r3, [fp, #-20]
#ifdef CONFIG_LBA48
		if (dev_desc->lba48)
			printf ("            Supports 48-bit addressing\n");
#endif
#if defined(CFG_64BIT_LBA) && defined(CFG_64BIT_VSPRINTF)
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%qd x %ld)\n",
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
21f0ead8:	e51b3030 	ldr	r3, [fp, #-48]
21f0eadc:	e5932014 	ldr	r2, [r3, #20]
21f0eae0:	e51b3014 	ldr	r3, [fp, #-20]
21f0eae4:	e58d3000 	str	r3, [sp]
21f0eae8:	e51b3010 	ldr	r3, [fp, #-16]
21f0eaec:	e58d3004 	str	r3, [sp, #4]
21f0eaf0:	e58d2008 	str	r2, [sp, #8]
21f0eaf4:	e59f0054 	ldr	r0, [pc, #84]	; 21f0eb50 <.text+0xeb50>
21f0eaf8:	e51b1024 	ldr	r1, [fp, #-36]
21f0eafc:	e51b2020 	ldr	r2, [fp, #-32]
21f0eb00:	e51b3018 	ldr	r3, [fp, #-24]
21f0eb04:	eb0033e0 	bl	21f1ba8c <printf>
21f0eb08:	ea000001 	b	21f0eb14 <.text+0xeb14>
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
21f0eb0c:	e59f0040 	ldr	r0, [pc, #64]	; 21f0eb54 <.text+0xeb54>
21f0eb10:	eb0033ca 	bl	21f1ba40 <puts>
	}
}
21f0eb14:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0eb18:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0eb1c:	21f2fb64 	mvncss	pc, r4, ror #22
21f0eb20:	21f2fb74 	mvncss	pc, r4, ror fp
21f0eb24:	21f2fb80 	mvncss	pc, r0, lsl #23
21f0eb28:	21f2fba0 	mvncss	pc, r0, lsr #23
21f0eb2c:	21f2fbc0 	mvncss	pc, r0, asr #23
21f0eb30:	21f2fbd4 	ldrcssb	pc, [r2, #180]!
21f0eb34:	21f2fbe0 	mvncss	pc, r0, ror #23
21f0eb38:	21f2fbec 	mvncss	pc, ip, ror #23
21f0eb3c:	21f2fbf4 	ldrcssh	pc, [r2, #180]!
21f0eb40:	21f2fc04 	mvncss	pc, r4, lsl #24
21f0eb44:	21f2fc0c 	mvncss	pc, ip, lsl #24
21f0eb48:	21f2fc18 	mvncss	pc, r8, lsl ip
21f0eb4c:	cccccccd 	stcgtl	12, cr12, [ip], {205}
21f0eb50:	21f2fc1c 	mvncss	pc, ip, lsl ip
21f0eb54:	21f2fc58 	mvncss	pc, r8, asr ip

21f0eb58 <init_part>:
#endif	/* CFG_CMD_IDE || CFG_CMD_SCSI || CFG_CMD_USB || CONFIG_MMC */

#if ((CONFIG_COMMANDS & CFG_CMD_IDE)	|| \
     (CONFIG_COMMANDS & CFG_CMD_SCSI)	|| \
     (CONFIG_COMMANDS & CFG_CMD_USB)	|| \
     defined(CONFIG_SYSTEMACE)          || \
     defined(CONFIG_MMC)	)
	
#if defined(CONFIG_MAC_PARTITION) || \
    defined(CONFIG_DOS_PARTITION) || \
    defined(CONFIG_ISO_PARTITION) || \
    defined(CONFIG_AMIGA_PARTITION)

void init_part (block_dev_desc_t * dev_desc)
{
21f0eb58:	e1a0c00d 	mov	ip, sp
21f0eb5c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0eb60:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0eb64:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0eb68:	e50b0010 	str	r0, [fp, #-16]
#ifdef CONFIG_ISO_PARTITION
	if (test_part_iso(dev_desc) == 0) {
		dev_desc->part_type = PART_TYPE_ISO;
		return;
	}
#endif

#ifdef CONFIG_MAC_PARTITION
	if (test_part_mac(dev_desc) == 0) {
		dev_desc->part_type = PART_TYPE_MAC;
		return;
	}
#endif

#ifdef CONFIG_DOS_PARTITION
	if (test_part_dos(dev_desc) == 0) {
21f0eb6c:	e51b0010 	ldr	r0, [fp, #-16]
21f0eb70:	eb0000f3 	bl	21f0ef44 <test_part_dos>
21f0eb74:	e1a03000 	mov	r3, r0
21f0eb78:	e3530000 	cmp	r3, #0	; 0x0
21f0eb7c:	1a000002 	bne	21f0eb8c <init_part+0x34>
		dev_desc->part_type = PART_TYPE_DOS;
21f0eb80:	e51b3010 	ldr	r3, [fp, #-16]
21f0eb84:	e3a02002 	mov	r2, #2	; 0x2
21f0eb88:	e5c32008 	strb	r2, [r3, #8]
		return;
	}
#endif

#ifdef CONFIG_AMIGA_PARTITION
	if (test_part_amiga(dev_desc) == 0) {
	    dev_desc->part_type = PART_TYPE_AMIGA;
	    return;
	}
#endif
}
21f0eb8c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0eb90 <get_partition_info>:


int get_partition_info (block_dev_desc_t *dev_desc, int part, disk_partition_t *info)
{
21f0eb90:	e1a0c00d 	mov	ip, sp
21f0eb94:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0eb98:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0eb9c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f0eba0:	e50b0010 	str	r0, [fp, #-16]
21f0eba4:	e50b1014 	str	r1, [fp, #-20]
21f0eba8:	e50b2018 	str	r2, [fp, #-24]
		switch (dev_desc->part_type) {
21f0ebac:	e51b3010 	ldr	r3, [fp, #-16]
21f0ebb0:	e5d33008 	ldrb	r3, [r3, #8]
21f0ebb4:	e3530002 	cmp	r3, #2	; 0x2
21f0ebb8:	0a000000 	beq	21f0ebc0 <get_partition_info+0x30>
21f0ebbc:	ea000009 	b	21f0ebe8 <get_partition_info+0x58>
#ifdef CONFIG_MAC_PARTITION
	case PART_TYPE_MAC:
		if (get_partition_info_mac(dev_desc,part,info) == 0) {
			PRINTF ("## Valid MAC partition found ##\n");
			return (0);
		}
		break;
#endif

#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		if (get_partition_info_dos(dev_desc,part,info) == 0) {
21f0ebc0:	e51b0010 	ldr	r0, [fp, #-16]
21f0ebc4:	e51b1014 	ldr	r1, [fp, #-20]
21f0ebc8:	e51b2018 	ldr	r2, [fp, #-24]
21f0ebcc:	eb0002ad 	bl	21f0f688 <get_partition_info_dos>
21f0ebd0:	e1a03000 	mov	r3, r0
21f0ebd4:	e3530000 	cmp	r3, #0	; 0x0
21f0ebd8:	1a000002 	bne	21f0ebe8 <get_partition_info+0x58>
			PRINTF ("## Valid DOS partition found ##\n");
			return (0);
21f0ebdc:	e3a03000 	mov	r3, #0	; 0x0
21f0ebe0:	e50b301c 	str	r3, [fp, #-28]
21f0ebe4:	ea000001 	b	21f0ebf0 <get_partition_info+0x60>
		}
		break;
#endif

#ifdef CONFIG_ISO_PARTITION
	case PART_TYPE_ISO:
		if (get_partition_info_iso(dev_desc,part,info) == 0) {
			PRINTF ("## Valid ISO boot partition found ##\n");
			return (0);
		}
		break;
#endif

#ifdef CONFIG_AMIGA_PARTITION
	case PART_TYPE_AMIGA:
	    if (get_partition_info_amiga(dev_desc, part, info) == 0)
	    {
		PRINTF ("## Valid Amiga partition found ##\n");
		return (0);
	    }
	    break;
#endif
	default:
		break;
	}
	return (-1);
21f0ebe8:	e3e03000 	mvn	r3, #0	; 0x0
21f0ebec:	e50b301c 	str	r3, [fp, #-28]
21f0ebf0:	e51b301c 	ldr	r3, [fp, #-28]
}
21f0ebf4:	e1a00003 	mov	r0, r3
21f0ebf8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0ebfc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0ec00 <print_part_header>:

static void print_part_header (const char *type, block_dev_desc_t * dev_desc)
{
21f0ec00:	e1a0c00d 	mov	ip, sp
21f0ec04:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ec08:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ec0c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0ec10:	e50b0010 	str	r0, [fp, #-16]
21f0ec14:	e50b1014 	str	r1, [fp, #-20]
	puts ("\nPartition Map for ");
21f0ec18:	e59f0090 	ldr	r0, [pc, #144]	; 21f0ecb0 <.text+0xecb0>
21f0ec1c:	eb003387 	bl	21f1ba40 <puts>
	switch (dev_desc->if_type) {
21f0ec20:	e51b3014 	ldr	r3, [fp, #-20]
21f0ec24:	e5933000 	ldr	r3, [r3]
21f0ec28:	e2433001 	sub	r3, r3, #1	; 0x1
21f0ec2c:	e3530004 	cmp	r3, #4	; 0x4
21f0ec30:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0ec34:	ea000013 	b	21f0ec88 <.text+0xec88>
21f0ec38:	21f0ec4c 	mvncss	lr, ip, asr #24
21f0ec3c:	21f0ec58 	mvncss	lr, r8, asr ip
21f0ec40:	21f0ec64 	mvncss	lr, r4, ror #24
21f0ec44:	21f0ec70 	mvncss	lr, r0, ror ip
21f0ec48:	21f0ec7c 	mvncss	lr, ip, ror ip
		case IF_TYPE_IDE:  	puts ("IDE");
21f0ec4c:	e59f0060 	ldr	r0, [pc, #96]	; 21f0ecb4 <.text+0xecb4>
21f0ec50:	eb00337a 	bl	21f1ba40 <puts>
					break;
21f0ec54:	ea00000d 	b	21f0ec90 <.text+0xec90>
		case IF_TYPE_SCSI: 	puts ("SCSI");
21f0ec58:	e59f0058 	ldr	r0, [pc, #88]	; 21f0ecb8 <.text+0xecb8>
21f0ec5c:	eb003377 	bl	21f1ba40 <puts>
					break;
21f0ec60:	ea00000a 	b	21f0ec90 <.text+0xec90>
		case IF_TYPE_ATAPI:	puts ("ATAPI");
21f0ec64:	e59f0050 	ldr	r0, [pc, #80]	; 21f0ecbc <.text+0xecbc>
21f0ec68:	eb003374 	bl	21f1ba40 <puts>
					break;
21f0ec6c:	ea000007 	b	21f0ec90 <.text+0xec90>
		case IF_TYPE_USB:	puts ("USB");
21f0ec70:	e59f0048 	ldr	r0, [pc, #72]	; 21f0ecc0 <.text+0xecc0>
21f0ec74:	eb003371 	bl	21f1ba40 <puts>
					break;
21f0ec78:	ea000004 	b	21f0ec90 <.text+0xec90>
		case IF_TYPE_DOC:	puts ("DOC");
21f0ec7c:	e59f0040 	ldr	r0, [pc, #64]	; 21f0ecc4 <.text+0xecc4>
21f0ec80:	eb00336e 	bl	21f1ba40 <puts>
					break;
21f0ec84:	ea000001 	b	21f0ec90 <.text+0xec90>
		default: 		puts ("UNKNOWN");
21f0ec88:	e59f0038 	ldr	r0, [pc, #56]	; 21f0ecc8 <.text+0xecc8>
21f0ec8c:	eb00336b 	bl	21f1ba40 <puts>
					break;
	}
	printf (" device %d  --   Partition Type: %s\n\n",
21f0ec90:	e51b3014 	ldr	r3, [fp, #-20]
21f0ec94:	e5933004 	ldr	r3, [r3, #4]
21f0ec98:	e59f002c 	ldr	r0, [pc, #44]	; 21f0eccc <.text+0xeccc>
21f0ec9c:	e1a01003 	mov	r1, r3
21f0eca0:	e51b2010 	ldr	r2, [fp, #-16]
21f0eca4:	eb003378 	bl	21f1ba8c <printf>
			dev_desc->dev, type);
}
21f0eca8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0ecac:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0ecb0:	21f2fc80 	mvncss	pc, r0, lsl #25
21f0ecb4:	21f2fc94 	ldrcsb	pc, [r2, #196]!
21f0ecb8:	21f2fc98 	ldrcsb	pc, [r2, #200]!
21f0ecbc:	21f2fca0 	mvncss	pc, r0, lsr #25
21f0ecc0:	21f2fca8 	mvncss	pc, r8, lsr #25
21f0ecc4:	21f2fcac 	mvncss	pc, ip, lsr #25
21f0ecc8:	21f2fcb0 	ldrcsh	pc, [r2, #192]!
21f0eccc:	21f2fcb8 	ldrcsh	pc, [r2, #200]!

21f0ecd0 <print_part>:

void print_part (block_dev_desc_t * dev_desc)
{
21f0ecd0:	e1a0c00d 	mov	ip, sp
21f0ecd4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ecd8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ecdc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0ece0:	e50b0010 	str	r0, [fp, #-16]

		switch (dev_desc->part_type) {
21f0ece4:	e51b3010 	ldr	r3, [fp, #-16]
21f0ece8:	e5d33008 	ldrb	r3, [r3, #8]
21f0ecec:	e3530002 	cmp	r3, #2	; 0x2
21f0ecf0:	0a000000 	beq	21f0ecf8 <print_part+0x28>
21f0ecf4:	ea000005 	b	21f0ed10 <print_part+0x40>
#ifdef CONFIG_MAC_PARTITION
	case PART_TYPE_MAC:
		PRINTF ("## Testing for valid MAC partition ##\n");
		print_part_header ("MAC", dev_desc);
		print_part_mac (dev_desc);
		return;
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
21f0ecf8:	e59f001c 	ldr	r0, [pc, #28]	; 21f0ed1c <.text+0xed1c>
21f0ecfc:	e51b1010 	ldr	r1, [fp, #-16]
21f0ed00:	ebffffbe 	bl	21f0ec00 <print_part_header>
		print_part_dos (dev_desc);
21f0ed04:	e51b0010 	ldr	r0, [fp, #-16]
21f0ed08:	eb000250 	bl	21f0f650 <print_part_dos>
		return;
21f0ed0c:	ea000001 	b	21f0ed18 <print_part+0x48>
#endif

#ifdef CONFIG_ISO_PARTITION
	case PART_TYPE_ISO:
		PRINTF ("## Testing for valid ISO Boot partition ##\n");
		print_part_header ("ISO", dev_desc);
		print_part_iso (dev_desc);
		return;
#endif

#ifdef CONFIG_AMIGA_PARTITION
	case PART_TYPE_AMIGA:
	    PRINTF ("## Testing for a valid Amiga partition ##\n");
	    print_part_header ("AMIGA", dev_desc);
	    print_part_amiga (dev_desc);
	    return;
#endif
	}
	puts ("## Unknown partition table\n");
21f0ed10:	e59f0008 	ldr	r0, [pc, #8]	; 21f0ed20 <.text+0xed20>
21f0ed14:	eb003349 	bl	21f1ba40 <puts>
}
21f0ed18:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f0ed1c:	21f2fce0 	mvncss	pc, r0, ror #25
21f0ed20:	21f2fce4 	mvncss	pc, r4, ror #25

21f0ed24 <print_one_part>:
	    part_type == 0x85);
}

static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
21f0ed24:	e1a0c00d 	mov	ip, sp
21f0ed28:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ed2c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ed30:	e24dd024 	sub	sp, sp, #36	; 0x24
21f0ed34:	e50b0018 	str	r0, [fp, #-24]
21f0ed38:	e50b101c 	str	r1, [fp, #-28]
21f0ed3c:	e50b2020 	str	r2, [fp, #-32]
	int lba_start = ext_part_sector + le32_to_int (p->start4);
21f0ed40:	e51b3018 	ldr	r3, [fp, #-24]
21f0ed44:	e2833008 	add	r3, r3, #8	; 0x8
21f0ed48:	e1a00003 	mov	r0, r3
21f0ed4c:	eb00003d 	bl	21f0ee48 <le32_to_int>
21f0ed50:	e1a02000 	mov	r2, r0
21f0ed54:	e51b301c 	ldr	r3, [fp, #-28]
21f0ed58:	e0823003 	add	r3, r2, r3
21f0ed5c:	e50b3014 	str	r3, [fp, #-20]
	int lba_size  = le32_to_int (p->size4);
21f0ed60:	e51b3018 	ldr	r3, [fp, #-24]
21f0ed64:	e283300c 	add	r3, r3, #12	; 0xc
21f0ed68:	e1a00003 	mov	r0, r3
21f0ed6c:	eb000035 	bl	21f0ee48 <le32_to_int>
21f0ed70:	e1a03000 	mov	r3, r0
21f0ed74:	e50b3010 	str	r3, [fp, #-16]

	printf ("%5d\t\t%10d\t%10d\t%2x%s\n",
21f0ed78:	e51b3018 	ldr	r3, [fp, #-24]
21f0ed7c:	e5d33004 	ldrb	r3, [r3, #4]
21f0ed80:	e50b3028 	str	r3, [fp, #-40]
21f0ed84:	e51b3018 	ldr	r3, [fp, #-24]
21f0ed88:	e5d33004 	ldrb	r3, [r3, #4]
21f0ed8c:	e1a00003 	mov	r0, r3
21f0ed90:	eb000015 	bl	21f0edec <is_extended>
21f0ed94:	e1a03000 	mov	r3, r0
21f0ed98:	e3530000 	cmp	r3, #0	; 0x0
21f0ed9c:	0a000002 	beq	21f0edac <print_one_part+0x88>
21f0eda0:	e59f3038 	ldr	r3, [pc, #56]	; 21f0ede0 <.text+0xede0>
21f0eda4:	e50b3024 	str	r3, [fp, #-36]
21f0eda8:	ea000001 	b	21f0edb4 <print_one_part+0x90>
21f0edac:	e59f3030 	ldr	r3, [pc, #48]	; 21f0ede4 <.text+0xede4>
21f0edb0:	e50b3024 	str	r3, [fp, #-36]
21f0edb4:	e51b3028 	ldr	r3, [fp, #-40]
21f0edb8:	e58d3000 	str	r3, [sp]
21f0edbc:	e51b3024 	ldr	r3, [fp, #-36]
21f0edc0:	e58d3004 	str	r3, [sp, #4]
21f0edc4:	e59f001c 	ldr	r0, [pc, #28]	; 21f0ede8 <.text+0xede8>
21f0edc8:	e51b1020 	ldr	r1, [fp, #-32]
21f0edcc:	e51b2014 	ldr	r2, [fp, #-20]
21f0edd0:	e51b3010 	ldr	r3, [fp, #-16]
21f0edd4:	eb00332c 	bl	21f1ba8c <printf>
		part_num, lba_start, lba_size, p->sys_ind,
		(is_extended (p->sys_ind) ? " Extd" : ""));
}
21f0edd8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0eddc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0ede0:	21f2fd00 	mvncss	pc, r0, lsl #26
21f0ede4:	21f2fd08 	mvncss	pc, r8, lsl #26
21f0ede8:	21f2fd0c 	mvncss	pc, ip, lsl #26

21f0edec <is_extended>:
21f0edec:	e1a0c00d 	mov	ip, sp
21f0edf0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0edf4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0edf8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0edfc:	e50b0010 	str	r0, [fp, #-16]
21f0ee00:	e51b3010 	ldr	r3, [fp, #-16]
21f0ee04:	e3530005 	cmp	r3, #5	; 0x5
21f0ee08:	0a000005 	beq	21f0ee24 <is_extended+0x38>
21f0ee0c:	e51b3010 	ldr	r3, [fp, #-16]
21f0ee10:	e353000f 	cmp	r3, #15	; 0xf
21f0ee14:	0a000002 	beq	21f0ee24 <is_extended+0x38>
21f0ee18:	e51b3010 	ldr	r3, [fp, #-16]
21f0ee1c:	e3530085 	cmp	r3, #133	; 0x85
21f0ee20:	1a000002 	bne	21f0ee30 <is_extended+0x44>
21f0ee24:	e3a03001 	mov	r3, #1	; 0x1
21f0ee28:	e50b3014 	str	r3, [fp, #-20]
21f0ee2c:	ea000001 	b	21f0ee38 <is_extended+0x4c>
21f0ee30:	e3a03000 	mov	r3, #0	; 0x0
21f0ee34:	e50b3014 	str	r3, [fp, #-20]
21f0ee38:	e51b3014 	ldr	r3, [fp, #-20]
21f0ee3c:	e1a00003 	mov	r0, r3
21f0ee40:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0ee44:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0ee48 <le32_to_int>:
21f0ee48:	e1a0c00d 	mov	ip, sp
21f0ee4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0ee50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ee54:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0ee58:	e50b0010 	str	r0, [fp, #-16]
21f0ee5c:	e51b3010 	ldr	r3, [fp, #-16]
21f0ee60:	e2833003 	add	r3, r3, #3	; 0x3
21f0ee64:	e5d33000 	ldrb	r3, [r3]
21f0ee68:	e1a02c03 	mov	r2, r3, lsl #24
21f0ee6c:	e51b3010 	ldr	r3, [fp, #-16]
21f0ee70:	e2833002 	add	r3, r3, #2	; 0x2
21f0ee74:	e5d33000 	ldrb	r3, [r3]
21f0ee78:	e1a03803 	mov	r3, r3, lsl #16
21f0ee7c:	e0822003 	add	r2, r2, r3
21f0ee80:	e51b3010 	ldr	r3, [fp, #-16]
21f0ee84:	e2833001 	add	r3, r3, #1	; 0x1
21f0ee88:	e5d33000 	ldrb	r3, [r3]
21f0ee8c:	e1a03403 	mov	r3, r3, lsl #8
21f0ee90:	e0822003 	add	r2, r2, r3
21f0ee94:	e51b3010 	ldr	r3, [fp, #-16]
21f0ee98:	e5d33000 	ldrb	r3, [r3]
21f0ee9c:	e0823003 	add	r3, r2, r3
21f0eea0:	e1a00003 	mov	r0, r3
21f0eea4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f0eea8 <test_block_type>:

static int test_block_type(unsigned char *buffer)
{
21f0eea8:	e1a0c00d 	mov	ip, sp
21f0eeac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0eeb0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0eeb4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f0eeb8:	e50b0010 	str	r0, [fp, #-16]
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
21f0eebc:	e51b3010 	ldr	r3, [fp, #-16]
21f0eec0:	e2833f7f 	add	r3, r3, #508	; 0x1fc
21f0eec4:	e2833002 	add	r3, r3, #2	; 0x2
21f0eec8:	e5d33000 	ldrb	r3, [r3]
21f0eecc:	e3530055 	cmp	r3, #85	; 0x55
21f0eed0:	1a000005 	bne	21f0eeec <test_block_type+0x44>
21f0eed4:	e51b3010 	ldr	r3, [fp, #-16]
21f0eed8:	e2833f7f 	add	r3, r3, #508	; 0x1fc
21f0eedc:	e2833003 	add	r3, r3, #3	; 0x3
21f0eee0:	e5d33000 	ldrb	r3, [r3]
21f0eee4:	e35300aa 	cmp	r3, #170	; 0xaa
21f0eee8:	0a000002 	beq	21f0eef8 <test_block_type+0x50>
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
21f0eeec:	e3e03000 	mvn	r3, #0	; 0x0
21f0eef0:	e50b3014 	str	r3, [fp, #-20]
21f0eef4:	ea00000d 	b	21f0ef30 <test_block_type+0x88>
	} /* no DOS Signature at all */
	if(strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0)
21f0eef8:	e51b3010 	ldr	r3, [fp, #-16]
21f0eefc:	e2833036 	add	r3, r3, #54	; 0x36
21f0ef00:	e1a00003 	mov	r0, r3
21f0ef04:	e59f1034 	ldr	r1, [pc, #52]	; 21f0ef40 <.text+0xef40>
21f0ef08:	e3a02003 	mov	r2, #3	; 0x3
21f0ef0c:	eb004eb8 	bl	21f229f4 <strncmp>
21f0ef10:	e1a03000 	mov	r3, r0
21f0ef14:	e3530000 	cmp	r3, #0	; 0x0
21f0ef18:	1a000002 	bne	21f0ef28 <test_block_type+0x80>
		return DOS_PBR; /* is PBR */
21f0ef1c:	e3a03001 	mov	r3, #1	; 0x1
21f0ef20:	e50b3014 	str	r3, [fp, #-20]
21f0ef24:	ea000001 	b	21f0ef30 <test_block_type+0x88>
	return DOS_MBR;	    /* Is MBR */
21f0ef28:	e3a03000 	mov	r3, #0	; 0x0
21f0ef2c:	e50b3014 	str	r3, [fp, #-20]
21f0ef30:	e51b3014 	ldr	r3, [fp, #-20]
}
21f0ef34:	e1a00003 	mov	r0, r3
21f0ef38:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0ef3c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f0ef40:	21f2fd24 	mvncss	pc, r4, lsr #26

21f0ef44 <test_part_dos>:


int test_part_dos (block_dev_desc_t *dev_desc)
{
21f0ef44:	e1a0c00d 	mov	ip, sp
21f0ef48:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f0ef4c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0ef50:	e24ddf82 	sub	sp, sp, #520	; 0x208
21f0ef54:	e50b0214 	str	r0, [fp, #-532]
	unsigned char buffer[DEFAULT_SECTOR_SIZE];

	if ((dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1) ||
21f0ef58:	e51b3214 	ldr	r3, [fp, #-532]
21f0ef5c:	e5934060 	ldr	r4, [r3, #96]
21f0ef60:	e51b3214 	ldr	r3, [fp, #-532]
21f0ef64:	e5933004 	ldr	r3, [r3, #4]
21f0ef68:	e24bce21 	sub	ip, fp, #528	; 0x210
21f0ef6c:	e1a00003 	mov	r0, r3
21f0ef70:	e3a01000 	mov	r1, #0	; 0x0
21f0ef74:	e3a02001 	mov	r2, #1	; 0x1
21f0ef78:	e1a0300c 	mov	r3, ip
21f0ef7c:	e1a0e00f 	mov	lr, pc
21f0ef80:	e1a0f004 	mov	pc, r4
21f0ef84:	e1a03000 	mov	r3, r0
21f0ef88:	e3530001 	cmp	r3, #1	; 0x1
21f0ef8c:	1a000005 	bne	21f0efa8 <test_part_dos+0x64>
21f0ef90:	e55b3012 	ldrb	r3, [fp, #-18]
21f0ef94:	e3530055 	cmp	r3, #85	; 0x55
21f0ef98:	1a000002 	bne	21f0efa8 <test_part_dos+0x64>
21f0ef9c:	e55b3011 	ldrb	r3, [fp, #-17]
21f0efa0:	e35300aa 	cmp	r3, #170	; 0xaa
21f0efa4:	0a000002 	beq	21f0efb4 <test_part_dos+0x70>
	    (buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
21f0efa8:	e3e03000 	mvn	r3, #0	; 0x0
21f0efac:	e50b3218 	str	r3, [fp, #-536]
21f0efb0:	ea000001 	b	21f0efbc <test_part_dos+0x78>
	}
	return (0);
21f0efb4:	e3a03000 	mov	r3, #0	; 0x0
21f0efb8:	e50b3218 	str	r3, [fp, #-536]
21f0efbc:	e51b3218 	ldr	r3, [fp, #-536]
}
21f0efc0:	e1a00003 	mov	r0, r3
21f0efc4:	e24bd010 	sub	sp, fp, #16	; 0x10
21f0efc8:	e89da810 	ldmia	sp, {r4, fp, sp, pc}

21f0efcc <print_partition_extended>:

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
21f0efcc:	e1a0c00d 	mov	ip, sp
21f0efd0:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f0efd4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0efd8:	e24dde22 	sub	sp, sp, #544	; 0x220
21f0efdc:	e50b0220 	str	r0, [fp, #-544]
21f0efe0:	e50b1224 	str	r1, [fp, #-548]
21f0efe4:	e50b2228 	str	r2, [fp, #-552]
21f0efe8:	e50b322c 	str	r3, [fp, #-556]
	unsigned char buffer[DEFAULT_SECTOR_SIZE];
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
21f0efec:	e51b3220 	ldr	r3, [fp, #-544]
21f0eff0:	e5934060 	ldr	r4, [r3, #96]
21f0eff4:	e51b3220 	ldr	r3, [fp, #-544]
21f0eff8:	e5933004 	ldr	r3, [r3, #4]
21f0effc:	e51b2224 	ldr	r2, [fp, #-548]
21f0f000:	e24bcf87 	sub	ip, fp, #540	; 0x21c
21f0f004:	e1a00003 	mov	r0, r3
21f0f008:	e1a01002 	mov	r1, r2
21f0f00c:	e3a02001 	mov	r2, #1	; 0x1
21f0f010:	e1a0300c 	mov	r3, ip
21f0f014:	e1a0e00f 	mov	lr, pc
21f0f018:	e1a0f004 	mov	pc, r4
21f0f01c:	e1a03000 	mov	r3, r0
21f0f020:	e3530001 	cmp	r3, #1	; 0x1
21f0f024:	0a000006 	beq	21f0f044 <print_partition_extended+0x78>
		printf ("** Can't read partition table on %d:%d **\n",
21f0f028:	e51b3220 	ldr	r3, [fp, #-544]
21f0f02c:	e5933004 	ldr	r3, [r3, #4]
21f0f030:	e59f01fc 	ldr	r0, [pc, #508]	; 21f0f234 <.text+0xf234>
21f0f034:	e1a01003 	mov	r1, r3
21f0f038:	e51b2224 	ldr	r2, [fp, #-548]
21f0f03c:	eb003292 	bl	21f1ba8c <printf>
			dev_desc->dev, ext_part_sector);
		return;
21f0f040:	ea000079 	b	21f0f22c <print_partition_extended+0x260>
	}
	i=test_block_type(buffer);
21f0f044:	e24b3f87 	sub	r3, fp, #540	; 0x21c
21f0f048:	e1a00003 	mov	r0, r3
21f0f04c:	ebffff95 	bl	21f0eea8 <test_block_type>
21f0f050:	e1a03000 	mov	r3, r0
21f0f054:	e50b3018 	str	r3, [fp, #-24]
	if(i==-1) {
21f0f058:	e51b3018 	ldr	r3, [fp, #-24]
21f0f05c:	e3730001 	cmn	r3, #1	; 0x1
21f0f060:	1a000007 	bne	21f0f084 <print_partition_extended+0xb8>
		printf ("bad MBR sector signature 0x%02x%02x\n",
21f0f064:	e55b301e 	ldrb	r3, [fp, #-30]
21f0f068:	e1a02003 	mov	r2, r3
21f0f06c:	e55b301d 	ldrb	r3, [fp, #-29]
21f0f070:	e59f01c0 	ldr	r0, [pc, #448]	; 21f0f238 <.text+0xf238>
21f0f074:	e1a01002 	mov	r1, r2
21f0f078:	e1a02003 	mov	r2, r3
21f0f07c:	eb003282 	bl	21f1ba8c <printf>
			buffer[DOS_PART_MAGIC_OFFSET],
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
21f0f080:	ea000069 	b	21f0f22c <print_partition_extended+0x260>
	}
	if(i==DOS_PBR) {
21f0f084:	e51b3018 	ldr	r3, [fp, #-24]
21f0f088:	e3530001 	cmp	r3, #1	; 0x1
21f0f08c:	1a000007 	bne	21f0f0b0 <print_partition_extended+0xe4>
		printf ("    1\t\t         0\t%10ld\t%2x\n",
21f0f090:	e51b3220 	ldr	r3, [fp, #-544]
21f0f094:	e5932010 	ldr	r2, [r3, #16]
21f0f098:	e55b3207 	ldrb	r3, [fp, #-519]
21f0f09c:	e59f0198 	ldr	r0, [pc, #408]	; 21f0f23c <.text+0xf23c>
21f0f0a0:	e1a01002 	mov	r1, r2
21f0f0a4:	e1a02003 	mov	r2, r3
21f0f0a8:	eb003277 	bl	21f1ba8c <printf>
			dev_desc->lba, buffer[DOS_PBR_MEDIA_TYPE_OFFSET]);
		return;
21f0f0ac:	ea00005e 	b	21f0f22c <print_partition_extended+0x260>
	}
	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
21f0f0b0:	e24b3f87 	sub	r3, fp, #540	; 0x21c
21f0f0b4:	e2833f6f 	add	r3, r3, #444	; 0x1bc
21f0f0b8:	e2833002 	add	r3, r3, #2	; 0x2
21f0f0bc:	e50b301c 	str	r3, [fp, #-28]
	for (i = 0; i < 4; i++, pt++) {
21f0f0c0:	e3a03000 	mov	r3, #0	; 0x0
21f0f0c4:	e50b3018 	str	r3, [fp, #-24]
21f0f0c8:	ea000028 	b	21f0f170 <print_partition_extended+0x1a4>
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */

		if ((pt->sys_ind != 0) &&
21f0f0cc:	e51b301c 	ldr	r3, [fp, #-28]
21f0f0d0:	e5d33004 	ldrb	r3, [r3, #4]
21f0f0d4:	e3530000 	cmp	r3, #0	; 0x0
21f0f0d8:	0a00000d 	beq	21f0f114 <print_partition_extended+0x148>
21f0f0dc:	e51b3224 	ldr	r3, [fp, #-548]
21f0f0e0:	e3530000 	cmp	r3, #0	; 0x0
21f0f0e4:	0a000006 	beq	21f0f104 <print_partition_extended+0x138>
21f0f0e8:	e51b301c 	ldr	r3, [fp, #-28]
21f0f0ec:	e5d33004 	ldrb	r3, [r3, #4]
21f0f0f0:	e1a00003 	mov	r0, r3
21f0f0f4:	ebffff3c 	bl	21f0edec <is_extended>
21f0f0f8:	e1a03000 	mov	r3, r0
21f0f0fc:	e3530000 	cmp	r3, #0	; 0x0
21f0f100:	1a000003 	bne	21f0f114 <print_partition_extended+0x148>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
21f0f104:	e51b001c 	ldr	r0, [fp, #-28]
21f0f108:	e51b1224 	ldr	r1, [fp, #-548]
21f0f10c:	e51b222c 	ldr	r2, [fp, #-556]
21f0f110:	ebffff03 	bl	21f0ed24 <print_one_part>
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
21f0f114:	e51b3224 	ldr	r3, [fp, #-548]
21f0f118:	e3530000 	cmp	r3, #0	; 0x0
21f0f11c:	0a00000a 	beq	21f0f14c <print_partition_extended+0x180>
21f0f120:	e51b301c 	ldr	r3, [fp, #-28]
21f0f124:	e5d33004 	ldrb	r3, [r3, #4]
21f0f128:	e3530000 	cmp	r3, #0	; 0x0
21f0f12c:	0a000009 	beq	21f0f158 <print_partition_extended+0x18c>
21f0f130:	e51b301c 	ldr	r3, [fp, #-28]
21f0f134:	e5d33004 	ldrb	r3, [r3, #4]
21f0f138:	e1a00003 	mov	r0, r3
21f0f13c:	ebffff2a 	bl	21f0edec <is_extended>
21f0f140:	e1a03000 	mov	r3, r0
21f0f144:	e3530000 	cmp	r3, #0	; 0x0
21f0f148:	1a000002 	bne	21f0f158 <print_partition_extended+0x18c>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
			part_num++;
21f0f14c:	e51b322c 	ldr	r3, [fp, #-556]
21f0f150:	e2833001 	add	r3, r3, #1	; 0x1
21f0f154:	e50b322c 	str	r3, [fp, #-556]
21f0f158:	e51b3018 	ldr	r3, [fp, #-24]
21f0f15c:	e2833001 	add	r3, r3, #1	; 0x1
21f0f160:	e50b3018 	str	r3, [fp, #-24]
21f0f164:	e51b301c 	ldr	r3, [fp, #-28]
21f0f168:	e2833010 	add	r3, r3, #16	; 0x10
21f0f16c:	e50b301c 	str	r3, [fp, #-28]
21f0f170:	e51b3018 	ldr	r3, [fp, #-24]
21f0f174:	e3530003 	cmp	r3, #3	; 0x3
21f0f178:	daffffd3 	ble	21f0f0cc <print_partition_extended+0x100>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
21f0f17c:	e24b3f87 	sub	r3, fp, #540	; 0x21c
21f0f180:	e2833f6f 	add	r3, r3, #444	; 0x1bc
21f0f184:	e2833002 	add	r3, r3, #2	; 0x2
21f0f188:	e50b301c 	str	r3, [fp, #-28]
	for (i = 0; i < 4; i++, pt++) {
21f0f18c:	e3a03000 	mov	r3, #0	; 0x0
21f0f190:	e50b3018 	str	r3, [fp, #-24]
21f0f194:	ea000021 	b	21f0f220 <print_partition_extended+0x254>
		if (is_extended (pt->sys_ind)) {
21f0f198:	e51b301c 	ldr	r3, [fp, #-28]
21f0f19c:	e5d33004 	ldrb	r3, [r3, #4]
21f0f1a0:	e1a00003 	mov	r0, r3
21f0f1a4:	ebffff10 	bl	21f0edec <is_extended>
21f0f1a8:	e1a03000 	mov	r3, r0
21f0f1ac:	e3530000 	cmp	r3, #0	; 0x0
21f0f1b0:	0a000014 	beq	21f0f208 <print_partition_extended+0x23c>
			int lba_start = le32_to_int (pt->start4) + relative;
21f0f1b4:	e51b301c 	ldr	r3, [fp, #-28]
21f0f1b8:	e2833008 	add	r3, r3, #8	; 0x8
21f0f1bc:	e1a00003 	mov	r0, r3
21f0f1c0:	ebffff20 	bl	21f0ee48 <le32_to_int>
21f0f1c4:	e1a02000 	mov	r2, r0
21f0f1c8:	e51b3228 	ldr	r3, [fp, #-552]
21f0f1cc:	e0823003 	add	r3, r2, r3
21f0f1d0:	e50b3014 	str	r3, [fp, #-20]

			print_partition_extended (dev_desc, lba_start,
21f0f1d4:	e51b3224 	ldr	r3, [fp, #-548]
21f0f1d8:	e3530000 	cmp	r3, #0	; 0x0
21f0f1dc:	1a000002 	bne	21f0f1ec <print_partition_extended+0x220>
21f0f1e0:	e51b3014 	ldr	r3, [fp, #-20]
21f0f1e4:	e50b3230 	str	r3, [fp, #-560]
21f0f1e8:	ea000001 	b	21f0f1f4 <print_partition_extended+0x228>
21f0f1ec:	e51b3228 	ldr	r3, [fp, #-552]
21f0f1f0:	e50b3230 	str	r3, [fp, #-560]
21f0f1f4:	e51b0220 	ldr	r0, [fp, #-544]
21f0f1f8:	e51b1014 	ldr	r1, [fp, #-20]
21f0f1fc:	e51b2230 	ldr	r2, [fp, #-560]
21f0f200:	e51b322c 	ldr	r3, [fp, #-556]
21f0f204:	ebffff70 	bl	21f0efcc <print_partition_extended>
21f0f208:	e51b3018 	ldr	r3, [fp, #-24]
21f0f20c:	e2833001 	add	r3, r3, #1	; 0x1
21f0f210:	e50b3018 	str	r3, [fp, #-24]
21f0f214:	e51b301c 	ldr	r3, [fp, #-28]
21f0f218:	e2833010 	add	r3, r3, #16	; 0x10
21f0f21c:	e50b301c 	str	r3, [fp, #-28]
21f0f220:	e51b3018 	ldr	r3, [fp, #-24]
21f0f224:	e3530003 	cmp	r3, #3	; 0x3
21f0f228:	daffffda 	ble	21f0f198 <print_partition_extended+0x1cc>
						  ext_part_sector == 0  ? lba_start
									: relative,
						  part_num);
		}
	}

	return;
}
21f0f22c:	e24bd010 	sub	sp, fp, #16	; 0x10
21f0f230:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f0f234:	21f2fd28 	mvncss	pc, r8, lsr #26
21f0f238:	21f2fd54 	mvncss	pc, r4, asr sp
21f0f23c:	21f2fd7c 	mvncss	pc, ip, ror sp

21f0f240 <get_partition_info_extended>:


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
				 int relative, int part_num,
				 int which_part, disk_partition_t *info)
{
21f0f240:	e1a0c00d 	mov	ip, sp
21f0f244:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f0f248:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0f24c:	e24ddf8b 	sub	sp, sp, #556	; 0x22c
21f0f250:	e50b0220 	str	r0, [fp, #-544]
21f0f254:	e50b1224 	str	r1, [fp, #-548]
21f0f258:	e50b2228 	str	r2, [fp, #-552]
21f0f25c:	e50b322c 	str	r3, [fp, #-556]
	unsigned char buffer[DEFAULT_SECTOR_SIZE];
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
21f0f260:	e51b3220 	ldr	r3, [fp, #-544]
21f0f264:	e5934060 	ldr	r4, [r3, #96]
21f0f268:	e51b3220 	ldr	r3, [fp, #-544]
21f0f26c:	e5933004 	ldr	r3, [r3, #4]
21f0f270:	e51b2224 	ldr	r2, [fp, #-548]
21f0f274:	e24bcf87 	sub	ip, fp, #540	; 0x21c
21f0f278:	e1a00003 	mov	r0, r3
21f0f27c:	e1a01002 	mov	r1, r2
21f0f280:	e3a02001 	mov	r2, #1	; 0x1
21f0f284:	e1a0300c 	mov	r3, ip
21f0f288:	e1a0e00f 	mov	lr, pc
21f0f28c:	e1a0f004 	mov	pc, r4
21f0f290:	e1a03000 	mov	r3, r0
21f0f294:	e3530001 	cmp	r3, #1	; 0x1
21f0f298:	0a000008 	beq	21f0f2c0 <get_partition_info_extended+0x80>
		printf ("** Can't read partition table on %d:%d **\n",
21f0f29c:	e51b3220 	ldr	r3, [fp, #-544]
21f0f2a0:	e5933004 	ldr	r3, [r3, #4]
21f0f2a4:	e59f0384 	ldr	r0, [pc, #900]	; 21f0f630 <.text+0xf630>
21f0f2a8:	e1a01003 	mov	r1, r3
21f0f2ac:	e51b2224 	ldr	r2, [fp, #-548]
21f0f2b0:	eb0031f5 	bl	21f1ba8c <printf>
			dev_desc->dev, ext_part_sector);
		return -1;
21f0f2b4:	e3e03000 	mvn	r3, #0	; 0x0
21f0f2b8:	e50b3234 	str	r3, [fp, #-564]
21f0f2bc:	ea0000d7 	b	21f0f620 <.text+0xf620>
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
21f0f2c0:	e55b301e 	ldrb	r3, [fp, #-30]
21f0f2c4:	e3530055 	cmp	r3, #85	; 0x55
21f0f2c8:	1a000002 	bne	21f0f2d8 <get_partition_info_extended+0x98>
21f0f2cc:	e55b301d 	ldrb	r3, [fp, #-29]
21f0f2d0:	e35300aa 	cmp	r3, #170	; 0xaa
21f0f2d4:	0a000009 	beq	21f0f300 <get_partition_info_extended+0xc0>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		printf ("bad MBR sector signature 0x%02x%02x\n",
21f0f2d8:	e55b301e 	ldrb	r3, [fp, #-30]
21f0f2dc:	e1a02003 	mov	r2, r3
21f0f2e0:	e55b301d 	ldrb	r3, [fp, #-29]
21f0f2e4:	e59f0348 	ldr	r0, [pc, #840]	; 21f0f634 <.text+0xf634>
21f0f2e8:	e1a01002 	mov	r1, r2
21f0f2ec:	e1a02003 	mov	r2, r3
21f0f2f0:	eb0031e5 	bl	21f1ba8c <printf>
			buffer[DOS_PART_MAGIC_OFFSET],
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return -1;
21f0f2f4:	e3e03000 	mvn	r3, #0	; 0x0
21f0f2f8:	e50b3234 	str	r3, [fp, #-564]
21f0f2fc:	ea0000c7 	b	21f0f620 <.text+0xf620>
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
21f0f300:	e24b3f87 	sub	r3, fp, #540	; 0x21c
21f0f304:	e2833f6f 	add	r3, r3, #444	; 0x1bc
21f0f308:	e2833002 	add	r3, r3, #2	; 0x2
21f0f30c:	e50b301c 	str	r3, [fp, #-28]
	for (i = 0; i < 4; i++, pt++) {
21f0f310:	e3a03000 	mov	r3, #0	; 0x0
21f0f314:	e50b3018 	str	r3, [fp, #-24]
21f0f318:	ea000088 	b	21f0f540 <.text+0xf540>
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if ((pt->sys_ind != 0) &&
21f0f31c:	e51b301c 	ldr	r3, [fp, #-28]
21f0f320:	e5d33004 	ldrb	r3, [r3, #4]
21f0f324:	e3530000 	cmp	r3, #0	; 0x0
21f0f328:	0a00006d 	beq	21f0f4e4 <.text+0xf4e4>
21f0f32c:	e51b222c 	ldr	r2, [fp, #-556]
21f0f330:	e59b3004 	ldr	r3, [fp, #4]
21f0f334:	e1520003 	cmp	r2, r3
21f0f338:	1a000069 	bne	21f0f4e4 <.text+0xf4e4>
21f0f33c:	e51b301c 	ldr	r3, [fp, #-28]
21f0f340:	e5d33004 	ldrb	r3, [r3, #4]
21f0f344:	e1a00003 	mov	r0, r3
21f0f348:	ebfffea7 	bl	21f0edec <is_extended>
21f0f34c:	e1a03000 	mov	r3, r0
21f0f350:	e3530000 	cmp	r3, #0	; 0x0
21f0f354:	1a000062 	bne	21f0f4e4 <.text+0xf4e4>
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
21f0f358:	e59b2008 	ldr	r2, [fp, #8]
21f0f35c:	e3a03c02 	mov	r3, #512	; 0x200
21f0f360:	e5823008 	str	r3, [r2, #8]
			info->start = ext_part_sector + le32_to_int (pt->start4);
21f0f364:	e51b301c 	ldr	r3, [fp, #-28]
21f0f368:	e2833008 	add	r3, r3, #8	; 0x8
21f0f36c:	e1a00003 	mov	r0, r3
21f0f370:	ebfffeb4 	bl	21f0ee48 <le32_to_int>
21f0f374:	e1a02000 	mov	r2, r0
21f0f378:	e51b3224 	ldr	r3, [fp, #-548]
21f0f37c:	e0823003 	add	r3, r2, r3
21f0f380:	e1a02003 	mov	r2, r3
21f0f384:	e59b3008 	ldr	r3, [fp, #8]
21f0f388:	e5832000 	str	r2, [r3]
			info->size  = le32_to_int (pt->size4);
21f0f38c:	e51b301c 	ldr	r3, [fp, #-28]
21f0f390:	e283300c 	add	r3, r3, #12	; 0xc
21f0f394:	e1a00003 	mov	r0, r3
21f0f398:	ebfffeaa 	bl	21f0ee48 <le32_to_int>
21f0f39c:	e1a03000 	mov	r3, r0
21f0f3a0:	e1a02003 	mov	r2, r3
21f0f3a4:	e59b3008 	ldr	r3, [fp, #8]
21f0f3a8:	e5832004 	str	r2, [r3, #4]
			switch(dev_desc->if_type) {
21f0f3ac:	e51b3220 	ldr	r3, [fp, #-544]
21f0f3b0:	e5933000 	ldr	r3, [r3]
21f0f3b4:	e2433001 	sub	r3, r3, #1	; 0x1
21f0f3b8:	e3530004 	cmp	r3, #4	; 0x4
21f0f3bc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f0f3c0:	ea000034 	b	21f0f498 <.text+0xf498>
21f0f3c4:	21f0f3d8 	ldrcssb	pc, [r0, #56]!
21f0f3c8:	21f0f408 	mvncss	pc, r8, lsl #8
21f0f3cc:	21f0f3d8 	ldrcssb	pc, [r0, #56]!
21f0f3d0:	21f0f438 	mvncss	pc, r8, lsr r4
21f0f3d4:	21f0f468 	mvncss	pc, r8, ror #8
				case IF_TYPE_IDE:
				case IF_TYPE_ATAPI:
					sprintf ((char *)info->name, "hd%c%d\n", 'a' + dev_desc->dev, part_num);
21f0f3d8:	e59b3008 	ldr	r3, [fp, #8]
21f0f3dc:	e283300c 	add	r3, r3, #12	; 0xc
21f0f3e0:	e1a02003 	mov	r2, r3
21f0f3e4:	e51b3220 	ldr	r3, [fp, #-544]
21f0f3e8:	e5933004 	ldr	r3, [r3, #4]
21f0f3ec:	e2833061 	add	r3, r3, #97	; 0x61
21f0f3f0:	e1a00002 	mov	r0, r2
21f0f3f4:	e59f123c 	ldr	r1, [pc, #572]	; 21f0f638 <.text+0xf638>
21f0f3f8:	e1a02003 	mov	r2, r3
21f0f3fc:	e51b322c 	ldr	r3, [fp, #-556]
21f0f400:	eb0054b0 	bl	21f246c8 <sprintf>
					break;
21f0f404:	ea00002e 	b	21f0f4c4 <.text+0xf4c4>
				case IF_TYPE_SCSI:
					sprintf ((char *)info->name, "sd%c%d\n", 'a' + dev_desc->dev, part_num);
21f0f408:	e59b3008 	ldr	r3, [fp, #8]
21f0f40c:	e283300c 	add	r3, r3, #12	; 0xc
21f0f410:	e1a02003 	mov	r2, r3
21f0f414:	e51b3220 	ldr	r3, [fp, #-544]
21f0f418:	e5933004 	ldr	r3, [r3, #4]
21f0f41c:	e2833061 	add	r3, r3, #97	; 0x61
21f0f420:	e1a00002 	mov	r0, r2
21f0f424:	e59f1210 	ldr	r1, [pc, #528]	; 21f0f63c <.text+0xf63c>
21f0f428:	e1a02003 	mov	r2, r3
21f0f42c:	e51b322c 	ldr	r3, [fp, #-556]
21f0f430:	eb0054a4 	bl	21f246c8 <sprintf>
					break;
21f0f434:	ea000022 	b	21f0f4c4 <.text+0xf4c4>
				case IF_TYPE_USB:
					sprintf ((char *)info->name, "usbd%c%d\n", 'a' + dev_desc->dev, part_num);
21f0f438:	e59b3008 	ldr	r3, [fp, #8]
21f0f43c:	e283300c 	add	r3, r3, #12	; 0xc
21f0f440:	e1a02003 	mov	r2, r3
21f0f444:	e51b3220 	ldr	r3, [fp, #-544]
21f0f448:	e5933004 	ldr	r3, [r3, #4]
21f0f44c:	e2833061 	add	r3, r3, #97	; 0x61
21f0f450:	e1a00002 	mov	r0, r2
21f0f454:	e59f11e4 	ldr	r1, [pc, #484]	; 21f0f640 <.text+0xf640>
21f0f458:	e1a02003 	mov	r2, r3
21f0f45c:	e51b322c 	ldr	r3, [fp, #-556]
21f0f460:	eb005498 	bl	21f246c8 <sprintf>
					break;
21f0f464:	ea000016 	b	21f0f4c4 <.text+0xf4c4>
				case IF_TYPE_DOC:
					sprintf ((char *)info->name, "docd%c%d\n", 'a' + dev_desc->dev, part_num);
21f0f468:	e59b3008 	ldr	r3, [fp, #8]
21f0f46c:	e283300c 	add	r3, r3, #12	; 0xc
21f0f470:	e1a02003 	mov	r2, r3
21f0f474:	e51b3220 	ldr	r3, [fp, #-544]
21f0f478:	e5933004 	ldr	r3, [r3, #4]
21f0f47c:	e2833061 	add	r3, r3, #97	; 0x61
21f0f480:	e1a00002 	mov	r0, r2
21f0f484:	e59f11b8 	ldr	r1, [pc, #440]	; 21f0f644 <.text+0xf644>
21f0f488:	e1a02003 	mov	r2, r3
21f0f48c:	e51b322c 	ldr	r3, [fp, #-556]
21f0f490:	eb00548c 	bl	21f246c8 <sprintf>
					break;
21f0f494:	ea00000a 	b	21f0f4c4 <.text+0xf4c4>
				default:
					sprintf ((char *)info->name, "xx%c%d\n", 'a' + dev_desc->dev, part_num);
21f0f498:	e59b3008 	ldr	r3, [fp, #8]
21f0f49c:	e283300c 	add	r3, r3, #12	; 0xc
21f0f4a0:	e1a02003 	mov	r2, r3
21f0f4a4:	e51b3220 	ldr	r3, [fp, #-544]
21f0f4a8:	e5933004 	ldr	r3, [r3, #4]
21f0f4ac:	e2833061 	add	r3, r3, #97	; 0x61
21f0f4b0:	e1a00002 	mov	r0, r2
21f0f4b4:	e59f118c 	ldr	r1, [pc, #396]	; 21f0f648 <.text+0xf648>
21f0f4b8:	e1a02003 	mov	r2, r3
21f0f4bc:	e51b322c 	ldr	r3, [fp, #-556]
21f0f4c0:	eb005480 	bl	21f246c8 <sprintf>
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
21f0f4c4:	e59b3008 	ldr	r3, [fp, #8]
21f0f4c8:	e283302c 	add	r3, r3, #44	; 0x2c
21f0f4cc:	e1a00003 	mov	r0, r3
21f0f4d0:	e59f1174 	ldr	r1, [pc, #372]	; 21f0f64c <.text+0xf64c>
21f0f4d4:	eb00547b 	bl	21f246c8 <sprintf>
			return 0;
21f0f4d8:	e3a03000 	mov	r3, #0	; 0x0
21f0f4dc:	e50b3234 	str	r3, [fp, #-564]
21f0f4e0:	ea00004e 	b	21f0f620 <.text+0xf620>
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
21f0f4e4:	e51b3224 	ldr	r3, [fp, #-548]
21f0f4e8:	e3530000 	cmp	r3, #0	; 0x0
21f0f4ec:	0a00000a 	beq	21f0f51c <.text+0xf51c>
21f0f4f0:	e51b301c 	ldr	r3, [fp, #-28]
21f0f4f4:	e5d33004 	ldrb	r3, [r3, #4]
21f0f4f8:	e3530000 	cmp	r3, #0	; 0x0
21f0f4fc:	0a000009 	beq	21f0f528 <.text+0xf528>
21f0f500:	e51b301c 	ldr	r3, [fp, #-28]
21f0f504:	e5d33004 	ldrb	r3, [r3, #4]
21f0f508:	e1a00003 	mov	r0, r3
21f0f50c:	ebfffe36 	bl	21f0edec <is_extended>
21f0f510:	e1a03000 	mov	r3, r0
21f0f514:	e3530000 	cmp	r3, #0	; 0x0
21f0f518:	1a000002 	bne	21f0f528 <.text+0xf528>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
			part_num++;
21f0f51c:	e51b322c 	ldr	r3, [fp, #-556]
21f0f520:	e2833001 	add	r3, r3, #1	; 0x1
21f0f524:	e50b322c 	str	r3, [fp, #-556]
21f0f528:	e51b3018 	ldr	r3, [fp, #-24]
21f0f52c:	e2833001 	add	r3, r3, #1	; 0x1
21f0f530:	e50b3018 	str	r3, [fp, #-24]
21f0f534:	e51b301c 	ldr	r3, [fp, #-28]
21f0f538:	e2833010 	add	r3, r3, #16	; 0x10
21f0f53c:	e50b301c 	str	r3, [fp, #-28]
21f0f540:	e51b3018 	ldr	r3, [fp, #-24]
21f0f544:	e3530003 	cmp	r3, #3	; 0x3
21f0f548:	daffff73 	ble	21f0f31c <get_partition_info_extended+0xdc>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
21f0f54c:	e24b3f87 	sub	r3, fp, #540	; 0x21c
21f0f550:	e2833f6f 	add	r3, r3, #444	; 0x1bc
21f0f554:	e2833002 	add	r3, r3, #2	; 0x2
21f0f558:	e50b301c 	str	r3, [fp, #-28]
	for (i = 0; i < 4; i++, pt++) {
21f0f55c:	e3a03000 	mov	r3, #0	; 0x0
21f0f560:	e50b3018 	str	r3, [fp, #-24]
21f0f564:	ea000028 	b	21f0f60c <.text+0xf60c>
		if (is_extended (pt->sys_ind)) {
21f0f568:	e51b301c 	ldr	r3, [fp, #-28]
21f0f56c:	e5d33004 	ldrb	r3, [r3, #4]
21f0f570:	e1a00003 	mov	r0, r3
21f0f574:	ebfffe1c 	bl	21f0edec <is_extended>
21f0f578:	e1a03000 	mov	r3, r0
21f0f57c:	e3530000 	cmp	r3, #0	; 0x0
21f0f580:	0a00001b 	beq	21f0f5f4 <.text+0xf5f4>
			int lba_start = le32_to_int (pt->start4) + relative;
21f0f584:	e51b301c 	ldr	r3, [fp, #-28]
21f0f588:	e2833008 	add	r3, r3, #8	; 0x8
21f0f58c:	e1a00003 	mov	r0, r3
21f0f590:	ebfffe2c 	bl	21f0ee48 <le32_to_int>
21f0f594:	e1a02000 	mov	r2, r0
21f0f598:	e51b3228 	ldr	r3, [fp, #-552]
21f0f59c:	e0823003 	add	r3, r2, r3
21f0f5a0:	e50b3014 	str	r3, [fp, #-20]

			return get_partition_info_extended (dev_desc, lba_start,
21f0f5a4:	e51b3224 	ldr	r3, [fp, #-548]
21f0f5a8:	e3530000 	cmp	r3, #0	; 0x0
21f0f5ac:	1a000002 	bne	21f0f5bc <.text+0xf5bc>
21f0f5b0:	e51b3014 	ldr	r3, [fp, #-20]
21f0f5b4:	e50b3230 	str	r3, [fp, #-560]
21f0f5b8:	ea000001 	b	21f0f5c4 <.text+0xf5c4>
21f0f5bc:	e51b3228 	ldr	r3, [fp, #-552]
21f0f5c0:	e50b3230 	str	r3, [fp, #-560]
21f0f5c4:	e59b3004 	ldr	r3, [fp, #4]
21f0f5c8:	e58d3000 	str	r3, [sp]
21f0f5cc:	e59b3008 	ldr	r3, [fp, #8]
21f0f5d0:	e58d3004 	str	r3, [sp, #4]
21f0f5d4:	e51b0220 	ldr	r0, [fp, #-544]
21f0f5d8:	e51b1014 	ldr	r1, [fp, #-20]
21f0f5dc:	e51b2230 	ldr	r2, [fp, #-560]
21f0f5e0:	e51b322c 	ldr	r3, [fp, #-556]
21f0f5e4:	ebffff15 	bl	21f0f240 <get_partition_info_extended>
21f0f5e8:	e1a03000 	mov	r3, r0
21f0f5ec:	e50b3234 	str	r3, [fp, #-564]
21f0f5f0:	ea00000a 	b	21f0f620 <.text+0xf620>
21f0f5f4:	e51b3018 	ldr	r3, [fp, #-24]
21f0f5f8:	e2833001 	add	r3, r3, #1	; 0x1
21f0f5fc:	e50b3018 	str	r3, [fp, #-24]
21f0f600:	e51b301c 	ldr	r3, [fp, #-28]
21f0f604:	e2833010 	add	r3, r3, #16	; 0x10
21f0f608:	e50b301c 	str	r3, [fp, #-28]
21f0f60c:	e51b3018 	ldr	r3, [fp, #-24]
21f0f610:	e3530003 	cmp	r3, #3	; 0x3
21f0f614:	daffffd3 	ble	21f0f568 <.text+0xf568>
				 ext_part_sector == 0 ? lba_start : relative,
				 part_num, which_part, info);
		}
	}
	return -1;
21f0f618:	e3e03000 	mvn	r3, #0	; 0x0
21f0f61c:	e50b3234 	str	r3, [fp, #-564]
21f0f620:	e51b3234 	ldr	r3, [fp, #-564]
}
21f0f624:	e1a00003 	mov	r0, r3
21f0f628:	e24bd010 	sub	sp, fp, #16	; 0x10
21f0f62c:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f0f630:	21f2fd28 	mvncss	pc, r8, lsr #26
21f0f634:	21f2fd54 	mvncss	pc, r4, asr sp
21f0f638:	21f2fd9c 	ldrcsb	pc, [r2, #220]!
21f0f63c:	21f2fda4 	mvncss	pc, r4, lsr #27
21f0f640:	21f2fdac 	mvncss	pc, ip, lsr #27
21f0f644:	21f2fdb8 	ldrcsh	pc, [r2, #216]!
21f0f648:	21f2fdc4 	mvncss	pc, r4, asr #27
21f0f64c:	21f2fdcc 	mvncss	pc, ip, asr #27

21f0f650 <print_part_dos>:

void print_part_dos (block_dev_desc_t *dev_desc)
{
21f0f650:	e1a0c00d 	mov	ip, sp
21f0f654:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0f658:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0f65c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f0f660:	e50b0010 	str	r0, [fp, #-16]
	printf ("Partition     Start Sector     Num Sectors     Type\n");
21f0f664:	e59f0018 	ldr	r0, [pc, #24]	; 21f0f684 <.text+0xf684>
21f0f668:	eb003107 	bl	21f1ba8c <printf>
	print_partition_extended (dev_desc, 0, 0, 1);
21f0f66c:	e51b0010 	ldr	r0, [fp, #-16]
21f0f670:	e3a01000 	mov	r1, #0	; 0x0
21f0f674:	e3a02000 	mov	r2, #0	; 0x0
21f0f678:	e3a03001 	mov	r3, #1	; 0x1
21f0f67c:	ebfffe52 	bl	21f0efcc <print_partition_extended>
}
21f0f680:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f0f684:	21f2fdd4 	ldrcssb	pc, [r2, #212]!

21f0f688 <get_partition_info_dos>:

int get_partition_info_dos (block_dev_desc_t *dev_desc, int part, disk_partition_t * info)
{
21f0f688:	e1a0c00d 	mov	ip, sp
21f0f68c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f0f690:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0f694:	e24dd014 	sub	sp, sp, #20	; 0x14
21f0f698:	e50b0010 	str	r0, [fp, #-16]
21f0f69c:	e50b1014 	str	r1, [fp, #-20]
21f0f6a0:	e50b2018 	str	r2, [fp, #-24]
	return get_partition_info_extended (dev_desc, 0, 0, 1, part, info);
21f0f6a4:	e51b3014 	ldr	r3, [fp, #-20]
21f0f6a8:	e58d3000 	str	r3, [sp]
21f0f6ac:	e51b3018 	ldr	r3, [fp, #-24]
21f0f6b0:	e58d3004 	str	r3, [sp, #4]
21f0f6b4:	e51b0010 	ldr	r0, [fp, #-16]
21f0f6b8:	e3a01000 	mov	r1, #0	; 0x0
21f0f6bc:	e3a02000 	mov	r2, #0	; 0x0
21f0f6c0:	e3a03001 	mov	r3, #1	; 0x1
21f0f6c4:	ebfffedd 	bl	21f0f240 <get_partition_info_extended>
21f0f6c8:	e1a03000 	mov	r3, r0
}
21f0f6cc:	e1a00003 	mov	r0, r3
21f0f6d0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f0f6d4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f0f6d8 <AT91F_DataflashInit>:
			            int dest,
				    int size );

int AT91F_DataflashInit (void)
{
21f0f6d8:	e1a0c00d 	mov	ip, sp
21f0f6dc:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f0f6e0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f0f6e4:	e24dd010 	sub	sp, sp, #16	; 0x10
	int i, j;
	int dfcode;

	AT91F_SpiInit ();
21f0f6e8:	eb006e1f 	bl	21f2af6c <AT91F_SpiInit>

	for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++) {
21f0f6ec:	e3a03000 	mov	r3, #0	; 0x0
21f0f6f0:	e50b301c 	str	r3, [fp, #-28]
21f0f6f4:	ea000255 	b	21f10050 <AT91F_DataflashInit+0x978>
		dataflash_info[i].Desc.state = IDLE;
21f0f6f8:	e51b201c 	ldr	r2, [fp, #-28]
21f0f6fc:	e59f1968 	ldr	r1, [pc, #2408]	; 21f1006c <.text+0x1006c>
21f0f700:	e3a00020 	mov	r0, #32	; 0x20
21f0f704:	e1a03002 	mov	r3, r2
21f0f708:	e1a03203 	mov	r3, r3, lsl #4
21f0f70c:	e0623003 	rsb	r3, r2, r3
21f0f710:	e1a03183 	mov	r3, r3, lsl #3
21f0f714:	e0833001 	add	r3, r3, r1
21f0f718:	e0832000 	add	r2, r3, r0
21f0f71c:	e3a03000 	mov	r3, #0	; 0x0
21f0f720:	e5c23000 	strb	r3, [r2]
		dataflash_info[i].id = 0;
21f0f724:	e51b201c 	ldr	r2, [fp, #-28]
21f0f728:	e59f193c 	ldr	r1, [pc, #2364]	; 21f1006c <.text+0x1006c>
21f0f72c:	e3a00074 	mov	r0, #116	; 0x74
21f0f730:	e1a03002 	mov	r3, r2
21f0f734:	e1a03203 	mov	r3, r3, lsl #4
21f0f738:	e0623003 	rsb	r3, r2, r3
21f0f73c:	e1a03183 	mov	r3, r3, lsl #3
21f0f740:	e0833001 	add	r3, r3, r1
21f0f744:	e0832000 	add	r2, r3, r0
21f0f748:	e3a03000 	mov	r3, #0	; 0x0
21f0f74c:	e5823000 	str	r3, [r2]
		dataflash_info[i].Device.pages_number = 0;
21f0f750:	e51b201c 	ldr	r2, [fp, #-28]
21f0f754:	e59f1910 	ldr	r1, [pc, #2320]	; 21f1006c <.text+0x1006c>
21f0f758:	e3a0002c 	mov	r0, #44	; 0x2c
21f0f75c:	e1a03002 	mov	r3, r2
21f0f760:	e1a03203 	mov	r3, r3, lsl #4
21f0f764:	e0623003 	rsb	r3, r2, r3
21f0f768:	e1a03183 	mov	r3, r3, lsl #3
21f0f76c:	e0833001 	add	r3, r3, r1
21f0f770:	e0832000 	add	r2, r3, r0
21f0f774:	e3a03000 	mov	r3, #0	; 0x0
21f0f778:	e5823000 	str	r3, [r2]
		dfcode = AT91F_DataflashProbe (cs[i][1], &dataflash_info[i].Desc);
21f0f77c:	e51b301c 	ldr	r3, [fp, #-28]
21f0f780:	e59f28e8 	ldr	r2, [pc, #2280]	; 21f10070 <.text+0x10070>
21f0f784:	e3a01004 	mov	r1, #4	; 0x4
21f0f788:	e1a03183 	mov	r3, r3, lsl #3
21f0f78c:	e0833002 	add	r3, r3, r2
21f0f790:	e0833001 	add	r3, r3, r1
21f0f794:	e5931000 	ldr	r1, [r3]
21f0f798:	e51b201c 	ldr	r2, [fp, #-28]
21f0f79c:	e1a03002 	mov	r3, r2
21f0f7a0:	e1a03203 	mov	r3, r3, lsl #4
21f0f7a4:	e0623003 	rsb	r3, r2, r3
21f0f7a8:	e1a02183 	mov	r2, r3, lsl #3
21f0f7ac:	e59f38b8 	ldr	r3, [pc, #2232]	; 21f1006c <.text+0x1006c>
21f0f7b0:	e0823003 	add	r3, r2, r3
21f0f7b4:	e1a00001 	mov	r0, r1
21f0f7b8:	e1a01003 	mov	r1, r3
21f0f7bc:	eb0072a9 	bl	21f2c268 <AT91F_DataflashProbe>
21f0f7c0:	e1a03000 	mov	r3, r0
21f0f7c4:	e50b3014 	str	r3, [fp, #-20]

		switch (dfcode) {
21f0f7c8:	e51b3014 	ldr	r3, [fp, #-20]
21f0f7cc:	e50b3020 	str	r3, [fp, #-32]
21f0f7d0:	e51b3020 	ldr	r3, [fp, #-32]
21f0f7d4:	e353002c 	cmp	r3, #44	; 0x2c
21f0f7d8:	0a00000d 	beq	21f0f814 <AT91F_DataflashInit+0x13c>
21f0f7dc:	e51b3020 	ldr	r3, [fp, #-32]
21f0f7e0:	e353002c 	cmp	r3, #44	; 0x2c
21f0f7e4:	ca000003 	bgt	21f0f7f8 <AT91F_DataflashInit+0x120>
21f0f7e8:	e51b3020 	ldr	r3, [fp, #-32]
21f0f7ec:	e3530010 	cmp	r3, #16	; 0x10
21f0f7f0:	0a00012d 	beq	21f0fcac <AT91F_DataflashInit+0x5d4>
21f0f7f4:	ea00018d 	b	21f0fe30 <AT91F_DataflashInit+0x758>
21f0f7f8:	e51b3020 	ldr	r3, [fp, #-32]
21f0f7fc:	e3530034 	cmp	r3, #52	; 0x34
21f0f800:	0a000065 	beq	21f0f99c <AT91F_DataflashInit+0x2c4>
21f0f804:	e51b3020 	ldr	r3, [fp, #-32]
21f0f808:	e353003c 	cmp	r3, #60	; 0x3c
21f0f80c:	0a0000c4 	beq	21f0fb24 <AT91F_DataflashInit+0x44c>
21f0f810:	ea000186 	b	21f0fe30 <AT91F_DataflashInit+0x758>
		case AT45DB161:
			dataflash_info[i].Device.pages_number = 4096;
21f0f814:	e51b201c 	ldr	r2, [fp, #-28]
21f0f818:	e59f184c 	ldr	r1, [pc, #2124]	; 21f1006c <.text+0x1006c>
21f0f81c:	e3a0002c 	mov	r0, #44	; 0x2c
21f0f820:	e1a03002 	mov	r3, r2
21f0f824:	e1a03203 	mov	r3, r3, lsl #4
21f0f828:	e0623003 	rsb	r3, r2, r3
21f0f82c:	e1a03183 	mov	r3, r3, lsl #3
21f0f830:	e0833001 	add	r3, r3, r1
21f0f834:	e0832000 	add	r2, r3, r0
21f0f838:	e3a03a01 	mov	r3, #4096	; 0x1000
21f0f83c:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.pages_size = 528;
21f0f840:	e51b201c 	ldr	r2, [fp, #-28]
21f0f844:	e59f1820 	ldr	r1, [pc, #2080]	; 21f1006c <.text+0x1006c>
21f0f848:	e3a00030 	mov	r0, #48	; 0x30
21f0f84c:	e1a03002 	mov	r3, r2
21f0f850:	e1a03203 	mov	r3, r3, lsl #4
21f0f854:	e0623003 	rsb	r3, r2, r3
21f0f858:	e1a03183 	mov	r3, r3, lsl #3
21f0f85c:	e0833001 	add	r3, r3, r1
21f0f860:	e0832000 	add	r2, r3, r0
21f0f864:	e3a03e21 	mov	r3, #528	; 0x210
21f0f868:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.page_offset = 10;
21f0f86c:	e51b201c 	ldr	r2, [fp, #-28]
21f0f870:	e59f17f4 	ldr	r1, [pc, #2036]	; 21f1006c <.text+0x1006c>
21f0f874:	e3a00034 	mov	r0, #52	; 0x34
21f0f878:	e1a03002 	mov	r3, r2
21f0f87c:	e1a03203 	mov	r3, r3, lsl #4
21f0f880:	e0623003 	rsb	r3, r2, r3
21f0f884:	e1a03183 	mov	r3, r3, lsl #3
21f0f888:	e0833001 	add	r3, r3, r1
21f0f88c:	e0832000 	add	r2, r3, r0
21f0f890:	e3a0300a 	mov	r3, #10	; 0xa
21f0f894:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.byte_mask = 0x300;
21f0f898:	e51b201c 	ldr	r2, [fp, #-28]
21f0f89c:	e59f17c8 	ldr	r1, [pc, #1992]	; 21f1006c <.text+0x1006c>
21f0f8a0:	e3a00038 	mov	r0, #56	; 0x38
21f0f8a4:	e1a03002 	mov	r3, r2
21f0f8a8:	e1a03203 	mov	r3, r3, lsl #4
21f0f8ac:	e0623003 	rsb	r3, r2, r3
21f0f8b0:	e1a03183 	mov	r3, r3, lsl #3
21f0f8b4:	e0833001 	add	r3, r3, r1
21f0f8b8:	e0832000 	add	r2, r3, r0
21f0f8bc:	e3a03c03 	mov	r3, #768	; 0x300
21f0f8c0:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.cs = cs[i][1];
21f0f8c4:	e51b001c 	ldr	r0, [fp, #-28]
21f0f8c8:	e51b301c 	ldr	r3, [fp, #-28]
21f0f8cc:	e59f279c 	ldr	r2, [pc, #1948]	; 21f10070 <.text+0x10070>
21f0f8d0:	e3a01004 	mov	r1, #4	; 0x4
21f0f8d4:	e1a03183 	mov	r3, r3, lsl #3
21f0f8d8:	e0833002 	add	r3, r3, r2
21f0f8dc:	e0833001 	add	r3, r3, r1
21f0f8e0:	e5932000 	ldr	r2, [r3]
21f0f8e4:	e59f1780 	ldr	r1, [pc, #1920]	; 21f1006c <.text+0x1006c>
21f0f8e8:	e3a0c03c 	mov	ip, #60	; 0x3c
21f0f8ec:	e1a03000 	mov	r3, r0
21f0f8f0:	e1a03203 	mov	r3, r3, lsl #4
21f0f8f4:	e0603003 	rsb	r3, r0, r3
21f0f8f8:	e1a03183 	mov	r3, r3, lsl #3
21f0f8fc:	e0833001 	add	r3, r3, r1
21f0f900:	e083300c 	add	r3, r3, ip
21f0f904:	e5832000 	str	r2, [r3]
			dataflash_info[i].Desc.DataFlash_state = IDLE;
21f0f908:	e51b201c 	ldr	r2, [fp, #-28]
21f0f90c:	e59f1758 	ldr	r1, [pc, #1880]	; 21f1006c <.text+0x1006c>
21f0f910:	e3a00020 	mov	r0, #32	; 0x20
21f0f914:	e1a03002 	mov	r3, r2
21f0f918:	e1a03203 	mov	r3, r3, lsl #4
21f0f91c:	e0623003 	rsb	r3, r2, r3
21f0f920:	e1a03183 	mov	r3, r3, lsl #3
21f0f924:	e0833001 	add	r3, r3, r1
21f0f928:	e0832000 	add	r2, r3, r0
21f0f92c:	e3a03000 	mov	r3, #0	; 0x0
21f0f930:	e5c23001 	strb	r3, [r2, #1]
			dataflash_info[i].logical_address = cs[i][0];
21f0f934:	e51b101c 	ldr	r1, [fp, #-28]
21f0f938:	e51b201c 	ldr	r2, [fp, #-28]
21f0f93c:	e59f372c 	ldr	r3, [pc, #1836]	; 21f10070 <.text+0x10070>
21f0f940:	e7933182 	ldr	r3, [r3, r2, lsl #3]
21f0f944:	e1a02003 	mov	r2, r3
21f0f948:	e59f071c 	ldr	r0, [pc, #1820]	; 21f1006c <.text+0x1006c>
21f0f94c:	e3a0c070 	mov	ip, #112	; 0x70
21f0f950:	e1a03001 	mov	r3, r1
21f0f954:	e1a03203 	mov	r3, r3, lsl #4
21f0f958:	e0613003 	rsb	r3, r1, r3
21f0f95c:	e1a03183 	mov	r3, r3, lsl #3
21f0f960:	e0833000 	add	r3, r3, r0
21f0f964:	e083300c 	add	r3, r3, ip
21f0f968:	e5832000 	str	r2, [r3]
			dataflash_info[i].id = dfcode;
21f0f96c:	e51b201c 	ldr	r2, [fp, #-28]
21f0f970:	e51b1014 	ldr	r1, [fp, #-20]
21f0f974:	e59f06f0 	ldr	r0, [pc, #1776]	; 21f1006c <.text+0x1006c>
21f0f978:	e3a0c074 	mov	ip, #116	; 0x74
21f0f97c:	e1a03002 	mov	r3, r2
21f0f980:	e1a03203 	mov	r3, r3, lsl #4
21f0f984:	e0623003 	rsb	r3, r2, r3
21f0f988:	e1a03183 	mov	r3, r3, lsl #3
21f0f98c:	e0833000 	add	r3, r3, r0
21f0f990:	e083300c 	add	r3, r3, ip
21f0f994:	e5831000 	str	r1, [r3]
			break;
21f0f998:	ea000124 	b	21f0fe30 <AT91F_DataflashInit+0x758>

		case AT45DB321:
			dataflash_info[i].Device.pages_number = 8192;
21f0f99c:	e51b201c 	ldr	r2, [fp, #-28]
21f0f9a0:	e59f16c4 	ldr	r1, [pc, #1732]	; 21f1006c <.text+0x1006c>
21f0f9a4:	e3a0002c 	mov	r0, #44	; 0x2c
21f0f9a8:	e1a03002 	mov	r3, r2
21f0f9ac:	e1a03203 	mov	r3, r3, lsl #4
21f0f9b0:	e0623003 	rsb	r3, r2, r3
21f0f9b4:	e1a03183 	mov	r3, r3, lsl #3
21f0f9b8:	e0833001 	add	r3, r3, r1
21f0f9bc:	e0832000 	add	r2, r3, r0
21f0f9c0:	e3a03a02 	mov	r3, #8192	; 0x2000
21f0f9c4:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.pages_size = 528;
21f0f9c8:	e51b201c 	ldr	r2, [fp, #-28]
21f0f9cc:	e59f1698 	ldr	r1, [pc, #1688]	; 21f1006c <.text+0x1006c>
21f0f9d0:	e3a00030 	mov	r0, #48	; 0x30
21f0f9d4:	e1a03002 	mov	r3, r2
21f0f9d8:	e1a03203 	mov	r3, r3, lsl #4
21f0f9dc:	e0623003 	rsb	r3, r2, r3
21f0f9e0:	e1a03183 	mov	r3, r3, lsl #3
21f0f9e4:	e0833001 	add	r3, r3, r1
21f0f9e8:	e0832000 	add	r2, r3, r0
21f0f9ec:	e3a03e21 	mov	r3, #528	; 0x210
21f0f9f0:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.page_offset = 10;
21f0f9f4:	e51b201c 	ldr	r2, [fp, #-28]
21f0f9f8:	e59f166c 	ldr	r1, [pc, #1644]	; 21f1006c <.text+0x1006c>
21f0f9fc:	e3a00034 	mov	r0, #52	; 0x34
21f0fa00:	e1a03002 	mov	r3, r2
21f0fa04:	e1a03203 	mov	r3, r3, lsl #4
21f0fa08:	e0623003 	rsb	r3, r2, r3
21f0fa0c:	e1a03183 	mov	r3, r3, lsl #3
21f0fa10:	e0833001 	add	r3, r3, r1
21f0fa14:	e0832000 	add	r2, r3, r0
21f0fa18:	e3a0300a 	mov	r3, #10	; 0xa
21f0fa1c:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.byte_mask = 0x300;
21f0fa20:	e51b201c 	ldr	r2, [fp, #-28]
21f0fa24:	e59f1640 	ldr	r1, [pc, #1600]	; 21f1006c <.text+0x1006c>
21f0fa28:	e3a00038 	mov	r0, #56	; 0x38
21f0fa2c:	e1a03002 	mov	r3, r2
21f0fa30:	e1a03203 	mov	r3, r3, lsl #4
21f0fa34:	e0623003 	rsb	r3, r2, r3
21f0fa38:	e1a03183 	mov	r3, r3, lsl #3
21f0fa3c:	e0833001 	add	r3, r3, r1
21f0fa40:	e0832000 	add	r2, r3, r0
21f0fa44:	e3a03c03 	mov	r3, #768	; 0x300
21f0fa48:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.cs = cs[i][1];
21f0fa4c:	e51b001c 	ldr	r0, [fp, #-28]
21f0fa50:	e51b301c 	ldr	r3, [fp, #-28]
21f0fa54:	e59f2614 	ldr	r2, [pc, #1556]	; 21f10070 <.text+0x10070>
21f0fa58:	e3a01004 	mov	r1, #4	; 0x4
21f0fa5c:	e1a03183 	mov	r3, r3, lsl #3
21f0fa60:	e0833002 	add	r3, r3, r2
21f0fa64:	e0833001 	add	r3, r3, r1
21f0fa68:	e5932000 	ldr	r2, [r3]
21f0fa6c:	e59f15f8 	ldr	r1, [pc, #1528]	; 21f1006c <.text+0x1006c>
21f0fa70:	e3a0c03c 	mov	ip, #60	; 0x3c
21f0fa74:	e1a03000 	mov	r3, r0
21f0fa78:	e1a03203 	mov	r3, r3, lsl #4
21f0fa7c:	e0603003 	rsb	r3, r0, r3
21f0fa80:	e1a03183 	mov	r3, r3, lsl #3
21f0fa84:	e0833001 	add	r3, r3, r1
21f0fa88:	e083300c 	add	r3, r3, ip
21f0fa8c:	e5832000 	str	r2, [r3]
			dataflash_info[i].Desc.DataFlash_state = IDLE;
21f0fa90:	e51b201c 	ldr	r2, [fp, #-28]
21f0fa94:	e59f15d0 	ldr	r1, [pc, #1488]	; 21f1006c <.text+0x1006c>
21f0fa98:	e3a00020 	mov	r0, #32	; 0x20
21f0fa9c:	e1a03002 	mov	r3, r2
21f0faa0:	e1a03203 	mov	r3, r3, lsl #4
21f0faa4:	e0623003 	rsb	r3, r2, r3
21f0faa8:	e1a03183 	mov	r3, r3, lsl #3
21f0faac:	e0833001 	add	r3, r3, r1
21f0fab0:	e0832000 	add	r2, r3, r0
21f0fab4:	e3a03000 	mov	r3, #0	; 0x0
21f0fab8:	e5c23001 	strb	r3, [r2, #1]
			dataflash_info[i].logical_address = cs[i][0];
21f0fabc:	e51b101c 	ldr	r1, [fp, #-28]
21f0fac0:	e51b201c 	ldr	r2, [fp, #-28]
21f0fac4:	e59f35a4 	ldr	r3, [pc, #1444]	; 21f10070 <.text+0x10070>
21f0fac8:	e7933182 	ldr	r3, [r3, r2, lsl #3]
21f0facc:	e1a02003 	mov	r2, r3
21f0fad0:	e59f0594 	ldr	r0, [pc, #1428]	; 21f1006c <.text+0x1006c>
21f0fad4:	e3a0c070 	mov	ip, #112	; 0x70
21f0fad8:	e1a03001 	mov	r3, r1
21f0fadc:	e1a03203 	mov	r3, r3, lsl #4
21f0fae0:	e0613003 	rsb	r3, r1, r3
21f0fae4:	e1a03183 	mov	r3, r3, lsl #3
21f0fae8:	e0833000 	add	r3, r3, r0
21f0faec:	e083300c 	add	r3, r3, ip
21f0faf0:	e5832000 	str	r2, [r3]
			dataflash_info[i].id = dfcode;
21f0faf4:	e51b201c 	ldr	r2, [fp, #-28]
21f0faf8:	e51b1014 	ldr	r1, [fp, #-20]
21f0fafc:	e59f0568 	ldr	r0, [pc, #1384]	; 21f1006c <.text+0x1006c>
21f0fb00:	e3a0c074 	mov	ip, #116	; 0x74
21f0fb04:	e1a03002 	mov	r3, r2
21f0fb08:	e1a03203 	mov	r3, r3, lsl #4
21f0fb0c:	e0623003 	rsb	r3, r2, r3
21f0fb10:	e1a03183 	mov	r3, r3, lsl #3
21f0fb14:	e0833000 	add	r3, r3, r0
21f0fb18:	e083300c 	add	r3, r3, ip
21f0fb1c:	e5831000 	str	r1, [r3]
			break;
21f0fb20:	ea0000c2 	b	21f0fe30 <AT91F_DataflashInit+0x758>

		case AT45DB642:
			dataflash_info[i].Device.pages_number = 8192;
21f0fb24:	e51b201c 	ldr	r2, [fp, #-28]
21f0fb28:	e59f153c 	ldr	r1, [pc, #1340]	; 21f1006c <.text+0x1006c>
21f0fb2c:	e3a0002c 	mov	r0, #44	; 0x2c
21f0fb30:	e1a03002 	mov	r3, r2
21f0fb34:	e1a03203 	mov	r3, r3, lsl #4
21f0fb38:	e0623003 	rsb	r3, r2, r3
21f0fb3c:	e1a03183 	mov	r3, r3, lsl #3
21f0fb40:	e0833001 	add	r3, r3, r1
21f0fb44:	e0832000 	add	r2, r3, r0
21f0fb48:	e3a03a02 	mov	r3, #8192	; 0x2000
21f0fb4c:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.pages_size = 1056;
21f0fb50:	e51b201c 	ldr	r2, [fp, #-28]
21f0fb54:	e59f1510 	ldr	r1, [pc, #1296]	; 21f1006c <.text+0x1006c>
21f0fb58:	e3a00030 	mov	r0, #48	; 0x30
21f0fb5c:	e1a03002 	mov	r3, r2
21f0fb60:	e1a03203 	mov	r3, r3, lsl #4
21f0fb64:	e0623003 	rsb	r3, r2, r3
21f0fb68:	e1a03183 	mov	r3, r3, lsl #3
21f0fb6c:	e0833001 	add	r3, r3, r1
21f0fb70:	e0832000 	add	r2, r3, r0
21f0fb74:	e3a03e42 	mov	r3, #1056	; 0x420
21f0fb78:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.page_offset = 11;
21f0fb7c:	e51b201c 	ldr	r2, [fp, #-28]
21f0fb80:	e59f14e4 	ldr	r1, [pc, #1252]	; 21f1006c <.text+0x1006c>
21f0fb84:	e3a00034 	mov	r0, #52	; 0x34
21f0fb88:	e1a03002 	mov	r3, r2
21f0fb8c:	e1a03203 	mov	r3, r3, lsl #4
21f0fb90:	e0623003 	rsb	r3, r2, r3
21f0fb94:	e1a03183 	mov	r3, r3, lsl #3
21f0fb98:	e0833001 	add	r3, r3, r1
21f0fb9c:	e0832000 	add	r2, r3, r0
21f0fba0:	e3a0300b 	mov	r3, #11	; 0xb
21f0fba4:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.byte_mask = 0x700;
21f0fba8:	e51b201c 	ldr	r2, [fp, #-28]
21f0fbac:	e59f14b8 	ldr	r1, [pc, #1208]	; 21f1006c <.text+0x1006c>
21f0fbb0:	e3a00038 	mov	r0, #56	; 0x38
21f0fbb4:	e1a03002 	mov	r3, r2
21f0fbb8:	e1a03203 	mov	r3, r3, lsl #4
21f0fbbc:	e0623003 	rsb	r3, r2, r3
21f0fbc0:	e1a03183 	mov	r3, r3, lsl #3
21f0fbc4:	e0833001 	add	r3, r3, r1
21f0fbc8:	e0832000 	add	r2, r3, r0
21f0fbcc:	e3a03c07 	mov	r3, #1792	; 0x700
21f0fbd0:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.cs = cs[i][1];
21f0fbd4:	e51b001c 	ldr	r0, [fp, #-28]
21f0fbd8:	e51b301c 	ldr	r3, [fp, #-28]
21f0fbdc:	e59f248c 	ldr	r2, [pc, #1164]	; 21f10070 <.text+0x10070>
21f0fbe0:	e3a01004 	mov	r1, #4	; 0x4
21f0fbe4:	e1a03183 	mov	r3, r3, lsl #3
21f0fbe8:	e0833002 	add	r3, r3, r2
21f0fbec:	e0833001 	add	r3, r3, r1
21f0fbf0:	e5932000 	ldr	r2, [r3]
21f0fbf4:	e59f1470 	ldr	r1, [pc, #1136]	; 21f1006c <.text+0x1006c>
21f0fbf8:	e3a0c03c 	mov	ip, #60	; 0x3c
21f0fbfc:	e1a03000 	mov	r3, r0
21f0fc00:	e1a03203 	mov	r3, r3, lsl #4
21f0fc04:	e0603003 	rsb	r3, r0, r3
21f0fc08:	e1a03183 	mov	r3, r3, lsl #3
21f0fc0c:	e0833001 	add	r3, r3, r1
21f0fc10:	e083300c 	add	r3, r3, ip
21f0fc14:	e5832000 	str	r2, [r3]
			dataflash_info[i].Desc.DataFlash_state = IDLE;
21f0fc18:	e51b201c 	ldr	r2, [fp, #-28]
21f0fc1c:	e59f1448 	ldr	r1, [pc, #1096]	; 21f1006c <.text+0x1006c>
21f0fc20:	e3a00020 	mov	r0, #32	; 0x20
21f0fc24:	e1a03002 	mov	r3, r2
21f0fc28:	e1a03203 	mov	r3, r3, lsl #4
21f0fc2c:	e0623003 	rsb	r3, r2, r3
21f0fc30:	e1a03183 	mov	r3, r3, lsl #3
21f0fc34:	e0833001 	add	r3, r3, r1
21f0fc38:	e0832000 	add	r2, r3, r0
21f0fc3c:	e3a03000 	mov	r3, #0	; 0x0
21f0fc40:	e5c23001 	strb	r3, [r2, #1]
			dataflash_info[i].logical_address = cs[i][0];
21f0fc44:	e51b101c 	ldr	r1, [fp, #-28]
21f0fc48:	e51b201c 	ldr	r2, [fp, #-28]
21f0fc4c:	e59f341c 	ldr	r3, [pc, #1052]	; 21f10070 <.text+0x10070>
21f0fc50:	e7933182 	ldr	r3, [r3, r2, lsl #3]
21f0fc54:	e1a02003 	mov	r2, r3
21f0fc58:	e59f040c 	ldr	r0, [pc, #1036]	; 21f1006c <.text+0x1006c>
21f0fc5c:	e3a0c070 	mov	ip, #112	; 0x70
21f0fc60:	e1a03001 	mov	r3, r1
21f0fc64:	e1a03203 	mov	r3, r3, lsl #4
21f0fc68:	e0613003 	rsb	r3, r1, r3
21f0fc6c:	e1a03183 	mov	r3, r3, lsl #3
21f0fc70:	e0833000 	add	r3, r3, r0
21f0fc74:	e083300c 	add	r3, r3, ip
21f0fc78:	e5832000 	str	r2, [r3]
			dataflash_info[i].id = dfcode;
21f0fc7c:	e51b201c 	ldr	r2, [fp, #-28]
21f0fc80:	e51b1014 	ldr	r1, [fp, #-20]
21f0fc84:	e59f03e0 	ldr	r0, [pc, #992]	; 21f1006c <.text+0x1006c>
21f0fc88:	e3a0c074 	mov	ip, #116	; 0x74
21f0fc8c:	e1a03002 	mov	r3, r2
21f0fc90:	e1a03203 	mov	r3, r3, lsl #4
21f0fc94:	e0623003 	rsb	r3, r2, r3
21f0fc98:	e1a03183 	mov	r3, r3, lsl #3
21f0fc9c:	e0833000 	add	r3, r3, r0
21f0fca0:	e083300c 	add	r3, r3, ip
21f0fca4:	e5831000 	str	r1, [r3]
			break;
21f0fca8:	ea000060 	b	21f0fe30 <AT91F_DataflashInit+0x758>
		case AT45DB128:
			dataflash_info[i].Device.pages_number = 16384;
21f0fcac:	e51b201c 	ldr	r2, [fp, #-28]
21f0fcb0:	e59f13b4 	ldr	r1, [pc, #948]	; 21f1006c <.text+0x1006c>
21f0fcb4:	e3a0002c 	mov	r0, #44	; 0x2c
21f0fcb8:	e1a03002 	mov	r3, r2
21f0fcbc:	e1a03203 	mov	r3, r3, lsl #4
21f0fcc0:	e0623003 	rsb	r3, r2, r3
21f0fcc4:	e1a03183 	mov	r3, r3, lsl #3
21f0fcc8:	e0833001 	add	r3, r3, r1
21f0fccc:	e0832000 	add	r2, r3, r0
21f0fcd0:	e3a03901 	mov	r3, #16384	; 0x4000
21f0fcd4:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.pages_size = 1056;
21f0fcd8:	e51b201c 	ldr	r2, [fp, #-28]
21f0fcdc:	e59f1388 	ldr	r1, [pc, #904]	; 21f1006c <.text+0x1006c>
21f0fce0:	e3a00030 	mov	r0, #48	; 0x30
21f0fce4:	e1a03002 	mov	r3, r2
21f0fce8:	e1a03203 	mov	r3, r3, lsl #4
21f0fcec:	e0623003 	rsb	r3, r2, r3
21f0fcf0:	e1a03183 	mov	r3, r3, lsl #3
21f0fcf4:	e0833001 	add	r3, r3, r1
21f0fcf8:	e0832000 	add	r2, r3, r0
21f0fcfc:	e3a03e42 	mov	r3, #1056	; 0x420
21f0fd00:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.page_offset = 11;
21f0fd04:	e51b201c 	ldr	r2, [fp, #-28]
21f0fd08:	e59f135c 	ldr	r1, [pc, #860]	; 21f1006c <.text+0x1006c>
21f0fd0c:	e3a00034 	mov	r0, #52	; 0x34
21f0fd10:	e1a03002 	mov	r3, r2
21f0fd14:	e1a03203 	mov	r3, r3, lsl #4
21f0fd18:	e0623003 	rsb	r3, r2, r3
21f0fd1c:	e1a03183 	mov	r3, r3, lsl #3
21f0fd20:	e0833001 	add	r3, r3, r1
21f0fd24:	e0832000 	add	r2, r3, r0
21f0fd28:	e3a0300b 	mov	r3, #11	; 0xb
21f0fd2c:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.byte_mask = 0x700;
21f0fd30:	e51b201c 	ldr	r2, [fp, #-28]
21f0fd34:	e59f1330 	ldr	r1, [pc, #816]	; 21f1006c <.text+0x1006c>
21f0fd38:	e3a00038 	mov	r0, #56	; 0x38
21f0fd3c:	e1a03002 	mov	r3, r2
21f0fd40:	e1a03203 	mov	r3, r3, lsl #4
21f0fd44:	e0623003 	rsb	r3, r2, r3
21f0fd48:	e1a03183 	mov	r3, r3, lsl #3
21f0fd4c:	e0833001 	add	r3, r3, r1
21f0fd50:	e0832000 	add	r2, r3, r0
21f0fd54:	e3a03c07 	mov	r3, #1792	; 0x700
21f0fd58:	e5823000 	str	r3, [r2]
			dataflash_info[i].Device.cs = cs[i][1];
21f0fd5c:	e51b001c 	ldr	r0, [fp, #-28]
21f0fd60:	e51b301c 	ldr	r3, [fp, #-28]
21f0fd64:	e59f2304 	ldr	r2, [pc, #772]	; 21f10070 <.text+0x10070>
21f0fd68:	e3a01004 	mov	r1, #4	; 0x4
21f0fd6c:	e1a03183 	mov	r3, r3, lsl #3
21f0fd70:	e0833002 	add	r3, r3, r2
21f0fd74:	e0833001 	add	r3, r3, r1
21f0fd78:	e5932000 	ldr	r2, [r3]
21f0fd7c:	e59f12e8 	ldr	r1, [pc, #744]	; 21f1006c <.text+0x1006c>
21f0fd80:	e3a0c03c 	mov	ip, #60	; 0x3c
21f0fd84:	e1a03000 	mov	r3, r0
21f0fd88:	e1a03203 	mov	r3, r3, lsl #4
21f0fd8c:	e0603003 	rsb	r3, r0, r3
21f0fd90:	e1a03183 	mov	r3, r3, lsl #3
21f0fd94:	e0833001 	add	r3, r3, r1
21f0fd98:	e083300c 	add	r3, r3, ip
21f0fd9c:	e5832000 	str	r2, [r3]
			dataflash_info[i].Desc.DataFlash_state = IDLE;
21f0fda0:	e51b201c 	ldr	r2, [fp, #-28]
21f0fda4:	e59f12c0 	ldr	r1, [pc, #704]	; 21f1006c <.text+0x1006c>
21f0fda8:	e3a00020 	mov	r0, #32	; 0x20
21f0fdac:	e1a03002 	mov	r3, r2
21f0fdb0:	e1a03203 	mov	r3, r3, lsl #4
21f0fdb4:	e0623003 	rsb	r3, r2, r3
21f0fdb8:	e1a03183 	mov	r3, r3, lsl #3
21f0fdbc:	e0833001 	add	r3, r3, r1
21f0fdc0:	e0832000 	add	r2, r3, r0
21f0fdc4:	e3a03000 	mov	r3, #0	; 0x0
21f0fdc8:	e5c23001 	strb	r3, [r2, #1]
			dataflash_info[i].logical_address = cs[i][0];
21f0fdcc:	e51b101c 	ldr	r1, [fp, #-28]
21f0fdd0:	e51b201c 	ldr	r2, [fp, #-28]
21f0fdd4:	e59f3294 	ldr	r3, [pc, #660]	; 21f10070 <.text+0x10070>
21f0fdd8:	e7933182 	ldr	r3, [r3, r2, lsl #3]
21f0fddc:	e1a02003 	mov	r2, r3
21f0fde0:	e59f0284 	ldr	r0, [pc, #644]	; 21f1006c <.text+0x1006c>
21f0fde4:	e3a0c070 	mov	ip, #112	; 0x70
21f0fde8:	e1a03001 	mov	r3, r1
21f0fdec:	e1a03203 	mov	r3, r3, lsl #4
21f0fdf0:	e0613003 	rsb	r3, r1, r3
21f0fdf4:	e1a03183 	mov	r3, r3, lsl #3
21f0fdf8:	e0833000 	add	r3, r3, r0
21f0fdfc:	e083300c 	add	r3, r3, ip
21f0fe00:	e5832000 	str	r2, [r3]
			dataflash_info[i].id = dfcode;
21f0fe04:	e51b201c 	ldr	r2, [fp, #-28]
21f0fe08:	e51b1014 	ldr	r1, [fp, #-20]
21f0fe0c:	e59f0258 	ldr	r0, [pc, #600]	; 21f1006c <.text+0x1006c>
21f0fe10:	e3a0c074 	mov	ip, #116	; 0x74
21f0fe14:	e1a03002 	mov	r3, r2
21f0fe18:	e1a03203 	mov	r3, r3, lsl #4
21f0fe1c:	e0623003 	rsb	r3, r2, r3
21f0fe20:	e1a03183 	mov	r3, r3, lsl #3
21f0fe24:	e0833000 	add	r3, r3, r0
21f0fe28:	e083300c 	add	r3, r3, ip
21f0fe2c:	e5831000 	str	r1, [r3]
			break;

		default:
			break;
		}
		/* set the last area end to the dataflash size*/
		area_list[NB_DATAFLASH_AREA -1].end =
21f0fe30:	e51b201c 	ldr	r2, [fp, #-28]
21f0fe34:	e59f1230 	ldr	r1, [pc, #560]	; 21f1006c <.text+0x1006c>
21f0fe38:	e3a0002c 	mov	r0, #44	; 0x2c
21f0fe3c:	e1a03002 	mov	r3, r2
21f0fe40:	e1a03203 	mov	r3, r3, lsl #4
21f0fe44:	e0623003 	rsb	r3, r2, r3
21f0fe48:	e1a03183 	mov	r3, r3, lsl #3
21f0fe4c:	e0833001 	add	r3, r3, r1
21f0fe50:	e0833000 	add	r3, r3, r0
21f0fe54:	e593c000 	ldr	ip, [r3]
21f0fe58:	e51b201c 	ldr	r2, [fp, #-28]
21f0fe5c:	e59f1208 	ldr	r1, [pc, #520]	; 21f1006c <.text+0x1006c>
21f0fe60:	e3a00030 	mov	r0, #48	; 0x30
21f0fe64:	e1a03002 	mov	r3, r2
21f0fe68:	e1a03203 	mov	r3, r3, lsl #4
21f0fe6c:	e0623003 	rsb	r3, r2, r3
21f0fe70:	e1a03183 	mov	r3, r3, lsl #3
21f0fe74:	e0833001 	add	r3, r3, r1
21f0fe78:	e0833000 	add	r3, r3, r0
21f0fe7c:	e5933000 	ldr	r3, [r3]
21f0fe80:	e003039c 	mul	r3, ip, r3
21f0fe84:	e2433001 	sub	r3, r3, #1	; 0x1
21f0fe88:	e1a02003 	mov	r2, r3
21f0fe8c:	e59f31e0 	ldr	r3, [pc, #480]	; 21f10074 <.text+0x10074>
21f0fe90:	e5832028 	str	r2, [r3, #40]
				(dataflash_info[i].Device.pages_number *
				dataflash_info[i].Device.pages_size)-1;

		/* set the area addresses */
		for(j = 0; j<NB_DATAFLASH_AREA; j++) {
21f0fe94:	e3a03000 	mov	r3, #0	; 0x0
21f0fe98:	e50b3018 	str	r3, [fp, #-24]
21f0fe9c:	ea000065 	b	21f10038 <AT91F_DataflashInit+0x960>
			dataflash_info[i].Device.area_list[j].start = area_list[j].start + dataflash_info[i].logical_address;
21f0fea0:	e51bc01c 	ldr	ip, [fp, #-28]
21f0fea4:	e51be018 	ldr	lr, [fp, #-24]
21f0fea8:	e51b2018 	ldr	r2, [fp, #-24]
21f0feac:	e59f11c0 	ldr	r1, [pc, #448]	; 21f10074 <.text+0x10074>
21f0feb0:	e1a03002 	mov	r3, r2
21f0feb4:	e1a03083 	mov	r3, r3, lsl #1
21f0feb8:	e0833002 	add	r3, r3, r2
21f0febc:	e1a03103 	mov	r3, r3, lsl #2
21f0fec0:	e0833001 	add	r3, r3, r1
21f0fec4:	e5934000 	ldr	r4, [r3]
21f0fec8:	e51b201c 	ldr	r2, [fp, #-28]
21f0fecc:	e59f1198 	ldr	r1, [pc, #408]	; 21f1006c <.text+0x1006c>
21f0fed0:	e3a00070 	mov	r0, #112	; 0x70
21f0fed4:	e1a03002 	mov	r3, r2
21f0fed8:	e1a03203 	mov	r3, r3, lsl #4
21f0fedc:	e0623003 	rsb	r3, r2, r3
21f0fee0:	e1a03183 	mov	r3, r3, lsl #3
21f0fee4:	e0833001 	add	r3, r3, r1
21f0fee8:	e0833000 	add	r3, r3, r0
21f0feec:	e5933000 	ldr	r3, [r3]
21f0fef0:	e0841003 	add	r1, r4, r3
21f0fef4:	e59f0170 	ldr	r0, [pc, #368]	; 21f1006c <.text+0x1006c>
21f0fef8:	e3a04040 	mov	r4, #64	; 0x40
21f0fefc:	e1a0300e 	mov	r3, lr
21f0ff00:	e1a03083 	mov	r3, r3, lsl #1
21f0ff04:	e083300e 	add	r3, r3, lr
21f0ff08:	e1a02103 	mov	r2, r3, lsl #2
21f0ff0c:	e1a0300c 	mov	r3, ip
21f0ff10:	e1a03203 	mov	r3, r3, lsl #4
21f0ff14:	e06c3003 	rsb	r3, ip, r3
21f0ff18:	e1a03183 	mov	r3, r3, lsl #3
21f0ff1c:	e0823003 	add	r3, r2, r3
21f0ff20:	e0833000 	add	r3, r3, r0
21f0ff24:	e0833004 	add	r3, r3, r4
21f0ff28:	e5831000 	str	r1, [r3]
			dataflash_info[i].Device.area_list[j].end = area_list[j].end + dataflash_info[i].logical_address;
21f0ff2c:	e51bc01c 	ldr	ip, [fp, #-28]
21f0ff30:	e51be018 	ldr	lr, [fp, #-24]
21f0ff34:	e51b2018 	ldr	r2, [fp, #-24]
21f0ff38:	e59f1134 	ldr	r1, [pc, #308]	; 21f10074 <.text+0x10074>
21f0ff3c:	e3a00004 	mov	r0, #4	; 0x4
21f0ff40:	e1a03002 	mov	r3, r2
21f0ff44:	e1a03083 	mov	r3, r3, lsl #1
21f0ff48:	e0833002 	add	r3, r3, r2
21f0ff4c:	e1a03103 	mov	r3, r3, lsl #2
21f0ff50:	e0833001 	add	r3, r3, r1
21f0ff54:	e0833000 	add	r3, r3, r0
21f0ff58:	e5934000 	ldr	r4, [r3]
21f0ff5c:	e51b201c 	ldr	r2, [fp, #-28]
21f0ff60:	e59f1104 	ldr	r1, [pc, #260]	; 21f1006c <.text+0x1006c>
21f0ff64:	e3a00070 	mov	r0, #112	; 0x70
21f0ff68:	e1a03002 	mov	r3, r2
21f0ff6c:	e1a03203 	mov	r3, r3, lsl #4
21f0ff70:	e0623003 	rsb	r3, r2, r3
21f0ff74:	e1a03183 	mov	r3, r3, lsl #3
21f0ff78:	e0833001 	add	r3, r3, r1
21f0ff7c:	e0833000 	add	r3, r3, r0
21f0ff80:	e5933000 	ldr	r3, [r3]
21f0ff84:	e0841003 	add	r1, r4, r3
21f0ff88:	e59f00dc 	ldr	r0, [pc, #220]	; 21f1006c <.text+0x1006c>
21f0ff8c:	e3a04044 	mov	r4, #68	; 0x44
21f0ff90:	e1a0300e 	mov	r3, lr
21f0ff94:	e1a03083 	mov	r3, r3, lsl #1
21f0ff98:	e083300e 	add	r3, r3, lr
21f0ff9c:	e1a02103 	mov	r2, r3, lsl #2
21f0ffa0:	e1a0300c 	mov	r3, ip
21f0ffa4:	e1a03203 	mov	r3, r3, lsl #4
21f0ffa8:	e06c3003 	rsb	r3, ip, r3
21f0ffac:	e1a03183 	mov	r3, r3, lsl #3
21f0ffb0:	e0823003 	add	r3, r2, r3
21f0ffb4:	e0833000 	add	r3, r3, r0
21f0ffb8:	e0833004 	add	r3, r3, r4
21f0ffbc:	e5831000 	str	r1, [r3]
			dataflash_info[i].Device.area_list[j].protected = area_list[j].protected;
21f0ffc0:	e51be01c 	ldr	lr, [fp, #-28]
21f0ffc4:	e51b1018 	ldr	r1, [fp, #-24]
21f0ffc8:	e51b2018 	ldr	r2, [fp, #-24]
21f0ffcc:	e59f00a0 	ldr	r0, [pc, #160]	; 21f10074 <.text+0x10074>
21f0ffd0:	e3a0c008 	mov	ip, #8	; 0x8
21f0ffd4:	e1a03002 	mov	r3, r2
21f0ffd8:	e1a03083 	mov	r3, r3, lsl #1
21f0ffdc:	e0833002 	add	r3, r3, r2
21f0ffe0:	e1a03103 	mov	r3, r3, lsl #2
21f0ffe4:	e0833000 	add	r3, r3, r0
21f0ffe8:	e083300c 	add	r3, r3, ip
21f0ffec:	e5d30000 	ldrb	r0, [r3]
21f0fff0:	e59fc074 	ldr	ip, [pc, #116]	; 21f1006c <.text+0x1006c>
21f0fff4:	e3a04048 	mov	r4, #72	; 0x48
21f0fff8:	e1a03001 	mov	r3, r1
21f0fffc:	e1a03083 	mov	r3, r3, lsl #1
21f10000:	e0833001 	add	r3, r3, r1
21f10004:	e1a02103 	mov	r2, r3, lsl #2
21f10008:	e1a0300e 	mov	r3, lr
21f1000c:	e1a03203 	mov	r3, r3, lsl #4
21f10010:	e06e3003 	rsb	r3, lr, r3
21f10014:	e1a03183 	mov	r3, r3, lsl #3
21f10018:	e0823003 	add	r3, r2, r3
21f1001c:	e083300c 	add	r3, r3, ip
21f10020:	e0832004 	add	r2, r3, r4
21f10024:	e1a03000 	mov	r3, r0
21f10028:	e5c23000 	strb	r3, [r2]
21f1002c:	e51b3018 	ldr	r3, [fp, #-24]
21f10030:	e2833001 	add	r3, r3, #1	; 0x1
21f10034:	e50b3018 	str	r3, [fp, #-24]
21f10038:	e51b3018 	ldr	r3, [fp, #-24]
21f1003c:	e3530003 	cmp	r3, #3	; 0x3
21f10040:	daffff96 	ble	21f0fea0 <AT91F_DataflashInit+0x7c8>
21f10044:	e51b301c 	ldr	r3, [fp, #-28]
21f10048:	e2833001 	add	r3, r3, #1	; 0x1
21f1004c:	e50b301c 	str	r3, [fp, #-28]
21f10050:	e51b301c 	ldr	r3, [fp, #-28]
21f10054:	e3530001 	cmp	r3, #1	; 0x1
21f10058:	dafffda6 	ble	21f0f6f8 <AT91F_DataflashInit+0x20>
		}
	}
	return (1);
21f1005c:	e3a03001 	mov	r3, #1	; 0x1
}
21f10060:	e1a00003 	mov	r0, r3
21f10064:	e24bd010 	sub	sp, fp, #16	; 0x10
21f10068:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f1006c:	21f6736c 	mvncss	r7, ip, ror #6
21f10070:	21f331dc 	ldrcssb	r3, [r3, #28]!
21f10074:	21f331ec 	mvncss	r3, ip, ror #3

21f10078 <dataflash_print_info>:


void dataflash_print_info (void)
{
21f10078:	e1a0c00d 	mov	ip, sp
21f1007c:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f10080:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10084:	e24dd01c 	sub	sp, sp, #28	; 0x1c
	int i, j;

	for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++) {
21f10088:	e3a03000 	mov	r3, #0	; 0x0
21f1008c:	e50b3018 	str	r3, [fp, #-24]
21f10090:	ea0000bc 	b	21f10388 <dataflash_print_info+0x310>
		if (dataflash_info[i].id != 0) {
21f10094:	e51b2018 	ldr	r2, [fp, #-24]
21f10098:	e59f12fc 	ldr	r1, [pc, #764]	; 21f1039c <.text+0x1039c>
21f1009c:	e3a00074 	mov	r0, #116	; 0x74
21f100a0:	e1a03002 	mov	r3, r2
21f100a4:	e1a03203 	mov	r3, r3, lsl #4
21f100a8:	e0623003 	rsb	r3, r2, r3
21f100ac:	e1a03183 	mov	r3, r3, lsl #3
21f100b0:	e0833001 	add	r3, r3, r1
21f100b4:	e0833000 	add	r3, r3, r0
21f100b8:	e5933000 	ldr	r3, [r3]
21f100bc:	e3530000 	cmp	r3, #0	; 0x0
21f100c0:	0a0000ad 	beq	21f1037c <dataflash_print_info+0x304>
			printf ("DataFlash:");
21f100c4:	e59f02d4 	ldr	r0, [pc, #724]	; 21f103a0 <.text+0x103a0>
21f100c8:	eb002e6f 	bl	21f1ba8c <printf>
			switch (dataflash_info[i].id) {
21f100cc:	e51b2018 	ldr	r2, [fp, #-24]
21f100d0:	e59f12c4 	ldr	r1, [pc, #708]	; 21f1039c <.text+0x1039c>
21f100d4:	e3a00074 	mov	r0, #116	; 0x74
21f100d8:	e1a03002 	mov	r3, r2
21f100dc:	e1a03203 	mov	r3, r3, lsl #4
21f100e0:	e0623003 	rsb	r3, r2, r3
21f100e4:	e1a03183 	mov	r3, r3, lsl #3
21f100e8:	e0833001 	add	r3, r3, r1
21f100ec:	e0833000 	add	r3, r3, r0
21f100f0:	e5933000 	ldr	r3, [r3]
21f100f4:	e50b3028 	str	r3, [fp, #-40]
21f100f8:	e51b3028 	ldr	r3, [fp, #-40]
21f100fc:	e353002c 	cmp	r3, #44	; 0x2c
21f10100:	0a00000d 	beq	21f1013c <dataflash_print_info+0xc4>
21f10104:	e51b3028 	ldr	r3, [fp, #-40]
21f10108:	e353002c 	cmp	r3, #44	; 0x2c
21f1010c:	8a000003 	bhi	21f10120 <dataflash_print_info+0xa8>
21f10110:	e51b3028 	ldr	r3, [fp, #-40]
21f10114:	e3530010 	cmp	r3, #16	; 0x10
21f10118:	0a000010 	beq	21f10160 <dataflash_print_info+0xe8>
21f1011c:	ea000011 	b	21f10168 <dataflash_print_info+0xf0>
21f10120:	e51b3028 	ldr	r3, [fp, #-40]
21f10124:	e3530034 	cmp	r3, #52	; 0x34
21f10128:	0a000006 	beq	21f10148 <dataflash_print_info+0xd0>
21f1012c:	e51b3028 	ldr	r3, [fp, #-40]
21f10130:	e353003c 	cmp	r3, #60	; 0x3c
21f10134:	0a000006 	beq	21f10154 <dataflash_print_info+0xdc>
21f10138:	ea00000a 	b	21f10168 <dataflash_print_info+0xf0>
			case AT45DB161:
				printf ("AT45DB161\n");
21f1013c:	e59f0260 	ldr	r0, [pc, #608]	; 21f103a4 <.text+0x103a4>
21f10140:	eb002e51 	bl	21f1ba8c <printf>
				break;
21f10144:	ea000007 	b	21f10168 <dataflash_print_info+0xf0>

			case AT45DB321:
				printf ("AT45DB321\n");
21f10148:	e59f0258 	ldr	r0, [pc, #600]	; 21f103a8 <.text+0x103a8>
21f1014c:	eb002e4e 	bl	21f1ba8c <printf>
				break;
21f10150:	ea000004 	b	21f10168 <dataflash_print_info+0xf0>

			case AT45DB642:
				printf ("AT45DB642\n");
21f10154:	e59f0250 	ldr	r0, [pc, #592]	; 21f103ac <.text+0x103ac>
21f10158:	eb002e4b 	bl	21f1ba8c <printf>
				break;
21f1015c:	ea000001 	b	21f10168 <dataflash_print_info+0xf0>
			case AT45DB128:
				printf ("AT45DB128\n");
21f10160:	e59f0248 	ldr	r0, [pc, #584]	; 21f103b0 <.text+0x103b0>
21f10164:	eb002e48 	bl	21f1ba8c <printf>
				break;
			}

			printf ("Nb pages: %6d\n"
21f10168:	e51b2018 	ldr	r2, [fp, #-24]
21f1016c:	e59f1228 	ldr	r1, [pc, #552]	; 21f1039c <.text+0x1039c>
21f10170:	e3a0002c 	mov	r0, #44	; 0x2c
21f10174:	e1a03002 	mov	r3, r2
21f10178:	e1a03203 	mov	r3, r3, lsl #4
21f1017c:	e0623003 	rsb	r3, r2, r3
21f10180:	e1a03183 	mov	r3, r3, lsl #3
21f10184:	e0833001 	add	r3, r3, r1
21f10188:	e0833000 	add	r3, r3, r0
21f1018c:	e5933000 	ldr	r3, [r3]
21f10190:	e1a0c003 	mov	ip, r3
21f10194:	e51b2018 	ldr	r2, [fp, #-24]
21f10198:	e59f11fc 	ldr	r1, [pc, #508]	; 21f1039c <.text+0x1039c>
21f1019c:	e3a00030 	mov	r0, #48	; 0x30
21f101a0:	e1a03002 	mov	r3, r2
21f101a4:	e1a03203 	mov	r3, r3, lsl #4
21f101a8:	e0623003 	rsb	r3, r2, r3
21f101ac:	e1a03183 	mov	r3, r3, lsl #3
21f101b0:	e0833001 	add	r3, r3, r1
21f101b4:	e0833000 	add	r3, r3, r0
21f101b8:	e5933000 	ldr	r3, [r3]
21f101bc:	e1a0e003 	mov	lr, r3
21f101c0:	e51b2018 	ldr	r2, [fp, #-24]
21f101c4:	e59f11d0 	ldr	r1, [pc, #464]	; 21f1039c <.text+0x1039c>
21f101c8:	e3a0002c 	mov	r0, #44	; 0x2c
21f101cc:	e1a03002 	mov	r3, r2
21f101d0:	e1a03203 	mov	r3, r3, lsl #4
21f101d4:	e0623003 	rsb	r3, r2, r3
21f101d8:	e1a03183 	mov	r3, r3, lsl #3
21f101dc:	e0833001 	add	r3, r3, r1
21f101e0:	e0833000 	add	r3, r3, r0
21f101e4:	e5933000 	ldr	r3, [r3]
21f101e8:	e1a04003 	mov	r4, r3
21f101ec:	e51b2018 	ldr	r2, [fp, #-24]
21f101f0:	e59f11a4 	ldr	r1, [pc, #420]	; 21f1039c <.text+0x1039c>
21f101f4:	e3a00030 	mov	r0, #48	; 0x30
21f101f8:	e1a03002 	mov	r3, r2
21f101fc:	e1a03203 	mov	r3, r3, lsl #4
21f10200:	e0623003 	rsb	r3, r2, r3
21f10204:	e1a03183 	mov	r3, r3, lsl #3
21f10208:	e0833001 	add	r3, r3, r1
21f1020c:	e0833000 	add	r3, r3, r0
21f10210:	e5933000 	ldr	r3, [r3]
21f10214:	e0040493 	mul	r4, r3, r4
21f10218:	e51b2018 	ldr	r2, [fp, #-24]
21f1021c:	e59f1178 	ldr	r1, [pc, #376]	; 21f1039c <.text+0x1039c>
21f10220:	e3a00070 	mov	r0, #112	; 0x70
21f10224:	e1a03002 	mov	r3, r2
21f10228:	e1a03203 	mov	r3, r3, lsl #4
21f1022c:	e0623003 	rsb	r3, r2, r3
21f10230:	e1a03183 	mov	r3, r3, lsl #3
21f10234:	e0833001 	add	r3, r3, r1
21f10238:	e0833000 	add	r3, r3, r0
21f1023c:	e5933000 	ldr	r3, [r3]
21f10240:	e58d3000 	str	r3, [sp]
21f10244:	e59f0168 	ldr	r0, [pc, #360]	; 21f103b4 <.text+0x103b4>
21f10248:	e1a0100c 	mov	r1, ip
21f1024c:	e1a0200e 	mov	r2, lr
21f10250:	e1a03004 	mov	r3, r4
21f10254:	eb002e0c 	bl	21f1ba8c <printf>
				"Page Size: %6d\n"
				"Size=%8d bytes\n"
				"Logical address: 0x%08X\n",
				(unsigned int) dataflash_info[i].Device.pages_number,
				(unsigned int) dataflash_info[i].Device.pages_size,
				(unsigned int) dataflash_info[i].Device.pages_number *
				dataflash_info[i].Device.pages_size,
				(unsigned int) dataflash_info[i].logical_address);
			for (j=0; j< NB_DATAFLASH_AREA; j++) {
21f10258:	e3a03000 	mov	r3, #0	; 0x0
21f1025c:	e50b3014 	str	r3, [fp, #-20]
21f10260:	ea000042 	b	21f10370 <dataflash_print_info+0x2f8>
				printf ("Area %i:\t%08lX to %08lX %s\n", j,
21f10264:	e51b1018 	ldr	r1, [fp, #-24]
21f10268:	e51b2014 	ldr	r2, [fp, #-20]
21f1026c:	e59f0128 	ldr	r0, [pc, #296]	; 21f1039c <.text+0x1039c>
21f10270:	e3a0c040 	mov	ip, #64	; 0x40
21f10274:	e1a03002 	mov	r3, r2
21f10278:	e1a03083 	mov	r3, r3, lsl #1
21f1027c:	e0833002 	add	r3, r3, r2
21f10280:	e1a02103 	mov	r2, r3, lsl #2
21f10284:	e1a03001 	mov	r3, r1
21f10288:	e1a03203 	mov	r3, r3, lsl #4
21f1028c:	e0613003 	rsb	r3, r1, r3
21f10290:	e1a03183 	mov	r3, r3, lsl #3
21f10294:	e0823003 	add	r3, r2, r3
21f10298:	e0833000 	add	r3, r3, r0
21f1029c:	e083300c 	add	r3, r3, ip
21f102a0:	e5933000 	ldr	r3, [r3]
21f102a4:	e50b3024 	str	r3, [fp, #-36]
21f102a8:	e51b1018 	ldr	r1, [fp, #-24]
21f102ac:	e51b2014 	ldr	r2, [fp, #-20]
21f102b0:	e59f00e4 	ldr	r0, [pc, #228]	; 21f1039c <.text+0x1039c>
21f102b4:	e3a0c044 	mov	ip, #68	; 0x44
21f102b8:	e1a03002 	mov	r3, r2
21f102bc:	e1a03083 	mov	r3, r3, lsl #1
21f102c0:	e0833002 	add	r3, r3, r2
21f102c4:	e1a02103 	mov	r2, r3, lsl #2
21f102c8:	e1a03001 	mov	r3, r1
21f102cc:	e1a03203 	mov	r3, r3, lsl #4
21f102d0:	e0613003 	rsb	r3, r1, r3
21f102d4:	e1a03183 	mov	r3, r3, lsl #3
21f102d8:	e0823003 	add	r3, r2, r3
21f102dc:	e0833000 	add	r3, r3, r0
21f102e0:	e083300c 	add	r3, r3, ip
21f102e4:	e5933000 	ldr	r3, [r3]
21f102e8:	e50b3020 	str	r3, [fp, #-32]
21f102ec:	e51b1018 	ldr	r1, [fp, #-24]
21f102f0:	e51b2014 	ldr	r2, [fp, #-20]
21f102f4:	e59f00a0 	ldr	r0, [pc, #160]	; 21f1039c <.text+0x1039c>
21f102f8:	e3a0c048 	mov	ip, #72	; 0x48
21f102fc:	e1a03002 	mov	r3, r2
21f10300:	e1a03083 	mov	r3, r3, lsl #1
21f10304:	e0833002 	add	r3, r3, r2
21f10308:	e1a02103 	mov	r2, r3, lsl #2
21f1030c:	e1a03001 	mov	r3, r1
21f10310:	e1a03203 	mov	r3, r3, lsl #4
21f10314:	e0613003 	rsb	r3, r1, r3
21f10318:	e1a03183 	mov	r3, r3, lsl #3
21f1031c:	e0823003 	add	r3, r2, r3
21f10320:	e0833000 	add	r3, r3, r0
21f10324:	e083300c 	add	r3, r3, ip
21f10328:	e5d33000 	ldrb	r3, [r3]
21f1032c:	e3530001 	cmp	r3, #1	; 0x1
21f10330:	1a000002 	bne	21f10340 <dataflash_print_info+0x2c8>
21f10334:	e59f307c 	ldr	r3, [pc, #124]	; 21f103b8 <.text+0x103b8>
21f10338:	e50b301c 	str	r3, [fp, #-28]
21f1033c:	ea000001 	b	21f10348 <dataflash_print_info+0x2d0>
21f10340:	e59f3074 	ldr	r3, [pc, #116]	; 21f103bc <.text+0x103bc>
21f10344:	e50b301c 	str	r3, [fp, #-28]
21f10348:	e51b301c 	ldr	r3, [fp, #-28]
21f1034c:	e58d3000 	str	r3, [sp]
21f10350:	e59f0068 	ldr	r0, [pc, #104]	; 21f103c0 <.text+0x103c0>
21f10354:	e51b1014 	ldr	r1, [fp, #-20]
21f10358:	e51b2024 	ldr	r2, [fp, #-36]
21f1035c:	e51b3020 	ldr	r3, [fp, #-32]
21f10360:	eb002dc9 	bl	21f1ba8c <printf>
21f10364:	e51b3014 	ldr	r3, [fp, #-20]
21f10368:	e2833001 	add	r3, r3, #1	; 0x1
21f1036c:	e50b3014 	str	r3, [fp, #-20]
21f10370:	e51b3014 	ldr	r3, [fp, #-20]
21f10374:	e3530003 	cmp	r3, #3	; 0x3
21f10378:	daffffb9 	ble	21f10264 <dataflash_print_info+0x1ec>
21f1037c:	e51b3018 	ldr	r3, [fp, #-24]
21f10380:	e2833001 	add	r3, r3, #1	; 0x1
21f10384:	e50b3018 	str	r3, [fp, #-24]
21f10388:	e51b3018 	ldr	r3, [fp, #-24]
21f1038c:	e3530001 	cmp	r3, #1	; 0x1
21f10390:	daffff3f 	ble	21f10094 <dataflash_print_info+0x1c>
					dataflash_info[i].Device.area_list[j].start,
					dataflash_info[i].Device.area_list[j].end,
					(dataflash_info[i].Device.area_list[j].protected ==
					FLAG_PROTECT_SET) ? "(RO)" : "");
			}
		}
	}
}
21f10394:	e24bd010 	sub	sp, fp, #16	; 0x10
21f10398:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f1039c:	21f6736c 	mvncss	r7, ip, ror #6
21f103a0:	21f2fe0c 	mvncss	pc, ip, lsl #28
21f103a4:	21f2fe18 	mvncss	pc, r8, lsl lr
21f103a8:	21f2fe24 	mvncss	pc, r4, lsr #28
21f103ac:	21f2fe30 	mvncss	pc, r0, lsr lr
21f103b0:	21f2fe3c 	mvncss	pc, ip, lsr lr
21f103b4:	21f2fe48 	mvncss	pc, r8, asr #28
21f103b8:	21f2fe90 	ldrcsb	pc, [r2, #224]!
21f103bc:	21f2fe98 	ldrcsb	pc, [r2, #232]!
21f103c0:	21f2fe9c 	ldrcsb	pc, [r2, #236]!

21f103c4 <AT91F_DataflashSelect>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_DataflashSelect 					*/
/* Object              : Select the correct device				*/
/*------------------------------------------------------------------------------*/
AT91PS_DataFlash AT91F_DataflashSelect (AT91PS_DataFlash pFlash, unsigned long *addr)
{
21f103c4:	e1a0c00d 	mov	ip, sp
21f103c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f103cc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f103d0:	e24dd014 	sub	sp, sp, #20	; 0x14
21f103d4:	e50b0018 	str	r0, [fp, #-24]
21f103d8:	e50b101c 	str	r1, [fp, #-28]
	char addr_valid = 0;
21f103dc:	e3a03000 	mov	r3, #0	; 0x0
21f103e0:	e54b3011 	strb	r3, [fp, #-17]
	int i;

	for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++)
21f103e4:	e3a03000 	mov	r3, #0	; 0x0
21f103e8:	e50b3010 	str	r3, [fp, #-16]
21f103ec:	ea000014 	b	21f10444 <AT91F_DataflashSelect+0x80>
		if ((*addr & 0xFF000000) == dataflash_info[i].logical_address) {
21f103f0:	e51b301c 	ldr	r3, [fp, #-28]
21f103f4:	e5933000 	ldr	r3, [r3]
21f103f8:	e203c4ff 	and	ip, r3, #-16777216	; 0xff000000
21f103fc:	e51b2010 	ldr	r2, [fp, #-16]
21f10400:	e59f1108 	ldr	r1, [pc, #264]	; 21f10510 <.text+0x10510>
21f10404:	e3a00070 	mov	r0, #112	; 0x70
21f10408:	e1a03002 	mov	r3, r2
21f1040c:	e1a03203 	mov	r3, r3, lsl #4
21f10410:	e0623003 	rsb	r3, r2, r3
21f10414:	e1a03183 	mov	r3, r3, lsl #3
21f10418:	e0833001 	add	r3, r3, r1
21f1041c:	e0833000 	add	r3, r3, r0
21f10420:	e5933000 	ldr	r3, [r3]
21f10424:	e15c0003 	cmp	ip, r3
21f10428:	1a000002 	bne	21f10438 <AT91F_DataflashSelect+0x74>
			addr_valid = 1;
21f1042c:	e3a03001 	mov	r3, #1	; 0x1
21f10430:	e54b3011 	strb	r3, [fp, #-17]
			break;
21f10434:	ea000005 	b	21f10450 <AT91F_DataflashSelect+0x8c>
21f10438:	e51b3010 	ldr	r3, [fp, #-16]
21f1043c:	e2833001 	add	r3, r3, #1	; 0x1
21f10440:	e50b3010 	str	r3, [fp, #-16]
21f10444:	e51b3010 	ldr	r3, [fp, #-16]
21f10448:	e3530001 	cmp	r3, #1	; 0x1
21f1044c:	daffffe7 	ble	21f103f0 <AT91F_DataflashSelect+0x2c>
		}
	if (!addr_valid) {
21f10450:	e55b3011 	ldrb	r3, [fp, #-17]
21f10454:	e3530000 	cmp	r3, #0	; 0x0
21f10458:	1a000004 	bne	21f10470 <AT91F_DataflashSelect+0xac>
		pFlash = (AT91PS_DataFlash) 0;
21f1045c:	e3a03000 	mov	r3, #0	; 0x0
21f10460:	e50b3018 	str	r3, [fp, #-24]
		return pFlash;
21f10464:	e51b3018 	ldr	r3, [fp, #-24]
21f10468:	e50b3020 	str	r3, [fp, #-32]
21f1046c:	ea000023 	b	21f10500 <AT91F_DataflashSelect+0x13c>
	}
	pFlash->pDataFlashDesc = &(dataflash_info[i].Desc);
21f10470:	e51b2010 	ldr	r2, [fp, #-16]
21f10474:	e1a03002 	mov	r3, r2
21f10478:	e1a03203 	mov	r3, r3, lsl #4
21f1047c:	e0623003 	rsb	r3, r2, r3
21f10480:	e1a02183 	mov	r2, r3, lsl #3
21f10484:	e59f3084 	ldr	r3, [pc, #132]	; 21f10510 <.text+0x10510>
21f10488:	e0822003 	add	r2, r2, r3
21f1048c:	e51b3018 	ldr	r3, [fp, #-24]
21f10490:	e5832000 	str	r2, [r3]
	pFlash->pDevice = &(dataflash_info[i].Device);
21f10494:	e51b2010 	ldr	r2, [fp, #-16]
21f10498:	e1a03002 	mov	r3, r2
21f1049c:	e1a03203 	mov	r3, r3, lsl #4
21f104a0:	e0623003 	rsb	r3, r2, r3
21f104a4:	e1a03183 	mov	r3, r3, lsl #3
21f104a8:	e283202c 	add	r2, r3, #44	; 0x2c
21f104ac:	e59f305c 	ldr	r3, [pc, #92]	; 21f10510 <.text+0x10510>
21f104b0:	e0822003 	add	r2, r2, r3
21f104b4:	e51b3018 	ldr	r3, [fp, #-24]
21f104b8:	e5832004 	str	r2, [r3, #4]
	*addr -= dataflash_info[i].logical_address;
21f104bc:	e51b301c 	ldr	r3, [fp, #-28]
21f104c0:	e593c000 	ldr	ip, [r3]
21f104c4:	e51b2010 	ldr	r2, [fp, #-16]
21f104c8:	e59f1040 	ldr	r1, [pc, #64]	; 21f10510 <.text+0x10510>
21f104cc:	e3a00070 	mov	r0, #112	; 0x70
21f104d0:	e1a03002 	mov	r3, r2
21f104d4:	e1a03203 	mov	r3, r3, lsl #4
21f104d8:	e0623003 	rsb	r3, r2, r3
21f104dc:	e1a03183 	mov	r3, r3, lsl #3
21f104e0:	e0833001 	add	r3, r3, r1
21f104e4:	e0833000 	add	r3, r3, r0
21f104e8:	e5933000 	ldr	r3, [r3]
21f104ec:	e063200c 	rsb	r2, r3, ip
21f104f0:	e51b301c 	ldr	r3, [fp, #-28]
21f104f4:	e5832000 	str	r2, [r3]
	return (pFlash);
21f104f8:	e51b3018 	ldr	r3, [fp, #-24]
21f104fc:	e50b3020 	str	r3, [fp, #-32]
21f10500:	e51b3020 	ldr	r3, [fp, #-32]
}
21f10504:	e1a00003 	mov	r0, r3
21f10508:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1050c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f10510:	21f6736c 	mvncss	r7, ip, ror #6

21f10514 <addr_dataflash>:

/*------------------------------------------------------------------------------*/
/* Function Name       : addr_dataflash 					*/
/* Object              : Test if address is valid				*/
/*------------------------------------------------------------------------------*/
int addr_dataflash (unsigned long addr)
{
21f10514:	e1a0c00d 	mov	ip, sp
21f10518:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1051c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10520:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f10524:	e50b0018 	str	r0, [fp, #-24]
	int addr_valid = 0;
21f10528:	e3a03000 	mov	r3, #0	; 0x0
21f1052c:	e50b3014 	str	r3, [fp, #-20]
	int i;

	for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++) {
21f10530:	e3a03000 	mov	r3, #0	; 0x0
21f10534:	e50b3010 	str	r3, [fp, #-16]
21f10538:	ea000013 	b	21f1058c <addr_dataflash+0x78>
		if ((((int) addr) & 0xFF000000) ==
21f1053c:	e51b3018 	ldr	r3, [fp, #-24]
21f10540:	e203c4ff 	and	ip, r3, #-16777216	; 0xff000000
21f10544:	e51b2010 	ldr	r2, [fp, #-16]
21f10548:	e59f1058 	ldr	r1, [pc, #88]	; 21f105a8 <.text+0x105a8>
21f1054c:	e3a00070 	mov	r0, #112	; 0x70
21f10550:	e1a03002 	mov	r3, r2
21f10554:	e1a03203 	mov	r3, r3, lsl #4
21f10558:	e0623003 	rsb	r3, r2, r3
21f1055c:	e1a03183 	mov	r3, r3, lsl #3
21f10560:	e0833001 	add	r3, r3, r1
21f10564:	e0833000 	add	r3, r3, r0
21f10568:	e5933000 	ldr	r3, [r3]
21f1056c:	e15c0003 	cmp	ip, r3
21f10570:	1a000002 	bne	21f10580 <addr_dataflash+0x6c>
			dataflash_info[i].logical_address) {
			addr_valid = 1;
21f10574:	e3a03001 	mov	r3, #1	; 0x1
21f10578:	e50b3014 	str	r3, [fp, #-20]
			break;
21f1057c:	ea000005 	b	21f10598 <addr_dataflash+0x84>
21f10580:	e51b3010 	ldr	r3, [fp, #-16]
21f10584:	e2833001 	add	r3, r3, #1	; 0x1
21f10588:	e50b3010 	str	r3, [fp, #-16]
21f1058c:	e51b3010 	ldr	r3, [fp, #-16]
21f10590:	e3530001 	cmp	r3, #1	; 0x1
21f10594:	daffffe8 	ble	21f1053c <addr_dataflash+0x28>
		}
	}

	return addr_valid;
21f10598:	e51b3014 	ldr	r3, [fp, #-20]
}
21f1059c:	e1a00003 	mov	r0, r3
21f105a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f105a4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f105a8:	21f6736c 	mvncss	r7, ip, ror #6

21f105ac <size_dataflash>:
/*-----------------------------------------------------------------------------*/
/* Function Name       : size_dataflash 					*/
/* Object              : Test if address is valid regarding the size		*/
/*-----------------------------------------------------------------------------*/
int size_dataflash (AT91PS_DataFlash pdataFlash, unsigned long addr, unsigned long size)
{
21f105ac:	e1a0c00d 	mov	ip, sp
21f105b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f105b4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f105b8:	e24dd010 	sub	sp, sp, #16	; 0x10
21f105bc:	e50b0010 	str	r0, [fp, #-16]
21f105c0:	e50b1014 	str	r1, [fp, #-20]
21f105c4:	e50b2018 	str	r2, [fp, #-24]
	/* is outside the dataflash */
	if (((int)addr & 0x0FFFFFFF) > (pdataFlash->pDevice->pages_size *
21f105c8:	e51b3014 	ldr	r3, [fp, #-20]
21f105cc:	e3c3120f 	bic	r1, r3, #-268435456	; 0xf0000000
21f105d0:	e51b3010 	ldr	r3, [fp, #-16]
21f105d4:	e5933004 	ldr	r3, [r3, #4]
21f105d8:	e5932004 	ldr	r2, [r3, #4]
21f105dc:	e51b3010 	ldr	r3, [fp, #-16]
21f105e0:	e5933004 	ldr	r3, [r3, #4]
21f105e4:	e5933000 	ldr	r3, [r3]
21f105e8:	e0030392 	mul	r3, r2, r3
21f105ec:	e1510003 	cmp	r1, r3
21f105f0:	da000002 	ble	21f10600 <size_dataflash+0x54>
		pdataFlash->pDevice->pages_number)) return 0;
21f105f4:	e3a03000 	mov	r3, #0	; 0x0
21f105f8:	e50b301c 	str	r3, [fp, #-28]
21f105fc:	ea000012 	b	21f1064c <size_dataflash+0xa0>
	/* is too large for the dataflash */
	if (size > ((pdataFlash->pDevice->pages_size *
21f10600:	e51b3010 	ldr	r3, [fp, #-16]
21f10604:	e5933004 	ldr	r3, [r3, #4]
21f10608:	e5932004 	ldr	r2, [r3, #4]
21f1060c:	e51b3010 	ldr	r3, [fp, #-16]
21f10610:	e5933004 	ldr	r3, [r3, #4]
21f10614:	e5933000 	ldr	r3, [r3]
21f10618:	e0020293 	mul	r2, r3, r2
21f1061c:	e51b3014 	ldr	r3, [fp, #-20]
21f10620:	e3c3320f 	bic	r3, r3, #-268435456	; 0xf0000000
21f10624:	e0633002 	rsb	r3, r3, r2
21f10628:	e1a02003 	mov	r2, r3
21f1062c:	e51b3018 	ldr	r3, [fp, #-24]
21f10630:	e1520003 	cmp	r2, r3
21f10634:	2a000002 	bcs	21f10644 <size_dataflash+0x98>
		pdataFlash->pDevice->pages_number) - ((int)addr & 0x0FFFFFFF))) return 0;
21f10638:	e3a03000 	mov	r3, #0	; 0x0
21f1063c:	e50b301c 	str	r3, [fp, #-28]
21f10640:	ea000001 	b	21f1064c <size_dataflash+0xa0>

	return 1;
21f10644:	e3a03001 	mov	r3, #1	; 0x1
21f10648:	e50b301c 	str	r3, [fp, #-28]
21f1064c:	e51b301c 	ldr	r3, [fp, #-28]
}
21f10650:	e1a00003 	mov	r0, r3
21f10654:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f10658:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1065c <prot_dataflash>:
/*-----------------------------------------------------------------------------*/
/* Function Name       : prot_dataflash 					*/
/* Object              : Test if destination area is protected			*/
/*-----------------------------------------------------------------------------*/
int prot_dataflash (AT91PS_DataFlash pdataFlash, unsigned long addr)
{
21f1065c:	e1a0c00d 	mov	ip, sp
21f10660:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10664:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10668:	e24dd010 	sub	sp, sp, #16	; 0x10
21f1066c:	e50b0014 	str	r0, [fp, #-20]
21f10670:	e50b1018 	str	r1, [fp, #-24]
int area;
	/* find area */
	for (area=0; area < NB_DATAFLASH_AREA; area++) {
21f10674:	e3a03000 	mov	r3, #0	; 0x0
21f10678:	e50b3010 	str	r3, [fp, #-16]
21f1067c:	ea00001e 	b	21f106fc <prot_dataflash+0xa0>
		if ((addr >= pdataFlash->pDevice->area_list[area].start) &&
21f10680:	e51b3014 	ldr	r3, [fp, #-20]
21f10684:	e5931004 	ldr	r1, [r3, #4]
21f10688:	e51b2010 	ldr	r2, [fp, #-16]
21f1068c:	e3a00014 	mov	r0, #20	; 0x14
21f10690:	e1a03002 	mov	r3, r2
21f10694:	e1a03083 	mov	r3, r3, lsl #1
21f10698:	e0833002 	add	r3, r3, r2
21f1069c:	e1a03103 	mov	r3, r3, lsl #2
21f106a0:	e0833001 	add	r3, r3, r1
21f106a4:	e0833000 	add	r3, r3, r0
21f106a8:	e5932000 	ldr	r2, [r3]
21f106ac:	e51b3018 	ldr	r3, [fp, #-24]
21f106b0:	e1520003 	cmp	r2, r3
21f106b4:	8a00000d 	bhi	21f106f0 <prot_dataflash+0x94>
21f106b8:	e51b3014 	ldr	r3, [fp, #-20]
21f106bc:	e5931004 	ldr	r1, [r3, #4]
21f106c0:	e51b2010 	ldr	r2, [fp, #-16]
21f106c4:	e3a00018 	mov	r0, #24	; 0x18
21f106c8:	e1a03002 	mov	r3, r2
21f106cc:	e1a03083 	mov	r3, r3, lsl #1
21f106d0:	e0833002 	add	r3, r3, r2
21f106d4:	e1a03103 	mov	r3, r3, lsl #2
21f106d8:	e0833001 	add	r3, r3, r1
21f106dc:	e0833000 	add	r3, r3, r0
21f106e0:	e5932000 	ldr	r2, [r3]
21f106e4:	e51b3018 	ldr	r3, [fp, #-24]
21f106e8:	e1520003 	cmp	r2, r3
21f106ec:	8a000005 	bhi	21f10708 <prot_dataflash+0xac>
21f106f0:	e51b3010 	ldr	r3, [fp, #-16]
21f106f4:	e2833001 	add	r3, r3, #1	; 0x1
21f106f8:	e50b3010 	str	r3, [fp, #-16]
21f106fc:	e51b3010 	ldr	r3, [fp, #-16]
21f10700:	e3530003 	cmp	r3, #3	; 0x3
21f10704:	daffffdd 	ble	21f10680 <prot_dataflash+0x24>
			(addr < pdataFlash->pDevice->area_list[area].end))
			break;
	}
	if (area == NB_DATAFLASH_AREA) return -1;
21f10708:	e51b3010 	ldr	r3, [fp, #-16]
21f1070c:	e3530004 	cmp	r3, #4	; 0x4
21f10710:	1a000002 	bne	21f10720 <prot_dataflash+0xc4>
21f10714:	e3e03000 	mvn	r3, #0	; 0x0
21f10718:	e50b301c 	str	r3, [fp, #-28]
21f1071c:	ea000011 	b	21f10768 <prot_dataflash+0x10c>
	/*test protection value*/
	if (pdataFlash->pDevice->area_list[area].protected == FLAG_PROTECT_SET) return 0;
21f10720:	e51b3014 	ldr	r3, [fp, #-20]
21f10724:	e5931004 	ldr	r1, [r3, #4]
21f10728:	e51b2010 	ldr	r2, [fp, #-16]
21f1072c:	e3a0001c 	mov	r0, #28	; 0x1c
21f10730:	e1a03002 	mov	r3, r2
21f10734:	e1a03083 	mov	r3, r3, lsl #1
21f10738:	e0833002 	add	r3, r3, r2
21f1073c:	e1a03103 	mov	r3, r3, lsl #2
21f10740:	e0833001 	add	r3, r3, r1
21f10744:	e0833000 	add	r3, r3, r0
21f10748:	e5d33000 	ldrb	r3, [r3]
21f1074c:	e3530001 	cmp	r3, #1	; 0x1
21f10750:	1a000002 	bne	21f10760 <prot_dataflash+0x104>
21f10754:	e3a03000 	mov	r3, #0	; 0x0
21f10758:	e50b301c 	str	r3, [fp, #-28]
21f1075c:	ea000001 	b	21f10768 <prot_dataflash+0x10c>

	return 1;
21f10760:	e3a03001 	mov	r3, #1	; 0x1
21f10764:	e50b301c 	str	r3, [fp, #-28]
21f10768:	e51b301c 	ldr	r3, [fp, #-28]
}
21f1076c:	e1a00003 	mov	r0, r3
21f10770:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f10774:	e89da800 	ldmia	sp, {fp, sp, pc}

21f10778 <dataflash_real_protect>:
/*-----------------------------------------------------------------------------*/
/* Function Name       : dataflash_real_protect				*/
/* Object              : protect/unprotect area				*/
/*-----------------------------------------------------------------------------*/
int dataflash_real_protect (int flag, unsigned long start_addr, unsigned long end_addr)
{
21f10778:	e1a0c00d 	mov	ip, sp
21f1077c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10780:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10784:	e24dd024 	sub	sp, sp, #36	; 0x24
21f10788:	e50b0024 	str	r0, [fp, #-36]
21f1078c:	e50b1028 	str	r1, [fp, #-40]
21f10790:	e50b202c 	str	r2, [fp, #-44]
int i,j, area1, area2, addr_valid = 0;
21f10794:	e3a03000 	mov	r3, #0	; 0x0
21f10798:	e50b3010 	str	r3, [fp, #-16]
	/* find dataflash */
	for (i = 0; i < CFG_MAX_DATAFLASH_BANKS; i++) {
21f1079c:	e3a03000 	mov	r3, #0	; 0x0
21f107a0:	e50b3020 	str	r3, [fp, #-32]
21f107a4:	ea000013 	b	21f107f8 <dataflash_real_protect+0x80>
		if ((((int) start_addr) & 0xF0000000) ==
21f107a8:	e51b3028 	ldr	r3, [fp, #-40]
21f107ac:	e203c20f 	and	ip, r3, #-268435456	; 0xf0000000
21f107b0:	e51b2020 	ldr	r2, [fp, #-32]
21f107b4:	e59f1258 	ldr	r1, [pc, #600]	; 21f10a14 <.text+0x10a14>
21f107b8:	e3a00070 	mov	r0, #112	; 0x70
21f107bc:	e1a03002 	mov	r3, r2
21f107c0:	e1a03203 	mov	r3, r3, lsl #4
21f107c4:	e0623003 	rsb	r3, r2, r3
21f107c8:	e1a03183 	mov	r3, r3, lsl #3
21f107cc:	e0833001 	add	r3, r3, r1
21f107d0:	e0833000 	add	r3, r3, r0
21f107d4:	e5933000 	ldr	r3, [r3]
21f107d8:	e15c0003 	cmp	ip, r3
21f107dc:	1a000002 	bne	21f107ec <dataflash_real_protect+0x74>
			dataflash_info[i].logical_address) {
				addr_valid = 1;
21f107e0:	e3a03001 	mov	r3, #1	; 0x1
21f107e4:	e50b3010 	str	r3, [fp, #-16]
				break;
21f107e8:	ea000005 	b	21f10804 <dataflash_real_protect+0x8c>
21f107ec:	e51b3020 	ldr	r3, [fp, #-32]
21f107f0:	e2833001 	add	r3, r3, #1	; 0x1
21f107f4:	e50b3020 	str	r3, [fp, #-32]
21f107f8:	e51b3020 	ldr	r3, [fp, #-32]
21f107fc:	e3530001 	cmp	r3, #1	; 0x1
21f10800:	daffffe8 	ble	21f107a8 <dataflash_real_protect+0x30>
		}
	}
	if (!addr_valid) {
21f10804:	e51b3010 	ldr	r3, [fp, #-16]
21f10808:	e3530000 	cmp	r3, #0	; 0x0
21f1080c:	1a000002 	bne	21f1081c <dataflash_real_protect+0xa4>
		return -1;
21f10810:	e3e03000 	mvn	r3, #0	; 0x0
21f10814:	e50b3030 	str	r3, [fp, #-48]
21f10818:	ea000079 	b	21f10a04 <dataflash_real_protect+0x28c>
	}
	/* find start area */
	for (area1=0; area1 < NB_DATAFLASH_AREA; area1++) {
21f1081c:	e3a03000 	mov	r3, #0	; 0x0
21f10820:	e50b3018 	str	r3, [fp, #-24]
21f10824:	ea000015 	b	21f10880 <dataflash_real_protect+0x108>
		if (start_addr == dataflash_info[i].Device.area_list[area1].start) break;
21f10828:	e51b1020 	ldr	r1, [fp, #-32]
21f1082c:	e51b2018 	ldr	r2, [fp, #-24]
21f10830:	e59f01dc 	ldr	r0, [pc, #476]	; 21f10a14 <.text+0x10a14>
21f10834:	e3a0c040 	mov	ip, #64	; 0x40
21f10838:	e1a03002 	mov	r3, r2
21f1083c:	e1a03083 	mov	r3, r3, lsl #1
21f10840:	e0833002 	add	r3, r3, r2
21f10844:	e1a02103 	mov	r2, r3, lsl #2
21f10848:	e1a03001 	mov	r3, r1
21f1084c:	e1a03203 	mov	r3, r3, lsl #4
21f10850:	e0613003 	rsb	r3, r1, r3
21f10854:	e1a03183 	mov	r3, r3, lsl #3
21f10858:	e0823003 	add	r3, r2, r3
21f1085c:	e0833000 	add	r3, r3, r0
21f10860:	e083300c 	add	r3, r3, ip
21f10864:	e5932000 	ldr	r2, [r3]
21f10868:	e51b3028 	ldr	r3, [fp, #-40]
21f1086c:	e1520003 	cmp	r2, r3
21f10870:	0a000005 	beq	21f1088c <dataflash_real_protect+0x114>
21f10874:	e51b3018 	ldr	r3, [fp, #-24]
21f10878:	e2833001 	add	r3, r3, #1	; 0x1
21f1087c:	e50b3018 	str	r3, [fp, #-24]
21f10880:	e51b3018 	ldr	r3, [fp, #-24]
21f10884:	e3530003 	cmp	r3, #3	; 0x3
21f10888:	daffffe6 	ble	21f10828 <dataflash_real_protect+0xb0>
	}
	if (area1 == NB_DATAFLASH_AREA) return -1;
21f1088c:	e51b3018 	ldr	r3, [fp, #-24]
21f10890:	e3530004 	cmp	r3, #4	; 0x4
21f10894:	1a000002 	bne	21f108a4 <dataflash_real_protect+0x12c>
21f10898:	e3e03000 	mvn	r3, #0	; 0x0
21f1089c:	e50b3030 	str	r3, [fp, #-48]
21f108a0:	ea000057 	b	21f10a04 <dataflash_real_protect+0x28c>
	/* find end area */
	for (area2=0; area2 < NB_DATAFLASH_AREA; area2++) {
21f108a4:	e3a03000 	mov	r3, #0	; 0x0
21f108a8:	e50b3014 	str	r3, [fp, #-20]
21f108ac:	ea000015 	b	21f10908 <dataflash_real_protect+0x190>
		if (end_addr == dataflash_info[i].Device.area_list[area2].end) break;
21f108b0:	e51b1020 	ldr	r1, [fp, #-32]
21f108b4:	e51b2014 	ldr	r2, [fp, #-20]
21f108b8:	e59f0154 	ldr	r0, [pc, #340]	; 21f10a14 <.text+0x10a14>
21f108bc:	e3a0c044 	mov	ip, #68	; 0x44
21f108c0:	e1a03002 	mov	r3, r2
21f108c4:	e1a03083 	mov	r3, r3, lsl #1
21f108c8:	e0833002 	add	r3, r3, r2
21f108cc:	e1a02103 	mov	r2, r3, lsl #2
21f108d0:	e1a03001 	mov	r3, r1
21f108d4:	e1a03203 	mov	r3, r3, lsl #4
21f108d8:	e0613003 	rsb	r3, r1, r3
21f108dc:	e1a03183 	mov	r3, r3, lsl #3
21f108e0:	e0823003 	add	r3, r2, r3
21f108e4:	e0833000 	add	r3, r3, r0
21f108e8:	e083300c 	add	r3, r3, ip
21f108ec:	e5932000 	ldr	r2, [r3]
21f108f0:	e51b302c 	ldr	r3, [fp, #-44]
21f108f4:	e1520003 	cmp	r2, r3
21f108f8:	0a000005 	beq	21f10914 <dataflash_real_protect+0x19c>
21f108fc:	e51b3014 	ldr	r3, [fp, #-20]
21f10900:	e2833001 	add	r3, r3, #1	; 0x1
21f10904:	e50b3014 	str	r3, [fp, #-20]
21f10908:	e51b3014 	ldr	r3, [fp, #-20]
21f1090c:	e3530003 	cmp	r3, #3	; 0x3
21f10910:	daffffe6 	ble	21f108b0 <dataflash_real_protect+0x138>
	}
	if (area2 == NB_DATAFLASH_AREA) return -1;
21f10914:	e51b3014 	ldr	r3, [fp, #-20]
21f10918:	e3530004 	cmp	r3, #4	; 0x4
21f1091c:	1a000002 	bne	21f1092c <dataflash_real_protect+0x1b4>
21f10920:	e3e03000 	mvn	r3, #0	; 0x0
21f10924:	e50b3030 	str	r3, [fp, #-48]
21f10928:	ea000035 	b	21f10a04 <dataflash_real_protect+0x28c>

	/*set protection value*/
	for(j = area1; j < area2+1 ; j++)
21f1092c:	e51b3018 	ldr	r3, [fp, #-24]
21f10930:	e50b301c 	str	r3, [fp, #-28]
21f10934:	ea000028 	b	21f109dc <dataflash_real_protect+0x264>
		if (flag == 0) dataflash_info[i].Device.area_list[j].protected = FLAG_PROTECT_CLEAR;
21f10938:	e51b3024 	ldr	r3, [fp, #-36]
21f1093c:	e3530000 	cmp	r3, #0	; 0x0
21f10940:	1a000011 	bne	21f1098c <dataflash_real_protect+0x214>
21f10944:	e51b1020 	ldr	r1, [fp, #-32]
21f10948:	e51b201c 	ldr	r2, [fp, #-28]
21f1094c:	e59f00c0 	ldr	r0, [pc, #192]	; 21f10a14 <.text+0x10a14>
21f10950:	e3a0c048 	mov	ip, #72	; 0x48
21f10954:	e1a03002 	mov	r3, r2
21f10958:	e1a03083 	mov	r3, r3, lsl #1
21f1095c:	e0833002 	add	r3, r3, r2
21f10960:	e1a02103 	mov	r2, r3, lsl #2
21f10964:	e1a03001 	mov	r3, r1
21f10968:	e1a03203 	mov	r3, r3, lsl #4
21f1096c:	e0613003 	rsb	r3, r1, r3
21f10970:	e1a03183 	mov	r3, r3, lsl #3
21f10974:	e0823003 	add	r3, r2, r3
21f10978:	e0833000 	add	r3, r3, r0
21f1097c:	e083200c 	add	r2, r3, ip
21f10980:	e3a03002 	mov	r3, #2	; 0x2
21f10984:	e5c23000 	strb	r3, [r2]
21f10988:	ea000010 	b	21f109d0 <dataflash_real_protect+0x258>
		else dataflash_info[i].Device.area_list[j].protected = FLAG_PROTECT_SET;
21f1098c:	e51b1020 	ldr	r1, [fp, #-32]
21f10990:	e51b201c 	ldr	r2, [fp, #-28]
21f10994:	e59f0078 	ldr	r0, [pc, #120]	; 21f10a14 <.text+0x10a14>
21f10998:	e3a0c048 	mov	ip, #72	; 0x48
21f1099c:	e1a03002 	mov	r3, r2
21f109a0:	e1a03083 	mov	r3, r3, lsl #1
21f109a4:	e0833002 	add	r3, r3, r2
21f109a8:	e1a02103 	mov	r2, r3, lsl #2
21f109ac:	e1a03001 	mov	r3, r1
21f109b0:	e1a03203 	mov	r3, r3, lsl #4
21f109b4:	e0613003 	rsb	r3, r1, r3
21f109b8:	e1a03183 	mov	r3, r3, lsl #3
21f109bc:	e0823003 	add	r3, r2, r3
21f109c0:	e0833000 	add	r3, r3, r0
21f109c4:	e083200c 	add	r2, r3, ip
21f109c8:	e3a03001 	mov	r3, #1	; 0x1
21f109cc:	e5c23000 	strb	r3, [r2]
21f109d0:	e51b301c 	ldr	r3, [fp, #-28]
21f109d4:	e2833001 	add	r3, r3, #1	; 0x1
21f109d8:	e50b301c 	str	r3, [fp, #-28]
21f109dc:	e51b3014 	ldr	r3, [fp, #-20]
21f109e0:	e2832001 	add	r2, r3, #1	; 0x1
21f109e4:	e51b301c 	ldr	r3, [fp, #-28]
21f109e8:	e1520003 	cmp	r2, r3
21f109ec:	caffffd1 	bgt	21f10938 <dataflash_real_protect+0x1c0>

	return (area2-area1+1);
21f109f0:	e51b3014 	ldr	r3, [fp, #-20]
21f109f4:	e51b2018 	ldr	r2, [fp, #-24]
21f109f8:	e0623003 	rsb	r3, r2, r3
21f109fc:	e2833001 	add	r3, r3, #1	; 0x1
21f10a00:	e50b3030 	str	r3, [fp, #-48]
21f10a04:	e51b3030 	ldr	r3, [fp, #-48]
}
21f10a08:	e1a00003 	mov	r0, r3
21f10a0c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f10a10:	e89da800 	ldmia	sp, {fp, sp, pc}
21f10a14:	21f6736c 	mvncss	r7, ip, ror #6

21f10a18 <read_dataflash>:

/*------------------------------------------------------------------------------*/
/* Function Name       : read_dataflash 					*/
/* Object              : dataflash memory read					*/
/*------------------------------------------------------------------------------*/
int read_dataflash (unsigned long addr, unsigned long size, char *result)
{
21f10a18:	e1a0c00d 	mov	ip, sp
21f10a1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10a20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10a24:	e24dd018 	sub	sp, sp, #24	; 0x18
21f10a28:	e50b0018 	str	r0, [fp, #-24]
21f10a2c:	e50b101c 	str	r1, [fp, #-28]
21f10a30:	e50b2020 	str	r2, [fp, #-32]
	unsigned long AddrToRead = addr;
21f10a34:	e51b3018 	ldr	r3, [fp, #-24]
21f10a38:	e50b3014 	str	r3, [fp, #-20]
	AT91PS_DataFlash pFlash = &DataFlashInst;
21f10a3c:	e59f3088 	ldr	r3, [pc, #136]	; 21f10acc <.text+0x10acc>
21f10a40:	e50b3010 	str	r3, [fp, #-16]

	pFlash = AT91F_DataflashSelect (pFlash, &AddrToRead);
21f10a44:	e24b3014 	sub	r3, fp, #20	; 0x14
21f10a48:	e51b0010 	ldr	r0, [fp, #-16]
21f10a4c:	e1a01003 	mov	r1, r3
21f10a50:	ebfffe5b 	bl	21f103c4 <AT91F_DataflashSelect>
21f10a54:	e1a03000 	mov	r3, r0
21f10a58:	e50b3010 	str	r3, [fp, #-16]

	if (pFlash == 0)
21f10a5c:	e51b3010 	ldr	r3, [fp, #-16]
21f10a60:	e3530000 	cmp	r3, #0	; 0x0
21f10a64:	1a000002 	bne	21f10a74 <read_dataflash+0x5c>
		return ERR_UNKNOWN_FLASH_TYPE;
21f10a68:	e3a03040 	mov	r3, #64	; 0x40
21f10a6c:	e50b3024 	str	r3, [fp, #-36]
21f10a70:	ea000011 	b	21f10abc <read_dataflash+0xa4>

	if (size_dataflash(pFlash,addr,size) == 0)
21f10a74:	e51b0010 	ldr	r0, [fp, #-16]
21f10a78:	e51b1018 	ldr	r1, [fp, #-24]
21f10a7c:	e51b201c 	ldr	r2, [fp, #-28]
21f10a80:	ebfffec9 	bl	21f105ac <size_dataflash>
21f10a84:	e1a03000 	mov	r3, r0
21f10a88:	e3530000 	cmp	r3, #0	; 0x0
21f10a8c:	1a000002 	bne	21f10a9c <read_dataflash+0x84>
		return ERR_INVAL;
21f10a90:	e3a03008 	mov	r3, #8	; 0x8
21f10a94:	e50b3024 	str	r3, [fp, #-36]
21f10a98:	ea000007 	b	21f10abc <read_dataflash+0xa4>

	return (AT91F_DataFlashRead (pFlash, AddrToRead, size, result));
21f10a9c:	e51b3014 	ldr	r3, [fp, #-20]
21f10aa0:	e51b0010 	ldr	r0, [fp, #-16]
21f10aa4:	e1a01003 	mov	r1, r3
21f10aa8:	e51b201c 	ldr	r2, [fp, #-28]
21f10aac:	e51b3020 	ldr	r3, [fp, #-32]
21f10ab0:	eb006da1 	bl	21f2c13c <AT91F_DataFlashRead>
21f10ab4:	e1a03000 	mov	r3, r0
21f10ab8:	e50b3024 	str	r3, [fp, #-36]
21f10abc:	e51b3024 	ldr	r3, [fp, #-36]
}
21f10ac0:	e1a00003 	mov	r0, r3
21f10ac4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f10ac8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f10acc:	21f6745c 	mvncss	r7, ip, asr r4

21f10ad0 <write_dataflash>:


/*-----------------------------------------------------------------------------*/
/* Function Name       : write_dataflash 				       */
/* Object              : write a block in dataflash			       */
/*-----------------------------------------------------------------------------*/
int write_dataflash (unsigned long addr_dest, unsigned long addr_src,
		     unsigned long size)
{
21f10ad0:	e1a0c00d 	mov	ip, sp
21f10ad4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10ad8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10adc:	e24dd018 	sub	sp, sp, #24	; 0x18
21f10ae0:	e50b0018 	str	r0, [fp, #-24]
21f10ae4:	e50b101c 	str	r1, [fp, #-28]
21f10ae8:	e50b2020 	str	r2, [fp, #-32]
	unsigned long AddrToWrite = addr_dest;
21f10aec:	e51b3018 	ldr	r3, [fp, #-24]
21f10af0:	e50b3014 	str	r3, [fp, #-20]
	AT91PS_DataFlash pFlash = &DataFlashInst;
21f10af4:	e59f30cc 	ldr	r3, [pc, #204]	; 21f10bc8 <.text+0x10bc8>
21f10af8:	e50b3010 	str	r3, [fp, #-16]

	pFlash = AT91F_DataflashSelect (pFlash, &AddrToWrite);
21f10afc:	e24b3014 	sub	r3, fp, #20	; 0x14
21f10b00:	e51b0010 	ldr	r0, [fp, #-16]
21f10b04:	e1a01003 	mov	r1, r3
21f10b08:	ebfffe2d 	bl	21f103c4 <AT91F_DataflashSelect>
21f10b0c:	e1a03000 	mov	r3, r0
21f10b10:	e50b3010 	str	r3, [fp, #-16]

	if (pFlash == 0)
21f10b14:	e51b3010 	ldr	r3, [fp, #-16]
21f10b18:	e3530000 	cmp	r3, #0	; 0x0
21f10b1c:	1a000002 	bne	21f10b2c <write_dataflash+0x5c>
		return ERR_UNKNOWN_FLASH_TYPE;
21f10b20:	e3a03040 	mov	r3, #64	; 0x40
21f10b24:	e50b3024 	str	r3, [fp, #-36]
21f10b28:	ea000022 	b	21f10bb8 <write_dataflash+0xe8>

	if (size_dataflash(pFlash,addr_dest,size) == 0)
21f10b2c:	e51b0010 	ldr	r0, [fp, #-16]
21f10b30:	e51b1018 	ldr	r1, [fp, #-24]
21f10b34:	e51b2020 	ldr	r2, [fp, #-32]
21f10b38:	ebfffe9b 	bl	21f105ac <size_dataflash>
21f10b3c:	e1a03000 	mov	r3, r0
21f10b40:	e3530000 	cmp	r3, #0	; 0x0
21f10b44:	1a000002 	bne	21f10b54 <write_dataflash+0x84>
		return ERR_INVAL;
21f10b48:	e3a03008 	mov	r3, #8	; 0x8
21f10b4c:	e50b3024 	str	r3, [fp, #-36]
21f10b50:	ea000018 	b	21f10bb8 <write_dataflash+0xe8>

	if (prot_dataflash(pFlash,addr_dest) == 0)
21f10b54:	e51b0010 	ldr	r0, [fp, #-16]
21f10b58:	e51b1018 	ldr	r1, [fp, #-24]
21f10b5c:	ebfffebe 	bl	21f1065c <prot_dataflash>
21f10b60:	e1a03000 	mov	r3, r0
21f10b64:	e3530000 	cmp	r3, #0	; 0x0
21f10b68:	1a000002 	bne	21f10b78 <write_dataflash+0xa8>
		return ERR_PROTECTED;
21f10b6c:	e3a03004 	mov	r3, #4	; 0x4
21f10b70:	e50b3024 	str	r3, [fp, #-36]
21f10b74:	ea00000f 	b	21f10bb8 <write_dataflash+0xe8>

	if (AddrToWrite == -1)
21f10b78:	e51b3014 	ldr	r3, [fp, #-20]
21f10b7c:	e3730001 	cmn	r3, #1	; 0x1
21f10b80:	1a000002 	bne	21f10b90 <write_dataflash+0xc0>
		return -1;
21f10b84:	e3e03000 	mvn	r3, #0	; 0x0
21f10b88:	e50b3024 	str	r3, [fp, #-36]
21f10b8c:	ea000009 	b	21f10bb8 <write_dataflash+0xe8>

	return AT91F_DataFlashWrite (pFlash, (uchar *)addr_src, AddrToWrite, size);
21f10b90:	e51b201c 	ldr	r2, [fp, #-28]
21f10b94:	e51b3014 	ldr	r3, [fp, #-20]
21f10b98:	e51bc020 	ldr	ip, [fp, #-32]
21f10b9c:	e51b0010 	ldr	r0, [fp, #-16]
21f10ba0:	e1a01002 	mov	r1, r2
21f10ba4:	e1a02003 	mov	r2, r3
21f10ba8:	e1a0300c 	mov	r3, ip
21f10bac:	eb006c95 	bl	21f2be08 <AT91F_DataFlashWrite>
21f10bb0:	e1a03000 	mov	r3, r0
21f10bb4:	e50b3024 	str	r3, [fp, #-36]
21f10bb8:	e51b3024 	ldr	r3, [fp, #-36]
}
21f10bbc:	e1a00003 	mov	r0, r3
21f10bc0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f10bc4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f10bc8:	21f6745c 	mvncss	r7, ip, asr r4

21f10bcc <dataflash_perror>:


void dataflash_perror (int err)
{
21f10bcc:	e1a0c00d 	mov	ip, sp
21f10bd0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10bd4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10bd8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f10bdc:	e50b0010 	str	r0, [fp, #-16]
	switch (err) {
21f10be0:	e51b3010 	ldr	r3, [fp, #-16]
21f10be4:	e50b3014 	str	r3, [fp, #-20]
21f10be8:	e51b3014 	ldr	r3, [fp, #-20]
21f10bec:	e3530004 	cmp	r3, #4	; 0x4
21f10bf0:	0a000016 	beq	21f10c50 <dataflash_perror+0x84>
21f10bf4:	e51b3014 	ldr	r3, [fp, #-20]
21f10bf8:	e3530004 	cmp	r3, #4	; 0x4
21f10bfc:	ca000006 	bgt	21f10c1c <dataflash_perror+0x50>
21f10c00:	e51b3014 	ldr	r3, [fp, #-20]
21f10c04:	e3530000 	cmp	r3, #0	; 0x0
21f10c08:	0a000022 	beq	21f10c98 <dataflash_perror+0xcc>
21f10c0c:	e51b3014 	ldr	r3, [fp, #-20]
21f10c10:	e3530001 	cmp	r3, #1	; 0x1
21f10c14:	0a00000a 	beq	21f10c44 <dataflash_perror+0x78>
21f10c18:	ea000018 	b	21f10c80 <dataflash_perror+0xb4>
21f10c1c:	e51b3014 	ldr	r3, [fp, #-20]
21f10c20:	e3530040 	cmp	r3, #64	; 0x40
21f10c24:	0a00000f 	beq	21f10c68 <dataflash_perror+0x9c>
21f10c28:	e51b3014 	ldr	r3, [fp, #-20]
21f10c2c:	e3530080 	cmp	r3, #128	; 0x80
21f10c30:	0a00000f 	beq	21f10c74 <dataflash_perror+0xa8>
21f10c34:	e51b3014 	ldr	r3, [fp, #-20]
21f10c38:	e3530008 	cmp	r3, #8	; 0x8
21f10c3c:	0a000006 	beq	21f10c5c <dataflash_perror+0x90>
21f10c40:	ea00000e 	b	21f10c80 <dataflash_perror+0xb4>
	case ERR_OK:
		break;
	case ERR_TIMOUT:
		printf ("Timeout writing to DataFlash\n");
21f10c44:	e59f0054 	ldr	r0, [pc, #84]	; 21f10ca0 <.text+0x10ca0>
21f10c48:	eb002b8f 	bl	21f1ba8c <printf>
		break;
21f10c4c:	ea000011 	b	21f10c98 <dataflash_perror+0xcc>
	case ERR_PROTECTED:
		printf ("Can't write to protected DataFlash sectors\n");
21f10c50:	e59f004c 	ldr	r0, [pc, #76]	; 21f10ca4 <.text+0x10ca4>
21f10c54:	eb002b8c 	bl	21f1ba8c <printf>
		break;
21f10c58:	ea00000e 	b	21f10c98 <dataflash_perror+0xcc>
	case ERR_INVAL:
		printf ("Outside available DataFlash\n");
21f10c5c:	e59f0044 	ldr	r0, [pc, #68]	; 21f10ca8 <.text+0x10ca8>
21f10c60:	eb002b89 	bl	21f1ba8c <printf>
		break;
21f10c64:	ea00000b 	b	21f10c98 <dataflash_perror+0xcc>
	case ERR_UNKNOWN_FLASH_TYPE:
		printf ("Unknown Type of DataFlash\n");
21f10c68:	e59f003c 	ldr	r0, [pc, #60]	; 21f10cac <.text+0x10cac>
21f10c6c:	eb002b86 	bl	21f1ba8c <printf>
		break;
21f10c70:	ea000008 	b	21f10c98 <dataflash_perror+0xcc>
	case ERR_PROG_ERROR:
		printf ("General DataFlash Programming Error\n");
21f10c74:	e59f0034 	ldr	r0, [pc, #52]	; 21f10cb0 <.text+0x10cb0>
21f10c78:	eb002b83 	bl	21f1ba8c <printf>
		break;
21f10c7c:	ea000005 	b	21f10c98 <dataflash_perror+0xcc>
	default:
		printf ("%s[%d] FIXME: rc=%d\n", __FILE__, __LINE__, err);
21f10c80:	e59f002c 	ldr	r0, [pc, #44]	; 21f10cb4 <.text+0x10cb4>
21f10c84:	e59f102c 	ldr	r1, [pc, #44]	; 21f10cb8 <.text+0x10cb8>
21f10c88:	e3a02f59 	mov	r2, #356	; 0x164
21f10c8c:	e2822001 	add	r2, r2, #1	; 0x1
21f10c90:	e51b3010 	ldr	r3, [fp, #-16]
21f10c94:	eb002b7c 	bl	21f1ba8c <printf>
		break;
	}
}
21f10c98:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f10c9c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f10ca0:	21f2feb8 	ldrcsh	pc, [r2, #232]!
21f10ca4:	21f2fed8 	ldrcssb	pc, [r2, #232]!
21f10ca8:	21f2ff04 	mvncss	pc, r4, lsl #30
21f10cac:	21f2ff24 	mvncss	pc, r4, lsr #30
21f10cb0:	21f2ff40 	mvncss	pc, r0, asr #30
21f10cb4:	21f2ff68 	mvncss	pc, r8, ror #30
21f10cb8:	21f2ff80 	mvncss	pc, r0, lsl #31

21f10cbc <main_loop>:

/****************************************************************************/

void main_loop (void)
{
21f10cbc:	e1a0c00d 	mov	ip, sp
21f10cc0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10cc4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10cc8:	e24dd018 	sub	sp, sp, #24	; 0x18
#ifndef CFG_HUSH_PARSER
	static char lastcommand[CFG_CBSIZE] = { 0, };
	int len;
	int rc = 1;
21f10ccc:	e3a03001 	mov	r3, #1	; 0x1
21f10cd0:	e50b301c 	str	r3, [fp, #-28]
	int flag;
#endif

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	char *s;
	int bootdelay;
#endif
#ifdef CONFIG_PREBOOT
	char *p;
#endif
#ifdef CONFIG_BOOTCOUNT_LIMIT
	unsigned long bootcount = 0;
	unsigned long bootlimit = 0;
	char *bcs;
	char bcs_set[16];
#endif /* CONFIG_BOOTCOUNT_LIMIT */

#if defined(CONFIG_VFD) && defined(VFD_TEST_LOGO)
	ulong bmp = 0;		/* default bitmap */
	extern int trab_vfd (ulong bitmap);

#ifdef CONFIG_MODEM_SUPPORT
	if (do_mdm_init)
		bmp = 1;	/* alternate bitmap */
#endif
	trab_vfd (bmp);
#endif	/* CONFIG_VFD && VFD_TEST_LOGO */

#ifdef CONFIG_BOOTCOUNT_LIMIT
	bootcount = bootcount_load();
	bootcount++;
	bootcount_store (bootcount);
	sprintf (bcs_set, "%lu", bootcount);
	setenv ("bootcount", bcs_set);
	bcs = getenv ("bootlimit");
	bootlimit = bcs ? simple_strtoul (bcs, NULL, 10) : 0;
#endif /* CONFIG_BOOTCOUNT_LIMIT */

#ifdef CONFIG_MODEM_SUPPORT
	debug ("DEBUG: main_loop:   do_mdm_init=%d\n", do_mdm_init);
	if (do_mdm_init) {
		char *str = strdup(getenv("mdm_cmd"));
		setenv ("preboot", str);  /* set or delete definition */
		if (str != NULL)
			free (str);
		mdm_init(); /* wait for modem connection */
	}
#endif  /* CONFIG_MODEM_SUPPORT */

#ifdef CONFIG_VERSION_VARIABLE
	{
		extern char version_string[];

		setenv ("ver", version_string);  /* set version variable */
	}
#endif /* CONFIG_VERSION_VARIABLE */

#ifdef CFG_HUSH_PARSER
	u_boot_hush_start ();
#endif

#ifdef CONFIG_AUTO_COMPLETE
	install_auto_complete();
#endif

#ifdef CONFIG_PREBOOT
	if ((p = getenv ("preboot")) != NULL) {
# ifdef CONFIG_AUTOBOOT_KEYED
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

# ifndef CFG_HUSH_PARSER
		run_command (p, 0);
# else
		parse_string_outer(p, FLAG_PARSE_SEMICOLON |
				    FLAG_EXIT_FROM_LOOP);
# endif

# ifdef CONFIG_AUTOBOOT_KEYED
		disable_ctrlc(prev);	/* restore Control C checking */
# endif
	}
#endif /* CONFIG_PREBOOT */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
21f10cd4:	e59f0120 	ldr	r0, [pc, #288]	; 21f10dfc <.text+0x10dfc>
21f10cd8:	eb0027ce 	bl	21f1ac18 <getenv>
21f10cdc:	e1a03000 	mov	r3, r0
21f10ce0:	e50b3014 	str	r3, [fp, #-20]
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
21f10ce4:	e51b3014 	ldr	r3, [fp, #-20]
21f10ce8:	e3530000 	cmp	r3, #0	; 0x0
21f10cec:	0a000006 	beq	21f10d0c <main_loop+0x50>
21f10cf0:	e51b0014 	ldr	r0, [fp, #-20]
21f10cf4:	e3a01000 	mov	r1, #0	; 0x0
21f10cf8:	e3a0200a 	mov	r2, #10	; 0xa
21f10cfc:	eb004abd 	bl	21f237f8 <simple_strtol>
21f10d00:	e1a03000 	mov	r3, r0
21f10d04:	e50b3024 	str	r3, [fp, #-36]
21f10d08:	ea000001 	b	21f10d14 <main_loop+0x58>
21f10d0c:	e3a03003 	mov	r3, #3	; 0x3
21f10d10:	e50b3024 	str	r3, [fp, #-36]
21f10d14:	e51b3024 	ldr	r3, [fp, #-36]
21f10d18:	e50b3010 	str	r3, [fp, #-16]

	debug ("### main_loop entered: bootdelay=%d\n\n", bootdelay);

# ifdef CONFIG_BOOT_RETRY_TIME
	init_cmd_timeout ();
# endif	/* CONFIG_BOOT_RETRY_TIME */

#ifdef CONFIG_BOOTCOUNT_LIMIT
	if (bootlimit && (bootcount > bootlimit)) {
		printf ("Warning: Bootlimit (%u) exceeded. Using altbootcmd.\n",
		        (unsigned)bootlimit);
		s = getenv ("altbootcmd");
	}
	else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");
21f10d1c:	e59f00dc 	ldr	r0, [pc, #220]	; 21f10e00 <.text+0x10e00>
21f10d20:	eb0027bc 	bl	21f1ac18 <getenv>
21f10d24:	e1a03000 	mov	r3, r0
21f10d28:	e50b3014 	str	r3, [fp, #-20]

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay >= 0 && s && !abortboot (bootdelay)) {
21f10d2c:	e51b3010 	ldr	r3, [fp, #-16]
21f10d30:	e3530000 	cmp	r3, #0	; 0x0
21f10d34:	ba00000b 	blt	21f10d68 <main_loop+0xac>
21f10d38:	e51b3014 	ldr	r3, [fp, #-20]
21f10d3c:	e3530000 	cmp	r3, #0	; 0x0
21f10d40:	0a000008 	beq	21f10d68 <main_loop+0xac>
21f10d44:	e51b0010 	ldr	r0, [fp, #-16]
21f10d48:	eb000031 	bl	21f10e14 <abortboot>
21f10d4c:	e1a03000 	mov	r3, r0
21f10d50:	e3530000 	cmp	r3, #0	; 0x0
21f10d54:	1a000003 	bne	21f10d68 <main_loop+0xac>
# ifdef CONFIG_AUTOBOOT_KEYED
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

# ifndef CFG_HUSH_PARSER
		run_command (s, 0);
21f10d58:	e51b0014 	ldr	r0, [fp, #-20]
21f10d5c:	e3a01000 	mov	r1, #0	; 0x0
21f10d60:	eb0002b7 	bl	21f11844 <run_command>
21f10d64:	eaffffff 	b	21f10d68 <main_loop+0xac>
# else
		parse_string_outer(s, FLAG_PARSE_SEMICOLON |
				    FLAG_EXIT_FROM_LOOP);
# endif

# ifdef CONFIG_AUTOBOOT_KEYED
		disable_ctrlc(prev);	/* restore Control C checking */
# endif
	}

# ifdef CONFIG_MENUKEY
	if (menukey == CONFIG_MENUKEY) {
	    s = getenv("menucmd");
	    if (s) {
# ifndef CFG_HUSH_PARSER
		run_command (s, 0);
# else
		parse_string_outer(s, FLAG_PARSE_SEMICOLON |
				    FLAG_EXIT_FROM_LOOP);
# endif
	    }
	}
#endif /* CONFIG_MENUKEY */
#endif	/* CONFIG_BOOTDELAY */

#ifdef CONFIG_AMIGAONEG3SE
	{
	    extern void video_banner(void);
	    video_banner();
	}
#endif

	/*
	 * Main Loop for Monitor Command Processing
	 */
#ifdef CFG_HUSH_PARSER
	parse_file_outer();
	/* This point is never reached */
	for (;;);
#else
	for (;;) {
#ifdef CONFIG_BOOT_RETRY_TIME
		if (rc >= 0) {
			/* Saw enough of a valid command to
			 * restart the timeout.
			 */
			reset_cmd_timeout();
		}
#endif
		len = readline (CFG_PROMPT);
21f10d68:	e59f0094 	ldr	r0, [pc, #148]	; 21f10e04 <.text+0x10e04>
21f10d6c:	eb000060 	bl	21f10ef4 <readline>
21f10d70:	e1a03000 	mov	r3, r0
21f10d74:	e50b3020 	str	r3, [fp, #-32]

		flag = 0;	/* assume no special flags for now */
21f10d78:	e3a03000 	mov	r3, #0	; 0x0
21f10d7c:	e50b3018 	str	r3, [fp, #-24]
		if (len > 0)
21f10d80:	e51b3020 	ldr	r3, [fp, #-32]
21f10d84:	e3530000 	cmp	r3, #0	; 0x0
21f10d88:	da000003 	ble	21f10d9c <main_loop+0xe0>
			strcpy (lastcommand, console_buffer);
21f10d8c:	e59f0074 	ldr	r0, [pc, #116]	; 21f10e08 <.text+0x10e08>
21f10d90:	e59f1074 	ldr	r1, [pc, #116]	; 21f10e0c <.text+0x10e0c>
21f10d94:	eb00464e 	bl	21f226d4 <strcpy>
21f10d98:	ea000005 	b	21f10db4 <main_loop+0xf8>
		else if (len == 0)
21f10d9c:	e51b3020 	ldr	r3, [fp, #-32]
21f10da0:	e3530000 	cmp	r3, #0	; 0x0
21f10da4:	1a000002 	bne	21f10db4 <main_loop+0xf8>
			flag |= CMD_FLAG_REPEAT;
21f10da8:	e51b3018 	ldr	r3, [fp, #-24]
21f10dac:	e3833001 	orr	r3, r3, #1	; 0x1
21f10db0:	e50b3018 	str	r3, [fp, #-24]
#ifdef CONFIG_BOOT_RETRY_TIME
		else if (len == -2) {
			/* -2 means timed out, retry autoboot
			 */
			puts ("\nTimed out waiting for command\n");
# ifdef CONFIG_RESET_TO_RETRY
			/* Reinit board to run initialization code again */
			do_reset (NULL, 0, 0, NULL);
# else
			return;		/* retry autoboot */
# endif
		}
#endif

		if (len == -1)
21f10db4:	e51b3020 	ldr	r3, [fp, #-32]
21f10db8:	e3730001 	cmn	r3, #1	; 0x1
21f10dbc:	1a000002 	bne	21f10dcc <main_loop+0x110>
			puts ("<INTERRUPT>\n");
21f10dc0:	e59f0048 	ldr	r0, [pc, #72]	; 21f10e10 <.text+0x10e10>
21f10dc4:	eb002b1d 	bl	21f1ba40 <puts>
21f10dc8:	ea000004 	b	21f10de0 <main_loop+0x124>
		else
			rc = run_command (lastcommand, flag);
21f10dcc:	e59f0034 	ldr	r0, [pc, #52]	; 21f10e08 <.text+0x10e08>
21f10dd0:	e51b1018 	ldr	r1, [fp, #-24]
21f10dd4:	eb00029a 	bl	21f11844 <run_command>
21f10dd8:	e1a03000 	mov	r3, r0
21f10ddc:	e50b301c 	str	r3, [fp, #-28]

		if (rc <= 0) {
21f10de0:	e51b301c 	ldr	r3, [fp, #-28]
21f10de4:	e3530000 	cmp	r3, #0	; 0x0
21f10de8:	caffffde 	bgt	21f10d68 <main_loop+0xac>
			/* invalid command or not repeatable, forget it */
			lastcommand[0] = 0;
21f10dec:	e59f3014 	ldr	r3, [pc, #20]	; 21f10e08 <.text+0x10e08>
21f10df0:	e3a02000 	mov	r2, #0	; 0x0
21f10df4:	e5c32000 	strb	r2, [r3]
21f10df8:	eaffffda 	b	21f10d68 <main_loop+0xac>
21f10dfc:	21f2ff8c 	mvncss	pc, ip, lsl #31
21f10e00:	21f2ff98 	ldrcsb	pc, [r2, #248]!
21f10e04:	21f2ffa0 	mvncss	pc, r0, lsr #31
21f10e08:	21f67564 	mvncss	r7, r4, ror #10
21f10e0c:	21f67464 	mvncss	r7, r4, ror #8
21f10e10:	21f2ffac 	mvncss	pc, ip, lsr #31

21f10e14 <abortboot>:
21f10e14:	e1a0c00d 	mov	ip, sp
21f10e18:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10e1c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10e20:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f10e24:	e50b0018 	str	r0, [fp, #-24]
21f10e28:	e3a03000 	mov	r3, #0	; 0x0
21f10e2c:	e50b3014 	str	r3, [fp, #-20]
21f10e30:	e59f00b4 	ldr	r0, [pc, #180]	; 21f10eec <.text+0x10eec>
21f10e34:	e51b1018 	ldr	r1, [fp, #-24]
21f10e38:	eb002b13 	bl	21f1ba8c <printf>
21f10e3c:	ea00001e 	b	21f10ebc <abortboot+0xa8>
21f10e40:	e51b3018 	ldr	r3, [fp, #-24]
21f10e44:	e2433001 	sub	r3, r3, #1	; 0x1
21f10e48:	e50b3018 	str	r3, [fp, #-24]
21f10e4c:	e3a03000 	mov	r3, #0	; 0x0
21f10e50:	e50b3010 	str	r3, [fp, #-16]
21f10e54:	ea00000f 	b	21f10e98 <abortboot+0x84>
21f10e58:	eb002acc 	bl	21f1b990 <tstc>
21f10e5c:	e1a03000 	mov	r3, r0
21f10e60:	e3530000 	cmp	r3, #0	; 0x0
21f10e64:	0a000005 	beq	21f10e80 <abortboot+0x6c>
21f10e68:	e3a03001 	mov	r3, #1	; 0x1
21f10e6c:	e50b3014 	str	r3, [fp, #-20]
21f10e70:	e3a03000 	mov	r3, #0	; 0x0
21f10e74:	e50b3018 	str	r3, [fp, #-24]
21f10e78:	eb002aae 	bl	21f1b938 <getc>
21f10e7c:	ea00000b 	b	21f10eb0 <abortboot+0x9c>
21f10e80:	e3a00c27 	mov	r0, #9984	; 0x2700
21f10e84:	e2800010 	add	r0, r0, #16	; 0x10
21f10e88:	ebffbf06 	bl	21f00aa8 <udelay>
21f10e8c:	e51b3010 	ldr	r3, [fp, #-16]
21f10e90:	e2833001 	add	r3, r3, #1	; 0x1
21f10e94:	e50b3010 	str	r3, [fp, #-16]
21f10e98:	e51b3014 	ldr	r3, [fp, #-20]
21f10e9c:	e3530000 	cmp	r3, #0	; 0x0
21f10ea0:	1a000002 	bne	21f10eb0 <abortboot+0x9c>
21f10ea4:	e51b3010 	ldr	r3, [fp, #-16]
21f10ea8:	e3530063 	cmp	r3, #99	; 0x63
21f10eac:	daffffe9 	ble	21f10e58 <abortboot+0x44>
21f10eb0:	e59f0038 	ldr	r0, [pc, #56]	; 21f10ef0 <.text+0x10ef0>
21f10eb4:	e51b1018 	ldr	r1, [fp, #-24]
21f10eb8:	eb002af3 	bl	21f1ba8c <printf>
21f10ebc:	e51b3018 	ldr	r3, [fp, #-24]
21f10ec0:	e3530000 	cmp	r3, #0	; 0x0
21f10ec4:	da000002 	ble	21f10ed4 <abortboot+0xc0>
21f10ec8:	e51b3014 	ldr	r3, [fp, #-20]
21f10ecc:	e3530000 	cmp	r3, #0	; 0x0
21f10ed0:	0affffda 	beq	21f10e40 <abortboot+0x2c>
21f10ed4:	e3a0000a 	mov	r0, #10	; 0xa
21f10ed8:	eb002ac2 	bl	21f1b9e8 <putc>
21f10edc:	e51b3014 	ldr	r3, [fp, #-20]
21f10ee0:	e1a00003 	mov	r0, r3
21f10ee4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f10ee8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f10eec:	21f2ffbc 	ldrcsh	pc, [r2, #252]!
21f10ef0:	21f2ffe0 	mvncss	pc, r0, ror #31

21f10ef4 <readline>:
		}
	}
#endif /*CFG_HUSH_PARSER*/
}

#ifdef CONFIG_BOOT_RETRY_TIME
/***************************************************************************
 * initialize command line timeout
 */
void init_cmd_timeout(void)
{
	char *s = getenv ("bootretry");

	if (s != NULL)
		retry_time = (int)simple_strtol(s, NULL, 10);
	else
		retry_time =  CONFIG_BOOT_RETRY_TIME;

	if (retry_time >= 0 && retry_time < CONFIG_BOOT_RETRY_MIN)
		retry_time = CONFIG_BOOT_RETRY_MIN;
}

/***************************************************************************
 * reset command line timeout to retry_time seconds
 */
void reset_cmd_timeout(void)
{
	endtime = endtick(retry_time);
}
#endif

#ifdef CONFIG_CMDLINE_EDITING

/*
 * cmdline-editing related codes from vivi.
 * Author: Janghoon Lyu <nandy@mizi.com>
 */

#define putnstr(str,n)	do {			\
		printf ("%.*s", n, str);	\
	} while (0)

#define CTL_CH(c)		((c) - 'a' + 1)

#define MAX_CMDBUF_SIZE		256

#define CTL_BACKSPACE		('\b')
#define DEL			((char)255)
#define DEL7			((char)127)
#define CREAD_HIST_CHAR		('!')

#define getcmd_putch(ch)	putc(ch)
#define getcmd_getch()		getc()
#define getcmd_cbeep()		getcmd_putch('\a')

#define HIST_MAX		20
#define HIST_SIZE		MAX_CMDBUF_SIZE

static int hist_max = 0;
static int hist_add_idx = 0;
static int hist_cur = -1;
unsigned hist_num = 0;

char* hist_list[HIST_MAX];
char hist_lines[HIST_MAX][HIST_SIZE];

#define add_idx_minus_one() ((hist_add_idx == 0) ? hist_max : hist_add_idx-1)

static void hist_init(void)
{
	int i;

	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
	hist_num = 0;

	for (i = 0; i < HIST_MAX; i++) {
		hist_list[i] = hist_lines[i];
		hist_list[i][0] = '\0';
	}
}

static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);

	if (++hist_add_idx >= HIST_MAX)
		hist_add_idx = 0;

	if (hist_add_idx > hist_max)
		hist_max = hist_add_idx;

	hist_num++;
}

static char* hist_prev(void)
{
	char *ret;
	int old_cur;

	if (hist_cur < 0)
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;

	if (hist_cur == hist_add_idx) {
		hist_cur = old_cur;
		ret = NULL;
	} else
		ret = hist_list[hist_cur];

	return (ret);
}

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
		return NULL;

	if (hist_cur == hist_add_idx)
		return NULL;

	if (++hist_cur > hist_max)
		hist_cur = 0;

	if (hist_cur == hist_add_idx) {
		ret = "";
	} else
		ret = hist_list[hist_cur];

	return (ret);
}

#ifndef CONFIG_CMDLINE_EDITING
static void cread_print_hist_list(void)
{
	int i;
	unsigned long n;

	n = hist_num - hist_max;

	i = hist_add_idx + 1;
	while (1) {
		if (i > hist_max)
			i = 0;
		if (i == hist_add_idx)
			break;
		printf("%s\n", hist_list[i]);
		n++;
		i++;
	}
}
#endif /* CONFIG_CMDLINE_EDITING */

#define BEGINNING_OF_LINE() {			\
	while (num) {				\
		getcmd_putch(CTL_BACKSPACE);	\
		num--;				\
	}					\
}

#define ERASE_TO_EOL() {				\
	if (num < eol_num) {				\
		int tmp;				\
		for (tmp = num; tmp < eol_num; tmp++)	\
			getcmd_putch(' ');		\
		while (tmp-- > num)			\
			getcmd_putch(CTL_BACKSPACE);	\
		eol_num = num;				\
	}						\
}

#define REFRESH_TO_EOL() {			\
	if (num < eol_num) {			\
		wlen = eol_num - num;		\
		putnstr(buf + num, wlen);	\
		num = eol_num;			\
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
			return;
		}
		(*eol_num)++;
	}

	if (insert) {
		wlen = *eol_num - *num;
		if (wlen > 1) {
			memmove(&buf[*num+1], &buf[*num], wlen-1);
		}

		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
		while (--wlen) {
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
	}
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
		str++;
	}
}

static int cread_line(char *buf, unsigned int *len)
{
	unsigned long num = 0;
	unsigned long eol_num = 0;
	unsigned long rlen;
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	int rc = 0;
	char esc_save[8];

	while (1) {
		rlen = 1;
		ichar = getcmd_getch();

		if ((ichar == '\n') || (ichar == '\r')) {
			putc('\n');
			break;
		}

		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
			if (esc_len == 1) {
				if (ichar == '[') {
					esc_save[esc_len] = ichar;
					esc_len = 2;
				} else {
					cread_add_str(esc_save, esc_len, insert,
						      &num, &eol_num, buf, *len);
					esc_len = 0;
				}
				continue;
			}

			switch (ichar) {

			case 'D':	/* <- key */
				ichar = CTL_CH('b');
				esc_len = 0;
				break;
			case 'C':	/* -> key */
				ichar = CTL_CH('f');
				esc_len = 0;
				break;	/* pass off to ^F handler */
			case 'H':	/* Home key */
				ichar = CTL_CH('a');
				esc_len = 0;
				break;	/* pass off to ^A handler */
			case 'A':	/* up arrow */
				ichar = CTL_CH('p');
				esc_len = 0;
				break;	/* pass off to ^P handler */
			case 'B':	/* down arrow */
				ichar = CTL_CH('n');
				esc_len = 0;
				break;	/* pass off to ^N handler */
			default:
				esc_save[esc_len++] = ichar;
				cread_add_str(esc_save, esc_len, insert,
					      &num, &eol_num, buf, *len);
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
		case 0x1b:
			if (esc_len == 0) {
				esc_save[esc_len] = ichar;
				esc_len = 1;
			} else {
				puts("impossible condition #876\n");
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
			break;
		case CTL_CH('c'):	/* ^C - break */
			*buf = '\0';	/* discard input */
			return (-1);
		case CTL_CH('f'):
			if (num < eol_num) {
				getcmd_putch(buf[num]);
				num++;
			}
			break;
		case CTL_CH('b'):
			if (num) {
				getcmd_putch(CTL_BACKSPACE);
				num--;
			}
			break;
		case CTL_CH('d'):
			if (num < eol_num) {
				wlen = eol_num - num - 1;
				if (wlen) {
					memmove(&buf[num], &buf[num+1], wlen);
					putnstr(buf + num, wlen);
				}

				getcmd_putch(' ');
				do {
					getcmd_putch(CTL_BACKSPACE);
				} while (wlen--);
				eol_num--;
			}
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
			break;
		case CTL_CH('o'):
			insert = !insert;
			break;
		case CTL_CH('x'):
			BEGINNING_OF_LINE();
			ERASE_TO_EOL();
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
				num--;
				memmove(&buf[num], &buf[num+1], wlen);
				getcmd_putch(CTL_BACKSPACE);
				putnstr(buf + num, wlen);
				getcmd_putch(' ');
				do {
					getcmd_putch(CTL_BACKSPACE);
				} while (wlen--);
				eol_num--;
			}
			break;
		case CTL_CH('p'):
		case CTL_CH('n'):
		{
			char * hline;

			esc_len = 0;

			if (ichar == CTL_CH('p'))
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
				getcmd_cbeep();
				continue;
			}

			/* nuke the current line */
			/* first, go home */
			BEGINNING_OF_LINE();

			/* erase to end of line */
			ERASE_TO_EOL();

			/* copy new line into place and display */
			strcpy(buf, hline);
			eol_num = strlen(buf);
			REFRESH_TO_EOL();
			continue;
		}
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
			break;
		}
	}
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;

	return (rc);
}

#endif /* CONFIG_CMDLINE_EDITING */

/****************************************************************************/

/*
 * Prompt for input and read a line.
 * If  CONFIG_BOOT_RETRY_TIME is defined and retry_time >= 0,
 * time out when time goes past endtime (timebase time in ticks).
 * Return:	number of read characters
 *		-1 if break
 *		-2 if timed out
 */
int readline (const char *const prompt)
{
21f10ef4:	e1a0c00d 	mov	ip, sp
21f10ef8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f10efc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f10f00:	e24dd024 	sub	sp, sp, #36	; 0x24
21f10f04:	e50b0024 	str	r0, [fp, #-36]
#ifdef CONFIG_CMDLINE_EDITING
	char *p = console_buffer;
	unsigned int len=MAX_CMDBUF_SIZE;
	int rc;
	static int initted = 0;

	if (!initted) {
		hist_init();
		initted = 1;
	}

	puts (prompt);

	rc = cread_line(p, &len);
	return rc < 0 ? rc : len;
#else
	char   *p = console_buffer;
21f10f08:	e59f3294 	ldr	r3, [pc, #660]	; 21f111a4 <.text+0x111a4>
21f10f0c:	e50b3018 	str	r3, [fp, #-24]
	int	n = 0;				/* buffer index		*/
21f10f10:	e3a03000 	mov	r3, #0	; 0x0
21f10f14:	e50b301c 	str	r3, [fp, #-28]
	int	plen = 0;			/* prompt length	*/
21f10f18:	e3a03000 	mov	r3, #0	; 0x0
21f10f1c:	e50b3014 	str	r3, [fp, #-20]
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
21f10f20:	e51b3024 	ldr	r3, [fp, #-36]
21f10f24:	e3530000 	cmp	r3, #0	; 0x0
21f10f28:	0a000005 	beq	21f10f44 <readline+0x50>
		plen = strlen (prompt);
21f10f2c:	e51b0024 	ldr	r0, [fp, #-36]
21f10f30:	eb004723 	bl	21f22bc4 <strlen>
21f10f34:	e1a03000 	mov	r3, r0
21f10f38:	e50b3014 	str	r3, [fp, #-20]
		puts (prompt);
21f10f3c:	e51b0024 	ldr	r0, [fp, #-36]
21f10f40:	eb002abe 	bl	21f1ba40 <puts>
	}
	col = plen;
21f10f44:	e51b3014 	ldr	r3, [fp, #-20]
21f10f48:	e50b3020 	str	r3, [fp, #-32]
21f10f4c:	eaffffff 	b	21f10f50 <readline+0x5c>

	for (;;) {
#ifdef CONFIG_BOOT_RETRY_TIME
		while (!tstc()) {	/* while no incoming data */
			if (retry_time >= 0 && get_ticks() > endtime)
				return (-2);	/* timed out */
		}
#endif
		WATCHDOG_RESET();		/* Trigger watchdog, if needed */

#ifdef CONFIG_SHOW_ACTIVITY
		while (!tstc()) {
			extern void show_activity(int arg);
			show_activity(0);
		}
#endif
		c = getc();
21f10f50:	eb002a78 	bl	21f1b938 <getc>
21f10f54:	e1a03000 	mov	r3, r0
21f10f58:	e54b300d 	strb	r3, [fp, #-13]

		/*
		 * Special character handling
		 */
		switch (c) {
21f10f5c:	e55b300d 	ldrb	r3, [fp, #-13]
21f10f60:	e50b302c 	str	r3, [fp, #-44]
21f10f64:	e51b302c 	ldr	r3, [fp, #-44]
21f10f68:	e353000a 	cmp	r3, #10	; 0xa
21f10f6c:	0a00001d 	beq	21f10fe8 <readline+0xf4>
21f10f70:	e51b302c 	ldr	r3, [fp, #-44]
21f10f74:	e353000a 	cmp	r3, #10	; 0xa
21f10f78:	ca000009 	bgt	21f10fa4 <readline+0xb0>
21f10f7c:	e51b302c 	ldr	r3, [fp, #-44]
21f10f80:	e3530003 	cmp	r3, #3	; 0x3
21f10f84:	0a000021 	beq	21f11010 <readline+0x11c>
21f10f88:	e51b302c 	ldr	r3, [fp, #-44]
21f10f8c:	e3530008 	cmp	r3, #8	; 0x8
21f10f90:	0a00004f 	beq	21f110d4 <readline+0x1e0>
21f10f94:	e51b302c 	ldr	r3, [fp, #-44]
21f10f98:	e3530000 	cmp	r3, #0	; 0x0
21f10f9c:	0affffeb 	beq	21f10f50 <readline+0x5c>
21f10fa0:	ea000056 	b	21f11100 <readline+0x20c>
21f10fa4:	e51b302c 	ldr	r3, [fp, #-44]
21f10fa8:	e3530015 	cmp	r3, #21	; 0x15
21f10fac:	0a000022 	beq	21f1103c <readline+0x148>
21f10fb0:	e51b302c 	ldr	r3, [fp, #-44]
21f10fb4:	e3530015 	cmp	r3, #21	; 0x15
21f10fb8:	ca000003 	bgt	21f10fcc <readline+0xd8>
21f10fbc:	e51b302c 	ldr	r3, [fp, #-44]
21f10fc0:	e353000d 	cmp	r3, #13	; 0xd
21f10fc4:	0a000007 	beq	21f10fe8 <readline+0xf4>
21f10fc8:	ea00004c 	b	21f11100 <readline+0x20c>
21f10fcc:	e51b302c 	ldr	r3, [fp, #-44]
21f10fd0:	e3530017 	cmp	r3, #23	; 0x17
21f10fd4:	0a000021 	beq	21f11060 <readline+0x16c>
21f10fd8:	e51b302c 	ldr	r3, [fp, #-44]
21f10fdc:	e353007f 	cmp	r3, #127	; 0x7f
21f10fe0:	0a00003b 	beq	21f110d4 <readline+0x1e0>
21f10fe4:	ea000045 	b	21f11100 <readline+0x20c>
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
21f10fe8:	e51b2018 	ldr	r2, [fp, #-24]
21f10fec:	e3a03000 	mov	r3, #0	; 0x0
21f10ff0:	e5c23000 	strb	r3, [r2]
			puts ("\r\n");
21f10ff4:	e59f01ac 	ldr	r0, [pc, #428]	; 21f111a8 <.text+0x111a8>
21f10ff8:	eb002a90 	bl	21f1ba40 <puts>
			return (p - console_buffer);
21f10ffc:	e51b2018 	ldr	r2, [fp, #-24]
21f11000:	e59f319c 	ldr	r3, [pc, #412]	; 21f111a4 <.text+0x111a4>
21f11004:	e0632002 	rsb	r2, r3, r2
21f11008:	e50b2028 	str	r2, [fp, #-40]
21f1100c:	ea000060 	b	21f11194 <readline+0x2a0>

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			console_buffer[0] = '\0';	/* discard input */
21f11010:	e59f318c 	ldr	r3, [pc, #396]	; 21f111a4 <.text+0x111a4>
21f11014:	e3a02000 	mov	r2, #0	; 0x0
21f11018:	e5c32000 	strb	r2, [r3]
			return (-1);
21f1101c:	e3e03000 	mvn	r3, #0	; 0x0
21f11020:	e50b3028 	str	r3, [fp, #-40]
21f11024:	ea00005a 	b	21f11194 <readline+0x2a0>

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
21f11028:	e59f017c 	ldr	r0, [pc, #380]	; 21f111ac <.text+0x111ac>
21f1102c:	eb002a83 	bl	21f1ba40 <puts>
				--col;
21f11030:	e51b3020 	ldr	r3, [fp, #-32]
21f11034:	e2433001 	sub	r3, r3, #1	; 0x1
21f11038:	e50b3020 	str	r3, [fp, #-32]
21f1103c:	e51b2020 	ldr	r2, [fp, #-32]
21f11040:	e51b3014 	ldr	r3, [fp, #-20]
21f11044:	e1520003 	cmp	r2, r3
21f11048:	cafffff6 	bgt	21f11028 <readline+0x134>
			}
			p = console_buffer;
21f1104c:	e59f3150 	ldr	r3, [pc, #336]	; 21f111a4 <.text+0x111a4>
21f11050:	e50b3018 	str	r3, [fp, #-24]
			n = 0;
21f11054:	e3a03000 	mov	r3, #0	; 0x0
21f11058:	e50b301c 	str	r3, [fp, #-28]
			continue;
21f1105c:	eaffffbb 	b	21f10f50 <readline+0x5c>

		case 0x17:				/* ^W - erase word 	*/
			p=delete_char(console_buffer, p, &col, &n, plen);
21f11060:	e24b2020 	sub	r2, fp, #32	; 0x20
21f11064:	e24bc01c 	sub	ip, fp, #28	; 0x1c
21f11068:	e51b3014 	ldr	r3, [fp, #-20]
21f1106c:	e58d3000 	str	r3, [sp]
21f11070:	e59f012c 	ldr	r0, [pc, #300]	; 21f111a4 <.text+0x111a4>
21f11074:	e51b1018 	ldr	r1, [fp, #-24]
21f11078:	e1a0300c 	mov	r3, ip
21f1107c:	eb00004c 	bl	21f111b4 <delete_char>
21f11080:	e1a03000 	mov	r3, r0
21f11084:	e50b3018 	str	r3, [fp, #-24]
			while ((n > 0) && (*p != ' ')) {
21f11088:	ea000009 	b	21f110b4 <readline+0x1c0>
				p=delete_char(console_buffer, p, &col, &n, plen);
21f1108c:	e24b2020 	sub	r2, fp, #32	; 0x20
21f11090:	e24bc01c 	sub	ip, fp, #28	; 0x1c
21f11094:	e51b3014 	ldr	r3, [fp, #-20]
21f11098:	e58d3000 	str	r3, [sp]
21f1109c:	e59f0100 	ldr	r0, [pc, #256]	; 21f111a4 <.text+0x111a4>
21f110a0:	e51b1018 	ldr	r1, [fp, #-24]
21f110a4:	e1a0300c 	mov	r3, ip
21f110a8:	eb000041 	bl	21f111b4 <delete_char>
21f110ac:	e1a03000 	mov	r3, r0
21f110b0:	e50b3018 	str	r3, [fp, #-24]
21f110b4:	e51b301c 	ldr	r3, [fp, #-28]
21f110b8:	e3530000 	cmp	r3, #0	; 0x0
21f110bc:	daffffa3 	ble	21f10f50 <readline+0x5c>
21f110c0:	e51b3018 	ldr	r3, [fp, #-24]
21f110c4:	e5d33000 	ldrb	r3, [r3]
21f110c8:	e3530020 	cmp	r3, #32	; 0x20
21f110cc:	1affffee 	bne	21f1108c <readline+0x198>
21f110d0:	eaffff9e 	b	21f10f50 <readline+0x5c>
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(console_buffer, p, &col, &n, plen);
21f110d4:	e24b2020 	sub	r2, fp, #32	; 0x20
21f110d8:	e24bc01c 	sub	ip, fp, #28	; 0x1c
21f110dc:	e51b3014 	ldr	r3, [fp, #-20]
21f110e0:	e58d3000 	str	r3, [sp]
21f110e4:	e59f00b8 	ldr	r0, [pc, #184]	; 21f111a4 <.text+0x111a4>
21f110e8:	e51b1018 	ldr	r1, [fp, #-24]
21f110ec:	e1a0300c 	mov	r3, ip
21f110f0:	eb00002f 	bl	21f111b4 <delete_char>
21f110f4:	e1a03000 	mov	r3, r0
21f110f8:	e50b3018 	str	r3, [fp, #-24]
			continue;
21f110fc:	eaffff93 	b	21f10f50 <readline+0x5c>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < CFG_CBSIZE-2) {
21f11100:	e51b301c 	ldr	r3, [fp, #-28]
21f11104:	e35300fd 	cmp	r3, #253	; 0xfd
21f11108:	ca00001e 	bgt	21f11188 <readline+0x294>
				if (c == '\t') {	/* expand TABs		*/
21f1110c:	e55b300d 	ldrb	r3, [fp, #-13]
21f11110:	e3530009 	cmp	r3, #9	; 0x9
21f11114:	1a00000b 	bne	21f11148 <readline+0x254>
#ifdef CONFIG_AUTO_COMPLETE
					/* if auto completion triggered just continue */
					*p = '\0';
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = console_buffer + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
21f11118:	e51b3020 	ldr	r3, [fp, #-32]
21f1111c:	e2033007 	and	r3, r3, #7	; 0x7
21f11120:	e1a02003 	mov	r2, r3
21f11124:	e59f3084 	ldr	r3, [pc, #132]	; 21f111b0 <.text+0x111b0>
21f11128:	e0823003 	add	r3, r2, r3
21f1112c:	e1a00003 	mov	r0, r3
21f11130:	eb002a42 	bl	21f1ba40 <puts>
					col += 8 - (col&07);
21f11134:	e51b3020 	ldr	r3, [fp, #-32]
21f11138:	e3c33007 	bic	r3, r3, #7	; 0x7
21f1113c:	e2833008 	add	r3, r3, #8	; 0x8
21f11140:	e50b3020 	str	r3, [fp, #-32]
21f11144:	ea000005 	b	21f11160 <readline+0x26c>
				} else {
					++col;		/* echo input		*/
21f11148:	e51b3020 	ldr	r3, [fp, #-32]
21f1114c:	e2833001 	add	r3, r3, #1	; 0x1
21f11150:	e50b3020 	str	r3, [fp, #-32]
					putc (c);
21f11154:	e55b300d 	ldrb	r3, [fp, #-13]
21f11158:	e1a00003 	mov	r0, r3
21f1115c:	eb002a21 	bl	21f1b9e8 <putc>
				}
				*p++ = c;
21f11160:	e51b2018 	ldr	r2, [fp, #-24]
21f11164:	e55b300d 	ldrb	r3, [fp, #-13]
21f11168:	e5c23000 	strb	r3, [r2]
21f1116c:	e51b3018 	ldr	r3, [fp, #-24]
21f11170:	e2833001 	add	r3, r3, #1	; 0x1
21f11174:	e50b3018 	str	r3, [fp, #-24]
				++n;
21f11178:	e51b301c 	ldr	r3, [fp, #-28]
21f1117c:	e2833001 	add	r3, r3, #1	; 0x1
21f11180:	e50b301c 	str	r3, [fp, #-28]
21f11184:	eaffff71 	b	21f10f50 <readline+0x5c>
			} else {			/* Buffer full		*/
				putc ('\a');
21f11188:	e3a00007 	mov	r0, #7	; 0x7
21f1118c:	eb002a15 	bl	21f1b9e8 <putc>
21f11190:	eaffff6e 	b	21f10f50 <readline+0x5c>
21f11194:	e51b3028 	ldr	r3, [fp, #-40]
			}
		}
	}
#endif /* CONFIG_CMDLINE_EDITING */
}
21f11198:	e1a00003 	mov	r0, r3
21f1119c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f111a0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f111a4:	21f67464 	mvncss	r7, r4, ror #8
21f111a8:	21f2ffe8 	mvncss	pc, r8, ror #31
21f111ac:	21f3321c 	mvncss	r3, ip, lsl r2
21f111b0:	21f33220 	mvncss	r3, r0, lsr #4

21f111b4 <delete_char>:

/****************************************************************************/

#ifndef CONFIG_CMDLINE_EDITING
static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
21f111b4:	e1a0c00d 	mov	ip, sp
21f111b8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f111bc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f111c0:	e24dd018 	sub	sp, sp, #24	; 0x18
21f111c4:	e50b0014 	str	r0, [fp, #-20]
21f111c8:	e50b1018 	str	r1, [fp, #-24]
21f111cc:	e50b201c 	str	r2, [fp, #-28]
21f111d0:	e50b3020 	str	r3, [fp, #-32]
	char *s;

	if (*np == 0) {
21f111d4:	e51b3020 	ldr	r3, [fp, #-32]
21f111d8:	e5933000 	ldr	r3, [r3]
21f111dc:	e3530000 	cmp	r3, #0	; 0x0
21f111e0:	1a000002 	bne	21f111f0 <delete_char+0x3c>
		return (p);
21f111e4:	e51b3018 	ldr	r3, [fp, #-24]
21f111e8:	e50b3024 	str	r3, [fp, #-36]
21f111ec:	ea000048 	b	21f11314 <delete_char+0x160>
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
21f111f0:	e51b3018 	ldr	r3, [fp, #-24]
21f111f4:	e2433001 	sub	r3, r3, #1	; 0x1
21f111f8:	e50b3018 	str	r3, [fp, #-24]
21f111fc:	e51b3018 	ldr	r3, [fp, #-24]
21f11200:	e5d33000 	ldrb	r3, [r3]
21f11204:	e3530009 	cmp	r3, #9	; 0x9
21f11208:	0a000007 	beq	21f1122c <delete_char+0x78>
21f1120c:	ea000032 	b	21f112dc <delete_char+0x128>
		while (*colp > plen) {
			puts (erase_seq);
21f11210:	e59f010c 	ldr	r0, [pc, #268]	; 21f11324 <.text+0x11324>
21f11214:	eb002a09 	bl	21f1ba40 <puts>
			(*colp)--;
21f11218:	e51b301c 	ldr	r3, [fp, #-28]
21f1121c:	e5933000 	ldr	r3, [r3]
21f11220:	e2432001 	sub	r2, r3, #1	; 0x1
21f11224:	e51b301c 	ldr	r3, [fp, #-28]
21f11228:	e5832000 	str	r2, [r3]
21f1122c:	e51b301c 	ldr	r3, [fp, #-28]
21f11230:	e5932000 	ldr	r2, [r3]
21f11234:	e59b3004 	ldr	r3, [fp, #4]
21f11238:	e1520003 	cmp	r2, r3
21f1123c:	cafffff3 	bgt	21f11210 <delete_char+0x5c>
		}
		for (s=buffer; s<p; ++s) {
21f11240:	e51b3014 	ldr	r3, [fp, #-20]
21f11244:	e50b3010 	str	r3, [fp, #-16]
21f11248:	ea00001e 	b	21f112c8 <delete_char+0x114>
			if (*s == '\t') {
21f1124c:	e51b3010 	ldr	r3, [fp, #-16]
21f11250:	e5d33000 	ldrb	r3, [r3]
21f11254:	e3530009 	cmp	r3, #9	; 0x9
21f11258:	1a00000e 	bne	21f11298 <delete_char+0xe4>
				puts (tab_seq+((*colp) & 07));
21f1125c:	e51b301c 	ldr	r3, [fp, #-28]
21f11260:	e5933000 	ldr	r3, [r3]
21f11264:	e2033007 	and	r3, r3, #7	; 0x7
21f11268:	e1a02003 	mov	r2, r3
21f1126c:	e59f30b4 	ldr	r3, [pc, #180]	; 21f11328 <.text+0x11328>
21f11270:	e0823003 	add	r3, r2, r3
21f11274:	e1a00003 	mov	r0, r3
21f11278:	eb0029f0 	bl	21f1ba40 <puts>
				*colp += 8 - ((*colp) & 07);
21f1127c:	e51b301c 	ldr	r3, [fp, #-28]
21f11280:	e5933000 	ldr	r3, [r3]
21f11284:	e3c33007 	bic	r3, r3, #7	; 0x7
21f11288:	e2832008 	add	r2, r3, #8	; 0x8
21f1128c:	e51b301c 	ldr	r3, [fp, #-28]
21f11290:	e5832000 	str	r2, [r3]
21f11294:	ea000008 	b	21f112bc <delete_char+0x108>
			} else {
				++(*colp);
21f11298:	e51b301c 	ldr	r3, [fp, #-28]
21f1129c:	e5933000 	ldr	r3, [r3]
21f112a0:	e2832001 	add	r2, r3, #1	; 0x1
21f112a4:	e51b301c 	ldr	r3, [fp, #-28]
21f112a8:	e5832000 	str	r2, [r3]
				putc (*s);
21f112ac:	e51b3010 	ldr	r3, [fp, #-16]
21f112b0:	e5d33000 	ldrb	r3, [r3]
21f112b4:	e1a00003 	mov	r0, r3
21f112b8:	eb0029ca 	bl	21f1b9e8 <putc>
21f112bc:	e51b3010 	ldr	r3, [fp, #-16]
21f112c0:	e2833001 	add	r3, r3, #1	; 0x1
21f112c4:	e50b3010 	str	r3, [fp, #-16]
21f112c8:	e51b2010 	ldr	r2, [fp, #-16]
21f112cc:	e51b3018 	ldr	r3, [fp, #-24]
21f112d0:	e1520003 	cmp	r2, r3
21f112d4:	3affffdc 	bcc	21f1124c <delete_char+0x98>
21f112d8:	ea000006 	b	21f112f8 <delete_char+0x144>
			}
		}
	} else {
		puts (erase_seq);
21f112dc:	e59f0040 	ldr	r0, [pc, #64]	; 21f11324 <.text+0x11324>
21f112e0:	eb0029d6 	bl	21f1ba40 <puts>
		(*colp)--;
21f112e4:	e51b301c 	ldr	r3, [fp, #-28]
21f112e8:	e5933000 	ldr	r3, [r3]
21f112ec:	e2432001 	sub	r2, r3, #1	; 0x1
21f112f0:	e51b301c 	ldr	r3, [fp, #-28]
21f112f4:	e5832000 	str	r2, [r3]
	}
	(*np)--;
21f112f8:	e51b3020 	ldr	r3, [fp, #-32]
21f112fc:	e5933000 	ldr	r3, [r3]
21f11300:	e2432001 	sub	r2, r3, #1	; 0x1
21f11304:	e51b3020 	ldr	r3, [fp, #-32]
21f11308:	e5832000 	str	r2, [r3]
	return (p);
21f1130c:	e51b3018 	ldr	r3, [fp, #-24]
21f11310:	e50b3024 	str	r3, [fp, #-36]
21f11314:	e51b3024 	ldr	r3, [fp, #-36]
}
21f11318:	e1a00003 	mov	r0, r3
21f1131c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f11320:	e89da800 	ldmia	sp, {fp, sp, pc}
21f11324:	21f3321c 	mvncss	r3, ip, lsl r2
21f11328:	21f33220 	mvncss	r3, r0, lsr #4

21f1132c <parse_line>:
#endif /* CONFIG_CMDLINE_EDITING */

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
21f1132c:	e1a0c00d 	mov	ip, sp
21f11330:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f11334:	e24cb004 	sub	fp, ip, #4	; 0x4
21f11338:	e24dd010 	sub	sp, sp, #16	; 0x10
21f1133c:	e50b0014 	str	r0, [fp, #-20]
21f11340:	e50b1018 	str	r1, [fp, #-24]
	int nargs = 0;
21f11344:	e3a03000 	mov	r3, #0	; 0x0
21f11348:	e50b3010 	str	r3, [fp, #-16]

#ifdef DEBUG_PARSER
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CFG_MAXARGS) {
21f1134c:	ea000046 	b	21f1146c <parse_line+0x140>

		/* skip any white space */
		while ((*line == ' ') || (*line == '\t')) {
			++line;
21f11350:	e51b3014 	ldr	r3, [fp, #-20]
21f11354:	e2833001 	add	r3, r3, #1	; 0x1
21f11358:	e50b3014 	str	r3, [fp, #-20]
21f1135c:	e51b3014 	ldr	r3, [fp, #-20]
21f11360:	e5d33000 	ldrb	r3, [r3]
21f11364:	e3530020 	cmp	r3, #32	; 0x20
21f11368:	0afffff8 	beq	21f11350 <parse_line+0x24>
21f1136c:	e51b3014 	ldr	r3, [fp, #-20]
21f11370:	e5d33000 	ldrb	r3, [r3]
21f11374:	e3530009 	cmp	r3, #9	; 0x9
21f11378:	0afffff4 	beq	21f11350 <parse_line+0x24>
		}

		if (*line == '\0') {	/* end of line, no more args	*/
21f1137c:	e51b3014 	ldr	r3, [fp, #-20]
21f11380:	e5d33000 	ldrb	r3, [r3]
21f11384:	e3530000 	cmp	r3, #0	; 0x0
21f11388:	1a000009 	bne	21f113b4 <parse_line+0x88>
			argv[nargs] = NULL;
21f1138c:	e51b3010 	ldr	r3, [fp, #-16]
21f11390:	e1a03103 	mov	r3, r3, lsl #2
21f11394:	e1a02003 	mov	r2, r3
21f11398:	e51b3018 	ldr	r3, [fp, #-24]
21f1139c:	e0822003 	add	r2, r2, r3
21f113a0:	e3a03000 	mov	r3, #0	; 0x0
21f113a4:	e5823000 	str	r3, [r2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
21f113a8:	e51b3010 	ldr	r3, [fp, #-16]
21f113ac:	e50b301c 	str	r3, [fp, #-28]
21f113b0:	ea000035 	b	21f1148c <parse_line+0x160>
		}

		argv[nargs++] = line;	/* begin of argument string	*/
21f113b4:	e51b3010 	ldr	r3, [fp, #-16]
21f113b8:	e1a03103 	mov	r3, r3, lsl #2
21f113bc:	e1a02003 	mov	r2, r3
21f113c0:	e51b3018 	ldr	r3, [fp, #-24]
21f113c4:	e0822003 	add	r2, r2, r3
21f113c8:	e51b3014 	ldr	r3, [fp, #-20]
21f113cc:	e5823000 	str	r3, [r2]
21f113d0:	e51b3010 	ldr	r3, [fp, #-16]
21f113d4:	e2833001 	add	r3, r3, #1	; 0x1
21f113d8:	e50b3010 	str	r3, [fp, #-16]

		/* find end of string */
		while (*line && (*line != ' ') && (*line != '\t')) {
21f113dc:	ea000002 	b	21f113ec <parse_line+0xc0>
			++line;
21f113e0:	e51b3014 	ldr	r3, [fp, #-20]
21f113e4:	e2833001 	add	r3, r3, #1	; 0x1
21f113e8:	e50b3014 	str	r3, [fp, #-20]
21f113ec:	e51b3014 	ldr	r3, [fp, #-20]
21f113f0:	e5d33000 	ldrb	r3, [r3]
21f113f4:	e3530000 	cmp	r3, #0	; 0x0
21f113f8:	0a000007 	beq	21f1141c <parse_line+0xf0>
21f113fc:	e51b3014 	ldr	r3, [fp, #-20]
21f11400:	e5d33000 	ldrb	r3, [r3]
21f11404:	e3530020 	cmp	r3, #32	; 0x20
21f11408:	0a000003 	beq	21f1141c <parse_line+0xf0>
21f1140c:	e51b3014 	ldr	r3, [fp, #-20]
21f11410:	e5d33000 	ldrb	r3, [r3]
21f11414:	e3530009 	cmp	r3, #9	; 0x9
21f11418:	1afffff0 	bne	21f113e0 <parse_line+0xb4>
		}

		if (*line == '\0') {	/* end of line, no more args	*/
21f1141c:	e51b3014 	ldr	r3, [fp, #-20]
21f11420:	e5d33000 	ldrb	r3, [r3]
21f11424:	e3530000 	cmp	r3, #0	; 0x0
21f11428:	1a000009 	bne	21f11454 <parse_line+0x128>
			argv[nargs] = NULL;
21f1142c:	e51b3010 	ldr	r3, [fp, #-16]
21f11430:	e1a03103 	mov	r3, r3, lsl #2
21f11434:	e1a02003 	mov	r2, r3
21f11438:	e51b3018 	ldr	r3, [fp, #-24]
21f1143c:	e0822003 	add	r2, r2, r3
21f11440:	e3a03000 	mov	r3, #0	; 0x0
21f11444:	e5823000 	str	r3, [r2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
21f11448:	e51b3010 	ldr	r3, [fp, #-16]
21f1144c:	e50b301c 	str	r3, [fp, #-28]
21f11450:	ea00000d 	b	21f1148c <parse_line+0x160>
		}

		*line++ = '\0';		/* terminate current arg	 */
21f11454:	e51b2014 	ldr	r2, [fp, #-20]
21f11458:	e3a03000 	mov	r3, #0	; 0x0
21f1145c:	e5c23000 	strb	r3, [r2]
21f11460:	e51b3014 	ldr	r3, [fp, #-20]
21f11464:	e2833001 	add	r3, r3, #1	; 0x1
21f11468:	e50b3014 	str	r3, [fp, #-20]
21f1146c:	e51b3010 	ldr	r3, [fp, #-16]
21f11470:	e353000f 	cmp	r3, #15	; 0xf
21f11474:	daffffb8 	ble	21f1135c <parse_line+0x30>
	}

	printf ("** Too many args (max. %d) **\n", CFG_MAXARGS);
21f11478:	e59f001c 	ldr	r0, [pc, #28]	; 21f1149c <.text+0x1149c>
21f1147c:	e3a01010 	mov	r1, #16	; 0x10
21f11480:	eb002981 	bl	21f1ba8c <printf>

#ifdef DEBUG_PARSER
	printf ("parse_line: nargs=%d\n", nargs);
#endif
	return (nargs);
21f11484:	e51b3010 	ldr	r3, [fp, #-16]
21f11488:	e50b301c 	str	r3, [fp, #-28]
21f1148c:	e51b301c 	ldr	r3, [fp, #-28]
}
21f11490:	e1a00003 	mov	r0, r3
21f11494:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f11498:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1149c:	21f2ffec 	mvncss	pc, ip, ror #31

21f114a0 <process_macros>:

/****************************************************************************/

static void process_macros (const char *input, char *output)
{
21f114a0:	e1a0c00d 	mov	ip, sp
21f114a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f114a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f114ac:	e24ddf4a 	sub	sp, sp, #296	; 0x128
21f114b0:	e50b0130 	str	r0, [fp, #-304]
21f114b4:	e50b1134 	str	r1, [fp, #-308]
	char c, prev;
	const char *varname_start = NULL;
21f114b8:	e3a03000 	mov	r3, #0	; 0x0
21f114bc:	e50b3028 	str	r3, [fp, #-40]
	int inputcnt = strlen (input);
21f114c0:	e51b0130 	ldr	r0, [fp, #-304]
21f114c4:	eb0045be 	bl	21f22bc4 <strlen>
21f114c8:	e1a03000 	mov	r3, r0
21f114cc:	e50b3024 	str	r3, [fp, #-36]
	int outputcnt = CFG_CBSIZE;
21f114d0:	e3a03c01 	mov	r3, #256	; 0x100
21f114d4:	e50b3020 	str	r3, [fp, #-32]
	int state = 0;		/* 0 = waiting for '$'  */
21f114d8:	e3a03000 	mov	r3, #0	; 0x0
21f114dc:	e50b301c 	str	r3, [fp, #-28]

	/* 1 = waiting for '(' or '{' */
	/* 2 = waiting for ')' or '}' */
	/* 3 = waiting for '''  */
#ifdef DEBUG_PARSER
	char *output_start = output;

	printf ("[PROCESS_MACROS] INPUT len %d: \"%s\"\n", strlen (input),
		input);
#endif

	prev = '\0';		/* previous character   */
21f114e0:	e3a03000 	mov	r3, #0	; 0x0
21f114e4:	e54b3029 	strb	r3, [fp, #-41]

	while (inputcnt && outputcnt) {
21f114e8:	ea0000c7 	b	21f1180c <.text+0x1180c>
		c = *input++;
21f114ec:	e51b3130 	ldr	r3, [fp, #-304]
21f114f0:	e5d33000 	ldrb	r3, [r3]
21f114f4:	e54b302a 	strb	r3, [fp, #-42]
21f114f8:	e51b3130 	ldr	r3, [fp, #-304]
21f114fc:	e2833001 	add	r3, r3, #1	; 0x1
21f11500:	e50b3130 	str	r3, [fp, #-304]
		inputcnt--;
21f11504:	e51b3024 	ldr	r3, [fp, #-36]
21f11508:	e2433001 	sub	r3, r3, #1	; 0x1
21f1150c:	e50b3024 	str	r3, [fp, #-36]

		if (state != 3) {
21f11510:	e51b301c 	ldr	r3, [fp, #-28]
21f11514:	e3530003 	cmp	r3, #3	; 0x3
21f11518:	0a000013 	beq	21f1156c <process_macros+0xcc>
			/* remove one level of escape characters */
			if ((c == '\\') && (prev != '\\')) {
21f1151c:	e55b302a 	ldrb	r3, [fp, #-42]
21f11520:	e353005c 	cmp	r3, #92	; 0x5c
21f11524:	1a000010 	bne	21f1156c <process_macros+0xcc>
21f11528:	e55b3029 	ldrb	r3, [fp, #-41]
21f1152c:	e353005c 	cmp	r3, #92	; 0x5c
21f11530:	0a00000d 	beq	21f1156c <process_macros+0xcc>
				if (inputcnt-- == 0)
21f11534:	e51b3024 	ldr	r3, [fp, #-36]
21f11538:	e2433001 	sub	r3, r3, #1	; 0x1
21f1153c:	e50b3024 	str	r3, [fp, #-36]
21f11540:	e51b3024 	ldr	r3, [fp, #-36]
21f11544:	e3730001 	cmn	r3, #1	; 0x1
21f11548:	0a0000b5 	beq	21f11824 <.text+0x11824>
					break;
				prev = c;
21f1154c:	e55b302a 	ldrb	r3, [fp, #-42]
21f11550:	e54b3029 	strb	r3, [fp, #-41]
				c = *input++;
21f11554:	e51b3130 	ldr	r3, [fp, #-304]
21f11558:	e5d33000 	ldrb	r3, [r3]
21f1155c:	e54b302a 	strb	r3, [fp, #-42]
21f11560:	e51b3130 	ldr	r3, [fp, #-304]
21f11564:	e2833001 	add	r3, r3, #1	; 0x1
21f11568:	e50b3130 	str	r3, [fp, #-304]
			}
		}

		switch (state) {
21f1156c:	e51b301c 	ldr	r3, [fp, #-28]
21f11570:	e3530003 	cmp	r3, #3	; 0x3
21f11574:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f11578:	ea0000a1 	b	21f11804 <.text+0x11804>
21f1157c:	21f1158c 	mvncss	r1, ip, lsl #11
21f11580:	21f11600 	mvncss	r1, r0, lsl #12
21f11584:	21f11690 	ldrcsb	r1, [r1, #96]!
21f11588:	21f117bc 	ldrcsh	r1, [r1, #124]!
		case 0:	/* Waiting for (unescaped) $    */
			if ((c == '\'') && (prev != '\\')) {
21f1158c:	e55b302a 	ldrb	r3, [fp, #-42]
21f11590:	e3530027 	cmp	r3, #39	; 0x27
21f11594:	1a000005 	bne	21f115b0 <.text+0x115b0>
21f11598:	e55b3029 	ldrb	r3, [fp, #-41]
21f1159c:	e353005c 	cmp	r3, #92	; 0x5c
21f115a0:	0a000002 	beq	21f115b0 <.text+0x115b0>
				state = 3;
21f115a4:	e3a03003 	mov	r3, #3	; 0x3
21f115a8:	e50b301c 	str	r3, [fp, #-28]
				break;
21f115ac:	ea000094 	b	21f11804 <.text+0x11804>
			}
			if ((c == '$') && (prev != '\\')) {
21f115b0:	e55b302a 	ldrb	r3, [fp, #-42]
21f115b4:	e3530024 	cmp	r3, #36	; 0x24
21f115b8:	1a000006 	bne	21f115d8 <.text+0x115d8>
21f115bc:	e55b3029 	ldrb	r3, [fp, #-41]
21f115c0:	e353005c 	cmp	r3, #92	; 0x5c
21f115c4:	0a000003 	beq	21f115d8 <.text+0x115d8>
				state++;
21f115c8:	e51b301c 	ldr	r3, [fp, #-28]
21f115cc:	e2833001 	add	r3, r3, #1	; 0x1
21f115d0:	e50b301c 	str	r3, [fp, #-28]
21f115d4:	ea00008a 	b	21f11804 <.text+0x11804>
			} else {
				*(output++) = c;
21f115d8:	e51b2134 	ldr	r2, [fp, #-308]
21f115dc:	e55b302a 	ldrb	r3, [fp, #-42]
21f115e0:	e5c23000 	strb	r3, [r2]
21f115e4:	e51b3134 	ldr	r3, [fp, #-308]
21f115e8:	e2833001 	add	r3, r3, #1	; 0x1
21f115ec:	e50b3134 	str	r3, [fp, #-308]
				outputcnt--;
21f115f0:	e51b3020 	ldr	r3, [fp, #-32]
21f115f4:	e2433001 	sub	r3, r3, #1	; 0x1
21f115f8:	e50b3020 	str	r3, [fp, #-32]
21f115fc:	ea000080 	b	21f11804 <.text+0x11804>
			}
			break;
		case 1:	/* Waiting for (        */
			if (c == '(' || c == '{') {
21f11600:	e55b302a 	ldrb	r3, [fp, #-42]
21f11604:	e3530028 	cmp	r3, #40	; 0x28
21f11608:	0a000002 	beq	21f11618 <.text+0x11618>
21f1160c:	e55b302a 	ldrb	r3, [fp, #-42]
21f11610:	e353007b 	cmp	r3, #123	; 0x7b
21f11614:	1a000005 	bne	21f11630 <.text+0x11630>
				state++;
21f11618:	e51b301c 	ldr	r3, [fp, #-28]
21f1161c:	e2833001 	add	r3, r3, #1	; 0x1
21f11620:	e50b301c 	str	r3, [fp, #-28]
				varname_start = input;
21f11624:	e51b3130 	ldr	r3, [fp, #-304]
21f11628:	e50b3028 	str	r3, [fp, #-40]
21f1162c:	ea000074 	b	21f11804 <.text+0x11804>
			} else {
				state = 0;
21f11630:	e3a03000 	mov	r3, #0	; 0x0
21f11634:	e50b301c 	str	r3, [fp, #-28]
				*(output++) = '$';
21f11638:	e51b2134 	ldr	r2, [fp, #-308]
21f1163c:	e3a03024 	mov	r3, #36	; 0x24
21f11640:	e5c23000 	strb	r3, [r2]
21f11644:	e51b3134 	ldr	r3, [fp, #-308]
21f11648:	e2833001 	add	r3, r3, #1	; 0x1
21f1164c:	e50b3134 	str	r3, [fp, #-308]
				outputcnt--;
21f11650:	e51b3020 	ldr	r3, [fp, #-32]
21f11654:	e2433001 	sub	r3, r3, #1	; 0x1
21f11658:	e50b3020 	str	r3, [fp, #-32]

				if (outputcnt) {
21f1165c:	e51b3020 	ldr	r3, [fp, #-32]
21f11660:	e3530000 	cmp	r3, #0	; 0x0
21f11664:	0a000066 	beq	21f11804 <.text+0x11804>
					*(output++) = c;
21f11668:	e51b2134 	ldr	r2, [fp, #-308]
21f1166c:	e55b302a 	ldrb	r3, [fp, #-42]
21f11670:	e5c23000 	strb	r3, [r2]
21f11674:	e51b3134 	ldr	r3, [fp, #-308]
21f11678:	e2833001 	add	r3, r3, #1	; 0x1
21f1167c:	e50b3134 	str	r3, [fp, #-308]
					outputcnt--;
21f11680:	e51b3020 	ldr	r3, [fp, #-32]
21f11684:	e2433001 	sub	r3, r3, #1	; 0x1
21f11688:	e50b3020 	str	r3, [fp, #-32]
21f1168c:	ea00005c 	b	21f11804 <.text+0x11804>
				}
			}
			break;
		case 2:	/* Waiting for )        */
			if (c == ')' || c == '}') {
21f11690:	e55b302a 	ldrb	r3, [fp, #-42]
21f11694:	e3530029 	cmp	r3, #41	; 0x29
21f11698:	0a000002 	beq	21f116a8 <.text+0x116a8>
21f1169c:	e55b302a 	ldrb	r3, [fp, #-42]
21f116a0:	e353007d 	cmp	r3, #125	; 0x7d
21f116a4:	1a000056 	bne	21f11804 <.text+0x11804>
				int i;
				char envname[CFG_CBSIZE], *envval;
				int envcnt = input - varname_start - 1;	/* Varname # of chars */
21f116a8:	e51b2130 	ldr	r2, [fp, #-304]
21f116ac:	e51b3028 	ldr	r3, [fp, #-40]
21f116b0:	e0633002 	rsb	r3, r3, r2
21f116b4:	e2433001 	sub	r3, r3, #1	; 0x1
21f116b8:	e50b3010 	str	r3, [fp, #-16]

				/* Get the varname */
				for (i = 0; i < envcnt; i++) {
21f116bc:	e3a03000 	mov	r3, #0	; 0x0
21f116c0:	e50b3018 	str	r3, [fp, #-24]
21f116c4:	ea00000f 	b	21f11708 <.text+0x11708>
					envname[i] = varname_start[i];
21f116c8:	e51b0018 	ldr	r0, [fp, #-24]
21f116cc:	e51b3018 	ldr	r3, [fp, #-24]
21f116d0:	e1a02003 	mov	r2, r3
21f116d4:	e51b3028 	ldr	r3, [fp, #-40]
21f116d8:	e0823003 	add	r3, r2, r3
21f116dc:	e5d31000 	ldrb	r1, [r3]
21f116e0:	e3e03f47 	mvn	r3, #284	; 0x11c
21f116e4:	e2433001 	sub	r3, r3, #1	; 0x1
21f116e8:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f116ec:	e08c2000 	add	r2, ip, r0
21f116f0:	e0822003 	add	r2, r2, r3
21f116f4:	e1a03001 	mov	r3, r1
21f116f8:	e5c23000 	strb	r3, [r2]
21f116fc:	e51b3018 	ldr	r3, [fp, #-24]
21f11700:	e2833001 	add	r3, r3, #1	; 0x1
21f11704:	e50b3018 	str	r3, [fp, #-24]
21f11708:	e51b2018 	ldr	r2, [fp, #-24]
21f1170c:	e51b3010 	ldr	r3, [fp, #-16]
21f11710:	e1520003 	cmp	r2, r3
21f11714:	baffffeb 	blt	21f116c8 <.text+0x116c8>
				}
				envname[i] = 0;
21f11718:	e51b2018 	ldr	r2, [fp, #-24]
21f1171c:	e3e03f47 	mvn	r3, #284	; 0x11c
21f11720:	e2433001 	sub	r3, r3, #1	; 0x1
21f11724:	e24b100c 	sub	r1, fp, #12	; 0xc
21f11728:	e0812002 	add	r2, r1, r2
21f1172c:	e0822003 	add	r2, r2, r3
21f11730:	e3a03000 	mov	r3, #0	; 0x0
21f11734:	e5c23000 	strb	r3, [r2]

				/* Get its value */
				envval = getenv (envname);
21f11738:	e24b3f4a 	sub	r3, fp, #296	; 0x128
21f1173c:	e2433002 	sub	r3, r3, #2	; 0x2
21f11740:	e1a00003 	mov	r0, r3
21f11744:	eb002533 	bl	21f1ac18 <getenv>
21f11748:	e1a03000 	mov	r3, r0
21f1174c:	e50b3014 	str	r3, [fp, #-20]

				/* Copy into the line if it exists */
				if (envval != NULL)
21f11750:	e51b3014 	ldr	r3, [fp, #-20]
21f11754:	e3530000 	cmp	r3, #0	; 0x0
21f11758:	1a00000d 	bne	21f11794 <.text+0x11794>
21f1175c:	ea000013 	b	21f117b0 <.text+0x117b0>
					while ((*envval) && outputcnt) {
						*(output++) = *(envval++);
21f11760:	e51b3014 	ldr	r3, [fp, #-20]
21f11764:	e5d33000 	ldrb	r3, [r3]
21f11768:	e51b2134 	ldr	r2, [fp, #-308]
21f1176c:	e5c23000 	strb	r3, [r2]
21f11770:	e51b3134 	ldr	r3, [fp, #-308]
21f11774:	e2833001 	add	r3, r3, #1	; 0x1
21f11778:	e50b3134 	str	r3, [fp, #-308]
21f1177c:	e51b3014 	ldr	r3, [fp, #-20]
21f11780:	e2833001 	add	r3, r3, #1	; 0x1
21f11784:	e50b3014 	str	r3, [fp, #-20]
						outputcnt--;
21f11788:	e51b3020 	ldr	r3, [fp, #-32]
21f1178c:	e2433001 	sub	r3, r3, #1	; 0x1
21f11790:	e50b3020 	str	r3, [fp, #-32]
21f11794:	e51b3014 	ldr	r3, [fp, #-20]
21f11798:	e5d33000 	ldrb	r3, [r3]
21f1179c:	e3530000 	cmp	r3, #0	; 0x0
21f117a0:	0a000002 	beq	21f117b0 <.text+0x117b0>
21f117a4:	e51b3020 	ldr	r3, [fp, #-32]
21f117a8:	e3530000 	cmp	r3, #0	; 0x0
21f117ac:	1affffeb 	bne	21f11760 <.text+0x11760>
					}
				/* Look for another '$' */
				state = 0;
21f117b0:	e3a03000 	mov	r3, #0	; 0x0
21f117b4:	e50b301c 	str	r3, [fp, #-28]
21f117b8:	ea000011 	b	21f11804 <.text+0x11804>
			}
			break;
		case 3:	/* Waiting for '        */
			if ((c == '\'') && (prev != '\\')) {
21f117bc:	e55b302a 	ldrb	r3, [fp, #-42]
21f117c0:	e3530027 	cmp	r3, #39	; 0x27
21f117c4:	1a000005 	bne	21f117e0 <.text+0x117e0>
21f117c8:	e55b3029 	ldrb	r3, [fp, #-41]
21f117cc:	e353005c 	cmp	r3, #92	; 0x5c
21f117d0:	0a000002 	beq	21f117e0 <.text+0x117e0>
				state = 0;
21f117d4:	e3a03000 	mov	r3, #0	; 0x0
21f117d8:	e50b301c 	str	r3, [fp, #-28]
21f117dc:	ea000008 	b	21f11804 <.text+0x11804>
			} else {
				*(output++) = c;
21f117e0:	e51b2134 	ldr	r2, [fp, #-308]
21f117e4:	e55b302a 	ldrb	r3, [fp, #-42]
21f117e8:	e5c23000 	strb	r3, [r2]
21f117ec:	e51b3134 	ldr	r3, [fp, #-308]
21f117f0:	e2833001 	add	r3, r3, #1	; 0x1
21f117f4:	e50b3134 	str	r3, [fp, #-308]
				outputcnt--;
21f117f8:	e51b3020 	ldr	r3, [fp, #-32]
21f117fc:	e2433001 	sub	r3, r3, #1	; 0x1
21f11800:	e50b3020 	str	r3, [fp, #-32]
			}
			break;
		}
		prev = c;
21f11804:	e55b302a 	ldrb	r3, [fp, #-42]
21f11808:	e54b3029 	strb	r3, [fp, #-41]
21f1180c:	e51b3024 	ldr	r3, [fp, #-36]
21f11810:	e3530000 	cmp	r3, #0	; 0x0
21f11814:	0a000002 	beq	21f11824 <.text+0x11824>
21f11818:	e51b3020 	ldr	r3, [fp, #-32]
21f1181c:	e3530000 	cmp	r3, #0	; 0x0
21f11820:	1affff31 	bne	21f114ec <process_macros+0x4c>
	}

	if (outputcnt)
21f11824:	e51b3020 	ldr	r3, [fp, #-32]
21f11828:	e3530000 	cmp	r3, #0	; 0x0
21f1182c:	0a000002 	beq	21f1183c <.text+0x1183c>
		*output = 0;
21f11830:	e51b3134 	ldr	r3, [fp, #-308]
21f11834:	e3a02000 	mov	r2, #0	; 0x0
21f11838:	e5c32000 	strb	r2, [r3]

#ifdef DEBUG_PARSER
	printf ("[PROCESS_MACROS] OUTPUT len %d: \"%s\"\n",
		strlen (output_start), output_start);
#endif
}
21f1183c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f11840:	e89da800 	ldmia	sp, {fp, sp, pc}

21f11844 <run_command>:

/****************************************************************************
 * returns:
 *	1  - command executed, repeatable
 *	0  - command executed but not repeatable, interrupted commands are
 *	     always considered not repeatable
 *	-1 - not executed (unrecognized, bootd recursion or too many args)
 *           (If cmd is NULL or "" or longer than CFG_CBSIZE-1 it is
 *           considered unrecognized)
 *
 * WARNING:
 *
 * We must create a temporary copy of the command since the command we get
 * may be the result from getenv(), which returns a pointer directly to
 * the environment data, which may change magicly when the command we run
 * creates or modifies environment variables (like "bootp" does).
 */

int run_command (const char *cmd, int flag)
{
21f11844:	e1a0c00d 	mov	ip, sp
21f11848:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1184c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f11850:	e24ddf9d 	sub	sp, sp, #628	; 0x274
21f11854:	e50b0274 	str	r0, [fp, #-628]
21f11858:	e50b1278 	str	r1, [fp, #-632]
	cmd_tbl_t *cmdtp;
	char cmdbuf[CFG_CBSIZE];	/* working copy of cmd		*/
	char *token;			/* start of token in cmdbuf	*/
	char *sep;			/* end of token (separator) in cmdbuf */
	char finaltoken[CFG_CBSIZE];
	char *str = cmdbuf;
21f1185c:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f11860:	e50b3020 	str	r3, [fp, #-32]
	char *argv[CFG_MAXARGS + 1];	/* NULL terminated	*/
	int argc, inquotes;
	int repeatable = 1;
21f11864:	e3a03001 	mov	r3, #1	; 0x1
21f11868:	e50b3014 	str	r3, [fp, #-20]
	int rc = 0;
21f1186c:	e3a03000 	mov	r3, #0	; 0x0
21f11870:	e50b3010 	str	r3, [fp, #-16]

#ifdef DEBUG_PARSER
	printf ("[RUN_COMMAND] cmd[%p]=\"", cmd);
	puts (cmd ? cmd : "NULL");	/* use puts - string may be loooong */
	puts ("\"\n");
#endif

	clear_ctrlc();		/* forget any previous Control C */
21f11874:	eb0028e7 	bl	21f1bc18 <clear_ctrlc>

	if (!cmd || !*cmd) {
21f11878:	e51b3274 	ldr	r3, [fp, #-628]
21f1187c:	e3530000 	cmp	r3, #0	; 0x0
21f11880:	0a000003 	beq	21f11894 <run_command+0x50>
21f11884:	e51b3274 	ldr	r3, [fp, #-628]
21f11888:	e5d33000 	ldrb	r3, [r3]
21f1188c:	e3530000 	cmp	r3, #0	; 0x0
21f11890:	1a000002 	bne	21f118a0 <run_command+0x5c>
		return -1;	/* empty command */
21f11894:	e3e03000 	mvn	r3, #0	; 0x0
21f11898:	e50b3280 	str	r3, [fp, #-640]
21f1189c:	ea0000ae 	b	21f11b5c <run_command+0x318>
	}

	if (strlen(cmd) >= CFG_CBSIZE) {
21f118a0:	e51b0274 	ldr	r0, [fp, #-628]
21f118a4:	eb0044c6 	bl	21f22bc4 <strlen>
21f118a8:	e1a03000 	mov	r3, r0
21f118ac:	e35300ff 	cmp	r3, #255	; 0xff
21f118b0:	9a000004 	bls	21f118c8 <run_command+0x84>
		puts ("## Command too long!\n");
21f118b4:	e59f02b0 	ldr	r0, [pc, #688]	; 21f11b6c <.text+0x11b6c>
21f118b8:	eb002860 	bl	21f1ba40 <puts>
		return -1;
21f118bc:	e3e03000 	mvn	r3, #0	; 0x0
21f118c0:	e50b3280 	str	r3, [fp, #-640]
21f118c4:	ea0000a4 	b	21f11b5c <run_command+0x318>
	}

	strcpy (cmdbuf, cmd);
21f118c8:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f118cc:	e1a00003 	mov	r0, r3
21f118d0:	e51b1274 	ldr	r1, [fp, #-628]
21f118d4:	eb00437e 	bl	21f226d4 <strcpy>

	/* Process separators and check for invalid
	 * repeatable commands
	 */

#ifdef DEBUG_PARSER
	printf ("[PROCESS_SEPARATORS] %s\n", cmd);
#endif
	while (*str) {
21f118d8:	ea000091 	b	21f11b24 <run_command+0x2e0>

		/*
		 * Find separator, or string end
		 * Allow simple escape of ';' by writing "\;"
		 */
		for (inquotes = 0, sep = str; *sep; sep++) {
21f118dc:	e3a03000 	mov	r3, #0	; 0x0
21f118e0:	e50b3018 	str	r3, [fp, #-24]
21f118e4:	e51b3020 	ldr	r3, [fp, #-32]
21f118e8:	e50b3024 	str	r3, [fp, #-36]
21f118ec:	ea000020 	b	21f11974 <run_command+0x130>
			if ((*sep=='\'') &&
21f118f0:	e51b3024 	ldr	r3, [fp, #-36]
21f118f4:	e5d33000 	ldrb	r3, [r3]
21f118f8:	e3530027 	cmp	r3, #39	; 0x27
21f118fc:	1a000009 	bne	21f11928 <run_command+0xe4>
21f11900:	e51b3024 	ldr	r3, [fp, #-36]
21f11904:	e2433001 	sub	r3, r3, #1	; 0x1
21f11908:	e5d33000 	ldrb	r3, [r3]
21f1190c:	e353005c 	cmp	r3, #92	; 0x5c
21f11910:	0a000004 	beq	21f11928 <run_command+0xe4>
			    (*(sep-1) != '\\'))
				inquotes=!inquotes;
21f11914:	e51b3018 	ldr	r3, [fp, #-24]
21f11918:	e3530000 	cmp	r3, #0	; 0x0
21f1191c:	13a03000 	movne	r3, #0	; 0x0
21f11920:	03a03001 	moveq	r3, #1	; 0x1
21f11924:	e50b3018 	str	r3, [fp, #-24]

			if (!inquotes &&
21f11928:	e51b3018 	ldr	r3, [fp, #-24]
21f1192c:	e3530000 	cmp	r3, #0	; 0x0
21f11930:	1a00000c 	bne	21f11968 <run_command+0x124>
21f11934:	e51b3024 	ldr	r3, [fp, #-36]
21f11938:	e5d33000 	ldrb	r3, [r3]
21f1193c:	e353003b 	cmp	r3, #59	; 0x3b
21f11940:	1a000008 	bne	21f11968 <run_command+0x124>
21f11944:	e51b2024 	ldr	r2, [fp, #-36]
21f11948:	e51b3020 	ldr	r3, [fp, #-32]
21f1194c:	e1520003 	cmp	r2, r3
21f11950:	0a000004 	beq	21f11968 <run_command+0x124>
21f11954:	e51b3024 	ldr	r3, [fp, #-36]
21f11958:	e2433001 	sub	r3, r3, #1	; 0x1
21f1195c:	e5d33000 	ldrb	r3, [r3]
21f11960:	e353005c 	cmp	r3, #92	; 0x5c
21f11964:	1a000006 	bne	21f11984 <run_command+0x140>
21f11968:	e51b3024 	ldr	r3, [fp, #-36]
21f1196c:	e2833001 	add	r3, r3, #1	; 0x1
21f11970:	e50b3024 	str	r3, [fp, #-36]
21f11974:	e51b3024 	ldr	r3, [fp, #-36]
21f11978:	e5d33000 	ldrb	r3, [r3]
21f1197c:	e3530000 	cmp	r3, #0	; 0x0
21f11980:	1affffda 	bne	21f118f0 <run_command+0xac>
			    (*sep == ';') &&	/* separator		*/
			    ( sep != str) &&	/* past string start	*/
			    (*(sep-1) != '\\'))	/* and NOT escaped	*/
				break;
		}

		/*
		 * Limit the token to data between separators
		 */
		token = str;
21f11984:	e51b3020 	ldr	r3, [fp, #-32]
21f11988:	e50b3028 	str	r3, [fp, #-40]
		if (*sep) {
21f1198c:	e51b3024 	ldr	r3, [fp, #-36]
21f11990:	e5d33000 	ldrb	r3, [r3]
21f11994:	e3530000 	cmp	r3, #0	; 0x0
21f11998:	0a000006 	beq	21f119b8 <run_command+0x174>
			str = sep + 1;	/* start of command for next pass */
21f1199c:	e51b3024 	ldr	r3, [fp, #-36]
21f119a0:	e2833001 	add	r3, r3, #1	; 0x1
21f119a4:	e50b3020 	str	r3, [fp, #-32]
			*sep = '\0';
21f119a8:	e51b2024 	ldr	r2, [fp, #-36]
21f119ac:	e3a03000 	mov	r3, #0	; 0x0
21f119b0:	e5c23000 	strb	r3, [r2]
21f119b4:	ea000001 	b	21f119c0 <run_command+0x17c>
		}
		else
			str = sep;	/* no more commands for next pass */
21f119b8:	e51b3024 	ldr	r3, [fp, #-36]
21f119bc:	e50b3020 	str	r3, [fp, #-32]
#ifdef DEBUG_PARSER
		printf ("token: \"%s\"\n", token);
#endif

		/* find macros in this token and replace them */
		process_macros (token, finaltoken);
21f119c0:	e24b3f8b 	sub	r3, fp, #556	; 0x22c
21f119c4:	e51b0028 	ldr	r0, [fp, #-40]
21f119c8:	e1a01003 	mov	r1, r3
21f119cc:	ebfffeb3 	bl	21f114a0 <process_macros>

		/* Extract arguments */
		if ((argc = parse_line (finaltoken, argv)) == 0) {
21f119d0:	e24b3f8b 	sub	r3, fp, #556	; 0x22c
21f119d4:	e24b2e27 	sub	r2, fp, #624	; 0x270
21f119d8:	e1a00003 	mov	r0, r3
21f119dc:	e1a01002 	mov	r1, r2
21f119e0:	ebfffe51 	bl	21f1132c <parse_line>
21f119e4:	e1a03000 	mov	r3, r0
21f119e8:	e50b301c 	str	r3, [fp, #-28]
21f119ec:	e51b301c 	ldr	r3, [fp, #-28]
21f119f0:	e3530000 	cmp	r3, #0	; 0x0
21f119f4:	1a000002 	bne	21f11a04 <run_command+0x1c0>
			rc = -1;	/* no command at all */
21f119f8:	e3e03000 	mvn	r3, #0	; 0x0
21f119fc:	e50b3010 	str	r3, [fp, #-16]
			continue;
21f11a00:	ea000047 	b	21f11b24 <run_command+0x2e0>
		}

		/* Look up command in command table */
		if ((cmdtp = find_cmd(argv[0])) == NULL) {
21f11a04:	e51b3270 	ldr	r3, [fp, #-624]
21f11a08:	e1a00003 	mov	r0, r3
21f11a0c:	eb0026a3 	bl	21f1b4a0 <find_cmd>
21f11a10:	e1a03000 	mov	r3, r0
21f11a14:	e50b302c 	str	r3, [fp, #-44]
21f11a18:	e51b302c 	ldr	r3, [fp, #-44]
21f11a1c:	e3530000 	cmp	r3, #0	; 0x0
21f11a20:	1a000006 	bne	21f11a40 <run_command+0x1fc>
			printf ("Unknown command '%s' - try 'help'\n", argv[0]);
21f11a24:	e51b3270 	ldr	r3, [fp, #-624]
21f11a28:	e59f0140 	ldr	r0, [pc, #320]	; 21f11b70 <.text+0x11b70>
21f11a2c:	e1a01003 	mov	r1, r3
21f11a30:	eb002815 	bl	21f1ba8c <printf>
			rc = -1;	/* give up after bad command */
21f11a34:	e3e03000 	mvn	r3, #0	; 0x0
21f11a38:	e50b3010 	str	r3, [fp, #-16]
			continue;
21f11a3c:	ea000038 	b	21f11b24 <run_command+0x2e0>
		}

		/* found - check max args */
		if (argc > cmdtp->maxargs) {
21f11a40:	e51b302c 	ldr	r3, [fp, #-44]
21f11a44:	e5932004 	ldr	r2, [r3, #4]
21f11a48:	e51b301c 	ldr	r3, [fp, #-28]
21f11a4c:	e1520003 	cmp	r2, r3
21f11a50:	aa000007 	bge	21f11a74 <run_command+0x230>
			printf ("Usage:\n%s\n", cmdtp->usage);
21f11a54:	e51b302c 	ldr	r3, [fp, #-44]
21f11a58:	e5933010 	ldr	r3, [r3, #16]
21f11a5c:	e59f0110 	ldr	r0, [pc, #272]	; 21f11b74 <.text+0x11b74>
21f11a60:	e1a01003 	mov	r1, r3
21f11a64:	eb002808 	bl	21f1ba8c <printf>
			rc = -1;
21f11a68:	e3e03000 	mvn	r3, #0	; 0x0
21f11a6c:	e50b3010 	str	r3, [fp, #-16]
			continue;
21f11a70:	ea00002b 	b	21f11b24 <run_command+0x2e0>
		}

#if (CONFIG_COMMANDS & CFG_CMD_BOOTD)
		/* avoid "bootd" recursion */
		if (cmdtp->cmd == do_bootd) {
21f11a74:	e51b302c 	ldr	r3, [fp, #-44]
21f11a78:	e593200c 	ldr	r2, [r3, #12]
21f11a7c:	e59f30f4 	ldr	r3, [pc, #244]	; 21f11b78 <.text+0x11b78>
21f11a80:	e1520003 	cmp	r2, r3
21f11a84:	1a00000d 	bne	21f11ac0 <run_command+0x27c>
#ifdef DEBUG_PARSER
			printf ("[%s]\n", finaltoken);
#endif
			if (flag & CMD_FLAG_BOOTD) {
21f11a88:	e51b3278 	ldr	r3, [fp, #-632]
21f11a8c:	e1a030a3 	mov	r3, r3, lsr #1
21f11a90:	e2033001 	and	r3, r3, #1	; 0x1
21f11a94:	e20330ff 	and	r3, r3, #255	; 0xff
21f11a98:	e3530000 	cmp	r3, #0	; 0x0
21f11a9c:	0a000004 	beq	21f11ab4 <run_command+0x270>
				puts ("'bootd' recursion detected\n");
21f11aa0:	e59f00d4 	ldr	r0, [pc, #212]	; 21f11b7c <.text+0x11b7c>
21f11aa4:	eb0027e5 	bl	21f1ba40 <puts>
				rc = -1;
21f11aa8:	e3e03000 	mvn	r3, #0	; 0x0
21f11aac:	e50b3010 	str	r3, [fp, #-16]
				continue;
21f11ab0:	ea00001b 	b	21f11b24 <run_command+0x2e0>
			} else {
				flag |= CMD_FLAG_BOOTD;
21f11ab4:	e51b3278 	ldr	r3, [fp, #-632]
21f11ab8:	e3833002 	orr	r3, r3, #2	; 0x2
21f11abc:	e50b3278 	str	r3, [fp, #-632]
			}
		}
#endif	/* CFG_CMD_BOOTD */

		/* OK - call function to do the command */
		if ((cmdtp->cmd) (cmdtp, flag, argc, argv) != 0) {
21f11ac0:	e51b302c 	ldr	r3, [fp, #-44]
21f11ac4:	e593c00c 	ldr	ip, [r3, #12]
21f11ac8:	e24b3e27 	sub	r3, fp, #624	; 0x270
21f11acc:	e51b002c 	ldr	r0, [fp, #-44]
21f11ad0:	e51b1278 	ldr	r1, [fp, #-632]
21f11ad4:	e51b201c 	ldr	r2, [fp, #-28]
21f11ad8:	e1a0e00f 	mov	lr, pc
21f11adc:	e1a0f00c 	mov	pc, ip
21f11ae0:	e1a03000 	mov	r3, r0
21f11ae4:	e3530000 	cmp	r3, #0	; 0x0
21f11ae8:	0a000001 	beq	21f11af4 <run_command+0x2b0>
			rc = -1;
21f11aec:	e3e03000 	mvn	r3, #0	; 0x0
21f11af0:	e50b3010 	str	r3, [fp, #-16]
		}

		repeatable &= cmdtp->repeatable;
21f11af4:	e51b302c 	ldr	r3, [fp, #-44]
21f11af8:	e5932008 	ldr	r2, [r3, #8]
21f11afc:	e51b3014 	ldr	r3, [fp, #-20]
21f11b00:	e0033002 	and	r3, r3, r2
21f11b04:	e50b3014 	str	r3, [fp, #-20]

		/* Did the user stop this? */
		if (had_ctrlc ())
21f11b08:	eb00283a 	bl	21f1bbf8 <had_ctrlc>
21f11b0c:	e1a03000 	mov	r3, r0
21f11b10:	e3530000 	cmp	r3, #0	; 0x0
21f11b14:	0a000002 	beq	21f11b24 <run_command+0x2e0>
			return 0;	/* if stopped then not repeatable */
21f11b18:	e3a03000 	mov	r3, #0	; 0x0
21f11b1c:	e50b3280 	str	r3, [fp, #-640]
21f11b20:	ea00000d 	b	21f11b5c <run_command+0x318>
21f11b24:	e51b3020 	ldr	r3, [fp, #-32]
21f11b28:	e5d33000 	ldrb	r3, [r3]
21f11b2c:	e3530000 	cmp	r3, #0	; 0x0
21f11b30:	1affff69 	bne	21f118dc <run_command+0x98>
	}

	return rc ? rc : repeatable;
21f11b34:	e51b3010 	ldr	r3, [fp, #-16]
21f11b38:	e3530000 	cmp	r3, #0	; 0x0
21f11b3c:	0a000002 	beq	21f11b4c <run_command+0x308>
21f11b40:	e51b3010 	ldr	r3, [fp, #-16]
21f11b44:	e50b327c 	str	r3, [fp, #-636]
21f11b48:	ea000001 	b	21f11b54 <run_command+0x310>
21f11b4c:	e51b3014 	ldr	r3, [fp, #-20]
21f11b50:	e50b327c 	str	r3, [fp, #-636]
21f11b54:	e51b327c 	ldr	r3, [fp, #-636]
21f11b58:	e50b3280 	str	r3, [fp, #-640]
21f11b5c:	e51b3280 	ldr	r3, [fp, #-640]
}
21f11b60:	e1a00003 	mov	r0, r3
21f11b64:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f11b68:	e89da800 	ldmia	sp, {fp, sp, pc}
21f11b6c:	21f3000c 	mvncss	r0, ip
21f11b70:	21f30024 	mvncss	r0, r4, lsr #32
21f11b74:	21f30048 	mvncss	r0, r8, asr #32
21f11b78:	21f12784 	mvncss	r2, r4, lsl #15
21f11b7c:	21f30054 	mvncss	r0, r4, asr r0

21f11b80 <do_run>:

/****************************************************************************/

#if (CONFIG_COMMANDS & CFG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
21f11b80:	e1a0c00d 	mov	ip, sp
21f11b84:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f11b88:	e24cb004 	sub	fp, ip, #4	; 0x4
21f11b8c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f11b90:	e50b0018 	str	r0, [fp, #-24]
21f11b94:	e50b101c 	str	r1, [fp, #-28]
21f11b98:	e50b2020 	str	r2, [fp, #-32]
21f11b9c:	e50b3024 	str	r3, [fp, #-36]
	int i;

	if (argc < 2) {
21f11ba0:	e51b3020 	ldr	r3, [fp, #-32]
21f11ba4:	e3530001 	cmp	r3, #1	; 0x1
21f11ba8:	ca000007 	bgt	21f11bcc <do_run+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f11bac:	e51b3018 	ldr	r3, [fp, #-24]
21f11bb0:	e5933010 	ldr	r3, [r3, #16]
21f11bb4:	e59f00d8 	ldr	r0, [pc, #216]	; 21f11c94 <.text+0x11c94>
21f11bb8:	e1a01003 	mov	r1, r3
21f11bbc:	eb0027b2 	bl	21f1ba8c <printf>
		return 1;
21f11bc0:	e3a03001 	mov	r3, #1	; 0x1
21f11bc4:	e50b3028 	str	r3, [fp, #-40]
21f11bc8:	ea00002d 	b	21f11c84 <do_run+0x104>
	}

	for (i=1; i<argc; ++i) {
21f11bcc:	e3a03001 	mov	r3, #1	; 0x1
21f11bd0:	e50b3014 	str	r3, [fp, #-20]
21f11bd4:	ea000024 	b	21f11c6c <do_run+0xec>
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
21f11bd8:	e51b3014 	ldr	r3, [fp, #-20]
21f11bdc:	e1a03103 	mov	r3, r3, lsl #2
21f11be0:	e1a02003 	mov	r2, r3
21f11be4:	e51b3024 	ldr	r3, [fp, #-36]
21f11be8:	e0823003 	add	r3, r2, r3
21f11bec:	e5933000 	ldr	r3, [r3]
21f11bf0:	e1a00003 	mov	r0, r3
21f11bf4:	eb002407 	bl	21f1ac18 <getenv>
21f11bf8:	e1a03000 	mov	r3, r0
21f11bfc:	e50b3010 	str	r3, [fp, #-16]
21f11c00:	e51b3010 	ldr	r3, [fp, #-16]
21f11c04:	e3530000 	cmp	r3, #0	; 0x0
21f11c08:	1a00000b 	bne	21f11c3c <do_run+0xbc>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
21f11c0c:	e51b3014 	ldr	r3, [fp, #-20]
21f11c10:	e1a03103 	mov	r3, r3, lsl #2
21f11c14:	e1a02003 	mov	r2, r3
21f11c18:	e51b3024 	ldr	r3, [fp, #-36]
21f11c1c:	e0823003 	add	r3, r2, r3
21f11c20:	e5933000 	ldr	r3, [r3]
21f11c24:	e59f006c 	ldr	r0, [pc, #108]	; 21f11c98 <.text+0x11c98>
21f11c28:	e1a01003 	mov	r1, r3
21f11c2c:	eb002796 	bl	21f1ba8c <printf>
			return 1;
21f11c30:	e3a03001 	mov	r3, #1	; 0x1
21f11c34:	e50b3028 	str	r3, [fp, #-40]
21f11c38:	ea000011 	b	21f11c84 <do_run+0x104>
		}
#ifndef CFG_HUSH_PARSER
		if (run_command (arg, flag) == -1)
21f11c3c:	e51b0010 	ldr	r0, [fp, #-16]
21f11c40:	e51b101c 	ldr	r1, [fp, #-28]
21f11c44:	ebfffefe 	bl	21f11844 <run_command>
21f11c48:	e1a03000 	mov	r3, r0
21f11c4c:	e3730001 	cmn	r3, #1	; 0x1
21f11c50:	1a000002 	bne	21f11c60 <do_run+0xe0>
			return 1;
21f11c54:	e3a03001 	mov	r3, #1	; 0x1
21f11c58:	e50b3028 	str	r3, [fp, #-40]
21f11c5c:	ea000008 	b	21f11c84 <do_run+0x104>
21f11c60:	e51b3014 	ldr	r3, [fp, #-20]
21f11c64:	e2833001 	add	r3, r3, #1	; 0x1
21f11c68:	e50b3014 	str	r3, [fp, #-20]
21f11c6c:	e51b2014 	ldr	r2, [fp, #-20]
21f11c70:	e51b3020 	ldr	r3, [fp, #-32]
21f11c74:	e1520003 	cmp	r2, r3
21f11c78:	baffffd6 	blt	21f11bd8 <do_run+0x58>
#else
		if (parse_string_outer(arg,
		    FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP) != 0)
			return 1;
#endif
	}
	return 0;
21f11c7c:	e3a03000 	mov	r3, #0	; 0x0
21f11c80:	e50b3028 	str	r3, [fp, #-40]
21f11c84:	e51b3028 	ldr	r3, [fp, #-40]
}
21f11c88:	e1a00003 	mov	r0, r3
21f11c8c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f11c90:	e89da800 	ldmia	sp, {fp, sp, pc}
21f11c94:	21f30048 	mvncss	r0, r8, asr #32
21f11c98:	21f30070 	mvncss	r0, r0, ror r0

21f11c9c <do_go>:
DECLARE_GLOBAL_DATA_PTR;
#endif

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f11c9c:	e1a0c00d 	mov	ip, sp
21f11ca0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f11ca4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f11ca8:	e24dd020 	sub	sp, sp, #32	; 0x20
21f11cac:	e50b001c 	str	r0, [fp, #-28]
21f11cb0:	e50b1020 	str	r1, [fp, #-32]
21f11cb4:	e50b2024 	str	r2, [fp, #-36]
21f11cb8:	e50b3028 	str	r3, [fp, #-40]
	ulong	addr, rc;
	int     rcode = 0;
21f11cbc:	e3a03000 	mov	r3, #0	; 0x0
21f11cc0:	e50b3010 	str	r3, [fp, #-16]

	if (argc < 2) {
21f11cc4:	e51b3024 	ldr	r3, [fp, #-36]
21f11cc8:	e3530001 	cmp	r3, #1	; 0x1
21f11ccc:	ca000007 	bgt	21f11cf0 <do_go+0x54>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f11cd0:	e51b301c 	ldr	r3, [fp, #-28]
21f11cd4:	e5933010 	ldr	r3, [r3, #16]
21f11cd8:	e59f00a8 	ldr	r0, [pc, #168]	; 21f11d88 <.text+0x11d88>
21f11cdc:	e1a01003 	mov	r1, r3
21f11ce0:	eb002769 	bl	21f1ba8c <printf>
		return 1;
21f11ce4:	e3a03001 	mov	r3, #1	; 0x1
21f11ce8:	e50b302c 	str	r3, [fp, #-44]
21f11cec:	ea000021 	b	21f11d78 <do_go+0xdc>
	}

	addr = simple_strtoul(argv[1], NULL, 16);
21f11cf0:	e51b3028 	ldr	r3, [fp, #-40]
21f11cf4:	e2833004 	add	r3, r3, #4	; 0x4
21f11cf8:	e5933000 	ldr	r3, [r3]
21f11cfc:	e1a00003 	mov	r0, r3
21f11d00:	e3a01000 	mov	r1, #0	; 0x0
21f11d04:	e3a02010 	mov	r2, #16	; 0x10
21f11d08:	eb00462e 	bl	21f235c8 <simple_strtoul>
21f11d0c:	e1a03000 	mov	r3, r0
21f11d10:	e50b3018 	str	r3, [fp, #-24]

	printf ("## Starting application at 0x%08lX ...\n", addr);
21f11d14:	e59f0070 	ldr	r0, [pc, #112]	; 21f11d8c <.text+0x11d8c>
21f11d18:	e51b1018 	ldr	r1, [fp, #-24]
21f11d1c:	eb00275a 	bl	21f1ba8c <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
#if defined(CONFIG_I386)
	/*
	 * x86 does not use a dedicated register to pass the pointer
	 * to the global_data
	 */
	argv[0] = (char *)gd;
#endif
#if !defined(CONFIG_NIOS)
	rc = ((ulong (*)(int, char *[]))addr) (--argc, &argv[1]);
21f11d20:	e51b2018 	ldr	r2, [fp, #-24]
21f11d24:	e51b3024 	ldr	r3, [fp, #-36]
21f11d28:	e2433001 	sub	r3, r3, #1	; 0x1
21f11d2c:	e50b3024 	str	r3, [fp, #-36]
21f11d30:	e51b3028 	ldr	r3, [fp, #-40]
21f11d34:	e2833004 	add	r3, r3, #4	; 0x4
21f11d38:	e51b0024 	ldr	r0, [fp, #-36]
21f11d3c:	e1a01003 	mov	r1, r3
21f11d40:	e1a0e00f 	mov	lr, pc
21f11d44:	e1a0f002 	mov	pc, r2
21f11d48:	e1a03000 	mov	r3, r0
21f11d4c:	e50b3014 	str	r3, [fp, #-20]
#else
	/*
	 * Nios function pointers are address >> 1
	 */
	rc = ((ulong (*)(int, char *[]))(addr>>1)) (--argc, &argv[1]);
#endif
	if (rc != 0) rcode = 1;
21f11d50:	e51b3014 	ldr	r3, [fp, #-20]
21f11d54:	e3530000 	cmp	r3, #0	; 0x0
21f11d58:	0a000001 	beq	21f11d64 <do_go+0xc8>
21f11d5c:	e3a03001 	mov	r3, #1	; 0x1
21f11d60:	e50b3010 	str	r3, [fp, #-16]

	printf ("## Application terminated, rc = 0x%lX\n", rc);
21f11d64:	e59f0024 	ldr	r0, [pc, #36]	; 21f11d90 <.text+0x11d90>
21f11d68:	e51b1014 	ldr	r1, [fp, #-20]
21f11d6c:	eb002746 	bl	21f1ba8c <printf>
	return rcode;
21f11d70:	e51b3010 	ldr	r3, [fp, #-16]
21f11d74:	e50b302c 	str	r3, [fp, #-44]
21f11d78:	e51b302c 	ldr	r3, [fp, #-44]
}
21f11d7c:	e1a00003 	mov	r0, r3
21f11d80:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f11d84:	e89da800 	ldmia	sp, {fp, sp, pc}
21f11d88:	21f3008c 	mvncss	r0, ip, lsl #1
21f11d8c:	21f30098 	ldrcsb	r0, [r3, #8]!
21f11d90:	21f300c0 	mvncss	r0, r0, asr #1

21f11d94 <do_bootm>:

ulong load_addr = CFG_LOAD_ADDR;		/* Default Load Address */

int do_bootm (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f11d94:	e1a0c00d 	mov	ip, sp
21f11d98:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f11d9c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f11da0:	e24dd088 	sub	sp, sp, #136	; 0x88
21f11da4:	e50b0068 	str	r0, [fp, #-104]
21f11da8:	e50b106c 	str	r1, [fp, #-108]
21f11dac:	e50b2070 	str	r2, [fp, #-112]
21f11db0:	e50b3074 	str	r3, [fp, #-116]
	ulong	iflag;
	ulong	addr;
	ulong	data, len, checksum;
	ulong  *len_ptr;
	uint	unc_len = CFG_BOOTM_LEN;
21f11db4:	e3a03502 	mov	r3, #8388608	; 0x800000
21f11db8:	e50b302c 	str	r3, [fp, #-44]
	int	i, verify;
	char	*name, *s;
	int	(*appl)(int, char *[]);
	image_header_t *hdr = &header;
21f11dbc:	e59f36dc 	ldr	r3, [pc, #1756]	; 21f124a0 <.text+0x124a0>
21f11dc0:	e50b3014 	str	r3, [fp, #-20]

	s = getenv ("verify");
21f11dc4:	e59f06d8 	ldr	r0, [pc, #1752]	; 21f124a4 <.text+0x124a4>
21f11dc8:	eb002392 	bl	21f1ac18 <getenv>
21f11dcc:	e1a03000 	mov	r3, r0
21f11dd0:	e50b301c 	str	r3, [fp, #-28]
	verify = (s && (*s == 'n')) ? 0 : 1;
21f11dd4:	e51b301c 	ldr	r3, [fp, #-28]
21f11dd8:	e3530000 	cmp	r3, #0	; 0x0
21f11ddc:	0a000003 	beq	21f11df0 <do_bootm+0x5c>
21f11de0:	e51b301c 	ldr	r3, [fp, #-28]
21f11de4:	e5d33000 	ldrb	r3, [r3]
21f11de8:	e353006e 	cmp	r3, #110	; 0x6e
21f11dec:	0a000002 	beq	21f11dfc <do_bootm+0x68>
21f11df0:	e3a03001 	mov	r3, #1	; 0x1
21f11df4:	e50b308c 	str	r3, [fp, #-140]
21f11df8:	ea000001 	b	21f11e04 <do_bootm+0x70>
21f11dfc:	e3a03000 	mov	r3, #0	; 0x0
21f11e00:	e50b308c 	str	r3, [fp, #-140]
21f11e04:	e51b308c 	ldr	r3, [fp, #-140]
21f11e08:	e50b3024 	str	r3, [fp, #-36]

	if (argc < 2) {
21f11e0c:	e51b3070 	ldr	r3, [fp, #-112]
21f11e10:	e3530001 	cmp	r3, #1	; 0x1
21f11e14:	ca000003 	bgt	21f11e28 <do_bootm+0x94>
		addr = load_addr;
21f11e18:	e59f3688 	ldr	r3, [pc, #1672]	; 21f124a8 <.text+0x124a8>
21f11e1c:	e5933000 	ldr	r3, [r3]
21f11e20:	e50b303c 	str	r3, [fp, #-60]
21f11e24:	ea000008 	b	21f11e4c <do_bootm+0xb8>
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
21f11e28:	e51b3074 	ldr	r3, [fp, #-116]
21f11e2c:	e2833004 	add	r3, r3, #4	; 0x4
21f11e30:	e5933000 	ldr	r3, [r3]
21f11e34:	e1a00003 	mov	r0, r3
21f11e38:	e3a01000 	mov	r1, #0	; 0x0
21f11e3c:	e3a02010 	mov	r2, #16	; 0x10
21f11e40:	eb0045e0 	bl	21f235c8 <simple_strtoul>
21f11e44:	e1a03000 	mov	r3, r0
21f11e48:	e50b303c 	str	r3, [fp, #-60]
	}

	SHOW_BOOT_PROGRESS (1);
	printf ("## Booting image at %08lx ...\n", addr);
21f11e4c:	e59f0658 	ldr	r0, [pc, #1624]	; 21f124ac <.text+0x124ac>
21f11e50:	e51b103c 	ldr	r1, [fp, #-60]
21f11e54:	eb00270c 	bl	21f1ba8c <printf>

	/* Copy header so we can blank CRC field for re-calculation */
#ifdef CONFIG_HAS_DATAFLASH
	if (addr_dataflash(addr)){
21f11e58:	e51b003c 	ldr	r0, [fp, #-60]
21f11e5c:	ebfff9ac 	bl	21f10514 <addr_dataflash>
21f11e60:	e1a03000 	mov	r3, r0
21f11e64:	e3530000 	cmp	r3, #0	; 0x0
21f11e68:	0a000005 	beq	21f11e84 <do_bootm+0xf0>
		read_dataflash(addr, sizeof(image_header_t), (char *)&header);
21f11e6c:	e59f362c 	ldr	r3, [pc, #1580]	; 21f124a0 <.text+0x124a0>
21f11e70:	e51b003c 	ldr	r0, [fp, #-60]
21f11e74:	e3a01040 	mov	r1, #64	; 0x40
21f11e78:	e1a02003 	mov	r2, r3
21f11e7c:	ebfffae5 	bl	21f10a18 <read_dataflash>
21f11e80:	ea000004 	b	21f11e98 <do_bootm+0x104>
	} else
#endif
	memmove (&header, (char *)addr, sizeof(image_header_t));
21f11e84:	e51b303c 	ldr	r3, [fp, #-60]
21f11e88:	e59f0610 	ldr	r0, [pc, #1552]	; 21f124a0 <.text+0x124a0>
21f11e8c:	e1a01003 	mov	r1, r3
21f11e90:	e3a02040 	mov	r2, #64	; 0x40
21f11e94:	eb0044ec 	bl	21f2324c <memmove>

	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
21f11e98:	e51b3014 	ldr	r3, [fp, #-20]
21f11e9c:	e5933000 	ldr	r3, [r3]
21f11ea0:	e1a00003 	mov	r0, r3
21f11ea4:	eb000195 	bl	21f12500 <__fswab32>
21f11ea8:	e1a03000 	mov	r3, r0
21f11eac:	e1a02003 	mov	r2, r3
21f11eb0:	e59f35f8 	ldr	r3, [pc, #1528]	; 21f124b0 <.text+0x124b0>
21f11eb4:	e1520003 	cmp	r2, r3
21f11eb8:	0a000004 	beq	21f11ed0 <do_bootm+0x13c>
#ifdef __I386__	/* correct image format not implemented yet - fake it */
		if (fake_header(hdr, (void*)addr, -1) != NULL) {
			/* to compensate for the addition below */
			addr -= sizeof(image_header_t);
			/* turnof verify,
			 * fake_header() does not fake the data crc
			 */
			verify = 0;
		} else
#endif	/* __I386__ */
	    {
		puts ("Bad Magic Number\n");
21f11ebc:	e59f05f0 	ldr	r0, [pc, #1520]	; 21f124b4 <.text+0x124b4>
21f11ec0:	eb0026de 	bl	21f1ba40 <puts>
		SHOW_BOOT_PROGRESS (-1);
		return 1;
21f11ec4:	e3a03001 	mov	r3, #1	; 0x1
21f11ec8:	e50b3088 	str	r3, [fp, #-136]
21f11ecc:	ea00016f 	b	21f12490 <do_bootm+0x6fc>
	    }
	}
	SHOW_BOOT_PROGRESS (2);

	data = (ulong)&header;
21f11ed0:	e59f35c8 	ldr	r3, [pc, #1480]	; 21f124a0 <.text+0x124a0>
21f11ed4:	e50b3038 	str	r3, [fp, #-56]
	len  = sizeof(image_header_t);
21f11ed8:	e3a03040 	mov	r3, #64	; 0x40
21f11edc:	e50b3044 	str	r3, [fp, #-68]

	checksum = ntohl(hdr->ih_hcrc);
21f11ee0:	e51b3014 	ldr	r3, [fp, #-20]
21f11ee4:	e5933004 	ldr	r3, [r3, #4]
21f11ee8:	e1a00003 	mov	r0, r3
21f11eec:	eb000183 	bl	21f12500 <__fswab32>
21f11ef0:	e1a03000 	mov	r3, r0
21f11ef4:	e50b3034 	str	r3, [fp, #-52]
	hdr->ih_hcrc = 0;
21f11ef8:	e51b2014 	ldr	r2, [fp, #-20]
21f11efc:	e3a03000 	mov	r3, #0	; 0x0
21f11f00:	e5823004 	str	r3, [r2, #4]

	if (crc32 (0, (uchar *)data, len) != checksum) {
21f11f04:	e51b3038 	ldr	r3, [fp, #-56]
21f11f08:	e51b2044 	ldr	r2, [fp, #-68]
21f11f0c:	e3a00000 	mov	r0, #0	; 0x0
21f11f10:	e1a01003 	mov	r1, r3
21f11f14:	eb0040f7 	bl	21f222f8 <crc32>
21f11f18:	e1a02000 	mov	r2, r0
21f11f1c:	e51b3034 	ldr	r3, [fp, #-52]
21f11f20:	e1520003 	cmp	r2, r3
21f11f24:	0a000004 	beq	21f11f3c <do_bootm+0x1a8>
		puts ("Bad Header Checksum\n");
21f11f28:	e59f0588 	ldr	r0, [pc, #1416]	; 21f124b8 <.text+0x124b8>
21f11f2c:	eb0026c3 	bl	21f1ba40 <puts>
		SHOW_BOOT_PROGRESS (-2);
		return 1;
21f11f30:	e3a03001 	mov	r3, #1	; 0x1
21f11f34:	e50b3088 	str	r3, [fp, #-136]
21f11f38:	ea000154 	b	21f12490 <do_bootm+0x6fc>
	}
	SHOW_BOOT_PROGRESS (3);

#ifdef CONFIG_HAS_DATAFLASH
	if (addr_dataflash(addr)){
21f11f3c:	e51b003c 	ldr	r0, [fp, #-60]
21f11f40:	ebfff973 	bl	21f10514 <addr_dataflash>
21f11f44:	e1a03000 	mov	r3, r0
21f11f48:	e3530000 	cmp	r3, #0	; 0x0
21f11f4c:	0a00000d 	beq	21f11f88 <do_bootm+0x1f4>
		len  = ntohl(hdr->ih_size) + sizeof(image_header_t);
21f11f50:	e51b3014 	ldr	r3, [fp, #-20]
21f11f54:	e593300c 	ldr	r3, [r3, #12]
21f11f58:	e1a00003 	mov	r0, r3
21f11f5c:	eb000167 	bl	21f12500 <__fswab32>
21f11f60:	e1a03000 	mov	r3, r0
21f11f64:	e2833040 	add	r3, r3, #64	; 0x40
21f11f68:	e50b3044 	str	r3, [fp, #-68]
		read_dataflash(addr, len, (char *)CFG_LOAD_ADDR);
21f11f6c:	e51b3044 	ldr	r3, [fp, #-68]
21f11f70:	e51b003c 	ldr	r0, [fp, #-60]
21f11f74:	e1a01003 	mov	r1, r3
21f11f78:	e3a02421 	mov	r2, #553648128	; 0x21000000
21f11f7c:	ebfffaa5 	bl	21f10a18 <read_dataflash>
		addr = CFG_LOAD_ADDR;
21f11f80:	e3a03421 	mov	r3, #553648128	; 0x21000000
21f11f84:	e50b303c 	str	r3, [fp, #-60]
	}
#endif


	/* for multi-file images we need the data part, too */
	print_image_hdr ((image_header_t *)addr);
21f11f88:	e51b303c 	ldr	r3, [fp, #-60]
21f11f8c:	e1a00003 	mov	r0, r3
21f11f90:	eb000296 	bl	21f129f0 <print_image_hdr>

	data = addr + sizeof(image_header_t);
21f11f94:	e51b303c 	ldr	r3, [fp, #-60]
21f11f98:	e2833040 	add	r3, r3, #64	; 0x40
21f11f9c:	e50b3038 	str	r3, [fp, #-56]
	len  = ntohl(hdr->ih_size);
21f11fa0:	e51b3014 	ldr	r3, [fp, #-20]
21f11fa4:	e593300c 	ldr	r3, [r3, #12]
21f11fa8:	e1a00003 	mov	r0, r3
21f11fac:	eb000153 	bl	21f12500 <__fswab32>
21f11fb0:	e1a03000 	mov	r3, r0
21f11fb4:	e50b3044 	str	r3, [fp, #-68]

	if (verify) {
21f11fb8:	e51b3024 	ldr	r3, [fp, #-36]
21f11fbc:	e3530000 	cmp	r3, #0	; 0x0
21f11fc0:	0a000015 	beq	21f1201c <do_bootm+0x288>
		puts ("   Verifying Checksum ... ");
21f11fc4:	e59f04f0 	ldr	r0, [pc, #1264]	; 21f124bc <.text+0x124bc>
21f11fc8:	eb00269c 	bl	21f1ba40 <puts>
		if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
21f11fcc:	e51b3038 	ldr	r3, [fp, #-56]
21f11fd0:	e51b2044 	ldr	r2, [fp, #-68]
21f11fd4:	e3a00000 	mov	r0, #0	; 0x0
21f11fd8:	e1a01003 	mov	r1, r3
21f11fdc:	eb0040c5 	bl	21f222f8 <crc32>
21f11fe0:	e1a04000 	mov	r4, r0
21f11fe4:	e51b3014 	ldr	r3, [fp, #-20]
21f11fe8:	e5933018 	ldr	r3, [r3, #24]
21f11fec:	e1a00003 	mov	r0, r3
21f11ff0:	eb000142 	bl	21f12500 <__fswab32>
21f11ff4:	e1a03000 	mov	r3, r0
21f11ff8:	e1540003 	cmp	r4, r3
21f11ffc:	0a000004 	beq	21f12014 <do_bootm+0x280>
			printf ("Bad Data CRC\n");
21f12000:	e59f04b8 	ldr	r0, [pc, #1208]	; 21f124c0 <.text+0x124c0>
21f12004:	eb0026a0 	bl	21f1ba8c <printf>
			SHOW_BOOT_PROGRESS (-3);
			return 1;
21f12008:	e3a03001 	mov	r3, #1	; 0x1
21f1200c:	e50b3088 	str	r3, [fp, #-136]
21f12010:	ea00011e 	b	21f12490 <do_bootm+0x6fc>
		}
		puts ("OK\n");
21f12014:	e59f04a8 	ldr	r0, [pc, #1192]	; 21f124c4 <.text+0x124c4>
21f12018:	eb002688 	bl	21f1ba40 <puts>
	}
	SHOW_BOOT_PROGRESS (4);

	len_ptr = (ulong *)data;
21f1201c:	e51b3038 	ldr	r3, [fp, #-56]
21f12020:	e50b3030 	str	r3, [fp, #-48]

#if defined(__PPC__)
	if (hdr->ih_arch != IH_CPU_PPC)
#elif defined(__ARM__)
	if (hdr->ih_arch != IH_CPU_ARM)
21f12024:	e51b3014 	ldr	r3, [fp, #-20]
21f12028:	e5d3301d 	ldrb	r3, [r3, #29]
21f1202c:	e3530002 	cmp	r3, #2	; 0x2
21f12030:	0a000007 	beq	21f12054 <do_bootm+0x2c0>
#elif defined(__I386__)
	if (hdr->ih_arch != IH_CPU_I386)
#elif defined(__mips__)
	if (hdr->ih_arch != IH_CPU_MIPS)
#elif defined(__nios__)
	if (hdr->ih_arch != IH_CPU_NIOS)
#elif defined(__M68K__)
	if (hdr->ih_arch != IH_CPU_M68K)
#elif defined(__microblaze__)
	if (hdr->ih_arch != IH_CPU_MICROBLAZE)
#elif defined(__nios2__)
	if (hdr->ih_arch != IH_CPU_NIOS2)
#elif defined(__blackfin__)
	if (hdr->ih_arch != IH_CPU_BLACKFIN)
#elif defined(__avr32__)
	if (hdr->ih_arch != IH_CPU_AVR32)
#else
# error Unknown CPU type
#endif
	{
		printf ("Unsupported Architecture 0x%x\n", hdr->ih_arch);
21f12034:	e51b3014 	ldr	r3, [fp, #-20]
21f12038:	e5d3301d 	ldrb	r3, [r3, #29]
21f1203c:	e59f0484 	ldr	r0, [pc, #1156]	; 21f124c8 <.text+0x124c8>
21f12040:	e1a01003 	mov	r1, r3
21f12044:	eb002690 	bl	21f1ba8c <printf>
		SHOW_BOOT_PROGRESS (-4);
		return 1;
21f12048:	e3a03001 	mov	r3, #1	; 0x1
21f1204c:	e50b3088 	str	r3, [fp, #-136]
21f12050:	ea00010e 	b	21f12490 <do_bootm+0x6fc>
	}
	SHOW_BOOT_PROGRESS (5);

	switch (hdr->ih_type) {
21f12054:	e51b3014 	ldr	r3, [fp, #-20]
21f12058:	e5d3301e 	ldrb	r3, [r3, #30]
21f1205c:	e50b3084 	str	r3, [fp, #-132]
21f12060:	e51b3084 	ldr	r3, [fp, #-132]
21f12064:	e3530002 	cmp	r3, #2	; 0x2
21f12068:	0a00001a 	beq	21f120d8 <do_bootm+0x344>
21f1206c:	e51b3084 	ldr	r3, [fp, #-132]
21f12070:	e3530004 	cmp	r3, #4	; 0x4
21f12074:	0a00001a 	beq	21f120e4 <do_bootm+0x350>
21f12078:	e51b3084 	ldr	r3, [fp, #-132]
21f1207c:	e3530001 	cmp	r3, #1	; 0x1
21f12080:	0a000000 	beq	21f12088 <do_bootm+0x2f4>
21f12084:	ea000033 	b	21f12158 <do_bootm+0x3c4>
	case IH_TYPE_STANDALONE:
		name = "Standalone Application";
21f12088:	e59f343c 	ldr	r3, [pc, #1084]	; 21f124cc <.text+0x124cc>
21f1208c:	e50b3020 	str	r3, [fp, #-32]
		/* A second argument overwrites the load address */
		if (argc > 2) {
21f12090:	e51b3070 	ldr	r3, [fp, #-112]
21f12094:	e3530002 	cmp	r3, #2	; 0x2
21f12098:	da000036 	ble	21f12178 <do_bootm+0x3e4>
			hdr->ih_load = htonl(simple_strtoul(argv[2], NULL, 16));
21f1209c:	e51b3074 	ldr	r3, [fp, #-116]
21f120a0:	e2833008 	add	r3, r3, #8	; 0x8
21f120a4:	e5933000 	ldr	r3, [r3]
21f120a8:	e1a00003 	mov	r0, r3
21f120ac:	e3a01000 	mov	r1, #0	; 0x0
21f120b0:	e3a02010 	mov	r2, #16	; 0x10
21f120b4:	eb004543 	bl	21f235c8 <simple_strtoul>
21f120b8:	e1a03000 	mov	r3, r0
21f120bc:	e1a00003 	mov	r0, r3
21f120c0:	eb00010e 	bl	21f12500 <__fswab32>
21f120c4:	e1a03000 	mov	r3, r0
21f120c8:	e1a02003 	mov	r2, r3
21f120cc:	e51b3014 	ldr	r3, [fp, #-20]
21f120d0:	e5832010 	str	r2, [r3, #16]
21f120d4:	ea000027 	b	21f12178 <do_bootm+0x3e4>
		}
		break;
	case IH_TYPE_KERNEL:
		name = "Kernel Image";
21f120d8:	e59f33f0 	ldr	r3, [pc, #1008]	; 21f124d0 <.text+0x124d0>
21f120dc:	e50b3020 	str	r3, [fp, #-32]
		break;
21f120e0:	ea000024 	b	21f12178 <do_bootm+0x3e4>
	case IH_TYPE_MULTI:
		name = "Multi-File Image";
21f120e4:	e59f33e8 	ldr	r3, [pc, #1000]	; 21f124d4 <.text+0x124d4>
21f120e8:	e50b3020 	str	r3, [fp, #-32]
		len  = ntohl(len_ptr[0]);
21f120ec:	e51b3030 	ldr	r3, [fp, #-48]
21f120f0:	e5933000 	ldr	r3, [r3]
21f120f4:	e1a00003 	mov	r0, r3
21f120f8:	eb000100 	bl	21f12500 <__fswab32>
21f120fc:	e1a03000 	mov	r3, r0
21f12100:	e50b3044 	str	r3, [fp, #-68]
		/* OS kernel is always the first image */
		data += 8; /* kernel_len + terminator */
21f12104:	e51b3038 	ldr	r3, [fp, #-56]
21f12108:	e2833008 	add	r3, r3, #8	; 0x8
21f1210c:	e50b3038 	str	r3, [fp, #-56]
		for (i=1; len_ptr[i]; ++i)
21f12110:	e3a03001 	mov	r3, #1	; 0x1
21f12114:	e50b3028 	str	r3, [fp, #-40]
21f12118:	ea000005 	b	21f12134 <do_bootm+0x3a0>
			data += 4;
21f1211c:	e51b3038 	ldr	r3, [fp, #-56]
21f12120:	e2833004 	add	r3, r3, #4	; 0x4
21f12124:	e50b3038 	str	r3, [fp, #-56]
21f12128:	e51b3028 	ldr	r3, [fp, #-40]
21f1212c:	e2833001 	add	r3, r3, #1	; 0x1
21f12130:	e50b3028 	str	r3, [fp, #-40]
21f12134:	e51b3028 	ldr	r3, [fp, #-40]
21f12138:	e1a03103 	mov	r3, r3, lsl #2
21f1213c:	e1a02003 	mov	r2, r3
21f12140:	e51b3030 	ldr	r3, [fp, #-48]
21f12144:	e0823003 	add	r3, r2, r3
21f12148:	e5933000 	ldr	r3, [r3]
21f1214c:	e3530000 	cmp	r3, #0	; 0x0
21f12150:	1afffff1 	bne	21f1211c <do_bootm+0x388>
21f12154:	ea000007 	b	21f12178 <do_bootm+0x3e4>
		break;
	default: printf ("Wrong Image Type for %s command\n", cmdtp->name);
21f12158:	e51b3068 	ldr	r3, [fp, #-104]
21f1215c:	e5933000 	ldr	r3, [r3]
21f12160:	e59f0370 	ldr	r0, [pc, #880]	; 21f124d8 <.text+0x124d8>
21f12164:	e1a01003 	mov	r1, r3
21f12168:	eb002647 	bl	21f1ba8c <printf>
		SHOW_BOOT_PROGRESS (-5);
		return 1;
21f1216c:	e3a03001 	mov	r3, #1	; 0x1
21f12170:	e50b3088 	str	r3, [fp, #-136]
21f12174:	ea0000c5 	b	21f12490 <do_bootm+0x6fc>
	}
	SHOW_BOOT_PROGRESS (6);

	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */

	iflag = disable_interrupts();
21f12178:	ebffb889 	bl	21f003a4 <disable_interrupts>
21f1217c:	e1a03000 	mov	r3, r0
21f12180:	e50b3040 	str	r3, [fp, #-64]

#ifdef CONFIG_AMIGAONEG3SE
	/*
	 * We've possible left the caches enabled during
	 * bios emulation, so turn them off again
	 */
	icache_disable();
	invalidate_l1_instruction_cache();
	flush_data_cache();
	dcache_disable();
#endif

	switch (hdr->ih_comp) {
21f12184:	e51b3014 	ldr	r3, [fp, #-20]
21f12188:	e5d3301f 	ldrb	r3, [r3, #31]
21f1218c:	e50b3080 	str	r3, [fp, #-128]
21f12190:	e51b3080 	ldr	r3, [fp, #-128]
21f12194:	e3530000 	cmp	r3, #0	; 0x0
21f12198:	0a000003 	beq	21f121ac <do_bootm+0x418>
21f1219c:	e51b3080 	ldr	r3, [fp, #-128]
21f121a0:	e3530001 	cmp	r3, #1	; 0x1
21f121a4:	0a000019 	beq	21f12210 <do_bootm+0x47c>
21f121a8:	ea000033 	b	21f1227c <do_bootm+0x4e8>
	case IH_COMP_NONE:
		if(ntohl(hdr->ih_load) == addr) {
21f121ac:	e51b3014 	ldr	r3, [fp, #-20]
21f121b0:	e5933010 	ldr	r3, [r3, #16]
21f121b4:	e1a00003 	mov	r0, r3
21f121b8:	eb0000d0 	bl	21f12500 <__fswab32>
21f121bc:	e1a03000 	mov	r3, r0
21f121c0:	e1a02003 	mov	r2, r3
21f121c4:	e51b303c 	ldr	r3, [fp, #-60]
21f121c8:	e1520003 	cmp	r2, r3
21f121cc:	1a000003 	bne	21f121e0 <do_bootm+0x44c>
			printf ("   XIP %s ... ", name);
21f121d0:	e59f0304 	ldr	r0, [pc, #772]	; 21f124dc <.text+0x124dc>
21f121d4:	e51b1020 	ldr	r1, [fp, #-32]
21f121d8:	eb00262b 	bl	21f1ba8c <printf>
21f121dc:	ea000032 	b	21f122ac <do_bootm+0x518>
		} else {
#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
			size_t l = len;
			void *to = (void *)ntohl(hdr->ih_load);
			void *from = (void *)data;

			printf ("   Loading %s ... ", name);

			while (l > 0) {
				size_t tail = (l > CHUNKSZ) ? CHUNKSZ : l;
				WATCHDOG_RESET();
				memmove (to, from, tail);
				to += tail;
				from += tail;
				l -= tail;
			}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
			memmove ((void *) ntohl(hdr->ih_load), (uchar *)data, len);
21f121e0:	e51b3014 	ldr	r3, [fp, #-20]
21f121e4:	e5933010 	ldr	r3, [r3, #16]
21f121e8:	e1a00003 	mov	r0, r3
21f121ec:	eb0000c3 	bl	21f12500 <__fswab32>
21f121f0:	e1a03000 	mov	r3, r0
21f121f4:	e51b2038 	ldr	r2, [fp, #-56]
21f121f8:	e51bc044 	ldr	ip, [fp, #-68]
21f121fc:	e1a00003 	mov	r0, r3
21f12200:	e1a01002 	mov	r1, r2
21f12204:	e1a0200c 	mov	r2, ip
21f12208:	eb00440f 	bl	21f2324c <memmove>
21f1220c:	ea000026 	b	21f122ac <do_bootm+0x518>
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
		}
		break;
	case IH_COMP_GZIP:
		printf ("   Uncompressing %s ... ", name);
21f12210:	e59f02c8 	ldr	r0, [pc, #712]	; 21f124e0 <.text+0x124e0>
21f12214:	e51b1020 	ldr	r1, [fp, #-32]
21f12218:	eb00261b 	bl	21f1ba8c <printf>
		if (gunzip ((void *)ntohl(hdr->ih_load), unc_len,
21f1221c:	e51b3014 	ldr	r3, [fp, #-20]
21f12220:	e5933010 	ldr	r3, [r3, #16]
21f12224:	e1a00003 	mov	r0, r3
21f12228:	eb0000b4 	bl	21f12500 <__fswab32>
21f1222c:	e1a03000 	mov	r3, r0
21f12230:	e51b202c 	ldr	r2, [fp, #-44]
21f12234:	e51bc038 	ldr	ip, [fp, #-56]
21f12238:	e24be044 	sub	lr, fp, #68	; 0x44
21f1223c:	e1a00003 	mov	r0, r3
21f12240:	e1a01002 	mov	r1, r2
21f12244:	e1a0200c 	mov	r2, ip
21f12248:	e1a0300e 	mov	r3, lr
21f1224c:	eb000353 	bl	21f12fa0 <gunzip>
21f12250:	e1a03000 	mov	r3, r0
21f12254:	e3530000 	cmp	r3, #0	; 0x0
21f12258:	0a000013 	beq	21f122ac <do_bootm+0x518>
			    (uchar *)data, &len) != 0) {
			puts ("GUNZIP ERROR - must RESET board to recover\n");
21f1225c:	e59f0280 	ldr	r0, [pc, #640]	; 21f124e4 <.text+0x124e4>
21f12260:	eb0025f6 	bl	21f1ba40 <puts>
			SHOW_BOOT_PROGRESS (-6);
			do_reset (cmdtp, flag, argc, argv);
21f12264:	e51b0068 	ldr	r0, [fp, #-104]
21f12268:	e51b106c 	ldr	r1, [fp, #-108]
21f1226c:	e51b2070 	ldr	r2, [fp, #-112]
21f12270:	e51b3074 	ldr	r3, [fp, #-116]
21f12274:	eb006c9b 	bl	21f2d4e8 <do_reset>
21f12278:	ea00000b 	b	21f122ac <do_bootm+0x518>
		}
		break;
#ifdef CONFIG_BZIP2
	case IH_COMP_BZIP2:
		printf ("   Uncompressing %s ... ", name);
		/*
		 * If we've got less than 4 MB of malloc() space,
		 * use slower decompression algorithm which requires
		 * at most 2300 KB of memory.
		 */
		i = BZ2_bzBuffToBuffDecompress ((char*)ntohl(hdr->ih_load),
						&unc_len, (char *)data, len,
						CFG_MALLOC_LEN < (4096 * 1024), 0);
		if (i != BZ_OK) {
			printf ("BUNZIP2 ERROR %d - must RESET board to recover\n", i);
			SHOW_BOOT_PROGRESS (-6);
			udelay(100000);
			do_reset (cmdtp, flag, argc, argv);
		}
		break;
#endif /* CONFIG_BZIP2 */
	default:
		if (iflag)
21f1227c:	e51b3040 	ldr	r3, [fp, #-64]
21f12280:	e3530000 	cmp	r3, #0	; 0x0
21f12284:	0a000000 	beq	21f1228c <do_bootm+0x4f8>
			enable_interrupts();
21f12288:	ebffb83c 	bl	21f00380 <enable_interrupts>
		printf ("Unimplemented compression type %d\n", hdr->ih_comp);
21f1228c:	e51b3014 	ldr	r3, [fp, #-20]
21f12290:	e5d3301f 	ldrb	r3, [r3, #31]
21f12294:	e59f024c 	ldr	r0, [pc, #588]	; 21f124e8 <.text+0x124e8>
21f12298:	e1a01003 	mov	r1, r3
21f1229c:	eb0025fa 	bl	21f1ba8c <printf>
		SHOW_BOOT_PROGRESS (-7);
		return 1;
21f122a0:	e3a03001 	mov	r3, #1	; 0x1
21f122a4:	e50b3088 	str	r3, [fp, #-136]
21f122a8:	ea000078 	b	21f12490 <do_bootm+0x6fc>
	}
	puts ("OK\n");
21f122ac:	e59f0210 	ldr	r0, [pc, #528]	; 21f124c4 <.text+0x124c4>
21f122b0:	eb0025e2 	bl	21f1ba40 <puts>
	SHOW_BOOT_PROGRESS (7);

	switch (hdr->ih_type) {
21f122b4:	e51b3014 	ldr	r3, [fp, #-20]
21f122b8:	e5d3301e 	ldrb	r3, [r3, #30]
21f122bc:	e50b307c 	str	r3, [fp, #-124]
21f122c0:	e51b307c 	ldr	r3, [fp, #-124]
21f122c4:	e3530002 	cmp	r3, #2	; 0x2
21f122c8:	0a000042 	beq	21f123d8 <do_bootm+0x644>
21f122cc:	e51b307c 	ldr	r3, [fp, #-124]
21f122d0:	e3530004 	cmp	r3, #4	; 0x4
21f122d4:	0a00003f 	beq	21f123d8 <do_bootm+0x644>
21f122d8:	e51b307c 	ldr	r3, [fp, #-124]
21f122dc:	e3530001 	cmp	r3, #1	; 0x1
21f122e0:	0a000000 	beq	21f122e8 <do_bootm+0x554>
21f122e4:	ea00002f 	b	21f123a8 <do_bootm+0x614>
	case IH_TYPE_STANDALONE:
		if (iflag)
21f122e8:	e51b3040 	ldr	r3, [fp, #-64]
21f122ec:	e3530000 	cmp	r3, #0	; 0x0
21f122f0:	0a000000 	beq	21f122f8 <do_bootm+0x564>
			enable_interrupts();
21f122f4:	ebffb821 	bl	21f00380 <enable_interrupts>

		/* load (and uncompress), but don't start if "autostart"
		 * is set to "no"
		 */
		if (((s = getenv("autostart")) != NULL) && (strcmp(s,"no") == 0)) {
21f122f8:	e59f01ec 	ldr	r0, [pc, #492]	; 21f124ec <.text+0x124ec>
21f122fc:	eb002245 	bl	21f1ac18 <getenv>
21f12300:	e1a03000 	mov	r3, r0
21f12304:	e50b301c 	str	r3, [fp, #-28]
21f12308:	e51b301c 	ldr	r3, [fp, #-28]
21f1230c:	e3530000 	cmp	r3, #0	; 0x0
21f12310:	0a000012 	beq	21f12360 <do_bootm+0x5cc>
21f12314:	e51b001c 	ldr	r0, [fp, #-28]
21f12318:	e59f11d0 	ldr	r1, [pc, #464]	; 21f124f0 <.text+0x124f0>
21f1231c:	eb00418a 	bl	21f2294c <strcmp>
21f12320:	e1a03000 	mov	r3, r0
21f12324:	e3530000 	cmp	r3, #0	; 0x0
21f12328:	1a00000c 	bne	21f12360 <do_bootm+0x5cc>
			char buf[32];
			sprintf(buf, "%lX", len);
21f1232c:	e51b3044 	ldr	r3, [fp, #-68]
21f12330:	e24b2064 	sub	r2, fp, #100	; 0x64
21f12334:	e1a00002 	mov	r0, r2
21f12338:	e59f11b4 	ldr	r1, [pc, #436]	; 21f124f4 <.text+0x124f4>
21f1233c:	e1a02003 	mov	r2, r3
21f12340:	eb0048e0 	bl	21f246c8 <sprintf>
			setenv("filesize", buf);
21f12344:	e24b3064 	sub	r3, fp, #100	; 0x64
21f12348:	e59f01a8 	ldr	r0, [pc, #424]	; 21f124f8 <.text+0x124f8>
21f1234c:	e1a01003 	mov	r1, r3
21f12350:	eb0021fc 	bl	21f1ab48 <setenv>
			return 0;
21f12354:	e3a03000 	mov	r3, #0	; 0x0
21f12358:	e50b3088 	str	r3, [fp, #-136]
21f1235c:	ea00004b 	b	21f12490 <do_bootm+0x6fc>
		}
		appl = (int (*)(int, char *[]))ntohl(hdr->ih_ep);
21f12360:	e51b3014 	ldr	r3, [fp, #-20]
21f12364:	e5933014 	ldr	r3, [r3, #20]
21f12368:	e1a00003 	mov	r0, r3
21f1236c:	eb000063 	bl	21f12500 <__fswab32>
21f12370:	e1a03000 	mov	r3, r0
21f12374:	e50b3018 	str	r3, [fp, #-24]
		(*appl)(argc-1, &argv[1]);
21f12378:	e51b3070 	ldr	r3, [fp, #-112]
21f1237c:	e2431001 	sub	r1, r3, #1	; 0x1
21f12380:	e51b3074 	ldr	r3, [fp, #-116]
21f12384:	e2833004 	add	r3, r3, #4	; 0x4
21f12388:	e51b2018 	ldr	r2, [fp, #-24]
21f1238c:	e1a00001 	mov	r0, r1
21f12390:	e1a01003 	mov	r1, r3
21f12394:	e1a0e00f 	mov	lr, pc
21f12398:	e1a0f002 	mov	pc, r2
		return 0;
21f1239c:	e3a03000 	mov	r3, #0	; 0x0
21f123a0:	e50b3088 	str	r3, [fp, #-136]
21f123a4:	ea000039 	b	21f12490 <do_bootm+0x6fc>
	case IH_TYPE_KERNEL:
	case IH_TYPE_MULTI:
		/* handled below */
		break;
	default:
		if (iflag)
21f123a8:	e51b3040 	ldr	r3, [fp, #-64]
21f123ac:	e3530000 	cmp	r3, #0	; 0x0
21f123b0:	0a000000 	beq	21f123b8 <do_bootm+0x624>
			enable_interrupts();
21f123b4:	ebffb7f1 	bl	21f00380 <enable_interrupts>
		printf ("Can't boot image type %d\n", hdr->ih_type);
21f123b8:	e51b3014 	ldr	r3, [fp, #-20]
21f123bc:	e5d3301e 	ldrb	r3, [r3, #30]
21f123c0:	e59f0134 	ldr	r0, [pc, #308]	; 21f124fc <.text+0x124fc>
21f123c4:	e1a01003 	mov	r1, r3
21f123c8:	eb0025af 	bl	21f1ba8c <printf>
		SHOW_BOOT_PROGRESS (-8);
		return 1;
21f123cc:	e3a03001 	mov	r3, #1	; 0x1
21f123d0:	e50b3088 	str	r3, [fp, #-136]
21f123d4:	ea00002d 	b	21f12490 <do_bootm+0x6fc>
	}
	SHOW_BOOT_PROGRESS (8);

	switch (hdr->ih_os) {
21f123d8:	e51b3014 	ldr	r3, [fp, #-20]
21f123dc:	e5d3301c 	ldrb	r3, [r3, #28]
21f123e0:	e50b3078 	str	r3, [fp, #-120]
21f123e4:	e51b3078 	ldr	r3, [fp, #-120]
21f123e8:	e3530002 	cmp	r3, #2	; 0x2
21f123ec:	0a00000e 	beq	21f1242c <do_bootm+0x698>
21f123f0:	e51b3078 	ldr	r3, [fp, #-120]
21f123f4:	e3530012 	cmp	r3, #18	; 0x12
21f123f8:	0a000017 	beq	21f1245c <do_bootm+0x6c8>
	default:			/* handled by (original) Linux case */
	case IH_OS_LINUX:
#ifdef CONFIG_SILENT_CONSOLE
	    fixup_silent_linux();
#endif
	    do_bootm_linux  (cmdtp, flag, argc, argv,
21f123fc:	e51b303c 	ldr	r3, [fp, #-60]
21f12400:	e58d3000 	str	r3, [sp]
21f12404:	e51b3030 	ldr	r3, [fp, #-48]
21f12408:	e58d3004 	str	r3, [sp, #4]
21f1240c:	e51b3024 	ldr	r3, [fp, #-36]
21f12410:	e58d3008 	str	r3, [sp, #8]
21f12414:	e51b0068 	ldr	r0, [fp, #-104]
21f12418:	e51b106c 	ldr	r1, [fp, #-108]
21f1241c:	e51b2070 	ldr	r2, [fp, #-112]
21f12420:	e51b3074 	ldr	r3, [fp, #-116]
21f12424:	eb007049 	bl	21f2e550 <do_bootm_linux>
			     addr, len_ptr, verify);
	    break;
21f12428:	ea000016 	b	21f12488 <do_bootm+0x6f4>
	case IH_OS_NETBSD:
	    do_bootm_netbsd (cmdtp, flag, argc, argv,
21f1242c:	e51b303c 	ldr	r3, [fp, #-60]
21f12430:	e58d3000 	str	r3, [sp]
21f12434:	e51b3030 	ldr	r3, [fp, #-48]
21f12438:	e58d3004 	str	r3, [sp, #4]
21f1243c:	e51b3024 	ldr	r3, [fp, #-36]
21f12440:	e58d3008 	str	r3, [sp, #8]
21f12444:	e51b0068 	ldr	r0, [fp, #-104]
21f12448:	e51b106c 	ldr	r1, [fp, #-108]
21f1244c:	e51b2070 	ldr	r2, [fp, #-112]
21f12450:	e51b3074 	ldr	r3, [fp, #-116]
21f12454:	eb00003f 	bl	21f12558 <do_bootm_netbsd>
			     addr, len_ptr, verify);
	    break;
21f12458:	ea00000a 	b	21f12488 <do_bootm+0x6f4>

#ifdef CONFIG_LYNXKDI
	case IH_OS_LYNXOS:
	    do_bootm_lynxkdi (cmdtp, flag, argc, argv,
			     addr, len_ptr, verify);
	    break;
#endif

	case IH_OS_RTEMS:
	    do_bootm_rtems (cmdtp, flag, argc, argv,
21f1245c:	e51b303c 	ldr	r3, [fp, #-60]
21f12460:	e58d3000 	str	r3, [sp]
21f12464:	e51b3030 	ldr	r3, [fp, #-48]
21f12468:	e58d3004 	str	r3, [sp, #4]
21f1246c:	e51b3024 	ldr	r3, [fp, #-36]
21f12470:	e58d3008 	str	r3, [sp, #8]
21f12474:	e51b0068 	ldr	r0, [fp, #-104]
21f12478:	e51b106c 	ldr	r1, [fp, #-108]
21f1247c:	e51b2070 	ldr	r2, [fp, #-112]
21f12480:	e51b3074 	ldr	r3, [fp, #-116]
21f12484:	eb000378 	bl	21f1326c <do_bootm_rtems>
			     addr, len_ptr, verify);
	    break;

#if (CONFIG_COMMANDS & CFG_CMD_ELF)
	case IH_OS_VXWORKS:
	    do_bootm_vxworks (cmdtp, flag, argc, argv,
			      addr, len_ptr, verify);
	    break;
	case IH_OS_QNX:
	    do_bootm_qnxelf (cmdtp, flag, argc, argv,
			      addr, len_ptr, verify);
	    break;
#endif /* CFG_CMD_ELF */
#ifdef CONFIG_ARTOS
	case IH_OS_ARTOS:
	    do_bootm_artos  (cmdtp, flag, argc, argv,
			     addr, len_ptr, verify);
	    break;
#endif
	}

	SHOW_BOOT_PROGRESS (-9);
#ifdef DEBUG
	puts ("\n## Control returned to monitor - resetting...\n");
	do_reset (cmdtp, flag, argc, argv);
#endif
	return 1;
21f12488:	e3a03001 	mov	r3, #1	; 0x1
21f1248c:	e50b3088 	str	r3, [fp, #-136]
21f12490:	e51b3088 	ldr	r3, [fp, #-136]
}
21f12494:	e1a00003 	mov	r0, r3
21f12498:	e24bd010 	sub	sp, fp, #16	; 0x10
21f1249c:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f124a0:	21f67664 	mvncss	r7, r4, ror #12
21f124a4:	21f30148 	mvncss	r0, r8, asr #2
21f124a8:	21f3322c 	mvncss	r3, ip, lsr #4
21f124ac:	21f30150 	mvncss	r0, r0, asr r1
21f124b0:	27051956 	smlsdcs	r5, r6, r9, r1
21f124b4:	21f30170 	mvncss	r0, r0, ror r1
21f124b8:	21f30184 	mvncss	r0, r4, lsl #3
21f124bc:	21f3019c 	ldrcsb	r0, [r3, #28]!
21f124c0:	21f301b8 	ldrcsh	r0, [r3, #24]!
21f124c4:	21f301c8 	mvncss	r0, r8, asr #3
21f124c8:	21f301cc 	mvncss	r0, ip, asr #3
21f124cc:	21f301ec 	mvncss	r0, ip, ror #3
21f124d0:	21f30204 	mvncss	r0, r4, lsl #4
21f124d4:	21f30214 	mvncss	r0, r4, lsl r2
21f124d8:	21f30228 	mvncss	r0, r8, lsr #4
21f124dc:	21f3024c 	mvncss	r0, ip, asr #4
21f124e0:	21f3025c 	mvncss	r0, ip, asr r2
21f124e4:	21f30278 	mvncss	r0, r8, ror r2
21f124e8:	21f302a4 	mvncss	r0, r4, lsr #5
21f124ec:	21f302c8 	mvncss	r0, r8, asr #5
21f124f0:	21f302d4 	ldrcssb	r0, [r3, #36]!
21f124f4:	21f302d8 	ldrcssb	r0, [r3, #40]!
21f124f8:	21f302dc 	ldrcssb	r0, [r3, #44]!
21f124fc:	21f302e8 	mvncss	r0, r8, ror #5

21f12500 <__fswab32>:
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
21f12500:	e1a0c00d 	mov	ip, sp
21f12504:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f12508:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1250c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f12510:	e50b0010 	str	r0, [fp, #-16]
	return __arch__swab32(x);
21f12514:	e51b3010 	ldr	r3, [fp, #-16]
21f12518:	e20330ff 	and	r3, r3, #255	; 0xff
21f1251c:	e1a02c03 	mov	r2, r3, lsl #24
21f12520:	e51b3010 	ldr	r3, [fp, #-16]
21f12524:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f12528:	e1a03403 	mov	r3, r3, lsl #8
21f1252c:	e1822003 	orr	r2, r2, r3
21f12530:	e51b3010 	ldr	r3, [fp, #-16]
21f12534:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f12538:	e1a03423 	mov	r3, r3, lsr #8
21f1253c:	e1822003 	orr	r2, r2, r3
21f12540:	e51b3010 	ldr	r3, [fp, #-16]
21f12544:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
21f12548:	e1a03c23 	mov	r3, r3, lsr #24
21f1254c:	e1823003 	orr	r3, r2, r3
}
21f12550:	e1a00003 	mov	r0, r3
21f12554:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f12558 <do_bootm_netbsd>:

U_BOOT_CMD(
 	bootm,	CFG_MAXARGS,	1,	do_bootm,
 	"bootm   - boot application image from memory\n",
 	"[addr [arg ...]]\n    - boot application image stored in memory\n"
 	"\tpassing arguments 'arg ...'; when booting a Linux kernel,\n"
 	"\t'arg' can be the address of an initrd image\n"
#ifdef CONFIG_OF_FLAT_TREE
	"\tWhen booting a Linux kernel which requires a flat device-tree\n"
	"\ta third argument is required which is the address of the of the\n"
	"\tdevice-tree blob. To boot that kernel without an initrd image,\n"
	"\tuse a '-' for the second argument. If you do not pass a third\n"
	"\ta bd_info struct will be passed instead\n"
#endif
);

#ifdef CONFIG_SILENT_CONSOLE
static void
fixup_silent_linux ()
{
	char buf[256], *start, *end;
	char *cmdline = getenv ("bootargs");

	/* Only fix cmdline when requested */
	if (!(gd->flags & GD_FLG_SILENT))
		return;

	debug ("before silent fix-up: %s\n", cmdline);
	if (cmdline) {
		if ((start = strstr (cmdline, "console=")) != NULL) {
			end = strchr (start, ' ');
			strncpy (buf, cmdline, (start - cmdline + 8));
			if (end)
				strcpy (buf + (start - cmdline + 8), end);
			else
				buf[start - cmdline + 8] = '\0';
		} else {
			strcpy (buf, cmdline);
			strcat (buf, " console=");
		}
	} else {
		strcpy (buf, "console=");
	}

	setenv ("bootargs", buf);
	debug ("after silent fix-up: %s\n", buf);
}
#endif /* CONFIG_SILENT_CONSOLE */

#ifdef CONFIG_PPC
static void  __attribute__((noinline))
do_bootm_linux (cmd_tbl_t *cmdtp, int flag,
		int	argc, char *argv[],
		ulong	addr,
		ulong	*len_ptr,
		int	verify)
{
	ulong	sp;
	ulong	len, checksum;
	ulong	initrd_start, initrd_end;
	ulong	cmd_start, cmd_end;
	ulong	initrd_high;
	ulong	data;
	int	initrd_copy_to_ram = 1;
	char    *cmdline;
	char	*s;
	bd_t	*kbd;
	void	(*kernel)(bd_t *, ulong, ulong, ulong, ulong);
	image_header_t *hdr = &header;
#ifdef CONFIG_OF_FLAT_TREE
	char	*of_flat_tree = NULL;
	ulong	of_data = 0;
#endif

	if ((s = getenv ("initrd_high")) != NULL) {
		/* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 */
		initrd_high = simple_strtoul(s, NULL, 16);
		if (initrd_high == ~0)
			initrd_copy_to_ram = 0;
	} else {	/* not set, no restrictions to load high */
		initrd_high = ~0;
	}

#ifdef CONFIG_LOGBUFFER
	kbd=gd->bd;
	/* Prevent initrd from overwriting logbuffer */
	if (initrd_high < (kbd->bi_memsize-LOGBUFF_LEN-LOGBUFF_OVERHEAD))
		initrd_high = kbd->bi_memsize-LOGBUFF_LEN-LOGBUFF_OVERHEAD;
	debug ("## Logbuffer at 0x%08lX ", kbd->bi_memsize-LOGBUFF_LEN);
#endif

	/*
	 * Booting a (Linux) kernel image
	 *
	 * Allocate space for command line and board info - the
	 * address should be as high as possible within the reach of
	 * the kernel (see CFG_BOOTMAPSZ settings), but in unused
	 * memory, which means far enough below the current stack
	 * pointer.
	 */

	asm( "mr %0,1": "=r"(sp) : );

	debug ("## Current stack ends at 0x%08lX ", sp);

	sp -= 2048;		/* just to be sure */
	if (sp > CFG_BOOTMAPSZ)
		sp = CFG_BOOTMAPSZ;
	sp &= ~0xF;

	debug ("=> set upper limit to 0x%08lX\n", sp);

	cmdline = (char *)((sp - CFG_BARGSIZE) & ~0xF);
	kbd = (bd_t *)(((ulong)cmdline - sizeof(bd_t)) & ~0xF);

	if ((s = getenv("bootargs")) == NULL)
		s = "";

	strcpy (cmdline, s);

	cmd_start    = (ulong)&cmdline[0];
	cmd_end      = cmd_start + strlen(cmdline);

	*kbd = *(gd->bd);

#ifdef	DEBUG
	printf ("## cmdline at 0x%08lX ... 0x%08lX\n", cmd_start, cmd_end);

	do_bdinfo (NULL, 0, 0, NULL);
#endif

	if ((s = getenv ("clocks_in_mhz")) != NULL) {
		/* convert all clock information to MHz */
		kbd->bi_intfreq /= 1000000L;
		kbd->bi_busfreq /= 1000000L;
#if defined(CONFIG_MPC8220)
	kbd->bi_inpfreq /= 1000000L;
	kbd->bi_pcifreq /= 1000000L;
	kbd->bi_pevfreq /= 1000000L;
	kbd->bi_flbfreq /= 1000000L;
	kbd->bi_vcofreq /= 1000000L;
#endif
#if defined(CONFIG_CPM2)
		kbd->bi_cpmfreq /= 1000000L;
		kbd->bi_brgfreq /= 1000000L;
		kbd->bi_sccfreq /= 1000000L;
		kbd->bi_vco     /= 1000000L;
#endif
#if defined(CONFIG_MPC5xxx)
		kbd->bi_ipbfreq /= 1000000L;
		kbd->bi_pcifreq /= 1000000L;
#endif /* CONFIG_MPC5xxx */
	}

	kernel = (void (*)(bd_t *, ulong, ulong, ulong, ulong)) ntohl(hdr->ih_ep);

	/*
	 * Check if there is an initrd image
	 */

#ifdef CONFIG_OF_FLAT_TREE
	/* Look for a '-' which indicates to ignore the ramdisk argument */
	if (argc >= 3 && strcmp(argv[2], "-") ==  0) {
			debug ("Skipping initrd\n");
			len = data = 0;
		}
	else
#endif
	if (argc >= 3) {
		debug ("Not skipping initrd\n");
		SHOW_BOOT_PROGRESS (9);

		addr = simple_strtoul(argv[2], NULL, 16);

		printf ("## Loading RAMDisk Image at %08lx ...\n", addr);

		/* Copy header so we can blank CRC field for re-calculation */
		memmove (&header, (char *)addr, sizeof(image_header_t));

		if (ntohl(hdr->ih_magic)  != IH_MAGIC) {
			puts ("Bad Magic Number\n");
			SHOW_BOOT_PROGRESS (-10);
			do_reset (cmdtp, flag, argc, argv);
		}

		data = (ulong)&header;
		len  = sizeof(image_header_t);

		checksum = ntohl(hdr->ih_hcrc);
		hdr->ih_hcrc = 0;

		if (crc32 (0, (uchar *)data, len) != checksum) {
			puts ("Bad Header Checksum\n");
			SHOW_BOOT_PROGRESS (-11);
			do_reset (cmdtp, flag, argc, argv);
		}

		SHOW_BOOT_PROGRESS (10);

		print_image_hdr (hdr);

		data = addr + sizeof(image_header_t);
		len  = ntohl(hdr->ih_size);

		if (verify) {
			ulong csum = 0;
#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
			ulong cdata = data, edata = cdata + len;
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */

			puts ("   Verifying Checksum ... ");

#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)

			while (cdata < edata) {
				ulong chunk = edata - cdata;

				if (chunk > CHUNKSZ)
					chunk = CHUNKSZ;
				csum = crc32 (csum, (uchar *)cdata, chunk);
				cdata += chunk;

				WATCHDOG_RESET();
			}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
			csum = crc32 (0, (uchar *)data, len);
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */

			if (csum != ntohl(hdr->ih_dcrc)) {
				puts ("Bad Data CRC\n");
				SHOW_BOOT_PROGRESS (-12);
				do_reset (cmdtp, flag, argc, argv);
			}
			puts ("OK\n");
		}

		SHOW_BOOT_PROGRESS (11);

		if ((hdr->ih_os   != IH_OS_LINUX)	||
		    (hdr->ih_arch != IH_CPU_PPC)	||
		    (hdr->ih_type != IH_TYPE_RAMDISK)	) {
			puts ("No Linux PPC Ramdisk Image\n");
			SHOW_BOOT_PROGRESS (-13);
			do_reset (cmdtp, flag, argc, argv);
		}

		/*
		 * Now check if we have a multifile image
		 */
	} else if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1])) {
		u_long tail    = ntohl(len_ptr[0]) % 4;
		int i;

		SHOW_BOOT_PROGRESS (13);

		/* skip kernel length and terminator */
		data = (ulong)(&len_ptr[2]);
		/* skip any additional image length fields */
		for (i=1; len_ptr[i]; ++i)
			data += 4;
		/* add kernel length, and align */
		data += ntohl(len_ptr[0]);
		if (tail) {
			data += 4 - tail;
		}

		len   = ntohl(len_ptr[1]);

	} else {
		/*
		 * no initrd image
		 */
		SHOW_BOOT_PROGRESS (14);

		len = data = 0;
	}

#ifdef CONFIG_OF_FLAT_TREE
	if(argc > 3) {
		of_flat_tree = (char *) simple_strtoul(argv[3], NULL, 16);
		hdr = (image_header_t *)of_flat_tree;

		if  (*(ulong *)of_flat_tree == OF_DT_HEADER) {
#ifndef CFG_NO_FLASH
			if (addr2info((ulong)of_flat_tree) != NULL)
				of_data = (ulong)of_flat_tree;
#endif
		} else if (ntohl(hdr->ih_magic) == IH_MAGIC) {
			printf("## Flat Device Tree Image at %08lX\n", hdr);
			print_image_hdr(hdr);

			if ((ntohl(hdr->ih_load) <  ((unsigned long)hdr + ntohl(hdr->ih_size) + sizeof(hdr))) &&
			   ((ntohl(hdr->ih_load) + ntohl(hdr->ih_size)) > (unsigned long)hdr)) {
				printf ("ERROR: Load address overwrites Flat Device Tree uImage\n");
				return;
			}

			printf("   Verifying Checksum ... ");
			memmove (&header, (char *)hdr, sizeof(image_header_t));
			checksum = ntohl(header.ih_hcrc);
			header.ih_hcrc = 0;

			if(checksum != crc32(0, (uchar *)&header, sizeof(image_header_t))) {
				printf("ERROR: Flat Device Tree header checksum is invalid\n");
				return;
			}

			checksum = ntohl(hdr->ih_dcrc);
			addr = (ulong)((uchar *)(hdr) + sizeof(image_header_t));
			len = ntohl(hdr->ih_size);

			if(checksum != crc32(0, (uchar *)addr, len)) {
				printf("ERROR: Flat Device Tree checksum is invalid\n");
				return;
			}
			printf("OK\n");

			if (ntohl(hdr->ih_type) != IH_TYPE_FLATDT) {
				printf ("ERROR: uImage not Flat Device Tree type\n");
				return;
			}
			if (ntohl(hdr->ih_comp) != IH_COMP_NONE) {
				printf("ERROR: uImage is not uncompressed\n");
				return;
			}
			if (*((ulong *)(of_flat_tree + sizeof(image_header_t))) != OF_DT_HEADER) {
				printf ("ERROR: uImage data is not a flat device tree\n");
				return;
			}

			memmove((void *)ntohl(hdr->ih_load),
		       		(void *)(of_flat_tree + sizeof(image_header_t)),
				ntohl(hdr->ih_size));
			of_flat_tree = (char *)ntohl(hdr->ih_load);
		} else {
			printf ("Did not find a flat flat device tree at address %08lX\n", of_flat_tree);
			return;
		}
		printf ("   Booting using flat device tree at 0x%x\n",
				of_flat_tree);
	} else if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1]) && (len_ptr[2])) {
		u_long tail    = ntohl(len_ptr[0]) % 4;
		int i;

		/* skip kernel length, initrd length, and terminator */
		of_data = (ulong)(&len_ptr[3]);
		/* skip any additional image length fields */
		for (i=2; len_ptr[i]; ++i)
			of_data += 4;
		/* add kernel length, and align */
		of_data += ntohl(len_ptr[0]);
		if (tail) {
			of_data += 4 - tail;
		}

		/* add initrd length, and align */
		tail = ntohl(len_ptr[1]) % 4;
		of_data += ntohl(len_ptr[1]);
		if (tail) {
			of_data += 4 - tail;
		}

		if (((struct boot_param_header *)of_data)->magic != OF_DT_HEADER) {
			printf ("ERROR: image is not a flat device tree\n");
			return;
		}

		if (((struct boot_param_header *)of_data)->totalsize != ntohl(len_ptr[2])) {
			printf ("ERROR: flat device tree size does not agree with image\n");
			return;
		}

	} else if (getenv("disable_of") == NULL) {
		printf ("ERROR: bootm needs flat device tree as third argument\n");
		return;
	}
#endif
	if (!data) {
		debug ("No initrd\n");
	}

	if (data) {
	    if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
		initrd_start = data;
		initrd_end = initrd_start + len;
	    } else {
		initrd_start  = (ulong)kbd - len;
		initrd_start &= ~(4096 - 1);	/* align on page */

		if (initrd_high) {
			ulong nsp;

			/*
			 * the inital ramdisk does not need to be within
			 * CFG_BOOTMAPSZ as it is not accessed until after
			 * the mm system is initialised.
			 *
			 * do the stack bottom calculation again and see if
			 * the initrd will fit just below the monitor stack
			 * bottom without overwriting the area allocated
			 * above for command line args and board info.
			 */
			asm( "mr %0,1": "=r"(nsp) : );
			nsp -= 2048;		/* just to be sure */
			nsp &= ~0xF;
			if (nsp > initrd_high)	/* limit as specified */
				nsp = initrd_high;
			nsp -= len;
			nsp &= ~(4096 - 1);	/* align on page */
			if (nsp >= sp)
				initrd_start = nsp;
		}

		SHOW_BOOT_PROGRESS (12);

		debug ("## initrd at 0x%08lX ... 0x%08lX (len=%ld=0x%lX)\n",
			data, data + len - 1, len, len);

		initrd_end    = initrd_start + len;
		printf ("   Loading Ramdisk to %08lx, end %08lx ... ",
			initrd_start, initrd_end);
#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
		{
			size_t l = len;
			void *to = (void *)initrd_start;
			void *from = (void *)data;

			while (l > 0) {
				size_t tail = (l > CHUNKSZ) ? CHUNKSZ : l;
				WATCHDOG_RESET();
				memmove (to, from, tail);
				to += tail;
				from += tail;
				l -= tail;
			}
		}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
		memmove ((void *)initrd_start, (void *)data, len);
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
		puts ("OK\n");
	    }
	} else {
		initrd_start = 0;
		initrd_end = 0;
	}

	debug ("## Transferring control to Linux (at address %08lx) ...\n",
		(ulong)kernel);

	SHOW_BOOT_PROGRESS (15);

#ifndef CONFIG_OF_FLAT_TREE

#if defined(CFG_INIT_RAM_LOCK) && !defined(CONFIG_E500)
	unlock_ram_in_cache();
#endif

	/*
	 * Linux Kernel Parameters:
	 *   r3: ptr to board info data
	 *   r4: initrd_start or 0 if no initrd
	 *   r5: initrd_end - unused if r4 is 0
	 *   r6: Start of command line string
	 *   r7: End   of command line string
	 */
	(*kernel) (kbd, initrd_start, initrd_end, cmd_start, cmd_end);

#else	/* CONFIG_OF_FLAT_TREE */
	/* move of_flat_tree if needed */
	if (of_data) {
		ulong of_start, of_len;
		of_len = ((struct boot_param_header *)of_data)->totalsize;
		/* provide extra 8k pad */
		if (initrd_start)
			of_start = initrd_start - of_len - 8192;
		else
			of_start  = (ulong)kbd - of_len - 8192;
		of_start &= ~(4096 - 1);	/* align on page */
		debug ("## device tree at 0x%08lX ... 0x%08lX (len=%ld=0x%lX)\n",
			of_data, of_data + of_len - 1, of_len, of_len);

		of_flat_tree = (char *)of_start;
		printf ("   Loading Device Tree to %08lx, end %08lx ... ",
			of_start, of_start + of_len - 1);
		memmove ((void *)of_start, (void *)of_data, of_len);
	}

	ft_setup(of_flat_tree, kbd, initrd_start, initrd_end);
	/* ft_dump_blob(of_flat_tree); */

#if defined(CFG_INIT_RAM_LOCK) && !defined(CONFIG_E500)
	unlock_ram_in_cache();
#endif
	/*
	 * Linux Kernel Parameters:
	 *   r3: ptr to OF flat tree, followed by the board info data
	 *   r4: physical pointer to the kernel itself
	 *   r5: NULL
	 *   r6: NULL
	 *   r7: NULL
	 */
	if (getenv("disable_of") != NULL)
		(*kernel) ((bd_t *)of_flat_tree, initrd_start, initrd_end,
			cmd_start, cmd_end);
	else {
		ft_setup(of_flat_tree, kbd, initrd_start, initrd_end);
		/* ft_dump_blob(of_flat_tree); */
		(*kernel) ((bd_t *)of_flat_tree, (ulong)kernel, 0, 0, 0);
	}
#endif	/* CONFIG_OF_FLAT_TREE */
}
#endif /* CONFIG_PPC */

static void
do_bootm_netbsd (cmd_tbl_t *cmdtp, int flag,
		int	argc, char *argv[],
		ulong	addr,
		ulong	*len_ptr,
		int	verify)
{
21f12558:	e1a0c00d 	mov	ip, sp
21f1255c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f12560:	e24cb004 	sub	fp, ip, #4	; 0x4
21f12564:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f12568:	e50b002c 	str	r0, [fp, #-44]
21f1256c:	e50b1030 	str	r1, [fp, #-48]
21f12570:	e50b2034 	str	r2, [fp, #-52]
21f12574:	e50b3038 	str	r3, [fp, #-56]
	image_header_t *hdr = &header;
21f12578:	e59f31f4 	ldr	r3, [pc, #500]	; 21f12774 <.text+0x12774>
21f1257c:	e50b3028 	str	r3, [fp, #-40]

	void	(*loader)(bd_t *, image_header_t *, char *, char *);
	image_header_t *img_addr;
	char     *consdev;
	char     *cmdline;


	/*
	 * Booting a (NetBSD) kernel image
	 *
	 * This process is pretty similar to a standalone application:
	 * The (first part of an multi-) image must be a stage-2 loader,
	 * which in turn is responsible for loading & invoking the actual
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */

	img_addr = 0;
21f12580:	e3a03000 	mov	r3, #0	; 0x0
21f12584:	e50b3020 	str	r3, [fp, #-32]
	if ((hdr->ih_type==IH_TYPE_MULTI) && (len_ptr[1]))
21f12588:	e51b3028 	ldr	r3, [fp, #-40]
21f1258c:	e5d3301e 	ldrb	r3, [r3, #30]
21f12590:	e3530004 	cmp	r3, #4	; 0x4
21f12594:	1a000006 	bne	21f125b4 <do_bootm_netbsd+0x5c>
21f12598:	e59b3008 	ldr	r3, [fp, #8]
21f1259c:	e2833004 	add	r3, r3, #4	; 0x4
21f125a0:	e5933000 	ldr	r3, [r3]
21f125a4:	e3530000 	cmp	r3, #0	; 0x0
21f125a8:	0a000001 	beq	21f125b4 <do_bootm_netbsd+0x5c>
		img_addr = (image_header_t *) addr;
21f125ac:	e59b3004 	ldr	r3, [fp, #4]
21f125b0:	e50b3020 	str	r3, [fp, #-32]


	consdev = "";
21f125b4:	e59f31bc 	ldr	r3, [pc, #444]	; 21f12778 <.text+0x12778>
21f125b8:	e50b301c 	str	r3, [fp, #-28]
#if   defined (CONFIG_8xx_CONS_SMC1)
	consdev = "smc1";
#elif defined (CONFIG_8xx_CONS_SMC2)
	consdev = "smc2";
#elif defined (CONFIG_8xx_CONS_SCC2)
	consdev = "scc2";
#elif defined (CONFIG_8xx_CONS_SCC3)
	consdev = "scc3";
#endif

	if (argc > 2) {
21f125bc:	e51b3034 	ldr	r3, [fp, #-52]
21f125c0:	e3530002 	cmp	r3, #2	; 0x2
21f125c4:	da00004c 	ble	21f126fc <do_bootm_netbsd+0x1a4>
		ulong len;
		int   i;

		for (i=2, len=0 ; i<argc ; i+=1)
21f125c8:	e3a03002 	mov	r3, #2	; 0x2
21f125cc:	e50b3010 	str	r3, [fp, #-16]
21f125d0:	e3a03000 	mov	r3, #0	; 0x0
21f125d4:	e50b3014 	str	r3, [fp, #-20]
21f125d8:	ea00000f 	b	21f1261c <do_bootm_netbsd+0xc4>
			len += strlen (argv[i]) + 1;
21f125dc:	e51b3010 	ldr	r3, [fp, #-16]
21f125e0:	e1a03103 	mov	r3, r3, lsl #2
21f125e4:	e1a02003 	mov	r2, r3
21f125e8:	e51b3038 	ldr	r3, [fp, #-56]
21f125ec:	e0823003 	add	r3, r2, r3
21f125f0:	e5933000 	ldr	r3, [r3]
21f125f4:	e1a00003 	mov	r0, r3
21f125f8:	eb004171 	bl	21f22bc4 <strlen>
21f125fc:	e1a02000 	mov	r2, r0
21f12600:	e51b3014 	ldr	r3, [fp, #-20]
21f12604:	e0823003 	add	r3, r2, r3
21f12608:	e2833001 	add	r3, r3, #1	; 0x1
21f1260c:	e50b3014 	str	r3, [fp, #-20]
21f12610:	e51b3010 	ldr	r3, [fp, #-16]
21f12614:	e2833001 	add	r3, r3, #1	; 0x1
21f12618:	e50b3010 	str	r3, [fp, #-16]
21f1261c:	e51b2010 	ldr	r2, [fp, #-16]
21f12620:	e51b3034 	ldr	r3, [fp, #-52]
21f12624:	e1520003 	cmp	r2, r3
21f12628:	baffffeb 	blt	21f125dc <do_bootm_netbsd+0x84>
		cmdline = malloc (len);
21f1262c:	e51b0014 	ldr	r0, [fp, #-20]
21f12630:	eb0027dc 	bl	21f1c5a8 <malloc>
21f12634:	e1a03000 	mov	r3, r0
21f12638:	e50b3018 	str	r3, [fp, #-24]

		for (i=2, len=0 ; i<argc ; i+=1) {
21f1263c:	e3a03002 	mov	r3, #2	; 0x2
21f12640:	e50b3010 	str	r3, [fp, #-16]
21f12644:	e3a03000 	mov	r3, #0	; 0x0
21f12648:	e50b3014 	str	r3, [fp, #-20]
21f1264c:	ea000025 	b	21f126e8 <do_bootm_netbsd+0x190>
			if (i > 2)
21f12650:	e51b3010 	ldr	r3, [fp, #-16]
21f12654:	e3530002 	cmp	r3, #2	; 0x2
21f12658:	da000007 	ble	21f1267c <do_bootm_netbsd+0x124>
				cmdline[len++] = ' ';
21f1265c:	e51b2014 	ldr	r2, [fp, #-20]
21f12660:	e51b3018 	ldr	r3, [fp, #-24]
21f12664:	e0822003 	add	r2, r2, r3
21f12668:	e3a03020 	mov	r3, #32	; 0x20
21f1266c:	e5c23000 	strb	r3, [r2]
21f12670:	e51b3014 	ldr	r3, [fp, #-20]
21f12674:	e2833001 	add	r3, r3, #1	; 0x1
21f12678:	e50b3014 	str	r3, [fp, #-20]
			strcpy (&cmdline[len], argv[i]);
21f1267c:	e51b2014 	ldr	r2, [fp, #-20]
21f12680:	e51b3018 	ldr	r3, [fp, #-24]
21f12684:	e0821003 	add	r1, r2, r3
21f12688:	e51b3010 	ldr	r3, [fp, #-16]
21f1268c:	e1a03103 	mov	r3, r3, lsl #2
21f12690:	e1a02003 	mov	r2, r3
21f12694:	e51b3038 	ldr	r3, [fp, #-56]
21f12698:	e0823003 	add	r3, r2, r3
21f1269c:	e5933000 	ldr	r3, [r3]
21f126a0:	e1a00001 	mov	r0, r1
21f126a4:	e1a01003 	mov	r1, r3
21f126a8:	eb004009 	bl	21f226d4 <strcpy>
			len += strlen (argv[i]);
21f126ac:	e51b3010 	ldr	r3, [fp, #-16]
21f126b0:	e1a03103 	mov	r3, r3, lsl #2
21f126b4:	e1a02003 	mov	r2, r3
21f126b8:	e51b3038 	ldr	r3, [fp, #-56]
21f126bc:	e0823003 	add	r3, r2, r3
21f126c0:	e5933000 	ldr	r3, [r3]
21f126c4:	e1a00003 	mov	r0, r3
21f126c8:	eb00413d 	bl	21f22bc4 <strlen>
21f126cc:	e1a02000 	mov	r2, r0
21f126d0:	e51b3014 	ldr	r3, [fp, #-20]
21f126d4:	e0833002 	add	r3, r3, r2
21f126d8:	e50b3014 	str	r3, [fp, #-20]
21f126dc:	e51b3010 	ldr	r3, [fp, #-16]
21f126e0:	e2833001 	add	r3, r3, #1	; 0x1
21f126e4:	e50b3010 	str	r3, [fp, #-16]
21f126e8:	e51b2010 	ldr	r2, [fp, #-16]
21f126ec:	e51b3034 	ldr	r3, [fp, #-52]
21f126f0:	e1520003 	cmp	r2, r3
21f126f4:	baffffd5 	blt	21f12650 <do_bootm_netbsd+0xf8>
21f126f8:	ea000008 	b	21f12720 <do_bootm_netbsd+0x1c8>
		}
	} else if ((cmdline = getenv("bootargs")) == NULL) {
21f126fc:	e59f0078 	ldr	r0, [pc, #120]	; 21f1277c <.text+0x1277c>
21f12700:	eb002144 	bl	21f1ac18 <getenv>
21f12704:	e1a03000 	mov	r3, r0
21f12708:	e50b3018 	str	r3, [fp, #-24]
21f1270c:	e51b3018 	ldr	r3, [fp, #-24]
21f12710:	e3530000 	cmp	r3, #0	; 0x0
21f12714:	1a000001 	bne	21f12720 <do_bootm_netbsd+0x1c8>
		cmdline = "";
21f12718:	e59f3058 	ldr	r3, [pc, #88]	; 21f12778 <.text+0x12778>
21f1271c:	e50b3018 	str	r3, [fp, #-24]
	}

	loader = (void (*)(bd_t *, image_header_t *, char *, char *)) ntohl(hdr->ih_ep);
21f12720:	e51b3028 	ldr	r3, [fp, #-40]
21f12724:	e5933014 	ldr	r3, [r3, #20]
21f12728:	e1a00003 	mov	r0, r3
21f1272c:	ebffff73 	bl	21f12500 <__fswab32>
21f12730:	e1a03000 	mov	r3, r0
21f12734:	e50b3024 	str	r3, [fp, #-36]

	printf ("## Transferring control to NetBSD stage-2 loader (at address %08lx) ...\n",
21f12738:	e51b3024 	ldr	r3, [fp, #-36]
21f1273c:	e59f003c 	ldr	r0, [pc, #60]	; 21f12780 <.text+0x12780>
21f12740:	e1a01003 	mov	r1, r3
21f12744:	eb0024d0 	bl	21f1ba8c <printf>
		(ulong)loader);

	SHOW_BOOT_PROGRESS (15);

	/*
	 * NetBSD Stage-2 Loader Parameters:
	 *   r3: ptr to board info data
	 *   r4: image address
	 *   r5: console device
	 *   r6: boot args string
	 */
	(*loader) (gd->bd, img_addr, consdev, cmdline);
21f12748:	e1a03008 	mov	r3, r8
21f1274c:	e5933000 	ldr	r3, [r3]
21f12750:	e51bc024 	ldr	ip, [fp, #-36]
21f12754:	e1a00003 	mov	r0, r3
21f12758:	e51b1020 	ldr	r1, [fp, #-32]
21f1275c:	e51b201c 	ldr	r2, [fp, #-28]
21f12760:	e51b3018 	ldr	r3, [fp, #-24]
21f12764:	e1a0e00f 	mov	lr, pc
21f12768:	e1a0f00c 	mov	pc, ip
}
21f1276c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f12770:	e89da800 	ldmia	sp, {fp, sp, pc}
21f12774:	21f67664 	mvncss	r7, r4, ror #12
21f12778:	21f3033c 	mvncss	r0, ip, lsr r3
21f1277c:	21f30340 	mvncss	r0, r0, asr #6
21f12780:	21f3034c 	mvncss	r0, ip, asr #6

21f12784 <do_bootd>:

#if defined(CONFIG_ARTOS) && defined(CONFIG_PPC)

/* Function that returns a character from the environment */
extern uchar (*env_get_char)(int);

static void
do_bootm_artos (cmd_tbl_t *cmdtp, int flag,
		int	argc, char *argv[],
		ulong	addr,
		ulong	*len_ptr,
		int	verify)
{
	ulong top;
	char *s, *cmdline;
	char **fwenv, **ss;
	int i, j, nxt, len, envno, envsz;
	bd_t *kbd;
	void (*entry)(bd_t *bd, char *cmdline, char **fwenv, ulong top);
	image_header_t *hdr = &header;

	/*
	 * Booting an ARTOS kernel image + application
	 */

	/* this used to be the top of memory, but was wrong... */
#ifdef CONFIG_PPC
	/* get stack pointer */
	asm volatile ("mr %0,1" : "=r"(top) );
#endif
	debug ("## Current stack ends at 0x%08lX ", top);

	top -= 2048;		/* just to be sure */
	if (top > CFG_BOOTMAPSZ)
		top = CFG_BOOTMAPSZ;
	top &= ~0xF;

	debug ("=> set upper limit to 0x%08lX\n", top);

	/* first check the artos specific boot args, then the linux args*/
	if ((s = getenv("abootargs")) == NULL && (s = getenv("bootargs")) == NULL)
		s = "";

	/* get length of cmdline, and place it */
	len = strlen(s);
	top = (top - (len + 1)) & ~0xF;
	cmdline = (char *)top;
	debug ("## cmdline at 0x%08lX ", top);
	strcpy(cmdline, s);

	/* copy bdinfo */
	top = (top - sizeof(bd_t)) & ~0xF;
	debug ("## bd at 0x%08lX ", top);
	kbd = (bd_t *)top;
	memcpy(kbd, gd->bd, sizeof(bd_t));

	/* first find number of env entries, and their size */
	envno = 0;
	envsz = 0;
	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt)
			;
		envno++;
		envsz += (nxt - i) + 1;	/* plus trailing zero */
	}
	envno++;	/* plus the terminating zero */
	debug ("## %u envvars total size %u ", envno, envsz);

	top = (top - sizeof(char **)*envno) & ~0xF;
	fwenv = (char **)top;
	debug ("## fwenv at 0x%08lX ", top);

	top = (top - envsz) & ~0xF;
	s = (char *)top;
	ss = fwenv;

	/* now copy them */
	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt)
			;
		*ss++ = s;
		for (j = i; j < nxt; ++j)
			*s++ = env_get_char(j);
		*s++ = '\0';
	}
	*ss++ = NULL;	/* terminate */

	entry = (void (*)(bd_t *, char *, char **, ulong))ntohl(hdr->ih_ep);
	(*entry)(kbd, cmdline, fwenv, top);
}
#endif


#if (CONFIG_COMMANDS & CFG_CMD_BOOTD)
int do_bootd (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f12784:	e1a0c00d 	mov	ip, sp
21f12788:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1278c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f12790:	e24dd014 	sub	sp, sp, #20	; 0x14
21f12794:	e50b0014 	str	r0, [fp, #-20]
21f12798:	e50b1018 	str	r1, [fp, #-24]
21f1279c:	e50b201c 	str	r2, [fp, #-28]
21f127a0:	e50b3020 	str	r3, [fp, #-32]
	int rcode = 0;
21f127a4:	e3a03000 	mov	r3, #0	; 0x0
21f127a8:	e50b3010 	str	r3, [fp, #-16]
#ifndef CFG_HUSH_PARSER
	if (run_command (getenv ("bootcmd"), flag) < 0) rcode = 1;
21f127ac:	e59f0034 	ldr	r0, [pc, #52]	; 21f127e8 <.text+0x127e8>
21f127b0:	eb002118 	bl	21f1ac18 <getenv>
21f127b4:	e1a03000 	mov	r3, r0
21f127b8:	e1a00003 	mov	r0, r3
21f127bc:	e51b1018 	ldr	r1, [fp, #-24]
21f127c0:	ebfffc1f 	bl	21f11844 <run_command>
21f127c4:	e1a03000 	mov	r3, r0
21f127c8:	e3530000 	cmp	r3, #0	; 0x0
21f127cc:	aa000001 	bge	21f127d8 <do_bootd+0x54>
21f127d0:	e3a03001 	mov	r3, #1	; 0x1
21f127d4:	e50b3010 	str	r3, [fp, #-16]
#else
	if (parse_string_outer(getenv("bootcmd"),
		FLAG_PARSE_SEMICOLON | FLAG_EXIT_FROM_LOOP) != 0 ) rcode = 1;
#endif
	return rcode;
21f127d8:	e51b3010 	ldr	r3, [fp, #-16]
}
21f127dc:	e1a00003 	mov	r0, r3
21f127e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f127e4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f127e8:	21f30398 	ldrcsb	r0, [r3, #56]!

21f127ec <do_imls>:

U_BOOT_CMD(
 	boot,	1,	1,	do_bootd,
 	"boot    - boot default, i.e., run 'bootcmd'\n",
	NULL
);

/* keep old command name "bootd" for backward compatibility */
U_BOOT_CMD(
 	bootd, 1,	1,	do_bootd,
 	"bootd   - boot default, i.e., run 'bootcmd'\n",
	NULL
);

#endif

#if (CONFIG_COMMANDS & CFG_CMD_IMI)
int do_iminfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	int	arg;
	ulong	addr;
	int     rcode=0;

	if (argc < 2) {
		return image_info (load_addr);
	}

	for (arg=1; arg <argc; ++arg) {
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info (addr) != 0) rcode = 1;
	}
	return rcode;
}

static int image_info (ulong addr)
{
	ulong	data, len, checksum;
	image_header_t *hdr = &header;

	printf ("\n## Checking Image at %08lx ...\n", addr);

	/* Copy header so we can blank CRC field for re-calculation */
	memmove (&header, (char *)addr, sizeof(image_header_t));

	if (ntohl(hdr->ih_magic) != IH_MAGIC) {
		puts ("   Bad Magic Number\n");
		return 1;
	}

	data = (ulong)&header;
	len  = sizeof(image_header_t);

	checksum = ntohl(hdr->ih_hcrc);
	hdr->ih_hcrc = 0;

	if (crc32 (0, (uchar *)data, len) != checksum) {
		puts ("   Bad Header Checksum\n");
		return 1;
	}

	/* for multi-file images we need the data part, too */
	print_image_hdr ((image_header_t *)addr);

	data = addr + sizeof(image_header_t);
	len  = ntohl(hdr->ih_size);

	puts ("   Verifying Checksum ... ");
	if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
		puts ("   Bad Data CRC\n");
		return 1;
	}
	puts ("OK\n");
	return 0;
}

U_BOOT_CMD(
	iminfo,	CFG_MAXARGS,	1,	do_iminfo,
	"iminfo  - print header information for application image\n",
	"addr [addr ...]\n"
	"    - print header information for application image starting at\n"
	"      address 'addr' in memory; this includes verification of the\n"
	"      image contents (magic number, header and payload checksums)\n"
);

#endif	/* CFG_CMD_IMI */

#if (CONFIG_COMMANDS & CFG_CMD_IMLS)
/*-----------------------------------------------------------------------
 * List all images found in flash.
 */
int do_imls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f127ec:	e1a0c00d 	mov	ip, sp
21f127f0:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f127f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f127f8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f127fc:	e50b0030 	str	r0, [fp, #-48]
21f12800:	e50b1034 	str	r1, [fp, #-52]
21f12804:	e50b2038 	str	r2, [fp, #-56]
21f12808:	e50b303c 	str	r3, [fp, #-60]
	flash_info_t *info;
	int i, j;
	image_header_t *hdr;
	ulong data, len, checksum;

	for (i=0, info=&flash_info[0]; i<CFG_MAX_FLASH_BANKS; ++i, ++info) {
21f1280c:	e3a03000 	mov	r3, #0	; 0x0
21f12810:	e50b3028 	str	r3, [fp, #-40]
21f12814:	e59f31b8 	ldr	r3, [pc, #440]	; 21f129d4 <.text+0x129d4>
21f12818:	e50b302c 	str	r3, [fp, #-44]
21f1281c:	ea000065 	b	21f129b8 <do_imls+0x1cc>
		if (info->flash_id == FLASH_UNKNOWN)
21f12820:	e51b302c 	ldr	r3, [fp, #-44]
21f12824:	e5932008 	ldr	r2, [r3, #8]
21f12828:	e3a03cff 	mov	r3, #65280	; 0xff00
21f1282c:	e28330ff 	add	r3, r3, #255	; 0xff
21f12830:	e1520003 	cmp	r2, r3
21f12834:	0a000058 	beq	21f1299c <do_imls+0x1b0>
			goto next_bank;
		for (j=0; j<info->sector_count; ++j) {
21f12838:	e3a03000 	mov	r3, #0	; 0x0
21f1283c:	e50b3024 	str	r3, [fp, #-36]
21f12840:	ea00004f 	b	21f12984 <do_imls+0x198>

			if (!(hdr=(image_header_t *)info->start[j]) ||
21f12844:	e51b3024 	ldr	r3, [fp, #-36]
21f12848:	e51b202c 	ldr	r2, [fp, #-44]
21f1284c:	e3a0100c 	mov	r1, #12	; 0xc
21f12850:	e1a03103 	mov	r3, r3, lsl #2
21f12854:	e0833002 	add	r3, r3, r2
21f12858:	e0833001 	add	r3, r3, r1
21f1285c:	e5933000 	ldr	r3, [r3]
21f12860:	e50b3020 	str	r3, [fp, #-32]
21f12864:	e51b3020 	ldr	r3, [fp, #-32]
21f12868:	e3530000 	cmp	r3, #0	; 0x0
21f1286c:	0a000041 	beq	21f12978 <do_imls+0x18c>
21f12870:	e51b3020 	ldr	r3, [fp, #-32]
21f12874:	e5933000 	ldr	r3, [r3]
21f12878:	e1a00003 	mov	r0, r3
21f1287c:	ebffff1f 	bl	21f12500 <__fswab32>
21f12880:	e1a03000 	mov	r3, r0
21f12884:	e1a02003 	mov	r2, r3
21f12888:	e59f3148 	ldr	r3, [pc, #328]	; 21f129d8 <.text+0x129d8>
21f1288c:	e1520003 	cmp	r2, r3
21f12890:	1a000038 	bne	21f12978 <do_imls+0x18c>
			    (ntohl(hdr->ih_magic) != IH_MAGIC))
				goto next_sector;

			/* Copy header so we can blank CRC field for re-calculation */
			memmove (&header, (char *)hdr, sizeof(image_header_t));
21f12894:	e51b3020 	ldr	r3, [fp, #-32]
21f12898:	e59f013c 	ldr	r0, [pc, #316]	; 21f129dc <.text+0x129dc>
21f1289c:	e1a01003 	mov	r1, r3
21f128a0:	e3a02040 	mov	r2, #64	; 0x40
21f128a4:	eb004268 	bl	21f2324c <memmove>

			checksum = ntohl(header.ih_hcrc);
21f128a8:	e59f312c 	ldr	r3, [pc, #300]	; 21f129dc <.text+0x129dc>
21f128ac:	e5933004 	ldr	r3, [r3, #4]
21f128b0:	e1a00003 	mov	r0, r3
21f128b4:	ebffff11 	bl	21f12500 <__fswab32>
21f128b8:	e1a03000 	mov	r3, r0
21f128bc:	e50b3014 	str	r3, [fp, #-20]
			header.ih_hcrc = 0;
21f128c0:	e59f2114 	ldr	r2, [pc, #276]	; 21f129dc <.text+0x129dc>
21f128c4:	e3a03000 	mov	r3, #0	; 0x0
21f128c8:	e5823004 	str	r3, [r2, #4]

			if (crc32 (0, (uchar *)&header, sizeof(image_header_t))
21f128cc:	e59f3108 	ldr	r3, [pc, #264]	; 21f129dc <.text+0x129dc>
21f128d0:	e3a00000 	mov	r0, #0	; 0x0
21f128d4:	e1a01003 	mov	r1, r3
21f128d8:	e3a02040 	mov	r2, #64	; 0x40
21f128dc:	eb003e85 	bl	21f222f8 <crc32>
21f128e0:	e1a02000 	mov	r2, r0
21f128e4:	e51b3014 	ldr	r3, [fp, #-20]
21f128e8:	e1520003 	cmp	r2, r3
21f128ec:	1a000021 	bne	21f12978 <do_imls+0x18c>
			    != checksum)
				goto next_sector;

			printf ("Image at %08lX:\n", (ulong)hdr);
21f128f0:	e51b3020 	ldr	r3, [fp, #-32]
21f128f4:	e59f00e4 	ldr	r0, [pc, #228]	; 21f129e0 <.text+0x129e0>
21f128f8:	e1a01003 	mov	r1, r3
21f128fc:	eb002462 	bl	21f1ba8c <printf>
			print_image_hdr( hdr );
21f12900:	e51b0020 	ldr	r0, [fp, #-32]
21f12904:	eb000039 	bl	21f129f0 <print_image_hdr>

			data = (ulong)hdr + sizeof(image_header_t);
21f12908:	e51b3020 	ldr	r3, [fp, #-32]
21f1290c:	e2833040 	add	r3, r3, #64	; 0x40
21f12910:	e50b301c 	str	r3, [fp, #-28]
			len  = ntohl(hdr->ih_size);
21f12914:	e51b3020 	ldr	r3, [fp, #-32]
21f12918:	e593300c 	ldr	r3, [r3, #12]
21f1291c:	e1a00003 	mov	r0, r3
21f12920:	ebfffef6 	bl	21f12500 <__fswab32>
21f12924:	e1a03000 	mov	r3, r0
21f12928:	e50b3018 	str	r3, [fp, #-24]

			puts ("   Verifying Checksum ... ");
21f1292c:	e59f00b0 	ldr	r0, [pc, #176]	; 21f129e4 <.text+0x129e4>
21f12930:	eb002442 	bl	21f1ba40 <puts>
			if (crc32 (0, (uchar *)data, len) != ntohl(hdr->ih_dcrc)) {
21f12934:	e51b301c 	ldr	r3, [fp, #-28]
21f12938:	e3a00000 	mov	r0, #0	; 0x0
21f1293c:	e1a01003 	mov	r1, r3
21f12940:	e51b2018 	ldr	r2, [fp, #-24]
21f12944:	eb003e6b 	bl	21f222f8 <crc32>
21f12948:	e1a04000 	mov	r4, r0
21f1294c:	e51b3020 	ldr	r3, [fp, #-32]
21f12950:	e5933018 	ldr	r3, [r3, #24]
21f12954:	e1a00003 	mov	r0, r3
21f12958:	ebfffee8 	bl	21f12500 <__fswab32>
21f1295c:	e1a03000 	mov	r3, r0
21f12960:	e1540003 	cmp	r4, r3
21f12964:	0a000001 	beq	21f12970 <do_imls+0x184>
				puts ("   Bad Data CRC\n");
21f12968:	e59f0078 	ldr	r0, [pc, #120]	; 21f129e8 <.text+0x129e8>
21f1296c:	eb002433 	bl	21f1ba40 <puts>
			}
			puts ("OK\n");
21f12970:	e59f0074 	ldr	r0, [pc, #116]	; 21f129ec <.text+0x129ec>
21f12974:	eb002431 	bl	21f1ba40 <puts>
21f12978:	e51b3024 	ldr	r3, [fp, #-36]
21f1297c:	e2833001 	add	r3, r3, #1	; 0x1
21f12980:	e50b3024 	str	r3, [fp, #-36]
21f12984:	e51b302c 	ldr	r3, [fp, #-44]
21f12988:	e1d330b4 	ldrh	r3, [r3, #4]
21f1298c:	e1a02003 	mov	r2, r3
21f12990:	e51b3024 	ldr	r3, [fp, #-36]
21f12994:	e1520003 	cmp	r2, r3
21f12998:	caffffa9 	bgt	21f12844 <do_imls+0x58>
21f1299c:	e51b3028 	ldr	r3, [fp, #-40]
21f129a0:	e2833001 	add	r3, r3, #1	; 0x1
21f129a4:	e50b3028 	str	r3, [fp, #-40]
21f129a8:	e51b302c 	ldr	r3, [fp, #-44]
21f129ac:	e2833c05 	add	r3, r3, #1280	; 0x500
21f129b0:	e283300c 	add	r3, r3, #12	; 0xc
21f129b4:	e50b302c 	str	r3, [fp, #-44]
21f129b8:	e51b3028 	ldr	r3, [fp, #-40]
21f129bc:	e3530000 	cmp	r3, #0	; 0x0
21f129c0:	daffff96 	ble	21f12820 <do_imls+0x34>
next_sector:		;
		}
next_bank:	;
	}

	return (0);
21f129c4:	e3a03000 	mov	r3, #0	; 0x0
}
21f129c8:	e1a00003 	mov	r0, r3
21f129cc:	e24bd010 	sub	sp, fp, #16	; 0x10
21f129d0:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f129d4:	21f68ca0 	mvncss	r8, r0, lsr #25
21f129d8:	27051956 	smlsdcs	r5, r6, r9, r1
21f129dc:	21f67664 	mvncss	r7, r4, ror #12
21f129e0:	21f30410 	mvncss	r0, r0, lsl r4
21f129e4:	21f3019c 	ldrcsb	r0, [r3, #28]!
21f129e8:	21f30424 	mvncss	r0, r4, lsr #8
21f129ec:	21f301c8 	mvncss	r0, r8, asr #3

21f129f0 <print_image_hdr>:

U_BOOT_CMD(
	imls,	1,		1,	do_imls,
	"imls    - list all images found in flash\n",
	"\n"
	"    - Prints information about all images found at sector\n"
	"      boundaries in flash.\n"
);
#endif	/* CFG_CMD_IMLS */

void
print_image_hdr (image_header_t *hdr)
{
21f129f0:	e1a0c00d 	mov	ip, sp
21f129f4:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f129f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f129fc:	e24dd010 	sub	sp, sp, #16	; 0x10
21f12a00:	e50b0020 	str	r0, [fp, #-32]
#if (CONFIG_COMMANDS & CFG_CMD_DATE) || defined(CONFIG_TIMESTAMP)
	time_t timestamp = (time_t)ntohl(hdr->ih_time);
	struct rtc_time tm;
#endif

	printf ("   Image Name:   %.*s\n", IH_NMLEN, hdr->ih_name);
21f12a04:	e51b3020 	ldr	r3, [fp, #-32]
21f12a08:	e2833020 	add	r3, r3, #32	; 0x20
21f12a0c:	e59f0124 	ldr	r0, [pc, #292]	; 21f12b38 <.text+0x12b38>
21f12a10:	e3a01020 	mov	r1, #32	; 0x20
21f12a14:	e1a02003 	mov	r2, r3
21f12a18:	eb00241b 	bl	21f1ba8c <printf>
#if (CONFIG_COMMANDS & CFG_CMD_DATE) || defined(CONFIG_TIMESTAMP)
	to_tm (timestamp, &tm);
	printf ("   Created:      %4d-%02d-%02d  %2d:%02d:%02d UTC\n",
		tm.tm_year, tm.tm_mon, tm.tm_mday,
		tm.tm_hour, tm.tm_min, tm.tm_sec);
#endif	/* CFG_CMD_DATE, CONFIG_TIMESTAMP */
	puts ("   Image Type:   "); print_type(hdr);
21f12a1c:	e59f0118 	ldr	r0, [pc, #280]	; 21f12b3c <.text+0x12b3c>
21f12a20:	eb002406 	bl	21f1ba40 <puts>
21f12a24:	e51b0020 	ldr	r0, [fp, #-32]
21f12a28:	eb000049 	bl	21f12b54 <print_type>
	printf ("\n   Data Size:    %d Bytes = ", ntohl(hdr->ih_size));
21f12a2c:	e51b3020 	ldr	r3, [fp, #-32]
21f12a30:	e593300c 	ldr	r3, [r3, #12]
21f12a34:	e1a00003 	mov	r0, r3
21f12a38:	ebfffeb0 	bl	21f12500 <__fswab32>
21f12a3c:	e1a03000 	mov	r3, r0
21f12a40:	e59f00f8 	ldr	r0, [pc, #248]	; 21f12b40 <.text+0x12b40>
21f12a44:	e1a01003 	mov	r1, r3
21f12a48:	eb00240f 	bl	21f1ba8c <printf>
	print_size (ntohl(hdr->ih_size), "\n");
21f12a4c:	e51b3020 	ldr	r3, [fp, #-32]
21f12a50:	e593300c 	ldr	r3, [r3, #12]
21f12a54:	e1a00003 	mov	r0, r3
21f12a58:	ebfffea8 	bl	21f12500 <__fswab32>
21f12a5c:	e1a03000 	mov	r3, r0
21f12a60:	e1a00003 	mov	r0, r3
21f12a64:	e59f10d8 	ldr	r1, [pc, #216]	; 21f12b44 <.text+0x12b44>
21f12a68:	eb003ed4 	bl	21f225c0 <print_size>
	printf ("   Load Address: %08x\n"
21f12a6c:	e51b3020 	ldr	r3, [fp, #-32]
21f12a70:	e5933010 	ldr	r3, [r3, #16]
21f12a74:	e1a00003 	mov	r0, r3
21f12a78:	ebfffea0 	bl	21f12500 <__fswab32>
21f12a7c:	e1a03000 	mov	r3, r0
21f12a80:	e1a04003 	mov	r4, r3
21f12a84:	e51b3020 	ldr	r3, [fp, #-32]
21f12a88:	e5933014 	ldr	r3, [r3, #20]
21f12a8c:	e1a00003 	mov	r0, r3
21f12a90:	ebfffe9a 	bl	21f12500 <__fswab32>
21f12a94:	e1a03000 	mov	r3, r0
21f12a98:	e59f00a8 	ldr	r0, [pc, #168]	; 21f12b48 <.text+0x12b48>
21f12a9c:	e1a01004 	mov	r1, r4
21f12aa0:	e1a02003 	mov	r2, r3
21f12aa4:	eb0023f8 	bl	21f1ba8c <printf>
		"   Entry Point:  %08x\n",
		 ntohl(hdr->ih_load), ntohl(hdr->ih_ep));

	if (hdr->ih_type == IH_TYPE_MULTI) {
21f12aa8:	e51b3020 	ldr	r3, [fp, #-32]
21f12aac:	e5d3301e 	ldrb	r3, [r3, #30]
21f12ab0:	e3530004 	cmp	r3, #4	; 0x4
21f12ab4:	1a00001d 	bne	21f12b30 <print_image_hdr+0x140>
		int i;
		ulong len;
		ulong *len_ptr = (ulong *)((ulong)hdr + sizeof(image_header_t));
21f12ab8:	e51b3020 	ldr	r3, [fp, #-32]
21f12abc:	e2833040 	add	r3, r3, #64	; 0x40
21f12ac0:	e50b3014 	str	r3, [fp, #-20]

		puts ("   Contents:\n");
21f12ac4:	e59f0080 	ldr	r0, [pc, #128]	; 21f12b4c <.text+0x12b4c>
21f12ac8:	eb0023dc 	bl	21f1ba40 <puts>
		for (i=0; (len = ntohl(*len_ptr)); ++i, ++len_ptr) {
21f12acc:	e3a03000 	mov	r3, #0	; 0x0
21f12ad0:	e50b301c 	str	r3, [fp, #-28]
21f12ad4:	ea00000c 	b	21f12b0c <print_image_hdr+0x11c>
			printf ("   Image %d: %8ld Bytes = ", i, len);
21f12ad8:	e59f0070 	ldr	r0, [pc, #112]	; 21f12b50 <.text+0x12b50>
21f12adc:	e51b101c 	ldr	r1, [fp, #-28]
21f12ae0:	e51b2018 	ldr	r2, [fp, #-24]
21f12ae4:	eb0023e8 	bl	21f1ba8c <printf>
			print_size (len, "\n");
21f12ae8:	e51b0018 	ldr	r0, [fp, #-24]
21f12aec:	e59f1050 	ldr	r1, [pc, #80]	; 21f12b44 <.text+0x12b44>
21f12af0:	eb003eb2 	bl	21f225c0 <print_size>
21f12af4:	e51b301c 	ldr	r3, [fp, #-28]
21f12af8:	e2833001 	add	r3, r3, #1	; 0x1
21f12afc:	e50b301c 	str	r3, [fp, #-28]
21f12b00:	e51b3014 	ldr	r3, [fp, #-20]
21f12b04:	e2833004 	add	r3, r3, #4	; 0x4
21f12b08:	e50b3014 	str	r3, [fp, #-20]
21f12b0c:	e51b3014 	ldr	r3, [fp, #-20]
21f12b10:	e5933000 	ldr	r3, [r3]
21f12b14:	e1a00003 	mov	r0, r3
21f12b18:	ebfffe78 	bl	21f12500 <__fswab32>
21f12b1c:	e1a03000 	mov	r3, r0
21f12b20:	e50b3018 	str	r3, [fp, #-24]
21f12b24:	e51b3018 	ldr	r3, [fp, #-24]
21f12b28:	e3530000 	cmp	r3, #0	; 0x0
21f12b2c:	1affffe9 	bne	21f12ad8 <print_image_hdr+0xe8>
		}
	}
}
21f12b30:	e24bd010 	sub	sp, fp, #16	; 0x10
21f12b34:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f12b38:	21f3046c 	mvncss	r0, ip, ror #8
21f12b3c:	21f30484 	mvncss	r0, r4, lsl #9
21f12b40:	21f30498 	ldrcsb	r0, [r3, #72]!
21f12b44:	21f304b8 	ldrcsh	r0, [r3, #72]!
21f12b48:	21f304bc 	ldrcsh	r0, [r3, #76]!
21f12b4c:	21f304ec 	mvncss	r0, ip, ror #9
21f12b50:	21f304fc 	ldrcssh	r0, [r3, #76]!

21f12b54 <print_type>:


static void
print_type (image_header_t *hdr)
{
21f12b54:	e1a0c00d 	mov	ip, sp
21f12b58:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f12b5c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f12b60:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f12b64:	e50b0020 	str	r0, [fp, #-32]
	char *os, *arch, *type, *comp;

	switch (hdr->ih_os) {
21f12b68:	e51b3020 	ldr	r3, [fp, #-32]
21f12b6c:	e5d3301c 	ldrb	r3, [r3, #28]
21f12b70:	e3530012 	cmp	r3, #18	; 0x12
21f12b74:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f12b78:	ea000027 	b	21f12c1c <.text+0x12c1c>
21f12b7c:	21f12bc8 	mvncss	r2, r8, asr #23
21f12b80:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12b84:	21f12bd4 	ldrcssb	r2, [r1, #180]!
21f12b88:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12b8c:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12b90:	21f12be0 	mvncss	r2, r0, ror #23
21f12b94:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12b98:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12b9c:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12ba0:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12ba4:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12ba8:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12bac:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12bb0:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12bb4:	21f12bec 	mvncss	r2, ip, ror #23
21f12bb8:	21f12c1c 	mvncss	r2, ip, lsl ip
21f12bbc:	21f12bf8 	ldrcssh	r2, [r1, #184]!
21f12bc0:	21f12c04 	mvncss	r2, r4, lsl #24
21f12bc4:	21f12c10 	mvncss	r2, r0, lsl ip
	case IH_OS_INVALID:	os = "Invalid OS";		break;
21f12bc8:	e59f32a8 	ldr	r3, [pc, #680]	; 21f12e78 <.text+0x12e78>
21f12bcc:	e50b301c 	str	r3, [fp, #-28]
21f12bd0:	ea000013 	b	21f12c24 <.text+0x12c24>
	case IH_OS_NETBSD:	os = "NetBSD";			break;
21f12bd4:	e59f32a0 	ldr	r3, [pc, #672]	; 21f12e7c <.text+0x12e7c>
21f12bd8:	e50b301c 	str	r3, [fp, #-28]
21f12bdc:	ea000010 	b	21f12c24 <.text+0x12c24>
	case IH_OS_LINUX:	os = "Linux";			break;
21f12be0:	e59f3298 	ldr	r3, [pc, #664]	; 21f12e80 <.text+0x12e80>
21f12be4:	e50b301c 	str	r3, [fp, #-28]
21f12be8:	ea00000d 	b	21f12c24 <.text+0x12c24>
	case IH_OS_VXWORKS:	os = "VxWorks";			break;
21f12bec:	e59f3290 	ldr	r3, [pc, #656]	; 21f12e84 <.text+0x12e84>
21f12bf0:	e50b301c 	str	r3, [fp, #-28]
21f12bf4:	ea00000a 	b	21f12c24 <.text+0x12c24>
	case IH_OS_QNX:		os = "QNX";			break;
21f12bf8:	e59f3288 	ldr	r3, [pc, #648]	; 21f12e88 <.text+0x12e88>
21f12bfc:	e50b301c 	str	r3, [fp, #-28]
21f12c00:	ea000007 	b	21f12c24 <.text+0x12c24>
	case IH_OS_U_BOOT:	os = "U-Boot";			break;
21f12c04:	e59f3280 	ldr	r3, [pc, #640]	; 21f12e8c <.text+0x12e8c>
21f12c08:	e50b301c 	str	r3, [fp, #-28]
21f12c0c:	ea000004 	b	21f12c24 <.text+0x12c24>
	case IH_OS_RTEMS:	os = "RTEMS";			break;
21f12c10:	e59f3278 	ldr	r3, [pc, #632]	; 21f12e90 <.text+0x12e90>
21f12c14:	e50b301c 	str	r3, [fp, #-28]
21f12c18:	ea000001 	b	21f12c24 <.text+0x12c24>
#ifdef CONFIG_ARTOS
	case IH_OS_ARTOS:	os = "ARTOS";			break;
#endif
#ifdef CONFIG_LYNXKDI
	case IH_OS_LYNXOS:	os = "LynxOS";			break;
#endif
	default:		os = "Unknown OS";		break;
21f12c1c:	e59f3270 	ldr	r3, [pc, #624]	; 21f12e94 <.text+0x12e94>
21f12c20:	e50b301c 	str	r3, [fp, #-28]
	}

	switch (hdr->ih_arch) {
21f12c24:	e51b3020 	ldr	r3, [fp, #-32]
21f12c28:	e5d3301d 	ldrb	r3, [r3, #29]
21f12c2c:	e3530011 	cmp	r3, #17	; 0x11
21f12c30:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f12c34:	ea000044 	b	21f12d4c <.text+0x12d4c>
21f12c38:	21f12c80 	mvncss	r2, r0, lsl #25
21f12c3c:	21f12c8c 	mvncss	r2, ip, lsl #25
21f12c40:	21f12c98 	ldrcsb	r2, [r1, #200]!
21f12c44:	21f12cb0 	ldrcsh	r2, [r1, #192]!
21f12c48:	21f12cbc 	ldrcsh	r2, [r1, #204]!
21f12c4c:	21f12cc8 	mvncss	r2, r8, asr #25
21f12c50:	21f12cd4 	ldrcssb	r2, [r1, #196]!
21f12c54:	21f12ce0 	mvncss	r2, r0, ror #25
21f12c58:	21f12cec 	mvncss	r2, ip, ror #25
21f12c5c:	21f12cf8 	ldrcssh	r2, [r1, #200]!
21f12c60:	21f12d04 	mvncss	r2, r4, lsl #26
21f12c64:	21f12d10 	mvncss	r2, r0, lsl sp
21f12c68:	21f12d1c 	mvncss	r2, ip, lsl sp
21f12c6c:	21f12d34 	mvncss	r2, r4, lsr sp
21f12c70:	21f12d28 	mvncss	r2, r8, lsr #26
21f12c74:	21f12d40 	mvncss	r2, r0, asr #26
21f12c78:	21f12d4c 	mvncss	r2, ip, asr #26
21f12c7c:	21f12ca4 	mvncss	r2, r4, lsr #25
	case IH_CPU_INVALID:	arch = "Invalid CPU";		break;
21f12c80:	e59f3210 	ldr	r3, [pc, #528]	; 21f12e98 <.text+0x12e98>
21f12c84:	e50b3018 	str	r3, [fp, #-24]
21f12c88:	ea000031 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_ALPHA:	arch = "Alpha";			break;
21f12c8c:	e59f3208 	ldr	r3, [pc, #520]	; 21f12e9c <.text+0x12e9c>
21f12c90:	e50b3018 	str	r3, [fp, #-24]
21f12c94:	ea00002e 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_ARM:	arch = "ARM";			break;
21f12c98:	e59f3200 	ldr	r3, [pc, #512]	; 21f12ea0 <.text+0x12ea0>
21f12c9c:	e50b3018 	str	r3, [fp, #-24]
21f12ca0:	ea00002b 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_AVR32:	arch = "AVR32";			break;
21f12ca4:	e59f31f8 	ldr	r3, [pc, #504]	; 21f12ea4 <.text+0x12ea4>
21f12ca8:	e50b3018 	str	r3, [fp, #-24]
21f12cac:	ea000028 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_I386:	arch = "Intel x86";		break;
21f12cb0:	e59f31f0 	ldr	r3, [pc, #496]	; 21f12ea8 <.text+0x12ea8>
21f12cb4:	e50b3018 	str	r3, [fp, #-24]
21f12cb8:	ea000025 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_IA64:	arch = "IA64";			break;
21f12cbc:	e59f31e8 	ldr	r3, [pc, #488]	; 21f12eac <.text+0x12eac>
21f12cc0:	e50b3018 	str	r3, [fp, #-24]
21f12cc4:	ea000022 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_MIPS:	arch = "MIPS";			break;
21f12cc8:	e59f31e0 	ldr	r3, [pc, #480]	; 21f12eb0 <.text+0x12eb0>
21f12ccc:	e50b3018 	str	r3, [fp, #-24]
21f12cd0:	ea00001f 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_MIPS64:	arch = "MIPS 64 Bit";		break;
21f12cd4:	e59f31d8 	ldr	r3, [pc, #472]	; 21f12eb4 <.text+0x12eb4>
21f12cd8:	e50b3018 	str	r3, [fp, #-24]
21f12cdc:	ea00001c 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_PPC:	arch = "PowerPC";		break;
21f12ce0:	e59f31d0 	ldr	r3, [pc, #464]	; 21f12eb8 <.text+0x12eb8>
21f12ce4:	e50b3018 	str	r3, [fp, #-24]
21f12ce8:	ea000019 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_S390:	arch = "IBM S390";		break;
21f12cec:	e59f31c8 	ldr	r3, [pc, #456]	; 21f12ebc <.text+0x12ebc>
21f12cf0:	e50b3018 	str	r3, [fp, #-24]
21f12cf4:	ea000016 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_SH:		arch = "SuperH";		break;
21f12cf8:	e59f31c0 	ldr	r3, [pc, #448]	; 21f12ec0 <.text+0x12ec0>
21f12cfc:	e50b3018 	str	r3, [fp, #-24]
21f12d00:	ea000013 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_SPARC:	arch = "SPARC";			break;
21f12d04:	e59f31b8 	ldr	r3, [pc, #440]	; 21f12ec4 <.text+0x12ec4>
21f12d08:	e50b3018 	str	r3, [fp, #-24]
21f12d0c:	ea000010 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_SPARC64:	arch = "SPARC 64 Bit";		break;
21f12d10:	e59f31b0 	ldr	r3, [pc, #432]	; 21f12ec8 <.text+0x12ec8>
21f12d14:	e50b3018 	str	r3, [fp, #-24]
21f12d18:	ea00000d 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_M68K:	arch = "M68K"; 			break;
21f12d1c:	e59f31a8 	ldr	r3, [pc, #424]	; 21f12ecc <.text+0x12ecc>
21f12d20:	e50b3018 	str	r3, [fp, #-24]
21f12d24:	ea00000a 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_MICROBLAZE:	arch = "Microblaze"; 		break;
21f12d28:	e59f31a0 	ldr	r3, [pc, #416]	; 21f12ed0 <.text+0x12ed0>
21f12d2c:	e50b3018 	str	r3, [fp, #-24]
21f12d30:	ea000007 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_NIOS:	arch = "Nios";			break;
21f12d34:	e59f3198 	ldr	r3, [pc, #408]	; 21f12ed4 <.text+0x12ed4>
21f12d38:	e50b3018 	str	r3, [fp, #-24]
21f12d3c:	ea000004 	b	21f12d54 <.text+0x12d54>
	case IH_CPU_NIOS2:	arch = "Nios-II";		break;
21f12d40:	e59f3190 	ldr	r3, [pc, #400]	; 21f12ed8 <.text+0x12ed8>
21f12d44:	e50b3018 	str	r3, [fp, #-24]
21f12d48:	ea000001 	b	21f12d54 <.text+0x12d54>
	default:		arch = "Unknown Architecture";	break;
21f12d4c:	e59f3188 	ldr	r3, [pc, #392]	; 21f12edc <.text+0x12edc>
21f12d50:	e50b3018 	str	r3, [fp, #-24]
	}

	switch (hdr->ih_type) {
21f12d54:	e51b3020 	ldr	r3, [fp, #-32]
21f12d58:	e5d3301e 	ldrb	r3, [r3, #30]
21f12d5c:	e3530008 	cmp	r3, #8	; 0x8
21f12d60:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f12d64:	ea000020 	b	21f12dec <.text+0x12dec>
21f12d68:	21f12d8c 	mvncss	r2, ip, lsl #27
21f12d6c:	21f12d98 	ldrcsb	r2, [r1, #216]!
21f12d70:	21f12da4 	mvncss	r2, r4, lsr #27
21f12d74:	21f12db0 	ldrcsh	r2, [r1, #208]!
21f12d78:	21f12dbc 	ldrcsh	r2, [r1, #220]!
21f12d7c:	21f12dc8 	mvncss	r2, r8, asr #27
21f12d80:	21f12dd4 	ldrcssb	r2, [r1, #212]!
21f12d84:	21f12dec 	mvncss	r2, ip, ror #27
21f12d88:	21f12de0 	mvncss	r2, r0, ror #27
	case IH_TYPE_INVALID:	type = "Invalid Image";		break;
21f12d8c:	e59f314c 	ldr	r3, [pc, #332]	; 21f12ee0 <.text+0x12ee0>
21f12d90:	e50b3014 	str	r3, [fp, #-20]
21f12d94:	ea000016 	b	21f12df4 <.text+0x12df4>
	case IH_TYPE_STANDALONE:type = "Standalone Program";	break;
21f12d98:	e59f3144 	ldr	r3, [pc, #324]	; 21f12ee4 <.text+0x12ee4>
21f12d9c:	e50b3014 	str	r3, [fp, #-20]
21f12da0:	ea000013 	b	21f12df4 <.text+0x12df4>
	case IH_TYPE_KERNEL:	type = "Kernel Image";		break;
21f12da4:	e59f313c 	ldr	r3, [pc, #316]	; 21f12ee8 <.text+0x12ee8>
21f12da8:	e50b3014 	str	r3, [fp, #-20]
21f12dac:	ea000010 	b	21f12df4 <.text+0x12df4>
	case IH_TYPE_RAMDISK:	type = "RAMDisk Image";		break;
21f12db0:	e59f3134 	ldr	r3, [pc, #308]	; 21f12eec <.text+0x12eec>
21f12db4:	e50b3014 	str	r3, [fp, #-20]
21f12db8:	ea00000d 	b	21f12df4 <.text+0x12df4>
	case IH_TYPE_MULTI:	type = "Multi-File Image";	break;
21f12dbc:	e59f312c 	ldr	r3, [pc, #300]	; 21f12ef0 <.text+0x12ef0>
21f12dc0:	e50b3014 	str	r3, [fp, #-20]
21f12dc4:	ea00000a 	b	21f12df4 <.text+0x12df4>
	case IH_TYPE_FIRMWARE:	type = "Firmware";		break;
21f12dc8:	e59f3124 	ldr	r3, [pc, #292]	; 21f12ef4 <.text+0x12ef4>
21f12dcc:	e50b3014 	str	r3, [fp, #-20]
21f12dd0:	ea000007 	b	21f12df4 <.text+0x12df4>
	case IH_TYPE_SCRIPT:	type = "Script";		break;
21f12dd4:	e59f311c 	ldr	r3, [pc, #284]	; 21f12ef8 <.text+0x12ef8>
21f12dd8:	e50b3014 	str	r3, [fp, #-20]
21f12ddc:	ea000004 	b	21f12df4 <.text+0x12df4>
	case IH_TYPE_FLATDT:	type = "Flat Device Tree";	break;
21f12de0:	e59f3114 	ldr	r3, [pc, #276]	; 21f12efc <.text+0x12efc>
21f12de4:	e50b3014 	str	r3, [fp, #-20]
21f12de8:	ea000001 	b	21f12df4 <.text+0x12df4>
	default:		type = "Unknown Image";		break;
21f12dec:	e59f310c 	ldr	r3, [pc, #268]	; 21f12f00 <.text+0x12f00>
21f12df0:	e50b3014 	str	r3, [fp, #-20]
	}

	switch (hdr->ih_comp) {
21f12df4:	e51b3020 	ldr	r3, [fp, #-32]
21f12df8:	e5d3301f 	ldrb	r3, [r3, #31]
21f12dfc:	e50b3024 	str	r3, [fp, #-36]
21f12e00:	e51b3024 	ldr	r3, [fp, #-36]
21f12e04:	e3530001 	cmp	r3, #1	; 0x1
21f12e08:	0a000009 	beq	21f12e34 <.text+0x12e34>
21f12e0c:	e51b3024 	ldr	r3, [fp, #-36]
21f12e10:	e3530002 	cmp	r3, #2	; 0x2
21f12e14:	0a000009 	beq	21f12e40 <.text+0x12e40>
21f12e18:	e51b3024 	ldr	r3, [fp, #-36]
21f12e1c:	e3530000 	cmp	r3, #0	; 0x0
21f12e20:	0a000000 	beq	21f12e28 <.text+0x12e28>
21f12e24:	ea000008 	b	21f12e4c <.text+0x12e4c>
	case IH_COMP_NONE:	comp = "uncompressed";		break;
21f12e28:	e59f30d4 	ldr	r3, [pc, #212]	; 21f12f04 <.text+0x12f04>
21f12e2c:	e50b3010 	str	r3, [fp, #-16]
21f12e30:	ea000007 	b	21f12e54 <.text+0x12e54>
	case IH_COMP_GZIP:	comp = "gzip compressed";	break;
21f12e34:	e59f30cc 	ldr	r3, [pc, #204]	; 21f12f08 <.text+0x12f08>
21f12e38:	e50b3010 	str	r3, [fp, #-16]
21f12e3c:	ea000004 	b	21f12e54 <.text+0x12e54>
	case IH_COMP_BZIP2:	comp = "bzip2 compressed";	break;
21f12e40:	e59f30c4 	ldr	r3, [pc, #196]	; 21f12f0c <.text+0x12f0c>
21f12e44:	e50b3010 	str	r3, [fp, #-16]
21f12e48:	ea000001 	b	21f12e54 <.text+0x12e54>
	default:		comp = "unknown compression";	break;
21f12e4c:	e59f30bc 	ldr	r3, [pc, #188]	; 21f12f10 <.text+0x12f10>
21f12e50:	e50b3010 	str	r3, [fp, #-16]
	}

	printf ("%s %s %s (%s)", arch, os, type, comp);
21f12e54:	e51b3010 	ldr	r3, [fp, #-16]
21f12e58:	e58d3000 	str	r3, [sp]
21f12e5c:	e59f00b0 	ldr	r0, [pc, #176]	; 21f12f14 <.text+0x12f14>
21f12e60:	e51b1018 	ldr	r1, [fp, #-24]
21f12e64:	e51b201c 	ldr	r2, [fp, #-28]
21f12e68:	e51b3014 	ldr	r3, [fp, #-20]
21f12e6c:	eb002306 	bl	21f1ba8c <printf>
}
21f12e70:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f12e74:	e89da800 	ldmia	sp, {fp, sp, pc}
21f12e78:	21f30518 	mvncss	r0, r8, lsl r5
21f12e7c:	21f30524 	mvncss	r0, r4, lsr #10
21f12e80:	21f3052c 	mvncss	r0, ip, lsr #10
21f12e84:	21f30534 	mvncss	r0, r4, lsr r5
21f12e88:	21f3053c 	mvncss	r0, ip, lsr r5
21f12e8c:	21f30540 	mvncss	r0, r0, asr #10
21f12e90:	21f30548 	mvncss	r0, r8, asr #10
21f12e94:	21f30550 	mvncss	r0, r0, asr r5
21f12e98:	21f3055c 	mvncss	r0, ip, asr r5
21f12e9c:	21f30568 	mvncss	r0, r8, ror #10
21f12ea0:	21f30570 	mvncss	r0, r0, ror r5
21f12ea4:	21f30574 	mvncss	r0, r4, ror r5
21f12ea8:	21f3057c 	mvncss	r0, ip, ror r5
21f12eac:	21f30588 	mvncss	r0, r8, lsl #11
21f12eb0:	21f30590 	ldrcsb	r0, [r3, #80]!
21f12eb4:	21f30598 	ldrcsb	r0, [r3, #88]!
21f12eb8:	21f305a4 	mvncss	r0, r4, lsr #11
21f12ebc:	21f305ac 	mvncss	r0, ip, lsr #11
21f12ec0:	21f305b8 	ldrcsh	r0, [r3, #88]!
21f12ec4:	21f305c0 	mvncss	r0, r0, asr #11
21f12ec8:	21f305c8 	mvncss	r0, r8, asr #11
21f12ecc:	21f305d8 	ldrcssb	r0, [r3, #88]!
21f12ed0:	21f305e0 	mvncss	r0, r0, ror #11
21f12ed4:	21f305ec 	mvncss	r0, ip, ror #11
21f12ed8:	21f305f4 	ldrcssh	r0, [r3, #84]!
21f12edc:	21f305fc 	ldrcssh	r0, [r3, #92]!
21f12ee0:	21f30614 	mvncss	r0, r4, lsl r6
21f12ee4:	21f30624 	mvncss	r0, r4, lsr #12
21f12ee8:	21f30204 	mvncss	r0, r4, lsl #4
21f12eec:	21f30638 	mvncss	r0, r8, lsr r6
21f12ef0:	21f30214 	mvncss	r0, r4, lsl r2
21f12ef4:	21f30648 	mvncss	r0, r8, asr #12
21f12ef8:	21f30654 	mvncss	r0, r4, asr r6
21f12efc:	21f3065c 	mvncss	r0, ip, asr r6
21f12f00:	21f30670 	mvncss	r0, r0, ror r6
21f12f04:	21f30680 	mvncss	r0, r0, lsl #13
21f12f08:	21f30690 	ldrcsb	r0, [r3, #96]!
21f12f0c:	21f306a0 	mvncss	r0, r0, lsr #13
21f12f10:	21f306b4 	ldrcsh	r0, [r3, #100]!
21f12f14:	21f306c8 	mvncss	r0, r8, asr #13

21f12f18 <zalloc>:

#define	ZALLOC_ALIGNMENT	16

static void *zalloc(void *x, unsigned items, unsigned size)
{
21f12f18:	e1a0c00d 	mov	ip, sp
21f12f1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f12f20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f12f24:	e24dd010 	sub	sp, sp, #16	; 0x10
21f12f28:	e50b0014 	str	r0, [fp, #-20]
21f12f2c:	e50b1018 	str	r1, [fp, #-24]
21f12f30:	e50b201c 	str	r2, [fp, #-28]
	void *p;

	size *= items;
21f12f34:	e51b201c 	ldr	r2, [fp, #-28]
21f12f38:	e51b3018 	ldr	r3, [fp, #-24]
21f12f3c:	e0030392 	mul	r3, r2, r3
21f12f40:	e50b301c 	str	r3, [fp, #-28]
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
21f12f44:	e51b301c 	ldr	r3, [fp, #-28]
21f12f48:	e283300f 	add	r3, r3, #15	; 0xf
21f12f4c:	e3c3300f 	bic	r3, r3, #15	; 0xf
21f12f50:	e50b301c 	str	r3, [fp, #-28]

	p = malloc (size);
21f12f54:	e51b001c 	ldr	r0, [fp, #-28]
21f12f58:	eb002592 	bl	21f1c5a8 <malloc>
21f12f5c:	e1a03000 	mov	r3, r0
21f12f60:	e50b3010 	str	r3, [fp, #-16]

	return (p);
21f12f64:	e51b3010 	ldr	r3, [fp, #-16]
}
21f12f68:	e1a00003 	mov	r0, r3
21f12f6c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f12f70:	e89da800 	ldmia	sp, {fp, sp, pc}

21f12f74 <zfree>:

static void zfree(void *x, void *addr, unsigned nb)
{
21f12f74:	e1a0c00d 	mov	ip, sp
21f12f78:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f12f7c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f12f80:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f12f84:	e50b0010 	str	r0, [fp, #-16]
21f12f88:	e50b1014 	str	r1, [fp, #-20]
21f12f8c:	e50b2018 	str	r2, [fp, #-24]
	free (addr);
21f12f90:	e51b0014 	ldr	r0, [fp, #-20]
21f12f94:	eb00286c 	bl	21f1d14c <free>
}
21f12f98:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f12f9c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f12fa0 <gunzip>:

#define HEAD_CRC	2
#define EXTRA_FIELD	4
#define ORIG_NAME	8
#define COMMENT		0x10
#define RESERVED	0xe0

#define DEFLATED	8

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
21f12fa0:	e1a0c00d 	mov	ip, sp
21f12fa4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f12fa8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f12fac:	e24dd054 	sub	sp, sp, #84	; 0x54
21f12fb0:	e50b0050 	str	r0, [fp, #-80]
21f12fb4:	e50b1054 	str	r1, [fp, #-84]
21f12fb8:	e50b2058 	str	r2, [fp, #-88]
21f12fbc:	e50b305c 	str	r3, [fp, #-92]
	z_stream s;
	int r, i, flags;

	/* skip header */
	i = 10;
21f12fc0:	e3a0300a 	mov	r3, #10	; 0xa
21f12fc4:	e50b3014 	str	r3, [fp, #-20]
	flags = src[3];
21f12fc8:	e51b3058 	ldr	r3, [fp, #-88]
21f12fcc:	e2833003 	add	r3, r3, #3	; 0x3
21f12fd0:	e5d33000 	ldrb	r3, [r3]
21f12fd4:	e50b3010 	str	r3, [fp, #-16]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
21f12fd8:	e51b3058 	ldr	r3, [fp, #-88]
21f12fdc:	e2833002 	add	r3, r3, #2	; 0x2
21f12fe0:	e5d33000 	ldrb	r3, [r3]
21f12fe4:	e3530008 	cmp	r3, #8	; 0x8
21f12fe8:	1a000003 	bne	21f12ffc <gunzip+0x5c>
21f12fec:	e51b3010 	ldr	r3, [fp, #-16]
21f12ff0:	e20330e0 	and	r3, r3, #224	; 0xe0
21f12ff4:	e3530000 	cmp	r3, #0	; 0x0
21f12ff8:	0a000004 	beq	21f13010 <gunzip+0x70>
		puts ("Error: Bad gzipped data\n");
21f12ffc:	e59f0250 	ldr	r0, [pc, #592]	; 21f13254 <.text+0x13254>
21f13000:	eb00228e 	bl	21f1ba40 <puts>
		return (-1);
21f13004:	e3e03000 	mvn	r3, #0	; 0x0
21f13008:	e50b3060 	str	r3, [fp, #-96]
21f1300c:	ea00008c 	b	21f13244 <gunzip+0x2a4>
	}
	if ((flags & EXTRA_FIELD) != 0)
21f13010:	e51b3010 	ldr	r3, [fp, #-16]
21f13014:	e1a03123 	mov	r3, r3, lsr #2
21f13018:	e2033001 	and	r3, r3, #1	; 0x1
21f1301c:	e20330ff 	and	r3, r3, #255	; 0xff
21f13020:	e3530000 	cmp	r3, #0	; 0x0
21f13024:	0a00000a 	beq	21f13054 <gunzip+0xb4>
		i = 12 + src[10] + (src[11] << 8);
21f13028:	e51b3058 	ldr	r3, [fp, #-88]
21f1302c:	e283300a 	add	r3, r3, #10	; 0xa
21f13030:	e5d33000 	ldrb	r3, [r3]
21f13034:	e1a02003 	mov	r2, r3
21f13038:	e51b3058 	ldr	r3, [fp, #-88]
21f1303c:	e283300b 	add	r3, r3, #11	; 0xb
21f13040:	e5d33000 	ldrb	r3, [r3]
21f13044:	e1a03403 	mov	r3, r3, lsl #8
21f13048:	e0823003 	add	r3, r2, r3
21f1304c:	e283300c 	add	r3, r3, #12	; 0xc
21f13050:	e50b3014 	str	r3, [fp, #-20]
	if ((flags & ORIG_NAME) != 0)
21f13054:	e51b3010 	ldr	r3, [fp, #-16]
21f13058:	e1a031a3 	mov	r3, r3, lsr #3
21f1305c:	e2033001 	and	r3, r3, #1	; 0x1
21f13060:	e20330ff 	and	r3, r3, #255	; 0xff
21f13064:	e3530000 	cmp	r3, #0	; 0x0
21f13068:	0a00000d 	beq	21f130a4 <gunzip+0x104>
		while (src[i++] != 0)
21f1306c:	e51b3014 	ldr	r3, [fp, #-20]
21f13070:	e1a02003 	mov	r2, r3
21f13074:	e51b3058 	ldr	r3, [fp, #-88]
21f13078:	e0823003 	add	r3, r2, r3
21f1307c:	e5d33000 	ldrb	r3, [r3]
21f13080:	e3530000 	cmp	r3, #0	; 0x0
21f13084:	03a03000 	moveq	r3, #0	; 0x0
21f13088:	13a03001 	movne	r3, #1	; 0x1
21f1308c:	e20320ff 	and	r2, r3, #255	; 0xff
21f13090:	e51b3014 	ldr	r3, [fp, #-20]
21f13094:	e2833001 	add	r3, r3, #1	; 0x1
21f13098:	e50b3014 	str	r3, [fp, #-20]
21f1309c:	e3520000 	cmp	r2, #0	; 0x0
21f130a0:	1afffff1 	bne	21f1306c <gunzip+0xcc>
			;
	if ((flags & COMMENT) != 0)
21f130a4:	e51b3010 	ldr	r3, [fp, #-16]
21f130a8:	e1a03223 	mov	r3, r3, lsr #4
21f130ac:	e2033001 	and	r3, r3, #1	; 0x1
21f130b0:	e20330ff 	and	r3, r3, #255	; 0xff
21f130b4:	e3530000 	cmp	r3, #0	; 0x0
21f130b8:	0a00000d 	beq	21f130f4 <gunzip+0x154>
		while (src[i++] != 0)
21f130bc:	e51b3014 	ldr	r3, [fp, #-20]
21f130c0:	e1a02003 	mov	r2, r3
21f130c4:	e51b3058 	ldr	r3, [fp, #-88]
21f130c8:	e0823003 	add	r3, r2, r3
21f130cc:	e5d33000 	ldrb	r3, [r3]
21f130d0:	e3530000 	cmp	r3, #0	; 0x0
21f130d4:	03a03000 	moveq	r3, #0	; 0x0
21f130d8:	13a03001 	movne	r3, #1	; 0x1
21f130dc:	e20320ff 	and	r2, r3, #255	; 0xff
21f130e0:	e51b3014 	ldr	r3, [fp, #-20]
21f130e4:	e2833001 	add	r3, r3, #1	; 0x1
21f130e8:	e50b3014 	str	r3, [fp, #-20]
21f130ec:	e3520000 	cmp	r2, #0	; 0x0
21f130f0:	1afffff1 	bne	21f130bc <gunzip+0x11c>
			;
	if ((flags & HEAD_CRC) != 0)
21f130f4:	e51b3010 	ldr	r3, [fp, #-16]
21f130f8:	e1a030a3 	mov	r3, r3, lsr #1
21f130fc:	e2033001 	and	r3, r3, #1	; 0x1
21f13100:	e20330ff 	and	r3, r3, #255	; 0xff
21f13104:	e3530000 	cmp	r3, #0	; 0x0
21f13108:	0a000002 	beq	21f13118 <gunzip+0x178>
		i += 2;
21f1310c:	e51b3014 	ldr	r3, [fp, #-20]
21f13110:	e2833002 	add	r3, r3, #2	; 0x2
21f13114:	e50b3014 	str	r3, [fp, #-20]
	if (i >= *lenp) {
21f13118:	e51b3014 	ldr	r3, [fp, #-20]
21f1311c:	e51b205c 	ldr	r2, [fp, #-92]
21f13120:	e5922000 	ldr	r2, [r2]
21f13124:	e1530002 	cmp	r3, r2
21f13128:	3a000004 	bcc	21f13140 <gunzip+0x1a0>
		puts ("Error: gunzip out of data in header\n");
21f1312c:	e59f0124 	ldr	r0, [pc, #292]	; 21f13258 <.text+0x13258>
21f13130:	eb002242 	bl	21f1ba40 <puts>
		return (-1);
21f13134:	e3e03000 	mvn	r3, #0	; 0x0
21f13138:	e50b3060 	str	r3, [fp, #-96]
21f1313c:	ea000040 	b	21f13244 <gunzip+0x2a4>
	}

	s.zalloc = zalloc;
21f13140:	e59f3114 	ldr	r3, [pc, #276]	; 21f1325c <.text+0x1325c>
21f13144:	e50b302c 	str	r3, [fp, #-44]
	s.zfree = zfree;
21f13148:	e59f3110 	ldr	r3, [pc, #272]	; 21f13260 <.text+0x13260>
21f1314c:	e50b3028 	str	r3, [fp, #-40]
#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
	s.outcb = (cb_func)WATCHDOG_RESET;
#else
	s.outcb = Z_NULL;
21f13150:	e3a03000 	mov	r3, #0	; 0x0
21f13154:	e50b301c 	str	r3, [fp, #-28]
#endif	/* CONFIG_HW_WATCHDOG */

	r = inflateInit2(&s, -MAX_WBITS);
21f13158:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f1315c:	e1a00003 	mov	r0, r3
21f13160:	e3e0100e 	mvn	r1, #14	; 0xe
21f13164:	eb0045ea 	bl	21f24914 <inflateInit2>
21f13168:	e1a03000 	mov	r3, r0
21f1316c:	e50b3018 	str	r3, [fp, #-24]
	if (r != Z_OK) {
21f13170:	e51b3018 	ldr	r3, [fp, #-24]
21f13174:	e3530000 	cmp	r3, #0	; 0x0
21f13178:	0a000005 	beq	21f13194 <gunzip+0x1f4>
		printf ("Error: inflateInit2() returned %d\n", r);
21f1317c:	e59f00e0 	ldr	r0, [pc, #224]	; 21f13264 <.text+0x13264>
21f13180:	e51b1018 	ldr	r1, [fp, #-24]
21f13184:	eb002240 	bl	21f1ba8c <printf>
		return (-1);
21f13188:	e3e03000 	mvn	r3, #0	; 0x0
21f1318c:	e50b3060 	str	r3, [fp, #-96]
21f13190:	ea00002b 	b	21f13244 <gunzip+0x2a4>
	}
	s.next_in = src + i;
21f13194:	e51b3014 	ldr	r3, [fp, #-20]
21f13198:	e1a02003 	mov	r2, r3
21f1319c:	e51b3058 	ldr	r3, [fp, #-88]
21f131a0:	e0823003 	add	r3, r2, r3
21f131a4:	e50b304c 	str	r3, [fp, #-76]
	s.avail_in = *lenp - i;
21f131a8:	e51b305c 	ldr	r3, [fp, #-92]
21f131ac:	e5932000 	ldr	r2, [r3]
21f131b0:	e51b3014 	ldr	r3, [fp, #-20]
21f131b4:	e0633002 	rsb	r3, r3, r2
21f131b8:	e50b3048 	str	r3, [fp, #-72]
	s.next_out = dst;
21f131bc:	e51b3050 	ldr	r3, [fp, #-80]
21f131c0:	e50b3040 	str	r3, [fp, #-64]
	s.avail_out = dstlen;
21f131c4:	e51b3054 	ldr	r3, [fp, #-84]
21f131c8:	e50b303c 	str	r3, [fp, #-60]
	r = inflate(&s, Z_FINISH);
21f131cc:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f131d0:	e1a00003 	mov	r0, r3
21f131d4:	e3a01004 	mov	r1, #4	; 0x4
21f131d8:	eb004642 	bl	21f24ae8 <inflate>
21f131dc:	e1a03000 	mov	r3, r0
21f131e0:	e50b3018 	str	r3, [fp, #-24]
	if (r != Z_OK && r != Z_STREAM_END) {
21f131e4:	e51b3018 	ldr	r3, [fp, #-24]
21f131e8:	e3530000 	cmp	r3, #0	; 0x0
21f131ec:	0a000008 	beq	21f13214 <gunzip+0x274>
21f131f0:	e51b3018 	ldr	r3, [fp, #-24]
21f131f4:	e3530001 	cmp	r3, #1	; 0x1
21f131f8:	0a000005 	beq	21f13214 <gunzip+0x274>
		printf ("Error: inflate() returned %d\n", r);
21f131fc:	e59f0064 	ldr	r0, [pc, #100]	; 21f13268 <.text+0x13268>
21f13200:	e51b1018 	ldr	r1, [fp, #-24]
21f13204:	eb002220 	bl	21f1ba8c <printf>
		return (-1);
21f13208:	e3e03000 	mvn	r3, #0	; 0x0
21f1320c:	e50b3060 	str	r3, [fp, #-96]
21f13210:	ea00000b 	b	21f13244 <gunzip+0x2a4>
	}
	*lenp = s.next_out - (unsigned char *) dst;
21f13214:	e51b3040 	ldr	r3, [fp, #-64]
21f13218:	e1a02003 	mov	r2, r3
21f1321c:	e51b3050 	ldr	r3, [fp, #-80]
21f13220:	e0633002 	rsb	r3, r3, r2
21f13224:	e1a02003 	mov	r2, r3
21f13228:	e51b305c 	ldr	r3, [fp, #-92]
21f1322c:	e5832000 	str	r2, [r3]
	inflateEnd(&s);
21f13230:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f13234:	e1a00003 	mov	r0, r3
21f13238:	eb004582 	bl	21f24848 <inflateEnd>

	return (0);
21f1323c:	e3a03000 	mov	r3, #0	; 0x0
21f13240:	e50b3060 	str	r3, [fp, #-96]
21f13244:	e51b3060 	ldr	r3, [fp, #-96]
}
21f13248:	e1a00003 	mov	r0, r3
21f1324c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f13250:	e89da800 	ldmia	sp, {fp, sp, pc}
21f13254:	21f306d8 	ldrcssb	r0, [r3, #104]!
21f13258:	21f306f4 	ldrcssh	r0, [r3, #100]!
21f1325c:	21f12f18 	mvncss	r2, r8, lsl pc
21f13260:	21f12f74 	mvncss	r2, r4, ror pc
21f13264:	21f3071c 	mvncss	r0, ip, lsl r7
21f13268:	21f30740 	mvncss	r0, r0, asr #14

21f1326c <do_bootm_rtems>:

#ifdef CONFIG_BZIP2
void bz_internal_error(int errcode)
{
	printf ("BZIP2 internal error %d\n", errcode);
}
#endif /* CONFIG_BZIP2 */

static void
do_bootm_rtems (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
		ulong addr, ulong *len_ptr, int verify)
{
21f1326c:	e1a0c00d 	mov	ip, sp
21f13270:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f13274:	e24cb004 	sub	fp, ip, #4	; 0x4
21f13278:	e24dd018 	sub	sp, sp, #24	; 0x18
21f1327c:	e50b0018 	str	r0, [fp, #-24]
21f13280:	e50b101c 	str	r1, [fp, #-28]
21f13284:	e50b2020 	str	r2, [fp, #-32]
21f13288:	e50b3024 	str	r3, [fp, #-36]
	image_header_t *hdr = &header;
21f1328c:	e59f3048 	ldr	r3, [pc, #72]	; 21f132dc <.text+0x132dc>
21f13290:	e50b3014 	str	r3, [fp, #-20]
	void	(*entry_point)(bd_t *);

	entry_point = (void (*)(bd_t *)) ntohl(hdr->ih_ep);
21f13294:	e51b3014 	ldr	r3, [fp, #-20]
21f13298:	e5933014 	ldr	r3, [r3, #20]
21f1329c:	e1a00003 	mov	r0, r3
21f132a0:	ebfffc96 	bl	21f12500 <__fswab32>
21f132a4:	e1a03000 	mov	r3, r0
21f132a8:	e50b3010 	str	r3, [fp, #-16]

	printf ("## Transferring control to RTEMS (at address %08lx) ...\n",
21f132ac:	e51b3010 	ldr	r3, [fp, #-16]
21f132b0:	e59f0028 	ldr	r0, [pc, #40]	; 21f132e0 <.text+0x132e0>
21f132b4:	e1a01003 	mov	r1, r3
21f132b8:	eb0021f3 	bl	21f1ba8c <printf>
		(ulong)entry_point);

	SHOW_BOOT_PROGRESS (15);

	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */

	(*entry_point ) ( gd->bd );
21f132bc:	e1a03008 	mov	r3, r8
21f132c0:	e5933000 	ldr	r3, [r3]
21f132c4:	e51b2010 	ldr	r2, [fp, #-16]
21f132c8:	e1a00003 	mov	r0, r3
21f132cc:	e1a0e00f 	mov	lr, pc
21f132d0:	e1a0f002 	mov	pc, r2
}
21f132d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f132d8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f132dc:	21f67664 	mvncss	r7, r4, ror #12
21f132e0:	21f30760 	mvncss	r0, r0, ror #14

21f132e4 <do_coninfo>:
#if (CONFIG_COMMANDS & CFG_CMD_CONSOLE)

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char *argv[])
{
21f132e4:	e1a0c00d 	mov	ip, sp
21f132e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f132ec:	e24cb004 	sub	fp, ip, #4	; 0x4
21f132f0:	e24dd038 	sub	sp, sp, #56	; 0x38
21f132f4:	e50b001c 	str	r0, [fp, #-28]
21f132f8:	e50b1020 	str	r1, [fp, #-32]
21f132fc:	e50b2024 	str	r2, [fp, #-36]
21f13300:	e50b3028 	str	r3, [fp, #-40]
	int i, l;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
21f13304:	e59f017c 	ldr	r0, [pc, #380]	; 21f13488 <.text+0x13488>
21f13308:	eb0021cc 	bl	21f1ba40 <puts>

	for (i = 1; i <= ListNumItems (devlist); i++) {
21f1330c:	e3a03001 	mov	r3, #1	; 0x1
21f13310:	e50b3018 	str	r3, [fp, #-24]
21f13314:	ea00004f 	b	21f13458 <do_coninfo+0x174>
		device_t *dev = ListGetPtrToItem (devlist, i);
21f13318:	e59f316c 	ldr	r3, [pc, #364]	; 21f1348c <.text+0x1348c>
21f1331c:	e5933000 	ldr	r3, [r3]
21f13320:	e1a00003 	mov	r0, r3
21f13324:	e51b1018 	ldr	r1, [fp, #-24]
21f13328:	eb003388 	bl	21f20150 <ListGetPtrToItem>
21f1332c:	e1a03000 	mov	r3, r0
21f13330:	e50b3010 	str	r3, [fp, #-16]

		printf ("%-8s %08x %c%c%c ",
21f13334:	e51b3010 	ldr	r3, [fp, #-16]
21f13338:	e2833008 	add	r3, r3, #8	; 0x8
21f1333c:	e50b303c 	str	r3, [fp, #-60]
21f13340:	e51b3010 	ldr	r3, [fp, #-16]
21f13344:	e5933000 	ldr	r3, [r3]
21f13348:	e50b3038 	str	r3, [fp, #-56]
21f1334c:	e51b3010 	ldr	r3, [fp, #-16]
21f13350:	e5933000 	ldr	r3, [r3]
21f13354:	e3530000 	cmp	r3, #0	; 0x0
21f13358:	aa000002 	bge	21f13368 <do_coninfo+0x84>
21f1335c:	e3a03053 	mov	r3, #83	; 0x53
21f13360:	e50b3034 	str	r3, [fp, #-52]
21f13364:	ea000001 	b	21f13370 <do_coninfo+0x8c>
21f13368:	e3a0302e 	mov	r3, #46	; 0x2e
21f1336c:	e50b3034 	str	r3, [fp, #-52]
21f13370:	e51b3010 	ldr	r3, [fp, #-16]
21f13374:	e5933000 	ldr	r3, [r3]
21f13378:	e2033001 	and	r3, r3, #1	; 0x1
21f1337c:	e20330ff 	and	r3, r3, #255	; 0xff
21f13380:	e3530000 	cmp	r3, #0	; 0x0
21f13384:	0a000002 	beq	21f13394 <do_coninfo+0xb0>
21f13388:	e3a03049 	mov	r3, #73	; 0x49
21f1338c:	e50b3030 	str	r3, [fp, #-48]
21f13390:	ea000001 	b	21f1339c <do_coninfo+0xb8>
21f13394:	e3a0302e 	mov	r3, #46	; 0x2e
21f13398:	e50b3030 	str	r3, [fp, #-48]
21f1339c:	e51b3010 	ldr	r3, [fp, #-16]
21f133a0:	e5933000 	ldr	r3, [r3]
21f133a4:	e1a030a3 	mov	r3, r3, lsr #1
21f133a8:	e2033001 	and	r3, r3, #1	; 0x1
21f133ac:	e20330ff 	and	r3, r3, #255	; 0xff
21f133b0:	e3530000 	cmp	r3, #0	; 0x0
21f133b4:	0a000002 	beq	21f133c4 <do_coninfo+0xe0>
21f133b8:	e3a0304f 	mov	r3, #79	; 0x4f
21f133bc:	e50b302c 	str	r3, [fp, #-44]
21f133c0:	ea000001 	b	21f133cc <do_coninfo+0xe8>
21f133c4:	e3a0302e 	mov	r3, #46	; 0x2e
21f133c8:	e50b302c 	str	r3, [fp, #-44]
21f133cc:	e51b3030 	ldr	r3, [fp, #-48]
21f133d0:	e58d3000 	str	r3, [sp]
21f133d4:	e51b302c 	ldr	r3, [fp, #-44]
21f133d8:	e58d3004 	str	r3, [sp, #4]
21f133dc:	e59f00ac 	ldr	r0, [pc, #172]	; 21f13490 <.text+0x13490>
21f133e0:	e51b103c 	ldr	r1, [fp, #-60]
21f133e4:	e51b2038 	ldr	r2, [fp, #-56]
21f133e8:	e51b3034 	ldr	r3, [fp, #-52]
21f133ec:	eb0021a6 	bl	21f1ba8c <printf>
			dev->name,
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
21f133f0:	e3a03000 	mov	r3, #0	; 0x0
21f133f4:	e50b3014 	str	r3, [fp, #-20]
21f133f8:	ea00000e 	b	21f13438 <do_coninfo+0x154>
			if (stdio_devices[l] == dev) {
21f133fc:	e51b2014 	ldr	r2, [fp, #-20]
21f13400:	e59f308c 	ldr	r3, [pc, #140]	; 21f13494 <.text+0x13494>
21f13404:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f13408:	e51b3010 	ldr	r3, [fp, #-16]
21f1340c:	e1520003 	cmp	r2, r3
21f13410:	1a000005 	bne	21f1342c <do_coninfo+0x148>
				printf ("%s ", stdio_names[l]);
21f13414:	e51b3014 	ldr	r3, [fp, #-20]
21f13418:	e59f2078 	ldr	r2, [pc, #120]	; 21f13498 <.text+0x13498>
21f1341c:	e7923103 	ldr	r3, [r2, r3, lsl #2]
21f13420:	e59f0074 	ldr	r0, [pc, #116]	; 21f1349c <.text+0x1349c>
21f13424:	e1a01003 	mov	r1, r3
21f13428:	eb002197 	bl	21f1ba8c <printf>
21f1342c:	e51b3014 	ldr	r3, [fp, #-20]
21f13430:	e2833001 	add	r3, r3, #1	; 0x1
21f13434:	e50b3014 	str	r3, [fp, #-20]
21f13438:	e51b3014 	ldr	r3, [fp, #-20]
21f1343c:	e3530002 	cmp	r3, #2	; 0x2
21f13440:	daffffed 	ble	21f133fc <do_coninfo+0x118>
			}
		}
		putc ('\n');
21f13444:	e3a0000a 	mov	r0, #10	; 0xa
21f13448:	eb002166 	bl	21f1b9e8 <putc>
21f1344c:	e51b3018 	ldr	r3, [fp, #-24]
21f13450:	e2833001 	add	r3, r3, #1	; 0x1
21f13454:	e50b3018 	str	r3, [fp, #-24]
21f13458:	e59f302c 	ldr	r3, [pc, #44]	; 21f1348c <.text+0x1348c>
21f1345c:	e5933000 	ldr	r3, [r3]
21f13460:	e1a00003 	mov	r0, r3
21f13464:	eb00336e 	bl	21f20224 <ListNumItems>
21f13468:	e1a02000 	mov	r2, r0
21f1346c:	e51b3018 	ldr	r3, [fp, #-24]
21f13470:	e1520003 	cmp	r2, r3
21f13474:	aaffffa7 	bge	21f13318 <do_coninfo+0x34>
	}
	return 0;
21f13478:	e3a03000 	mov	r3, #0	; 0x0
}
21f1347c:	e1a00003 	mov	r0, r3
21f13480:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f13484:	e89da800 	ldmia	sp, {fp, sp, pc}
21f13488:	21f3079c 	ldrcsb	r0, [r3, #124]!
21f1348c:	21f67760 	mvncss	r7, r0, ror #14
21f13490:	21f307b8 	ldrcsh	r0, [r3, #120]!
21f13494:	21f67764 	mvncss	r7, r4, ror #14
21f13498:	21f33584 	mvncss	r3, r4, lsl #11
21f1349c:	21f307cc 	mvncss	r0, ip, asr #15

21f134a0 <get_dev>:
#include <fat.h>


block_dev_desc_t *get_dev (char* ifname, int dev)
{
21f134a0:	e1a0c00d 	mov	ip, sp
21f134a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f134a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f134ac:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f134b0:	e50b0010 	str	r0, [fp, #-16]
21f134b4:	e50b1014 	str	r1, [fp, #-20]
#if (CONFIG_COMMANDS & CFG_CMD_IDE)
	if (strncmp(ifname,"ide",3)==0) {
		extern block_dev_desc_t * ide_get_dev(int dev);
		return(ide_get_dev(dev));
	}
#endif
#if (CONFIG_COMMANDS & CFG_CMD_SCSI)
	if (strncmp(ifname,"scsi",4)==0) {
		extern block_dev_desc_t * scsi_get_dev(int dev);
		return(scsi_get_dev(dev));
	}
#endif
#if ((CONFIG_COMMANDS & CFG_CMD_USB) && defined(CONFIG_USB_STORAGE))
	if (strncmp(ifname,"usb",3)==0) {
		extern block_dev_desc_t * usb_stor_get_dev(int dev);
		return(usb_stor_get_dev(dev));
	}
#endif
#if defined(CONFIG_MMC)
	if (strncmp(ifname,"mmc",3)==0) {
21f134b8:	e51b0010 	ldr	r0, [fp, #-16]
21f134bc:	e59f103c 	ldr	r1, [pc, #60]	; 21f13500 <.text+0x13500>
21f134c0:	e3a02003 	mov	r2, #3	; 0x3
21f134c4:	eb003d4a 	bl	21f229f4 <strncmp>
21f134c8:	e1a03000 	mov	r3, r0
21f134cc:	e3530000 	cmp	r3, #0	; 0x0
21f134d0:	1a000004 	bne	21f134e8 <get_dev+0x48>
		extern block_dev_desc_t *  mmc_get_dev(int dev);
		return(mmc_get_dev(dev));
21f134d4:	e51b0014 	ldr	r0, [fp, #-20]
21f134d8:	ebffc725 	bl	21f05174 <mmc_get_dev>
21f134dc:	e1a03000 	mov	r3, r0
21f134e0:	e50b3018 	str	r3, [fp, #-24]
21f134e4:	ea000001 	b	21f134f0 <get_dev+0x50>
	}
#endif
#if defined(CONFIG_SYSTEMACE)
	if (strcmp(ifname,"ace")==0) {
		extern block_dev_desc_t *  systemace_get_dev(int dev);
		return(systemace_get_dev(dev));
	}
#endif
	return NULL;
21f134e8:	e3a03000 	mov	r3, #0	; 0x0
21f134ec:	e50b3018 	str	r3, [fp, #-24]
21f134f0:	e51b3018 	ldr	r3, [fp, #-24]
}
21f134f4:	e1a00003 	mov	r0, r3
21f134f8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f134fc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f13500:	21f3080c 	mvncss	r0, ip, lsl #16

21f13504 <do_fat_fsload>:


int do_fat_fsload (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f13504:	e1a0c00d 	mov	ip, sp
21f13508:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1350c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f13510:	e24dd040 	sub	sp, sp, #64	; 0x40
21f13514:	e50b0038 	str	r0, [fp, #-56]
21f13518:	e50b103c 	str	r1, [fp, #-60]
21f1351c:	e50b2040 	str	r2, [fp, #-64]
21f13520:	e50b3044 	str	r3, [fp, #-68]
	long size;
	unsigned long offset;
	unsigned long count;
	char buf [12];
	block_dev_desc_t *dev_desc=NULL;
21f13524:	e3a03000 	mov	r3, #0	; 0x0
21f13528:	e50b3018 	str	r3, [fp, #-24]
	int dev=0;
21f1352c:	e3a03000 	mov	r3, #0	; 0x0
21f13530:	e50b3014 	str	r3, [fp, #-20]
	int part=1;
21f13534:	e3a03001 	mov	r3, #1	; 0x1
21f13538:	e50b3010 	str	r3, [fp, #-16]
	char *ep;

	if (argc < 5) {
21f1353c:	e51b3040 	ldr	r3, [fp, #-64]
21f13540:	e3530004 	cmp	r3, #4	; 0x4
21f13544:	ca000004 	bgt	21f1355c <do_fat_fsload+0x58>
		printf ("usage: fatload <interface> <dev[:part]> <addr> <filename> [bytes]\n");
21f13548:	e59f0228 	ldr	r0, [pc, #552]	; 21f13778 <.text+0x13778>
21f1354c:	eb00214e 	bl	21f1ba8c <printf>
		return 1;
21f13550:	e3a03001 	mov	r3, #1	; 0x1
21f13554:	e50b3048 	str	r3, [fp, #-72]
21f13558:	ea000082 	b	21f13768 <do_fat_fsload+0x264>
	}
	dev = (int)simple_strtoul (argv[2], &ep, 16);
21f1355c:	e51b3044 	ldr	r3, [fp, #-68]
21f13560:	e2833008 	add	r3, r3, #8	; 0x8
21f13564:	e5933000 	ldr	r3, [r3]
21f13568:	e24b2034 	sub	r2, fp, #52	; 0x34
21f1356c:	e1a00003 	mov	r0, r3
21f13570:	e1a01002 	mov	r1, r2
21f13574:	e3a02010 	mov	r2, #16	; 0x10
21f13578:	eb004012 	bl	21f235c8 <simple_strtoul>
21f1357c:	e1a03000 	mov	r3, r0
21f13580:	e50b3014 	str	r3, [fp, #-20]
	dev_desc=get_dev(argv[1],dev);
21f13584:	e51b3044 	ldr	r3, [fp, #-68]
21f13588:	e2833004 	add	r3, r3, #4	; 0x4
21f1358c:	e5933000 	ldr	r3, [r3]
21f13590:	e1a00003 	mov	r0, r3
21f13594:	e51b1014 	ldr	r1, [fp, #-20]
21f13598:	ebffffc0 	bl	21f134a0 <get_dev>
21f1359c:	e1a03000 	mov	r3, r0
21f135a0:	e50b3018 	str	r3, [fp, #-24]
	if (dev_desc==NULL) {
21f135a4:	e51b3018 	ldr	r3, [fp, #-24]
21f135a8:	e3530000 	cmp	r3, #0	; 0x0
21f135ac:	1a000004 	bne	21f135c4 <do_fat_fsload+0xc0>
		puts ("\n** Invalid boot device **\n");
21f135b0:	e59f01c4 	ldr	r0, [pc, #452]	; 21f1377c <.text+0x1377c>
21f135b4:	eb002121 	bl	21f1ba40 <puts>
		return 1;
21f135b8:	e3a03001 	mov	r3, #1	; 0x1
21f135bc:	e50b3048 	str	r3, [fp, #-72]
21f135c0:	ea000068 	b	21f13768 <do_fat_fsload+0x264>
	}
	if (*ep) {
21f135c4:	e51b3034 	ldr	r3, [fp, #-52]
21f135c8:	e5d33000 	ldrb	r3, [r3]
21f135cc:	e3530000 	cmp	r3, #0	; 0x0
21f135d0:	0a000012 	beq	21f13620 <do_fat_fsload+0x11c>
		if (*ep != ':') {
21f135d4:	e51b3034 	ldr	r3, [fp, #-52]
21f135d8:	e5d33000 	ldrb	r3, [r3]
21f135dc:	e353003a 	cmp	r3, #58	; 0x3a
21f135e0:	0a000004 	beq	21f135f8 <do_fat_fsload+0xf4>
			puts ("\n** Invalid boot device, use `dev[:part]' **\n");
21f135e4:	e59f0194 	ldr	r0, [pc, #404]	; 21f13780 <.text+0x13780>
21f135e8:	eb002114 	bl	21f1ba40 <puts>
			return 1;
21f135ec:	e3a03001 	mov	r3, #1	; 0x1
21f135f0:	e50b3048 	str	r3, [fp, #-72]
21f135f4:	ea00005b 	b	21f13768 <do_fat_fsload+0x264>
		}
		part = (int)simple_strtoul(++ep, NULL, 16);
21f135f8:	e51b3034 	ldr	r3, [fp, #-52]
21f135fc:	e2833001 	add	r3, r3, #1	; 0x1
21f13600:	e50b3034 	str	r3, [fp, #-52]
21f13604:	e51b3034 	ldr	r3, [fp, #-52]
21f13608:	e1a00003 	mov	r0, r3
21f1360c:	e3a01000 	mov	r1, #0	; 0x0
21f13610:	e3a02010 	mov	r2, #16	; 0x10
21f13614:	eb003feb 	bl	21f235c8 <simple_strtoul>
21f13618:	e1a03000 	mov	r3, r0
21f1361c:	e50b3010 	str	r3, [fp, #-16]
	}
	if (fat_register_device(dev_desc,part)!=0) {
21f13620:	e51b0018 	ldr	r0, [fp, #-24]
21f13624:	e51b1010 	ldr	r1, [fp, #-16]
21f13628:	ebffcb30 	bl	21f062f0 <fat_register_device>
21f1362c:	e1a03000 	mov	r3, r0
21f13630:	e3530000 	cmp	r3, #0	; 0x0
21f13634:	0a00000a 	beq	21f13664 <do_fat_fsload+0x160>
		printf ("\n** Unable to use %s %d:%d for fatload **\n",argv[1],dev,part);
21f13638:	e51b3044 	ldr	r3, [fp, #-68]
21f1363c:	e2833004 	add	r3, r3, #4	; 0x4
21f13640:	e5933000 	ldr	r3, [r3]
21f13644:	e59f0138 	ldr	r0, [pc, #312]	; 21f13784 <.text+0x13784>
21f13648:	e1a01003 	mov	r1, r3
21f1364c:	e51b2014 	ldr	r2, [fp, #-20]
21f13650:	e51b3010 	ldr	r3, [fp, #-16]
21f13654:	eb00210c 	bl	21f1ba8c <printf>
		return 1;
21f13658:	e3a03001 	mov	r3, #1	; 0x1
21f1365c:	e50b3048 	str	r3, [fp, #-72]
21f13660:	ea000040 	b	21f13768 <do_fat_fsload+0x264>
	}
	offset = simple_strtoul (argv[3], NULL, 16);
21f13664:	e51b3044 	ldr	r3, [fp, #-68]
21f13668:	e283300c 	add	r3, r3, #12	; 0xc
21f1366c:	e5933000 	ldr	r3, [r3]
21f13670:	e1a00003 	mov	r0, r3
21f13674:	e3a01000 	mov	r1, #0	; 0x0
21f13678:	e3a02010 	mov	r2, #16	; 0x10
21f1367c:	eb003fd1 	bl	21f235c8 <simple_strtoul>
21f13680:	e1a03000 	mov	r3, r0
21f13684:	e50b3020 	str	r3, [fp, #-32]
	if (argc == 6)
21f13688:	e51b3040 	ldr	r3, [fp, #-64]
21f1368c:	e3530006 	cmp	r3, #6	; 0x6
21f13690:	1a000009 	bne	21f136bc <do_fat_fsload+0x1b8>
		count = simple_strtoul (argv[5], NULL, 16);
21f13694:	e51b3044 	ldr	r3, [fp, #-68]
21f13698:	e2833014 	add	r3, r3, #20	; 0x14
21f1369c:	e5933000 	ldr	r3, [r3]
21f136a0:	e1a00003 	mov	r0, r3
21f136a4:	e3a01000 	mov	r1, #0	; 0x0
21f136a8:	e3a02010 	mov	r2, #16	; 0x10
21f136ac:	eb003fc5 	bl	21f235c8 <simple_strtoul>
21f136b0:	e1a03000 	mov	r3, r0
21f136b4:	e50b301c 	str	r3, [fp, #-28]
21f136b8:	ea000001 	b	21f136c4 <do_fat_fsload+0x1c0>
	else
		count = 0;
21f136bc:	e3a03000 	mov	r3, #0	; 0x0
21f136c0:	e50b301c 	str	r3, [fp, #-28]
	size = file_fat_read (argv[4], (unsigned char *) offset, count);
21f136c4:	e51b3044 	ldr	r3, [fp, #-68]
21f136c8:	e2833010 	add	r3, r3, #16	; 0x10
21f136cc:	e5933000 	ldr	r3, [r3]
21f136d0:	e51b2020 	ldr	r2, [fp, #-32]
21f136d4:	e1a00003 	mov	r0, r3
21f136d8:	e1a01002 	mov	r1, r2
21f136dc:	e51b201c 	ldr	r2, [fp, #-28]
21f136e0:	ebffd4b4 	bl	21f089b8 <file_fat_read>
21f136e4:	e1a03000 	mov	r3, r0
21f136e8:	e50b3024 	str	r3, [fp, #-36]

	if(size==-1) {
21f136ec:	e51b3024 	ldr	r3, [fp, #-36]
21f136f0:	e3730001 	cmn	r3, #1	; 0x1
21f136f4:	1a00000d 	bne	21f13730 <do_fat_fsload+0x22c>
		printf("\n** Unable to read \"%s\" from %s %d:%d **\n",argv[4],argv[1],dev,part);
21f136f8:	e51b3044 	ldr	r3, [fp, #-68]
21f136fc:	e2833010 	add	r3, r3, #16	; 0x10
21f13700:	e5931000 	ldr	r1, [r3]
21f13704:	e51b3044 	ldr	r3, [fp, #-68]
21f13708:	e2833004 	add	r3, r3, #4	; 0x4
21f1370c:	e5932000 	ldr	r2, [r3]
21f13710:	e51b3010 	ldr	r3, [fp, #-16]
21f13714:	e58d3000 	str	r3, [sp]
21f13718:	e59f0068 	ldr	r0, [pc, #104]	; 21f13788 <.text+0x13788>
21f1371c:	e51b3014 	ldr	r3, [fp, #-20]
21f13720:	eb0020d9 	bl	21f1ba8c <printf>
		return 1;
21f13724:	e3a03001 	mov	r3, #1	; 0x1
21f13728:	e50b3048 	str	r3, [fp, #-72]
21f1372c:	ea00000d 	b	21f13768 <do_fat_fsload+0x264>
	}

	printf ("\n%ld bytes read\n", size);
21f13730:	e59f0054 	ldr	r0, [pc, #84]	; 21f1378c <.text+0x1378c>
21f13734:	e51b1024 	ldr	r1, [fp, #-36]
21f13738:	eb0020d3 	bl	21f1ba8c <printf>

	sprintf(buf, "%lX", size);
21f1373c:	e24b3030 	sub	r3, fp, #48	; 0x30
21f13740:	e1a00003 	mov	r0, r3
21f13744:	e59f1044 	ldr	r1, [pc, #68]	; 21f13790 <.text+0x13790>
21f13748:	e51b2024 	ldr	r2, [fp, #-36]
21f1374c:	eb0043dd 	bl	21f246c8 <sprintf>
	setenv("filesize", buf);
21f13750:	e24b3030 	sub	r3, fp, #48	; 0x30
21f13754:	e59f0038 	ldr	r0, [pc, #56]	; 21f13794 <.text+0x13794>
21f13758:	e1a01003 	mov	r1, r3
21f1375c:	eb001cf9 	bl	21f1ab48 <setenv>

	return 0;
21f13760:	e3a03000 	mov	r3, #0	; 0x0
21f13764:	e50b3048 	str	r3, [fp, #-72]
21f13768:	e51b3048 	ldr	r3, [fp, #-72]
}
21f1376c:	e1a00003 	mov	r0, r3
21f13770:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f13774:	e89da800 	ldmia	sp, {fp, sp, pc}
21f13778:	21f30810 	mvncss	r0, r0, lsl r8
21f1377c:	21f30854 	mvncss	r0, r4, asr r8
21f13780:	21f30870 	mvncss	r0, r0, ror r8
21f13784:	21f308a0 	mvncss	r0, r0, lsr #17
21f13788:	21f308cc 	mvncss	r0, ip, asr #17
21f1378c:	21f308f8 	ldrcssh	r0, [r3, #136]!
21f13790:	21f3090c 	mvncss	r0, ip, lsl #18
21f13794:	21f30910 	mvncss	r0, r0, lsl r9

21f13798 <do_fat_ls>:


U_BOOT_CMD(
	fatload,	6,	0,	do_fat_fsload,
	"fatload - load binary file from a dos filesystem\n",
	"<interface> <dev[:part]>  <addr> <filename> [bytes]\n"
	"    - load binary file 'filename' from 'dev' on 'interface'\n"
	"      to address 'addr' from dos filesystem\n"
);

int do_fat_ls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f13798:	e1a0c00d 	mov	ip, sp
21f1379c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f137a0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f137a4:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f137a8:	e50b0028 	str	r0, [fp, #-40]
21f137ac:	e50b102c 	str	r1, [fp, #-44]
21f137b0:	e50b2030 	str	r2, [fp, #-48]
21f137b4:	e50b3034 	str	r3, [fp, #-52]
	char *filename = "/";
21f137b8:	e59f31a8 	ldr	r3, [pc, #424]	; 21f13968 <.text+0x13968>
21f137bc:	e50b3020 	str	r3, [fp, #-32]
	int ret;
	int dev=0;
21f137c0:	e3a03000 	mov	r3, #0	; 0x0
21f137c4:	e50b3018 	str	r3, [fp, #-24]
	int part=1;
21f137c8:	e3a03001 	mov	r3, #1	; 0x1
21f137cc:	e50b3014 	str	r3, [fp, #-20]
	char *ep;
	block_dev_desc_t *dev_desc=NULL;
21f137d0:	e3a03000 	mov	r3, #0	; 0x0
21f137d4:	e50b3010 	str	r3, [fp, #-16]

	if (argc < 3) {
21f137d8:	e51b3030 	ldr	r3, [fp, #-48]
21f137dc:	e3530002 	cmp	r3, #2	; 0x2
21f137e0:	ca000004 	bgt	21f137f8 <do_fat_ls+0x60>
		printf ("usage: fatls <interface> <dev[:part]> [directory]\n");
21f137e4:	e59f0180 	ldr	r0, [pc, #384]	; 21f1396c <.text+0x1396c>
21f137e8:	eb0020a7 	bl	21f1ba8c <printf>
		return (0);
21f137ec:	e3a03000 	mov	r3, #0	; 0x0
21f137f0:	e50b3038 	str	r3, [fp, #-56]
21f137f4:	ea000057 	b	21f13958 <do_fat_ls+0x1c0>
	}
	dev = (int)simple_strtoul (argv[2], &ep, 16);
21f137f8:	e51b3034 	ldr	r3, [fp, #-52]
21f137fc:	e2833008 	add	r3, r3, #8	; 0x8
21f13800:	e5933000 	ldr	r3, [r3]
21f13804:	e24b2024 	sub	r2, fp, #36	; 0x24
21f13808:	e1a00003 	mov	r0, r3
21f1380c:	e1a01002 	mov	r1, r2
21f13810:	e3a02010 	mov	r2, #16	; 0x10
21f13814:	eb003f6b 	bl	21f235c8 <simple_strtoul>
21f13818:	e1a03000 	mov	r3, r0
21f1381c:	e50b3018 	str	r3, [fp, #-24]
	dev_desc=get_dev(argv[1],dev);
21f13820:	e51b3034 	ldr	r3, [fp, #-52]
21f13824:	e2833004 	add	r3, r3, #4	; 0x4
21f13828:	e5933000 	ldr	r3, [r3]
21f1382c:	e1a00003 	mov	r0, r3
21f13830:	e51b1018 	ldr	r1, [fp, #-24]
21f13834:	ebffff19 	bl	21f134a0 <get_dev>
21f13838:	e1a03000 	mov	r3, r0
21f1383c:	e50b3010 	str	r3, [fp, #-16]
	if (dev_desc==NULL) {
21f13840:	e51b3010 	ldr	r3, [fp, #-16]
21f13844:	e3530000 	cmp	r3, #0	; 0x0
21f13848:	1a000004 	bne	21f13860 <do_fat_ls+0xc8>
		puts ("\n** Invalid boot device **\n");
21f1384c:	e59f011c 	ldr	r0, [pc, #284]	; 21f13970 <.text+0x13970>
21f13850:	eb00207a 	bl	21f1ba40 <puts>
		return 1;
21f13854:	e3a03001 	mov	r3, #1	; 0x1
21f13858:	e50b3038 	str	r3, [fp, #-56]
21f1385c:	ea00003d 	b	21f13958 <do_fat_ls+0x1c0>
	}
	if (*ep) {
21f13860:	e51b3024 	ldr	r3, [fp, #-36]
21f13864:	e5d33000 	ldrb	r3, [r3]
21f13868:	e3530000 	cmp	r3, #0	; 0x0
21f1386c:	0a000012 	beq	21f138bc <do_fat_ls+0x124>
		if (*ep != ':') {
21f13870:	e51b3024 	ldr	r3, [fp, #-36]
21f13874:	e5d33000 	ldrb	r3, [r3]
21f13878:	e353003a 	cmp	r3, #58	; 0x3a
21f1387c:	0a000004 	beq	21f13894 <do_fat_ls+0xfc>
			puts ("\n** Invalid boot device, use `dev[:part]' **\n");
21f13880:	e59f00ec 	ldr	r0, [pc, #236]	; 21f13974 <.text+0x13974>
21f13884:	eb00206d 	bl	21f1ba40 <puts>
			return 1;
21f13888:	e3a03001 	mov	r3, #1	; 0x1
21f1388c:	e50b3038 	str	r3, [fp, #-56]
21f13890:	ea000030 	b	21f13958 <do_fat_ls+0x1c0>
		}
		part = (int)simple_strtoul(++ep, NULL, 16);
21f13894:	e51b3024 	ldr	r3, [fp, #-36]
21f13898:	e2833001 	add	r3, r3, #1	; 0x1
21f1389c:	e50b3024 	str	r3, [fp, #-36]
21f138a0:	e51b3024 	ldr	r3, [fp, #-36]
21f138a4:	e1a00003 	mov	r0, r3
21f138a8:	e3a01000 	mov	r1, #0	; 0x0
21f138ac:	e3a02010 	mov	r2, #16	; 0x10
21f138b0:	eb003f44 	bl	21f235c8 <simple_strtoul>
21f138b4:	e1a03000 	mov	r3, r0
21f138b8:	e50b3014 	str	r3, [fp, #-20]
	}
	if (fat_register_device(dev_desc,part)!=0) {
21f138bc:	e51b0010 	ldr	r0, [fp, #-16]
21f138c0:	e51b1014 	ldr	r1, [fp, #-20]
21f138c4:	ebffca89 	bl	21f062f0 <fat_register_device>
21f138c8:	e1a03000 	mov	r3, r0
21f138cc:	e3530000 	cmp	r3, #0	; 0x0
21f138d0:	0a00000a 	beq	21f13900 <do_fat_ls+0x168>
		printf ("\n** Unable to use %s %d:%d for fatls **\n",argv[1],dev,part);
21f138d4:	e51b3034 	ldr	r3, [fp, #-52]
21f138d8:	e2833004 	add	r3, r3, #4	; 0x4
21f138dc:	e5933000 	ldr	r3, [r3]
21f138e0:	e59f0090 	ldr	r0, [pc, #144]	; 21f13978 <.text+0x13978>
21f138e4:	e1a01003 	mov	r1, r3
21f138e8:	e51b2018 	ldr	r2, [fp, #-24]
21f138ec:	e51b3014 	ldr	r3, [fp, #-20]
21f138f0:	eb002065 	bl	21f1ba8c <printf>
		return 1;
21f138f4:	e3a03001 	mov	r3, #1	; 0x1
21f138f8:	e50b3038 	str	r3, [fp, #-56]
21f138fc:	ea000015 	b	21f13958 <do_fat_ls+0x1c0>
	}
	if (argc == 4)
21f13900:	e51b3030 	ldr	r3, [fp, #-48]
21f13904:	e3530004 	cmp	r3, #4	; 0x4
21f13908:	1a000007 	bne	21f1392c <do_fat_ls+0x194>
		ret = file_fat_ls (argv[3]);
21f1390c:	e51b3034 	ldr	r3, [fp, #-52]
21f13910:	e283300c 	add	r3, r3, #12	; 0xc
21f13914:	e5933000 	ldr	r3, [r3]
21f13918:	e1a00003 	mov	r0, r3
21f1391c:	ebffd418 	bl	21f08984 <file_fat_ls>
21f13920:	e1a03000 	mov	r3, r0
21f13924:	e50b301c 	str	r3, [fp, #-28]
21f13928:	ea000003 	b	21f1393c <do_fat_ls+0x1a4>
	else
		ret = file_fat_ls (filename);
21f1392c:	e51b0020 	ldr	r0, [fp, #-32]
21f13930:	ebffd413 	bl	21f08984 <file_fat_ls>
21f13934:	e1a03000 	mov	r3, r0
21f13938:	e50b301c 	str	r3, [fp, #-28]

	if(ret!=0)
21f1393c:	e51b301c 	ldr	r3, [fp, #-28]
21f13940:	e3530000 	cmp	r3, #0	; 0x0
21f13944:	0a000001 	beq	21f13950 <do_fat_ls+0x1b8>
		printf("No Fat FS detected\n");
21f13948:	e59f002c 	ldr	r0, [pc, #44]	; 21f1397c <.text+0x1397c>
21f1394c:	eb00204e 	bl	21f1ba8c <printf>
	return (ret);
21f13950:	e51b301c 	ldr	r3, [fp, #-28]
21f13954:	e50b3038 	str	r3, [fp, #-56]
21f13958:	e51b3038 	ldr	r3, [fp, #-56]
}
21f1395c:	e1a00003 	mov	r0, r3
21f13960:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f13964:	e89da800 	ldmia	sp, {fp, sp, pc}
21f13968:	21f30958 	mvncss	r0, r8, asr r9
21f1396c:	21f3095c 	mvncss	r0, ip, asr r9
21f13970:	21f30854 	mvncss	r0, r4, asr r8
21f13974:	21f30870 	mvncss	r0, r0, ror r8
21f13978:	21f30990 	ldrcsb	r0, [r3, #144]!
21f1397c:	21f309bc 	ldrcsh	r0, [r3, #156]!

21f13980 <do_fat_fsinfo>:

U_BOOT_CMD(
	fatls,	4,	1,	do_fat_ls,
	"fatls   - list files in a directory (default /)\n",
	"<interface> <dev[:part]> [directory]\n"
	"    - list files from 'dev' on 'interface' in a 'directory'\n"
);

int do_fat_fsinfo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f13980:	e1a0c00d 	mov	ip, sp
21f13984:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f13988:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1398c:	e24dd024 	sub	sp, sp, #36	; 0x24
21f13990:	e50b0020 	str	r0, [fp, #-32]
21f13994:	e50b1024 	str	r1, [fp, #-36]
21f13998:	e50b2028 	str	r2, [fp, #-40]
21f1399c:	e50b302c 	str	r3, [fp, #-44]
	int dev=0;
21f139a0:	e3a03000 	mov	r3, #0	; 0x0
21f139a4:	e50b3018 	str	r3, [fp, #-24]
	int part=1;
21f139a8:	e3a03001 	mov	r3, #1	; 0x1
21f139ac:	e50b3014 	str	r3, [fp, #-20]
	char *ep;
	block_dev_desc_t *dev_desc=NULL;
21f139b0:	e3a03000 	mov	r3, #0	; 0x0
21f139b4:	e50b3010 	str	r3, [fp, #-16]

	if (argc < 2) {
21f139b8:	e51b3028 	ldr	r3, [fp, #-40]
21f139bc:	e3530001 	cmp	r3, #1	; 0x1
21f139c0:	ca000004 	bgt	21f139d8 <do_fat_fsinfo+0x58>
		printf ("usage: fatinfo <interface> <dev[:part]>\n");
21f139c4:	e59f0130 	ldr	r0, [pc, #304]	; 21f13afc <.text+0x13afc>
21f139c8:	eb00202f 	bl	21f1ba8c <printf>
		return (0);
21f139cc:	e3a03000 	mov	r3, #0	; 0x0
21f139d0:	e50b3030 	str	r3, [fp, #-48]
21f139d4:	ea000044 	b	21f13aec <do_fat_fsinfo+0x16c>
	}
	dev = (int)simple_strtoul (argv[2], &ep, 16);
21f139d8:	e51b302c 	ldr	r3, [fp, #-44]
21f139dc:	e2833008 	add	r3, r3, #8	; 0x8
21f139e0:	e5933000 	ldr	r3, [r3]
21f139e4:	e24b201c 	sub	r2, fp, #28	; 0x1c
21f139e8:	e1a00003 	mov	r0, r3
21f139ec:	e1a01002 	mov	r1, r2
21f139f0:	e3a02010 	mov	r2, #16	; 0x10
21f139f4:	eb003ef3 	bl	21f235c8 <simple_strtoul>
21f139f8:	e1a03000 	mov	r3, r0
21f139fc:	e50b3018 	str	r3, [fp, #-24]
	dev_desc=get_dev(argv[1],dev);
21f13a00:	e51b302c 	ldr	r3, [fp, #-44]
21f13a04:	e2833004 	add	r3, r3, #4	; 0x4
21f13a08:	e5933000 	ldr	r3, [r3]
21f13a0c:	e1a00003 	mov	r0, r3
21f13a10:	e51b1018 	ldr	r1, [fp, #-24]
21f13a14:	ebfffea1 	bl	21f134a0 <get_dev>
21f13a18:	e1a03000 	mov	r3, r0
21f13a1c:	e50b3010 	str	r3, [fp, #-16]
	if (dev_desc==NULL) {
21f13a20:	e51b3010 	ldr	r3, [fp, #-16]
21f13a24:	e3530000 	cmp	r3, #0	; 0x0
21f13a28:	1a000004 	bne	21f13a40 <do_fat_fsinfo+0xc0>
		puts ("\n** Invalid boot device **\n");
21f13a2c:	e59f00cc 	ldr	r0, [pc, #204]	; 21f13b00 <.text+0x13b00>
21f13a30:	eb002002 	bl	21f1ba40 <puts>
		return 1;
21f13a34:	e3a03001 	mov	r3, #1	; 0x1
21f13a38:	e50b3030 	str	r3, [fp, #-48]
21f13a3c:	ea00002a 	b	21f13aec <do_fat_fsinfo+0x16c>
	}
	if (*ep) {
21f13a40:	e51b301c 	ldr	r3, [fp, #-28]
21f13a44:	e5d33000 	ldrb	r3, [r3]
21f13a48:	e3530000 	cmp	r3, #0	; 0x0
21f13a4c:	0a000012 	beq	21f13a9c <do_fat_fsinfo+0x11c>
		if (*ep != ':') {
21f13a50:	e51b301c 	ldr	r3, [fp, #-28]
21f13a54:	e5d33000 	ldrb	r3, [r3]
21f13a58:	e353003a 	cmp	r3, #58	; 0x3a
21f13a5c:	0a000004 	beq	21f13a74 <do_fat_fsinfo+0xf4>
			puts ("\n** Invalid boot device, use `dev[:part]' **\n");
21f13a60:	e59f009c 	ldr	r0, [pc, #156]	; 21f13b04 <.text+0x13b04>
21f13a64:	eb001ff5 	bl	21f1ba40 <puts>
			return 1;
21f13a68:	e3a03001 	mov	r3, #1	; 0x1
21f13a6c:	e50b3030 	str	r3, [fp, #-48]
21f13a70:	ea00001d 	b	21f13aec <do_fat_fsinfo+0x16c>
		}
		part = (int)simple_strtoul(++ep, NULL, 16);
21f13a74:	e51b301c 	ldr	r3, [fp, #-28]
21f13a78:	e2833001 	add	r3, r3, #1	; 0x1
21f13a7c:	e50b301c 	str	r3, [fp, #-28]
21f13a80:	e51b301c 	ldr	r3, [fp, #-28]
21f13a84:	e1a00003 	mov	r0, r3
21f13a88:	e3a01000 	mov	r1, #0	; 0x0
21f13a8c:	e3a02010 	mov	r2, #16	; 0x10
21f13a90:	eb003ecc 	bl	21f235c8 <simple_strtoul>
21f13a94:	e1a03000 	mov	r3, r0
21f13a98:	e50b3014 	str	r3, [fp, #-20]
	}
	if (fat_register_device(dev_desc,part)!=0) {
21f13a9c:	e51b0010 	ldr	r0, [fp, #-16]
21f13aa0:	e51b1014 	ldr	r1, [fp, #-20]
21f13aa4:	ebffca11 	bl	21f062f0 <fat_register_device>
21f13aa8:	e1a03000 	mov	r3, r0
21f13aac:	e3530000 	cmp	r3, #0	; 0x0
21f13ab0:	0a00000a 	beq	21f13ae0 <do_fat_fsinfo+0x160>
		printf ("\n** Unable to use %s %d:%d for fatinfo **\n",argv[1],dev,part);
21f13ab4:	e51b302c 	ldr	r3, [fp, #-44]
21f13ab8:	e2833004 	add	r3, r3, #4	; 0x4
21f13abc:	e5933000 	ldr	r3, [r3]
21f13ac0:	e59f0040 	ldr	r0, [pc, #64]	; 21f13b08 <.text+0x13b08>
21f13ac4:	e1a01003 	mov	r1, r3
21f13ac8:	e51b2018 	ldr	r2, [fp, #-24]
21f13acc:	e51b3014 	ldr	r3, [fp, #-20]
21f13ad0:	eb001fed 	bl	21f1ba8c <printf>
		return 1;
21f13ad4:	e3a03001 	mov	r3, #1	; 0x1
21f13ad8:	e50b3030 	str	r3, [fp, #-48]
21f13adc:	ea000002 	b	21f13aec <do_fat_fsinfo+0x16c>
	}
	return (file_fat_detectfs ());
21f13ae0:	ebffd335 	bl	21f087bc <file_fat_detectfs>
21f13ae4:	e1a03000 	mov	r3, r0
21f13ae8:	e50b3030 	str	r3, [fp, #-48]
21f13aec:	e51b3030 	ldr	r3, [fp, #-48]
}
21f13af0:	e1a00003 	mov	r0, r3
21f13af4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f13af8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f13afc:	21f30a0c 	mvncss	r0, ip, lsl #20
21f13b00:	21f30854 	mvncss	r0, r4, asr r8
21f13b04:	21f30870 	mvncss	r0, r0, ror r8
21f13b08:	21f30a38 	mvncss	r0, r8, lsr sl

21f13b0c <abbrev_spec>:
 *			  or an invalid flash bank.
 */
static int
abbrev_spec (char *str, flash_info_t ** pinfo, int *psf, int *psl)
{
21f13b0c:	e1a0c00d 	mov	ip, sp
21f13b10:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f13b14:	e24cb004 	sub	fp, ip, #4	; 0x4
21f13b18:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f13b1c:	e50b0028 	str	r0, [fp, #-40]
21f13b20:	e50b102c 	str	r1, [fp, #-44]
21f13b24:	e50b2030 	str	r2, [fp, #-48]
21f13b28:	e50b3034 	str	r3, [fp, #-52]
	flash_info_t *fp;
	int bank, first, last;
	char *p, *ep;

	if ((p = strchr (str, ':')) == NULL)
21f13b2c:	e51b0028 	ldr	r0, [fp, #-40]
21f13b30:	e3a0103a 	mov	r1, #58	; 0x3a
21f13b34:	eb003be2 	bl	21f22ac4 <strchr>
21f13b38:	e1a03000 	mov	r3, r0
21f13b3c:	e50b3010 	str	r3, [fp, #-16]
21f13b40:	e51b3010 	ldr	r3, [fp, #-16]
21f13b44:	e3530000 	cmp	r3, #0	; 0x0
21f13b48:	1a000002 	bne	21f13b58 <abbrev_spec+0x4c>
		return 0;
21f13b4c:	e3a03000 	mov	r3, #0	; 0x0
21f13b50:	e50b3038 	str	r3, [fp, #-56]
21f13b54:	ea000086 	b	21f13d74 <abbrev_spec+0x268>
	*p++ = '\0';
21f13b58:	e51b2010 	ldr	r2, [fp, #-16]
21f13b5c:	e3a03000 	mov	r3, #0	; 0x0
21f13b60:	e5c23000 	strb	r3, [r2]
21f13b64:	e51b3010 	ldr	r3, [fp, #-16]
21f13b68:	e2833001 	add	r3, r3, #1	; 0x1
21f13b6c:	e50b3010 	str	r3, [fp, #-16]

	bank = simple_strtoul (str, &ep, 10);
21f13b70:	e24b3024 	sub	r3, fp, #36	; 0x24
21f13b74:	e51b0028 	ldr	r0, [fp, #-40]
21f13b78:	e1a01003 	mov	r1, r3
21f13b7c:	e3a0200a 	mov	r2, #10	; 0xa
21f13b80:	eb003e90 	bl	21f235c8 <simple_strtoul>
21f13b84:	e1a03000 	mov	r3, r0
21f13b88:	e50b301c 	str	r3, [fp, #-28]
	if (ep == str || *ep != '\0' ||
21f13b8c:	e51b2024 	ldr	r2, [fp, #-36]
21f13b90:	e51b3028 	ldr	r3, [fp, #-40]
21f13b94:	e1520003 	cmp	r2, r3
21f13b98:	0a00001e 	beq	21f13c18 <abbrev_spec+0x10c>
21f13b9c:	e51b3024 	ldr	r3, [fp, #-36]
21f13ba0:	e5d33000 	ldrb	r3, [r3]
21f13ba4:	e3530000 	cmp	r3, #0	; 0x0
21f13ba8:	1a00001a 	bne	21f13c18 <abbrev_spec+0x10c>
21f13bac:	e51b301c 	ldr	r3, [fp, #-28]
21f13bb0:	e3530000 	cmp	r3, #0	; 0x0
21f13bb4:	da000017 	ble	21f13c18 <abbrev_spec+0x10c>
21f13bb8:	e51b301c 	ldr	r3, [fp, #-28]
21f13bbc:	e3530001 	cmp	r3, #1	; 0x1
21f13bc0:	ca000014 	bgt	21f13c18 <abbrev_spec+0x10c>
21f13bc4:	e51b201c 	ldr	r2, [fp, #-28]
21f13bc8:	e1a03002 	mov	r3, r2
21f13bcc:	e1a03183 	mov	r3, r3, lsl #3
21f13bd0:	e0833002 	add	r3, r3, r2
21f13bd4:	e1a03083 	mov	r3, r3, lsl #1
21f13bd8:	e0833002 	add	r3, r3, r2
21f13bdc:	e1a02203 	mov	r2, r3, lsl #4
21f13be0:	e0833002 	add	r3, r3, r2
21f13be4:	e1a03103 	mov	r3, r3, lsl #2
21f13be8:	e1a02003 	mov	r2, r3
21f13bec:	e59f3190 	ldr	r3, [pc, #400]	; 21f13d84 <.text+0x13d84>
21f13bf0:	e2433c05 	sub	r3, r3, #1280	; 0x500
21f13bf4:	e243300c 	sub	r3, r3, #12	; 0xc
21f13bf8:	e0823003 	add	r3, r2, r3
21f13bfc:	e50b3020 	str	r3, [fp, #-32]
21f13c00:	e51b3020 	ldr	r3, [fp, #-32]
21f13c04:	e5932008 	ldr	r2, [r3, #8]
21f13c08:	e3a03cff 	mov	r3, #65280	; 0xff00
21f13c0c:	e28330ff 	add	r3, r3, #255	; 0xff
21f13c10:	e1520003 	cmp	r2, r3
21f13c14:	1a000002 	bne	21f13c24 <abbrev_spec+0x118>
		bank < 1 || bank > CFG_MAX_FLASH_BANKS ||
		(fp = &flash_info[bank - 1])->flash_id == FLASH_UNKNOWN)
		return -1;
21f13c18:	e3e03000 	mvn	r3, #0	; 0x0
21f13c1c:	e50b3038 	str	r3, [fp, #-56]
21f13c20:	ea000053 	b	21f13d74 <abbrev_spec+0x268>

	str = p;
21f13c24:	e51b3010 	ldr	r3, [fp, #-16]
21f13c28:	e50b3028 	str	r3, [fp, #-40]
	if ((p = strchr (str, '-')) != NULL)
21f13c2c:	e51b0028 	ldr	r0, [fp, #-40]
21f13c30:	e3a0102d 	mov	r1, #45	; 0x2d
21f13c34:	eb003ba2 	bl	21f22ac4 <strchr>
21f13c38:	e1a03000 	mov	r3, r0
21f13c3c:	e50b3010 	str	r3, [fp, #-16]
21f13c40:	e51b3010 	ldr	r3, [fp, #-16]
21f13c44:	e3530000 	cmp	r3, #0	; 0x0
21f13c48:	0a000005 	beq	21f13c64 <abbrev_spec+0x158>
		*p++ = '\0';
21f13c4c:	e51b2010 	ldr	r2, [fp, #-16]
21f13c50:	e3a03000 	mov	r3, #0	; 0x0
21f13c54:	e5c23000 	strb	r3, [r2]
21f13c58:	e51b3010 	ldr	r3, [fp, #-16]
21f13c5c:	e2833001 	add	r3, r3, #1	; 0x1
21f13c60:	e50b3010 	str	r3, [fp, #-16]

	first = simple_strtoul (str, &ep, 10);
21f13c64:	e24b3024 	sub	r3, fp, #36	; 0x24
21f13c68:	e51b0028 	ldr	r0, [fp, #-40]
21f13c6c:	e1a01003 	mov	r1, r3
21f13c70:	e3a0200a 	mov	r2, #10	; 0xa
21f13c74:	eb003e53 	bl	21f235c8 <simple_strtoul>
21f13c78:	e1a03000 	mov	r3, r0
21f13c7c:	e50b3018 	str	r3, [fp, #-24]
	if (ep == str || *ep != '\0' || first >= fp->sector_count)
21f13c80:	e51b2024 	ldr	r2, [fp, #-36]
21f13c84:	e51b3028 	ldr	r3, [fp, #-40]
21f13c88:	e1520003 	cmp	r2, r3
21f13c8c:	0a000009 	beq	21f13cb8 <abbrev_spec+0x1ac>
21f13c90:	e51b3024 	ldr	r3, [fp, #-36]
21f13c94:	e5d33000 	ldrb	r3, [r3]
21f13c98:	e3530000 	cmp	r3, #0	; 0x0
21f13c9c:	1a000005 	bne	21f13cb8 <abbrev_spec+0x1ac>
21f13ca0:	e51b3020 	ldr	r3, [fp, #-32]
21f13ca4:	e1d330b4 	ldrh	r3, [r3, #4]
21f13ca8:	e1a02003 	mov	r2, r3
21f13cac:	e51b3018 	ldr	r3, [fp, #-24]
21f13cb0:	e1520003 	cmp	r2, r3
21f13cb4:	ca000002 	bgt	21f13cc4 <abbrev_spec+0x1b8>
		return -1;
21f13cb8:	e3e03000 	mvn	r3, #0	; 0x0
21f13cbc:	e50b3038 	str	r3, [fp, #-56]
21f13cc0:	ea00002b 	b	21f13d74 <abbrev_spec+0x268>

	if (p != NULL) {
21f13cc4:	e51b3010 	ldr	r3, [fp, #-16]
21f13cc8:	e3530000 	cmp	r3, #0	; 0x0
21f13ccc:	0a00001b 	beq	21f13d40 <abbrev_spec+0x234>
		last = simple_strtoul (p, &ep, 10);
21f13cd0:	e24b3024 	sub	r3, fp, #36	; 0x24
21f13cd4:	e51b0010 	ldr	r0, [fp, #-16]
21f13cd8:	e1a01003 	mov	r1, r3
21f13cdc:	e3a0200a 	mov	r2, #10	; 0xa
21f13ce0:	eb003e38 	bl	21f235c8 <simple_strtoul>
21f13ce4:	e1a03000 	mov	r3, r0
21f13ce8:	e50b3014 	str	r3, [fp, #-20]
		if (ep == p || *ep != '\0' ||
21f13cec:	e51b2024 	ldr	r2, [fp, #-36]
21f13cf0:	e51b3010 	ldr	r3, [fp, #-16]
21f13cf4:	e1520003 	cmp	r2, r3
21f13cf8:	0a00000d 	beq	21f13d34 <abbrev_spec+0x228>
21f13cfc:	e51b3024 	ldr	r3, [fp, #-36]
21f13d00:	e5d33000 	ldrb	r3, [r3]
21f13d04:	e3530000 	cmp	r3, #0	; 0x0
21f13d08:	1a000009 	bne	21f13d34 <abbrev_spec+0x228>
21f13d0c:	e51b2014 	ldr	r2, [fp, #-20]
21f13d10:	e51b3018 	ldr	r3, [fp, #-24]
21f13d14:	e1520003 	cmp	r2, r3
21f13d18:	ba000005 	blt	21f13d34 <abbrev_spec+0x228>
21f13d1c:	e51b3020 	ldr	r3, [fp, #-32]
21f13d20:	e1d330b4 	ldrh	r3, [r3, #4]
21f13d24:	e1a02003 	mov	r2, r3
21f13d28:	e51b3014 	ldr	r3, [fp, #-20]
21f13d2c:	e1520003 	cmp	r2, r3
21f13d30:	ca000004 	bgt	21f13d48 <abbrev_spec+0x23c>
			last < first || last >= fp->sector_count)
			return -1;
21f13d34:	e3e03000 	mvn	r3, #0	; 0x0
21f13d38:	e50b3038 	str	r3, [fp, #-56]
21f13d3c:	ea00000c 	b	21f13d74 <abbrev_spec+0x268>
	} else {
		last = first;
21f13d40:	e51b3018 	ldr	r3, [fp, #-24]
21f13d44:	e50b3014 	str	r3, [fp, #-20]
	}

	*pinfo = fp;
21f13d48:	e51b202c 	ldr	r2, [fp, #-44]
21f13d4c:	e51b3020 	ldr	r3, [fp, #-32]
21f13d50:	e5823000 	str	r3, [r2]
	*psf = first;
21f13d54:	e51b2030 	ldr	r2, [fp, #-48]
21f13d58:	e51b3018 	ldr	r3, [fp, #-24]
21f13d5c:	e5823000 	str	r3, [r2]
	*psl = last;
21f13d60:	e51b2034 	ldr	r2, [fp, #-52]
21f13d64:	e51b3014 	ldr	r3, [fp, #-20]
21f13d68:	e5823000 	str	r3, [r2]

	return 1;
21f13d6c:	e3a03001 	mov	r3, #1	; 0x1
21f13d70:	e50b3038 	str	r3, [fp, #-56]
21f13d74:	e51b3038 	ldr	r3, [fp, #-56]
}
21f13d78:	e1a00003 	mov	r0, r3
21f13d7c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f13d80:	e89da800 	ldmia	sp, {fp, sp, pc}
21f13d84:	21f68ca0 	mvncss	r8, r0, lsr #25

21f13d88 <addr_spec>:

/*
 * This function computes the start and end addresses for both
 * erase and protect commands. The range of the addresses on which
 * either of the commands is to operate can be given in two forms:
 * 1. <cmd> start end - operate on <'start',  'end')
 * 2. <cmd> start +length - operate on <'start', start + length)
 * If the second form is used and the end address doesn't fall on the
 * sector boundary, than it will be adjusted to the next sector boundary.
 * If it isn't in the flash, the function will fail (return -1).
 * Input:
 *    arg1, arg2: address specification (i.e. both command arguments)
 * Output:
 *    addr_first, addr_last: computed address range
 * Return:
 *    1: success
 *   -1: failure (bad format, bad address).
*/
static int
addr_spec(char *arg1, char *arg2, ulong *addr_first, ulong *addr_last)
{
21f13d88:	e1a0c00d 	mov	ip, sp
21f13d8c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f13d90:	e24cb004 	sub	fp, ip, #4	; 0x4
21f13d94:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f13d98:	e50b0028 	str	r0, [fp, #-40]
21f13d9c:	e50b102c 	str	r1, [fp, #-44]
21f13da0:	e50b2030 	str	r2, [fp, #-48]
21f13da4:	e50b3034 	str	r3, [fp, #-52]
	char *ep;
	char len_used; /* indicates if the "start +length" form used */
	char found;
	ulong bank;

	*addr_first = simple_strtoul(arg1, &ep, 16);
21f13da8:	e24b3024 	sub	r3, fp, #36	; 0x24
21f13dac:	e51b0028 	ldr	r0, [fp, #-40]
21f13db0:	e1a01003 	mov	r1, r3
21f13db4:	e3a02010 	mov	r2, #16	; 0x10
21f13db8:	eb003e02 	bl	21f235c8 <simple_strtoul>
21f13dbc:	e1a02000 	mov	r2, r0
21f13dc0:	e51b3030 	ldr	r3, [fp, #-48]
21f13dc4:	e5832000 	str	r2, [r3]
	if (ep == arg1 || *ep != '\0')
21f13dc8:	e51b2024 	ldr	r2, [fp, #-36]
21f13dcc:	e51b3028 	ldr	r3, [fp, #-40]
21f13dd0:	e1520003 	cmp	r2, r3
21f13dd4:	0a000003 	beq	21f13de8 <addr_spec+0x60>
21f13dd8:	e51b3024 	ldr	r3, [fp, #-36]
21f13ddc:	e5d33000 	ldrb	r3, [r3]
21f13de0:	e3530000 	cmp	r3, #0	; 0x0
21f13de4:	0a000002 	beq	21f13df4 <addr_spec+0x6c>
		return -1;
21f13de8:	e3e03000 	mvn	r3, #0	; 0x0
21f13dec:	e50b3038 	str	r3, [fp, #-56]
21f13df0:	ea000094 	b	21f14048 <addr_spec+0x2c0>

	len_used = 0;
21f13df4:	e3a03000 	mov	r3, #0	; 0x0
21f13df8:	e54b301e 	strb	r3, [fp, #-30]
	if (arg2 && *arg2 == '+'){
21f13dfc:	e51b302c 	ldr	r3, [fp, #-44]
21f13e00:	e3530000 	cmp	r3, #0	; 0x0
21f13e04:	0a000008 	beq	21f13e2c <addr_spec+0xa4>
21f13e08:	e51b302c 	ldr	r3, [fp, #-44]
21f13e0c:	e5d33000 	ldrb	r3, [r3]
21f13e10:	e353002b 	cmp	r3, #43	; 0x2b
21f13e14:	1a000004 	bne	21f13e2c <addr_spec+0xa4>
		len_used = 1;
21f13e18:	e3a03001 	mov	r3, #1	; 0x1
21f13e1c:	e54b301e 	strb	r3, [fp, #-30]
		++arg2;
21f13e20:	e51b302c 	ldr	r3, [fp, #-44]
21f13e24:	e2833001 	add	r3, r3, #1	; 0x1
21f13e28:	e50b302c 	str	r3, [fp, #-44]
	}

	*addr_last = simple_strtoul(arg2, &ep, 16);
21f13e2c:	e24b3024 	sub	r3, fp, #36	; 0x24
21f13e30:	e51b002c 	ldr	r0, [fp, #-44]
21f13e34:	e1a01003 	mov	r1, r3
21f13e38:	e3a02010 	mov	r2, #16	; 0x10
21f13e3c:	eb003de1 	bl	21f235c8 <simple_strtoul>
21f13e40:	e1a02000 	mov	r2, r0
21f13e44:	e51b3034 	ldr	r3, [fp, #-52]
21f13e48:	e5832000 	str	r2, [r3]
	if (ep == arg2 || *ep != '\0')
21f13e4c:	e51b2024 	ldr	r2, [fp, #-36]
21f13e50:	e51b302c 	ldr	r3, [fp, #-44]
21f13e54:	e1520003 	cmp	r2, r3
21f13e58:	0a000003 	beq	21f13e6c <addr_spec+0xe4>
21f13e5c:	e51b3024 	ldr	r3, [fp, #-36]
21f13e60:	e5d33000 	ldrb	r3, [r3]
21f13e64:	e3530000 	cmp	r3, #0	; 0x0
21f13e68:	0a000002 	beq	21f13e78 <addr_spec+0xf0>
		return -1;
21f13e6c:	e3e03000 	mvn	r3, #0	; 0x0
21f13e70:	e50b3038 	str	r3, [fp, #-56]
21f13e74:	ea000073 	b	21f14048 <addr_spec+0x2c0>

	if (len_used){
21f13e78:	e55b301e 	ldrb	r3, [fp, #-30]
21f13e7c:	e3530000 	cmp	r3, #0	; 0x0
21f13e80:	0a00006e 	beq	21f14040 <addr_spec+0x2b8>
		/*
		 * *addr_last has the length, compute correct *addr_last
		 * XXX watch out for the integer overflow! Right now it is
		 * checked for in both the callers.
		 */
		*addr_last = *addr_first + *addr_last - 1;
21f13e84:	e51b3030 	ldr	r3, [fp, #-48]
21f13e88:	e5932000 	ldr	r2, [r3]
21f13e8c:	e51b3034 	ldr	r3, [fp, #-52]
21f13e90:	e5933000 	ldr	r3, [r3]
21f13e94:	e0823003 	add	r3, r2, r3
21f13e98:	e2432001 	sub	r2, r3, #1	; 0x1
21f13e9c:	e51b3034 	ldr	r3, [fp, #-52]
21f13ea0:	e5832000 	str	r2, [r3]

		/*
		 * It may happen that *addr_last doesn't fall on the sector
		 * boundary. We want to round such an address to the next
		 * sector boundary, so that the commands don't fail later on.
		 */

		/* find the end addr of the sector where the *addr_last is */
		found = 0;
21f13ea4:	e3a03000 	mov	r3, #0	; 0x0
21f13ea8:	e54b301d 	strb	r3, [fp, #-29]
		for (bank = 0; bank < CFG_MAX_FLASH_BANKS && !found; ++bank){
21f13eac:	e3a03000 	mov	r3, #0	; 0x0
21f13eb0:	e50b301c 	str	r3, [fp, #-28]
21f13eb4:	ea000050 	b	21f13ffc <addr_spec+0x274>
			int i;
			flash_info_t *info = &flash_info[bank];
21f13eb8:	e51b201c 	ldr	r2, [fp, #-28]
21f13ebc:	e1a03002 	mov	r3, r2
21f13ec0:	e1a03183 	mov	r3, r3, lsl #3
21f13ec4:	e0833002 	add	r3, r3, r2
21f13ec8:	e1a03083 	mov	r3, r3, lsl #1
21f13ecc:	e0833002 	add	r3, r3, r2
21f13ed0:	e1a02203 	mov	r2, r3, lsl #4
21f13ed4:	e0833002 	add	r3, r3, r2
21f13ed8:	e1a03103 	mov	r3, r3, lsl #2
21f13edc:	e1a02003 	mov	r2, r3
21f13ee0:	e59f3170 	ldr	r3, [pc, #368]	; 21f14058 <.text+0x14058>
21f13ee4:	e0823003 	add	r3, r2, r3
21f13ee8:	e50b3014 	str	r3, [fp, #-20]
			for (i = 0; i < info->sector_count && !found; ++i){
21f13eec:	e3a03000 	mov	r3, #0	; 0x0
21f13ef0:	e50b3018 	str	r3, [fp, #-24]
21f13ef4:	ea000034 	b	21f13fcc <addr_spec+0x244>
				/* get the end address of the sector */
				ulong sector_end_addr;
				if (i == info->sector_count - 1){
21f13ef8:	e51b3014 	ldr	r3, [fp, #-20]
21f13efc:	e1d330b4 	ldrh	r3, [r3, #4]
21f13f00:	e2432001 	sub	r2, r3, #1	; 0x1
21f13f04:	e51b3018 	ldr	r3, [fp, #-24]
21f13f08:	e1520003 	cmp	r2, r3
21f13f0c:	1a000007 	bne	21f13f30 <addr_spec+0x1a8>
					sector_end_addr =
21f13f10:	e51b3014 	ldr	r3, [fp, #-20]
21f13f14:	e593200c 	ldr	r2, [r3, #12]
21f13f18:	e51b3014 	ldr	r3, [fp, #-20]
21f13f1c:	e5933000 	ldr	r3, [r3]
21f13f20:	e0823003 	add	r3, r2, r3
21f13f24:	e2433001 	sub	r3, r3, #1	; 0x1
21f13f28:	e50b3010 	str	r3, [fp, #-16]
21f13f2c:	ea000009 	b	21f13f58 <addr_spec+0x1d0>
						info->start[0] + info->size - 1;
				} else {
					sector_end_addr =
21f13f30:	e51b3018 	ldr	r3, [fp, #-24]
21f13f34:	e2833001 	add	r3, r3, #1	; 0x1
21f13f38:	e51b2014 	ldr	r2, [fp, #-20]
21f13f3c:	e3a0100c 	mov	r1, #12	; 0xc
21f13f40:	e1a03103 	mov	r3, r3, lsl #2
21f13f44:	e0833002 	add	r3, r3, r2
21f13f48:	e0833001 	add	r3, r3, r1
21f13f4c:	e5933000 	ldr	r3, [r3]
21f13f50:	e2433001 	sub	r3, r3, #1	; 0x1
21f13f54:	e50b3010 	str	r3, [fp, #-16]
						info->start[i+1] - 1;
				}
				if (*addr_last <= sector_end_addr &&
21f13f58:	e51b3034 	ldr	r3, [fp, #-52]
21f13f5c:	e5932000 	ldr	r2, [r3]
21f13f60:	e51b3010 	ldr	r3, [fp, #-16]
21f13f64:	e1520003 	cmp	r2, r3
21f13f68:	8a000014 	bhi	21f13fc0 <addr_spec+0x238>
21f13f6c:	e51b3034 	ldr	r3, [fp, #-52]
21f13f70:	e5930000 	ldr	r0, [r3]
21f13f74:	e51b3018 	ldr	r3, [fp, #-24]
21f13f78:	e51b2014 	ldr	r2, [fp, #-20]
21f13f7c:	e3a0100c 	mov	r1, #12	; 0xc
21f13f80:	e1a03103 	mov	r3, r3, lsl #2
21f13f84:	e0833002 	add	r3, r3, r2
21f13f88:	e0833001 	add	r3, r3, r1
21f13f8c:	e5933000 	ldr	r3, [r3]
21f13f90:	e1500003 	cmp	r0, r3
21f13f94:	3a000009 	bcc	21f13fc0 <addr_spec+0x238>
						*addr_last >= info->start[i]){
					/* sector found */
					found = 1;
21f13f98:	e3a03001 	mov	r3, #1	; 0x1
21f13f9c:	e54b301d 	strb	r3, [fp, #-29]
					/* adjust *addr_last if necessary */
					if (*addr_last < sector_end_addr){
21f13fa0:	e51b3034 	ldr	r3, [fp, #-52]
21f13fa4:	e5932000 	ldr	r2, [r3]
21f13fa8:	e51b3010 	ldr	r3, [fp, #-16]
21f13fac:	e1520003 	cmp	r2, r3
21f13fb0:	2a000002 	bcs	21f13fc0 <addr_spec+0x238>
						*addr_last = sector_end_addr;
21f13fb4:	e51b2034 	ldr	r2, [fp, #-52]
21f13fb8:	e51b3010 	ldr	r3, [fp, #-16]
21f13fbc:	e5823000 	str	r3, [r2]
21f13fc0:	e51b3018 	ldr	r3, [fp, #-24]
21f13fc4:	e2833001 	add	r3, r3, #1	; 0x1
21f13fc8:	e50b3018 	str	r3, [fp, #-24]
21f13fcc:	e51b3014 	ldr	r3, [fp, #-20]
21f13fd0:	e1d330b4 	ldrh	r3, [r3, #4]
21f13fd4:	e1a02003 	mov	r2, r3
21f13fd8:	e51b3018 	ldr	r3, [fp, #-24]
21f13fdc:	e1520003 	cmp	r2, r3
21f13fe0:	da000002 	ble	21f13ff0 <addr_spec+0x268>
21f13fe4:	e55b301d 	ldrb	r3, [fp, #-29]
21f13fe8:	e3530000 	cmp	r3, #0	; 0x0
21f13fec:	0affffc1 	beq	21f13ef8 <addr_spec+0x170>
21f13ff0:	e51b301c 	ldr	r3, [fp, #-28]
21f13ff4:	e2833001 	add	r3, r3, #1	; 0x1
21f13ff8:	e50b301c 	str	r3, [fp, #-28]
21f13ffc:	e51b301c 	ldr	r3, [fp, #-28]
21f14000:	e3530000 	cmp	r3, #0	; 0x0
21f14004:	1a000002 	bne	21f14014 <addr_spec+0x28c>
21f14008:	e55b301d 	ldrb	r3, [fp, #-29]
21f1400c:	e3530000 	cmp	r3, #0	; 0x0
21f14010:	0affffa8 	beq	21f13eb8 <addr_spec+0x130>
					}
				}
			} /* sector */
		} /* bank */
		if (!found){
21f14014:	e55b301d 	ldrb	r3, [fp, #-29]
21f14018:	e3530000 	cmp	r3, #0	; 0x0
21f1401c:	1a000007 	bne	21f14040 <addr_spec+0x2b8>
			/* error, addres not in flash */
			printf("Error: end address (0x%08lx) not in flash!\n",
21f14020:	e51b3034 	ldr	r3, [fp, #-52]
21f14024:	e5933000 	ldr	r3, [r3]
21f14028:	e59f002c 	ldr	r0, [pc, #44]	; 21f1405c <.text+0x1405c>
21f1402c:	e1a01003 	mov	r1, r3
21f14030:	eb001e95 	bl	21f1ba8c <printf>
								*addr_last);
			return -1;
21f14034:	e3e03000 	mvn	r3, #0	; 0x0
21f14038:	e50b3038 	str	r3, [fp, #-56]
21f1403c:	ea000001 	b	21f14048 <addr_spec+0x2c0>
		}
	} /* "start +length" from used */

	return 1;
21f14040:	e3a03001 	mov	r3, #1	; 0x1
21f14044:	e50b3038 	str	r3, [fp, #-56]
21f14048:	e51b3038 	ldr	r3, [fp, #-56]
}
21f1404c:	e1a00003 	mov	r0, r3
21f14050:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f14054:	e89da800 	ldmia	sp, {fp, sp, pc}
21f14058:	21f68ca0 	mvncss	r8, r0, lsr #25
21f1405c:	21f30a9c 	ldrcsb	r0, [r3, #172]!

21f14060 <flash_fill_sect_ranges>:

static int
flash_fill_sect_ranges (ulong addr_first, ulong addr_last,
			int *s_first, int *s_last,
			int *s_count )
{
21f14060:	e1a0c00d 	mov	ip, sp
21f14064:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f14068:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1406c:	e24dd034 	sub	sp, sp, #52	; 0x34
21f14070:	e50b002c 	str	r0, [fp, #-44]
21f14074:	e50b1030 	str	r1, [fp, #-48]
21f14078:	e50b2034 	str	r2, [fp, #-52]
21f1407c:	e50b3038 	str	r3, [fp, #-56]
	flash_info_t *info;
	ulong bank;
	int rcode = 0;
21f14080:	e3a03000 	mov	r3, #0	; 0x0
21f14084:	e50b3020 	str	r3, [fp, #-32]

	*s_count = 0;
21f14088:	e59b2004 	ldr	r2, [fp, #4]
21f1408c:	e3a03000 	mov	r3, #0	; 0x0
21f14090:	e5823000 	str	r3, [r2]

	for (bank=0; bank < CFG_MAX_FLASH_BANKS; ++bank) {
21f14094:	e3a03000 	mov	r3, #0	; 0x0
21f14098:	e50b3024 	str	r3, [fp, #-36]
21f1409c:	ea000010 	b	21f140e4 <flash_fill_sect_ranges+0x84>
		s_first[bank] = -1;	/* first sector to erase	*/
21f140a0:	e51b3024 	ldr	r3, [fp, #-36]
21f140a4:	e1a03103 	mov	r3, r3, lsl #2
21f140a8:	e1a02003 	mov	r2, r3
21f140ac:	e51b3034 	ldr	r3, [fp, #-52]
21f140b0:	e0822003 	add	r2, r2, r3
21f140b4:	e3e03000 	mvn	r3, #0	; 0x0
21f140b8:	e5823000 	str	r3, [r2]
		s_last [bank] = -1;	/* last  sector to erase	*/
21f140bc:	e51b3024 	ldr	r3, [fp, #-36]
21f140c0:	e1a03103 	mov	r3, r3, lsl #2
21f140c4:	e1a02003 	mov	r2, r3
21f140c8:	e51b3038 	ldr	r3, [fp, #-56]
21f140cc:	e0822003 	add	r2, r2, r3
21f140d0:	e3e03000 	mvn	r3, #0	; 0x0
21f140d4:	e5823000 	str	r3, [r2]
21f140d8:	e51b3024 	ldr	r3, [fp, #-36]
21f140dc:	e2833001 	add	r3, r3, #1	; 0x1
21f140e0:	e50b3024 	str	r3, [fp, #-36]
21f140e4:	e51b3024 	ldr	r3, [fp, #-36]
21f140e8:	e3530000 	cmp	r3, #0	; 0x0
21f140ec:	0affffeb 	beq	21f140a0 <flash_fill_sect_ranges+0x40>
	}

	for (bank=0,info=&flash_info[0];
21f140f0:	e3a03000 	mov	r3, #0	; 0x0
21f140f4:	e50b3024 	str	r3, [fp, #-36]
21f140f8:	e59f33a8 	ldr	r3, [pc, #936]	; 21f144a8 <.text+0x144a8>
21f140fc:	e50b3028 	str	r3, [fp, #-40]
	     (bank < CFG_MAX_FLASH_BANKS) && (addr_first <= addr_last);
21f14100:	ea0000dd 	b	21f1447c <flash_fill_sect_ranges+0x41c>
	     ++bank, ++info) {
		ulong b_end;
		int sect;
		short s_end;

		if (info->flash_id == FLASH_UNKNOWN) {
21f14104:	e51b3028 	ldr	r3, [fp, #-40]
21f14108:	e5932008 	ldr	r2, [r3, #8]
21f1410c:	e3a03cff 	mov	r3, #65280	; 0xff00
21f14110:	e28330ff 	add	r3, r3, #255	; 0xff
21f14114:	e1520003 	cmp	r2, r3
21f14118:	0a0000d0 	beq	21f14460 <flash_fill_sect_ranges+0x400>
			continue;
		}

		b_end = info->start[0] + info->size - 1;	/* bank end addr */
21f1411c:	e51b3028 	ldr	r3, [fp, #-40]
21f14120:	e593200c 	ldr	r2, [r3, #12]
21f14124:	e51b3028 	ldr	r3, [fp, #-40]
21f14128:	e5933000 	ldr	r3, [r3]
21f1412c:	e0823003 	add	r3, r2, r3
21f14130:	e2433001 	sub	r3, r3, #1	; 0x1
21f14134:	e50b301c 	str	r3, [fp, #-28]
		s_end = info->sector_count - 1;			/* last sector   */
21f14138:	e51b3028 	ldr	r3, [fp, #-40]
21f1413c:	e1d330b4 	ldrh	r3, [r3, #4]
21f14140:	e2433001 	sub	r3, r3, #1	; 0x1
21f14144:	e14b31b2 	strh	r3, [fp, #-18]


		for (sect=0; sect < info->sector_count; ++sect) {
21f14148:	e3a03000 	mov	r3, #0	; 0x0
21f1414c:	e50b3018 	str	r3, [fp, #-24]
21f14150:	ea00003f 	b	21f14254 <flash_fill_sect_ranges+0x1f4>
			ulong end;	/* last address in current sect	*/

			end = (sect == s_end) ? b_end : info->start[sect + 1] - 1;
21f14154:	e15b21f2 	ldrsh	r2, [fp, #-18]
21f14158:	e51b3018 	ldr	r3, [fp, #-24]
21f1415c:	e1520003 	cmp	r2, r3
21f14160:	0a00000a 	beq	21f14190 <flash_fill_sect_ranges+0x130>
21f14164:	e51b3018 	ldr	r3, [fp, #-24]
21f14168:	e2833001 	add	r3, r3, #1	; 0x1
21f1416c:	e51b2028 	ldr	r2, [fp, #-40]
21f14170:	e3a0100c 	mov	r1, #12	; 0xc
21f14174:	e1a03103 	mov	r3, r3, lsl #2
21f14178:	e0833002 	add	r3, r3, r2
21f1417c:	e0833001 	add	r3, r3, r1
21f14180:	e5933000 	ldr	r3, [r3]
21f14184:	e2433001 	sub	r3, r3, #1	; 0x1
21f14188:	e50b3040 	str	r3, [fp, #-64]
21f1418c:	ea000001 	b	21f14198 <flash_fill_sect_ranges+0x138>
21f14190:	e51b301c 	ldr	r3, [fp, #-28]
21f14194:	e50b3040 	str	r3, [fp, #-64]
21f14198:	e51b3040 	ldr	r3, [fp, #-64]
21f1419c:	e50b3010 	str	r3, [fp, #-16]

			if (addr_first > end)
21f141a0:	e51b202c 	ldr	r2, [fp, #-44]
21f141a4:	e51b3010 	ldr	r3, [fp, #-16]
21f141a8:	e1520003 	cmp	r2, r3
21f141ac:	8a000025 	bhi	21f14248 <flash_fill_sect_ranges+0x1e8>
				continue;
			if (addr_last < info->start[sect])
21f141b0:	e51b3018 	ldr	r3, [fp, #-24]
21f141b4:	e51b2028 	ldr	r2, [fp, #-40]
21f141b8:	e3a0100c 	mov	r1, #12	; 0xc
21f141bc:	e1a03103 	mov	r3, r3, lsl #2
21f141c0:	e0833002 	add	r3, r3, r2
21f141c4:	e0833001 	add	r3, r3, r1
21f141c8:	e5932000 	ldr	r2, [r3]
21f141cc:	e51b3030 	ldr	r3, [fp, #-48]
21f141d0:	e1520003 	cmp	r2, r3
21f141d4:	8a00001b 	bhi	21f14248 <flash_fill_sect_ranges+0x1e8>
				continue;

			if (addr_first == info->start[sect]) {
21f141d8:	e51b3018 	ldr	r3, [fp, #-24]
21f141dc:	e51b2028 	ldr	r2, [fp, #-40]
21f141e0:	e3a0100c 	mov	r1, #12	; 0xc
21f141e4:	e1a03103 	mov	r3, r3, lsl #2
21f141e8:	e0833002 	add	r3, r3, r2
21f141ec:	e0833001 	add	r3, r3, r1
21f141f0:	e5932000 	ldr	r2, [r3]
21f141f4:	e51b302c 	ldr	r3, [fp, #-44]
21f141f8:	e1520003 	cmp	r2, r3
21f141fc:	1a000006 	bne	21f1421c <flash_fill_sect_ranges+0x1bc>
				s_first[bank] = sect;
21f14200:	e51b3024 	ldr	r3, [fp, #-36]
21f14204:	e1a03103 	mov	r3, r3, lsl #2
21f14208:	e1a02003 	mov	r2, r3
21f1420c:	e51b3034 	ldr	r3, [fp, #-52]
21f14210:	e0822003 	add	r2, r2, r3
21f14214:	e51b3018 	ldr	r3, [fp, #-24]
21f14218:	e5823000 	str	r3, [r2]
			}
			if (addr_last  == end) {
21f1421c:	e51b2030 	ldr	r2, [fp, #-48]
21f14220:	e51b3010 	ldr	r3, [fp, #-16]
21f14224:	e1520003 	cmp	r2, r3
21f14228:	1a000006 	bne	21f14248 <flash_fill_sect_ranges+0x1e8>
				s_last[bank]  = sect;
21f1422c:	e51b3024 	ldr	r3, [fp, #-36]
21f14230:	e1a03103 	mov	r3, r3, lsl #2
21f14234:	e1a02003 	mov	r2, r3
21f14238:	e51b3038 	ldr	r3, [fp, #-56]
21f1423c:	e0822003 	add	r2, r2, r3
21f14240:	e51b3018 	ldr	r3, [fp, #-24]
21f14244:	e5823000 	str	r3, [r2]
21f14248:	e51b3018 	ldr	r3, [fp, #-24]
21f1424c:	e2833001 	add	r3, r3, #1	; 0x1
21f14250:	e50b3018 	str	r3, [fp, #-24]
21f14254:	e51b3028 	ldr	r3, [fp, #-40]
21f14258:	e1d330b4 	ldrh	r3, [r3, #4]
21f1425c:	e1a02003 	mov	r2, r3
21f14260:	e51b3018 	ldr	r3, [fp, #-24]
21f14264:	e1520003 	cmp	r2, r3
21f14268:	caffffb9 	bgt	21f14154 <flash_fill_sect_ranges+0xf4>
			}
		}
		if (s_first[bank] >= 0) {
21f1426c:	e51b3024 	ldr	r3, [fp, #-36]
21f14270:	e1a03103 	mov	r3, r3, lsl #2
21f14274:	e1a02003 	mov	r2, r3
21f14278:	e51b3034 	ldr	r3, [fp, #-52]
21f1427c:	e0823003 	add	r3, r2, r3
21f14280:	e5933000 	ldr	r3, [r3]
21f14284:	e3530000 	cmp	r3, #0	; 0x0
21f14288:	ba000059 	blt	21f143f4 <flash_fill_sect_ranges+0x394>
			if (s_last[bank] < 0) {
21f1428c:	e51b3024 	ldr	r3, [fp, #-36]
21f14290:	e1a03103 	mov	r3, r3, lsl #2
21f14294:	e1a02003 	mov	r2, r3
21f14298:	e51b3038 	ldr	r3, [fp, #-56]
21f1429c:	e0823003 	add	r3, r2, r3
21f142a0:	e5933000 	ldr	r3, [r3]
21f142a4:	e3530000 	cmp	r3, #0	; 0x0
21f142a8:	aa000010 	bge	21f142f0 <flash_fill_sect_ranges+0x290>
				if (addr_last > b_end) {
21f142ac:	e51b2030 	ldr	r2, [fp, #-48]
21f142b0:	e51b301c 	ldr	r3, [fp, #-28]
21f142b4:	e1520003 	cmp	r2, r3
21f142b8:	9a000007 	bls	21f142dc <flash_fill_sect_ranges+0x27c>
					s_last[bank] = s_end;
21f142bc:	e51b3024 	ldr	r3, [fp, #-36]
21f142c0:	e1a03103 	mov	r3, r3, lsl #2
21f142c4:	e1a02003 	mov	r2, r3
21f142c8:	e51b3038 	ldr	r3, [fp, #-56]
21f142cc:	e0822003 	add	r2, r2, r3
21f142d0:	e15b31f2 	ldrsh	r3, [fp, #-18]
21f142d4:	e5823000 	str	r3, [r2]
21f142d8:	ea000004 	b	21f142f0 <flash_fill_sect_ranges+0x290>
				} else {
					puts ("Error: end address"
21f142dc:	e59f01c8 	ldr	r0, [pc, #456]	; 21f144ac <.text+0x144ac>
21f142e0:	eb001dd6 	bl	21f1ba40 <puts>
						" not on sector boundary\n");
					rcode = 1;
21f142e4:	e3a03001 	mov	r3, #1	; 0x1
21f142e8:	e50b3020 	str	r3, [fp, #-32]
					break;
21f142ec:	ea000069 	b	21f14498 <flash_fill_sect_ranges+0x438>
				}
			}
			if (s_last[bank] < s_first[bank]) {
21f142f0:	e51b3024 	ldr	r3, [fp, #-36]
21f142f4:	e1a03103 	mov	r3, r3, lsl #2
21f142f8:	e1a02003 	mov	r2, r3
21f142fc:	e51b3038 	ldr	r3, [fp, #-56]
21f14300:	e0823003 	add	r3, r2, r3
21f14304:	e5931000 	ldr	r1, [r3]
21f14308:	e51b3024 	ldr	r3, [fp, #-36]
21f1430c:	e1a03103 	mov	r3, r3, lsl #2
21f14310:	e1a02003 	mov	r2, r3
21f14314:	e51b3034 	ldr	r3, [fp, #-52]
21f14318:	e0823003 	add	r3, r2, r3
21f1431c:	e5933000 	ldr	r3, [r3]
21f14320:	e1510003 	cmp	r1, r3
21f14324:	aa000004 	bge	21f1433c <flash_fill_sect_ranges+0x2dc>
				puts ("Error: end sector"
21f14328:	e59f0180 	ldr	r0, [pc, #384]	; 21f144b0 <.text+0x144b0>
21f1432c:	eb001dc3 	bl	21f1ba40 <puts>
					" precedes start sector\n");
				rcode = 1;
21f14330:	e3a03001 	mov	r3, #1	; 0x1
21f14334:	e50b3020 	str	r3, [fp, #-32]
				break;
21f14338:	ea000056 	b	21f14498 <flash_fill_sect_ranges+0x438>
			}
			sect = s_last[bank];
21f1433c:	e51b3024 	ldr	r3, [fp, #-36]
21f14340:	e1a03103 	mov	r3, r3, lsl #2
21f14344:	e1a02003 	mov	r2, r3
21f14348:	e51b3038 	ldr	r3, [fp, #-56]
21f1434c:	e0823003 	add	r3, r2, r3
21f14350:	e5933000 	ldr	r3, [r3]
21f14354:	e50b3018 	str	r3, [fp, #-24]
			addr_first = (sect == s_end) ? b_end + 1: info->start[sect + 1];
21f14358:	e15b21f2 	ldrsh	r2, [fp, #-18]
21f1435c:	e51b3018 	ldr	r3, [fp, #-24]
21f14360:	e1520003 	cmp	r2, r3
21f14364:	1a000003 	bne	21f14378 <flash_fill_sect_ranges+0x318>
21f14368:	e51b301c 	ldr	r3, [fp, #-28]
21f1436c:	e2833001 	add	r3, r3, #1	; 0x1
21f14370:	e50b303c 	str	r3, [fp, #-60]
21f14374:	ea000008 	b	21f1439c <flash_fill_sect_ranges+0x33c>
21f14378:	e51b3018 	ldr	r3, [fp, #-24]
21f1437c:	e2833001 	add	r3, r3, #1	; 0x1
21f14380:	e51b2028 	ldr	r2, [fp, #-40]
21f14384:	e3a0100c 	mov	r1, #12	; 0xc
21f14388:	e1a03103 	mov	r3, r3, lsl #2
21f1438c:	e0833002 	add	r3, r3, r2
21f14390:	e0833001 	add	r3, r3, r1
21f14394:	e5933000 	ldr	r3, [r3]
21f14398:	e50b303c 	str	r3, [fp, #-60]
21f1439c:	e51b303c 	ldr	r3, [fp, #-60]
21f143a0:	e50b302c 	str	r3, [fp, #-44]
			(*s_count) += s_last[bank] - s_first[bank] + 1;
21f143a4:	e59b3004 	ldr	r3, [fp, #4]
21f143a8:	e5930000 	ldr	r0, [r3]
21f143ac:	e51b3024 	ldr	r3, [fp, #-36]
21f143b0:	e1a03103 	mov	r3, r3, lsl #2
21f143b4:	e1a02003 	mov	r2, r3
21f143b8:	e51b3038 	ldr	r3, [fp, #-56]
21f143bc:	e0823003 	add	r3, r2, r3
21f143c0:	e5931000 	ldr	r1, [r3]
21f143c4:	e51b3024 	ldr	r3, [fp, #-36]
21f143c8:	e1a03103 	mov	r3, r3, lsl #2
21f143cc:	e1a02003 	mov	r2, r3
21f143d0:	e51b3034 	ldr	r3, [fp, #-52]
21f143d4:	e0823003 	add	r3, r2, r3
21f143d8:	e5933000 	ldr	r3, [r3]
21f143dc:	e0633001 	rsb	r3, r3, r1
21f143e0:	e0803003 	add	r3, r0, r3
21f143e4:	e2832001 	add	r2, r3, #1	; 0x1
21f143e8:	e59b3004 	ldr	r3, [fp, #4]
21f143ec:	e5832000 	str	r2, [r3]
21f143f0:	ea00001a 	b	21f14460 <flash_fill_sect_ranges+0x400>
		} else if (addr_first >= info->start[0] && addr_first < b_end) {
21f143f4:	e51b3028 	ldr	r3, [fp, #-40]
21f143f8:	e593200c 	ldr	r2, [r3, #12]
21f143fc:	e51b302c 	ldr	r3, [fp, #-44]
21f14400:	e1520003 	cmp	r2, r3
21f14404:	8a000008 	bhi	21f1442c <flash_fill_sect_ranges+0x3cc>
21f14408:	e51b202c 	ldr	r2, [fp, #-44]
21f1440c:	e51b301c 	ldr	r3, [fp, #-28]
21f14410:	e1520003 	cmp	r2, r3
21f14414:	2a000004 	bcs	21f1442c <flash_fill_sect_ranges+0x3cc>
			puts ("Error: start address not on sector boundary\n");
21f14418:	e59f0094 	ldr	r0, [pc, #148]	; 21f144b4 <.text+0x144b4>
21f1441c:	eb001d87 	bl	21f1ba40 <puts>
			rcode = 1;
21f14420:	e3a03001 	mov	r3, #1	; 0x1
21f14424:	e50b3020 	str	r3, [fp, #-32]
			break;
21f14428:	ea00001a 	b	21f14498 <flash_fill_sect_ranges+0x438>
		} else if (s_last[bank] >= 0) {
21f1442c:	e51b3024 	ldr	r3, [fp, #-36]
21f14430:	e1a03103 	mov	r3, r3, lsl #2
21f14434:	e1a02003 	mov	r2, r3
21f14438:	e51b3038 	ldr	r3, [fp, #-56]
21f1443c:	e0823003 	add	r3, r2, r3
21f14440:	e5933000 	ldr	r3, [r3]
21f14444:	e3530000 	cmp	r3, #0	; 0x0
21f14448:	ba000004 	blt	21f14460 <flash_fill_sect_ranges+0x400>
			puts ("Error: cannot span across banks when they are"
21f1444c:	e59f0064 	ldr	r0, [pc, #100]	; 21f144b8 <.text+0x144b8>
21f14450:	eb001d7a 	bl	21f1ba40 <puts>
			       " mapped in reverse order\n");
			rcode = 1;
21f14454:	e3a03001 	mov	r3, #1	; 0x1
21f14458:	e50b3020 	str	r3, [fp, #-32]
			break;
21f1445c:	ea00000d 	b	21f14498 <flash_fill_sect_ranges+0x438>
21f14460:	e51b3024 	ldr	r3, [fp, #-36]
21f14464:	e2833001 	add	r3, r3, #1	; 0x1
21f14468:	e50b3024 	str	r3, [fp, #-36]
21f1446c:	e51b3028 	ldr	r3, [fp, #-40]
21f14470:	e2833c05 	add	r3, r3, #1280	; 0x500
21f14474:	e283300c 	add	r3, r3, #12	; 0xc
21f14478:	e50b3028 	str	r3, [fp, #-40]
21f1447c:	e51b3024 	ldr	r3, [fp, #-36]
21f14480:	e3530000 	cmp	r3, #0	; 0x0
21f14484:	1a000003 	bne	21f14498 <flash_fill_sect_ranges+0x438>
21f14488:	e51b202c 	ldr	r2, [fp, #-44]
21f1448c:	e51b3030 	ldr	r3, [fp, #-48]
21f14490:	e1520003 	cmp	r2, r3
21f14494:	9affff1a 	bls	21f14104 <flash_fill_sect_ranges+0xa4>
		}
	}

	return rcode;
21f14498:	e51b3020 	ldr	r3, [fp, #-32]
}
21f1449c:	e1a00003 	mov	r0, r3
21f144a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f144a4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f144a8:	21f68ca0 	mvncss	r8, r0, lsr #25
21f144ac:	21f30ac8 	mvncss	r0, r8, asr #21
21f144b0:	21f30af4 	ldrcssh	r0, [r3, #164]!
21f144b4:	21f30b20 	mvncss	r0, r0, lsr #22
21f144b8:	21f30b50 	mvncss	r0, r0, asr fp

21f144bc <do_flinfo>:

int do_flinfo ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f144bc:	e1a0c00d 	mov	ip, sp
21f144c0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f144c4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f144c8:	e24dd018 	sub	sp, sp, #24	; 0x18
21f144cc:	e50b0014 	str	r0, [fp, #-20]
21f144d0:	e50b1018 	str	r1, [fp, #-24]
21f144d4:	e50b201c 	str	r2, [fp, #-28]
21f144d8:	e50b3020 	str	r3, [fp, #-32]
	ulong bank;

#ifdef CONFIG_HAS_DATAFLASH
	dataflash_print_info();
21f144dc:	ebffeee5 	bl	21f10078 <dataflash_print_info>
#endif

	if (argc == 1) {	/* print info for all FLASH banks */
21f144e0:	e51b301c 	ldr	r3, [fp, #-28]
21f144e4:	e3530001 	cmp	r3, #1	; 0x1
21f144e8:	1a00001e 	bne	21f14568 <do_flinfo+0xac>
		for (bank=0; bank <CFG_MAX_FLASH_BANKS; ++bank) {
21f144ec:	e3a03000 	mov	r3, #0	; 0x0
21f144f0:	e50b3010 	str	r3, [fp, #-16]
21f144f4:	ea000015 	b	21f14550 <do_flinfo+0x94>
			printf ("\nBank # %ld: ", bank+1);
21f144f8:	e51b3010 	ldr	r3, [fp, #-16]
21f144fc:	e2833001 	add	r3, r3, #1	; 0x1
21f14500:	e59f0118 	ldr	r0, [pc, #280]	; 21f14620 <.text+0x14620>
21f14504:	e1a01003 	mov	r1, r3
21f14508:	eb001d5f 	bl	21f1ba8c <printf>

			flash_print_info (&flash_info[bank]);
21f1450c:	e51b2010 	ldr	r2, [fp, #-16]
21f14510:	e1a03002 	mov	r3, r2
21f14514:	e1a03183 	mov	r3, r3, lsl #3
21f14518:	e0833002 	add	r3, r3, r2
21f1451c:	e1a03083 	mov	r3, r3, lsl #1
21f14520:	e0833002 	add	r3, r3, r2
21f14524:	e1a02203 	mov	r2, r3, lsl #4
21f14528:	e0833002 	add	r3, r3, r2
21f1452c:	e1a03103 	mov	r3, r3, lsl #2
21f14530:	e1a02003 	mov	r2, r3
21f14534:	e59f30e8 	ldr	r3, [pc, #232]	; 21f14624 <.text+0x14624>
21f14538:	e0823003 	add	r3, r2, r3
21f1453c:	e1a00003 	mov	r0, r3
21f14540:	eb00616c 	bl	21f2caf8 <flash_print_info>
21f14544:	e51b3010 	ldr	r3, [fp, #-16]
21f14548:	e2833001 	add	r3, r3, #1	; 0x1
21f1454c:	e50b3010 	str	r3, [fp, #-16]
21f14550:	e51b3010 	ldr	r3, [fp, #-16]
21f14554:	e3530000 	cmp	r3, #0	; 0x0
21f14558:	0affffe6 	beq	21f144f8 <do_flinfo+0x3c>
		}
		return 0;
21f1455c:	e3a03000 	mov	r3, #0	; 0x0
21f14560:	e50b3024 	str	r3, [fp, #-36]
21f14564:	ea000029 	b	21f14610 <do_flinfo+0x154>
	}

	bank = simple_strtoul(argv[1], NULL, 16);
21f14568:	e51b3020 	ldr	r3, [fp, #-32]
21f1456c:	e2833004 	add	r3, r3, #4	; 0x4
21f14570:	e5933000 	ldr	r3, [r3]
21f14574:	e1a00003 	mov	r0, r3
21f14578:	e3a01000 	mov	r1, #0	; 0x0
21f1457c:	e3a02010 	mov	r2, #16	; 0x10
21f14580:	eb003c10 	bl	21f235c8 <simple_strtoul>
21f14584:	e1a03000 	mov	r3, r0
21f14588:	e50b3010 	str	r3, [fp, #-16]
	if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
21f1458c:	e51b3010 	ldr	r3, [fp, #-16]
21f14590:	e3530000 	cmp	r3, #0	; 0x0
21f14594:	0a000002 	beq	21f145a4 <do_flinfo+0xe8>
21f14598:	e51b3010 	ldr	r3, [fp, #-16]
21f1459c:	e3530001 	cmp	r3, #1	; 0x1
21f145a0:	9a000005 	bls	21f145bc <do_flinfo+0x100>
		printf ("Only FLASH Banks # 1 ... # %d supported\n",
21f145a4:	e59f007c 	ldr	r0, [pc, #124]	; 21f14628 <.text+0x14628>
21f145a8:	e3a01001 	mov	r1, #1	; 0x1
21f145ac:	eb001d36 	bl	21f1ba8c <printf>
			CFG_MAX_FLASH_BANKS);
		return 1;
21f145b0:	e3a03001 	mov	r3, #1	; 0x1
21f145b4:	e50b3024 	str	r3, [fp, #-36]
21f145b8:	ea000014 	b	21f14610 <do_flinfo+0x154>
	}
	printf ("\nBank # %ld: ", bank);
21f145bc:	e59f005c 	ldr	r0, [pc, #92]	; 21f14620 <.text+0x14620>
21f145c0:	e51b1010 	ldr	r1, [fp, #-16]
21f145c4:	eb001d30 	bl	21f1ba8c <printf>
	flash_print_info (&flash_info[bank-1]);
21f145c8:	e51b2010 	ldr	r2, [fp, #-16]
21f145cc:	e1a03002 	mov	r3, r2
21f145d0:	e1a03183 	mov	r3, r3, lsl #3
21f145d4:	e0833002 	add	r3, r3, r2
21f145d8:	e1a03083 	mov	r3, r3, lsl #1
21f145dc:	e0833002 	add	r3, r3, r2
21f145e0:	e1a02203 	mov	r2, r3, lsl #4
21f145e4:	e0833002 	add	r3, r3, r2
21f145e8:	e1a03103 	mov	r3, r3, lsl #2
21f145ec:	e1a02003 	mov	r2, r3
21f145f0:	e59f302c 	ldr	r3, [pc, #44]	; 21f14624 <.text+0x14624>
21f145f4:	e2433c05 	sub	r3, r3, #1280	; 0x500
21f145f8:	e243300c 	sub	r3, r3, #12	; 0xc
21f145fc:	e0823003 	add	r3, r2, r3
21f14600:	e1a00003 	mov	r0, r3
21f14604:	eb00613b 	bl	21f2caf8 <flash_print_info>
	return 0;
21f14608:	e3a03000 	mov	r3, #0	; 0x0
21f1460c:	e50b3024 	str	r3, [fp, #-36]
21f14610:	e51b3024 	ldr	r3, [fp, #-36]
}
21f14614:	e1a00003 	mov	r0, r3
21f14618:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1461c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f14620:	21f30b98 	ldrcsb	r0, [r3, #184]!
21f14624:	21f68ca0 	mvncss	r8, r0, lsr #25
21f14628:	21f30ba8 	mvncss	r0, r8, lsr #23

21f1462c <do_flerase>:

int do_flerase (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f1462c:	e1a0c00d 	mov	ip, sp
21f14630:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f14634:	e24cb004 	sub	fp, ip, #4	; 0x4
21f14638:	e24dd034 	sub	sp, sp, #52	; 0x34
21f1463c:	e50b0030 	str	r0, [fp, #-48]
21f14640:	e50b1034 	str	r1, [fp, #-52]
21f14644:	e50b2038 	str	r2, [fp, #-56]
21f14648:	e50b303c 	str	r3, [fp, #-60]
	flash_info_t *info;
	ulong bank, addr_first, addr_last;
	int n, sect_first, sect_last;
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	struct mtd_device *dev;
	struct part_info *part;
	u8 dev_type, dev_num, pnum;
#endif
	int rcode = 0;
21f1464c:	e3a03000 	mov	r3, #0	; 0x0
21f14650:	e50b3010 	str	r3, [fp, #-16]

	if (argc < 2) {
21f14654:	e51b3038 	ldr	r3, [fp, #-56]
21f14658:	e3530001 	cmp	r3, #1	; 0x1
21f1465c:	ca000007 	bgt	21f14680 <do_flerase+0x54>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f14660:	e51b3030 	ldr	r3, [fp, #-48]
21f14664:	e5933010 	ldr	r3, [r3, #16]
21f14668:	e59f03b4 	ldr	r0, [pc, #948]	; 21f14a24 <.text+0x14a24>
21f1466c:	e1a01003 	mov	r1, r3
21f14670:	eb001d05 	bl	21f1ba8c <printf>
		return 1;
21f14674:	e3a03001 	mov	r3, #1	; 0x1
21f14678:	e50b3040 	str	r3, [fp, #-64]
21f1467c:	ea0000e4 	b	21f14a14 <do_flerase+0x3e8>
	}

	if (strcmp(argv[1], "all") == 0) {
21f14680:	e51b303c 	ldr	r3, [fp, #-60]
21f14684:	e2833004 	add	r3, r3, #4	; 0x4
21f14688:	e5933000 	ldr	r3, [r3]
21f1468c:	e1a00003 	mov	r0, r3
21f14690:	e59f1390 	ldr	r1, [pc, #912]	; 21f14a28 <.text+0x14a28>
21f14694:	eb0038ac 	bl	21f2294c <strcmp>
21f14698:	e1a03000 	mov	r3, r0
21f1469c:	e3530000 	cmp	r3, #0	; 0x0
21f146a0:	1a000027 	bne	21f14744 <do_flerase+0x118>
		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
21f146a4:	e3a03001 	mov	r3, #1	; 0x1
21f146a8:	e50b3018 	str	r3, [fp, #-24]
21f146ac:	ea00001e 	b	21f1472c <do_flerase+0x100>
			printf ("Erase Flash Bank # %ld ", bank);
21f146b0:	e59f0374 	ldr	r0, [pc, #884]	; 21f14a2c <.text+0x14a2c>
21f146b4:	e51b1018 	ldr	r1, [fp, #-24]
21f146b8:	eb001cf3 	bl	21f1ba8c <printf>
			info = &flash_info[bank-1];
21f146bc:	e51b2018 	ldr	r2, [fp, #-24]
21f146c0:	e1a03002 	mov	r3, r2
21f146c4:	e1a03183 	mov	r3, r3, lsl #3
21f146c8:	e0833002 	add	r3, r3, r2
21f146cc:	e1a03083 	mov	r3, r3, lsl #1
21f146d0:	e0833002 	add	r3, r3, r2
21f146d4:	e1a02203 	mov	r2, r3, lsl #4
21f146d8:	e0833002 	add	r3, r3, r2
21f146dc:	e1a03103 	mov	r3, r3, lsl #2
21f146e0:	e1a02003 	mov	r2, r3
21f146e4:	e59f3344 	ldr	r3, [pc, #836]	; 21f14a30 <.text+0x14a30>
21f146e8:	e2433c05 	sub	r3, r3, #1280	; 0x500
21f146ec:	e243300c 	sub	r3, r3, #12	; 0xc
21f146f0:	e0823003 	add	r3, r2, r3
21f146f4:	e50b301c 	str	r3, [fp, #-28]
			rcode = flash_erase (info, 0, info->sector_count-1);
21f146f8:	e51b201c 	ldr	r2, [fp, #-28]
21f146fc:	e51b301c 	ldr	r3, [fp, #-28]
21f14700:	e1d330b4 	ldrh	r3, [r3, #4]
21f14704:	e2433001 	sub	r3, r3, #1	; 0x1
21f14708:	e1a00002 	mov	r0, r2
21f1470c:	e3a01000 	mov	r1, #0	; 0x0
21f14710:	e1a02003 	mov	r2, r3
21f14714:	eb00617a 	bl	21f2cd04 <flash_erase>
21f14718:	e1a03000 	mov	r3, r0
21f1471c:	e50b3010 	str	r3, [fp, #-16]
21f14720:	e51b3018 	ldr	r3, [fp, #-24]
21f14724:	e2833001 	add	r3, r3, #1	; 0x1
21f14728:	e50b3018 	str	r3, [fp, #-24]
21f1472c:	e51b3018 	ldr	r3, [fp, #-24]
21f14730:	e3530001 	cmp	r3, #1	; 0x1
21f14734:	9affffdd 	bls	21f146b0 <do_flerase+0x84>
		}
		return rcode;
21f14738:	e51b3010 	ldr	r3, [fp, #-16]
21f1473c:	e50b3040 	str	r3, [fp, #-64]
21f14740:	ea0000b3 	b	21f14a14 <do_flerase+0x3e8>
	}

	if ((n = abbrev_spec(argv[1], &info, &sect_first, &sect_last)) != 0) {
21f14744:	e51b303c 	ldr	r3, [fp, #-60]
21f14748:	e2833004 	add	r3, r3, #4	; 0x4
21f1474c:	e5933000 	ldr	r3, [r3]
21f14750:	e24b201c 	sub	r2, fp, #28	; 0x1c
21f14754:	e24bc028 	sub	ip, fp, #40	; 0x28
21f14758:	e24be02c 	sub	lr, fp, #44	; 0x2c
21f1475c:	e1a00003 	mov	r0, r3
21f14760:	e1a01002 	mov	r1, r2
21f14764:	e1a0200c 	mov	r2, ip
21f14768:	e1a0300e 	mov	r3, lr
21f1476c:	ebfffce6 	bl	21f13b0c <abbrev_spec>
21f14770:	e1a03000 	mov	r3, r0
21f14774:	e50b3014 	str	r3, [fp, #-20]
21f14778:	e51b3014 	ldr	r3, [fp, #-20]
21f1477c:	e3530000 	cmp	r3, #0	; 0x0
21f14780:	0a000032 	beq	21f14850 <do_flerase+0x224>
		if (n < 0) {
21f14784:	e51b3014 	ldr	r3, [fp, #-20]
21f14788:	e3530000 	cmp	r3, #0	; 0x0
21f1478c:	aa000004 	bge	21f147a4 <do_flerase+0x178>
			puts ("Bad sector specification\n");
21f14790:	e59f029c 	ldr	r0, [pc, #668]	; 21f14a34 <.text+0x14a34>
21f14794:	eb001ca9 	bl	21f1ba40 <puts>
			return 1;
21f14798:	e3a03001 	mov	r3, #1	; 0x1
21f1479c:	e50b3040 	str	r3, [fp, #-64]
21f147a0:	ea00009b 	b	21f14a14 <do_flerase+0x3e8>
		}
		printf ("Erase Flash Sectors %d-%d in Bank # %d ",
21f147a4:	e51bc028 	ldr	ip, [fp, #-40]
21f147a8:	e51be02c 	ldr	lr, [fp, #-44]
21f147ac:	e51b301c 	ldr	r3, [fp, #-28]
21f147b0:	e1a02003 	mov	r2, r3
21f147b4:	e59f3274 	ldr	r3, [pc, #628]	; 21f14a30 <.text+0x14a30>
21f147b8:	e0633002 	rsb	r3, r3, r2
21f147bc:	e1a01143 	mov	r1, r3, asr #2
21f147c0:	e1a02001 	mov	r2, r1
21f147c4:	e1a02182 	mov	r2, r2, lsl #3
21f147c8:	e0612002 	rsb	r2, r1, r2
21f147cc:	e1a02102 	mov	r2, r2, lsl #2
21f147d0:	e0822001 	add	r2, r2, r1
21f147d4:	e1a03302 	mov	r3, r2, lsl #6
21f147d8:	e0822003 	add	r2, r2, r3
21f147dc:	e1a02302 	mov	r2, r2, lsl #6
21f147e0:	e0612002 	rsb	r2, r1, r2
21f147e4:	e1a02182 	mov	r2, r2, lsl #3
21f147e8:	e0822001 	add	r2, r2, r1
21f147ec:	e1a03282 	mov	r3, r2, lsl #5
21f147f0:	e0623003 	rsb	r3, r2, r3
21f147f4:	e1a03183 	mov	r3, r3, lsl #3
21f147f8:	e0613003 	rsb	r3, r1, r3
21f147fc:	e1a03103 	mov	r3, r3, lsl #2
21f14800:	e0613003 	rsb	r3, r1, r3
21f14804:	e1a03103 	mov	r3, r3, lsl #2
21f14808:	e0613003 	rsb	r3, r1, r3
21f1480c:	e2833001 	add	r3, r3, #1	; 0x1
21f14810:	e59f0220 	ldr	r0, [pc, #544]	; 21f14a38 <.text+0x14a38>
21f14814:	e1a0100c 	mov	r1, ip
21f14818:	e1a0200e 	mov	r2, lr
21f1481c:	eb001c9a 	bl	21f1ba8c <printf>
			sect_first, sect_last, (info-flash_info)+1);
		rcode = flash_erase(info, sect_first, sect_last);
21f14820:	e51b301c 	ldr	r3, [fp, #-28]
21f14824:	e51b2028 	ldr	r2, [fp, #-40]
21f14828:	e51bc02c 	ldr	ip, [fp, #-44]
21f1482c:	e1a00003 	mov	r0, r3
21f14830:	e1a01002 	mov	r1, r2
21f14834:	e1a0200c 	mov	r2, ip
21f14838:	eb006131 	bl	21f2cd04 <flash_erase>
21f1483c:	e1a03000 	mov	r3, r0
21f14840:	e50b3010 	str	r3, [fp, #-16]
		return rcode;
21f14844:	e51b3010 	ldr	r3, [fp, #-16]
21f14848:	e50b3040 	str	r3, [fp, #-64]
21f1484c:	ea000070 	b	21f14a14 <do_flerase+0x3e8>
	}

#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	/* erase <part-id> - erase partition */
	if ((argc == 2) && (id_parse(argv[1], NULL, &dev_type, &dev_num) == 0)) {
		mtdparts_init();
		if (find_dev_and_part(argv[1], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
				bank = dev->id->num;
				info = &flash_info[bank];
				addr_first = part->offset + info->start[0];
				addr_last = addr_first + part->size - 1;

				printf ("Erase Flash Parition %s, "
						"bank %d, 0x%08lx - 0x%08lx ",
						argv[1], bank, addr_first,
						addr_last);

				rcode = flash_sect_erase(addr_first, addr_last);
				return rcode;
			}

			printf("cannot erase, not a NOR device\n");
			return 1;
		}
	}
#endif

	if (argc != 3) {
21f14850:	e51b3038 	ldr	r3, [fp, #-56]
21f14854:	e3530003 	cmp	r3, #3	; 0x3
21f14858:	0a000007 	beq	21f1487c <do_flerase+0x250>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f1485c:	e51b3030 	ldr	r3, [fp, #-48]
21f14860:	e5933010 	ldr	r3, [r3, #16]
21f14864:	e59f01b8 	ldr	r0, [pc, #440]	; 21f14a24 <.text+0x14a24>
21f14868:	e1a01003 	mov	r1, r3
21f1486c:	eb001c86 	bl	21f1ba8c <printf>
		return 1;
21f14870:	e3a03001 	mov	r3, #1	; 0x1
21f14874:	e50b3040 	str	r3, [fp, #-64]
21f14878:	ea000065 	b	21f14a14 <do_flerase+0x3e8>
	}

	if (strcmp(argv[1], "bank") == 0) {
21f1487c:	e51b303c 	ldr	r3, [fp, #-60]
21f14880:	e2833004 	add	r3, r3, #4	; 0x4
21f14884:	e5933000 	ldr	r3, [r3]
21f14888:	e1a00003 	mov	r0, r3
21f1488c:	e59f11a8 	ldr	r1, [pc, #424]	; 21f14a3c <.text+0x14a3c>
21f14890:	eb00382d 	bl	21f2294c <strcmp>
21f14894:	e1a03000 	mov	r3, r0
21f14898:	e3530000 	cmp	r3, #0	; 0x0
21f1489c:	1a000033 	bne	21f14970 <do_flerase+0x344>
		bank = simple_strtoul(argv[2], NULL, 16);
21f148a0:	e51b303c 	ldr	r3, [fp, #-60]
21f148a4:	e2833008 	add	r3, r3, #8	; 0x8
21f148a8:	e5933000 	ldr	r3, [r3]
21f148ac:	e1a00003 	mov	r0, r3
21f148b0:	e3a01000 	mov	r1, #0	; 0x0
21f148b4:	e3a02010 	mov	r2, #16	; 0x10
21f148b8:	eb003b42 	bl	21f235c8 <simple_strtoul>
21f148bc:	e1a03000 	mov	r3, r0
21f148c0:	e50b3018 	str	r3, [fp, #-24]
		if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
21f148c4:	e51b3018 	ldr	r3, [fp, #-24]
21f148c8:	e3530000 	cmp	r3, #0	; 0x0
21f148cc:	0a000002 	beq	21f148dc <do_flerase+0x2b0>
21f148d0:	e51b3018 	ldr	r3, [fp, #-24]
21f148d4:	e3530001 	cmp	r3, #1	; 0x1
21f148d8:	9a000005 	bls	21f148f4 <do_flerase+0x2c8>
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
21f148dc:	e59f015c 	ldr	r0, [pc, #348]	; 21f14a40 <.text+0x14a40>
21f148e0:	e3a01001 	mov	r1, #1	; 0x1
21f148e4:	eb001c68 	bl	21f1ba8c <printf>
				CFG_MAX_FLASH_BANKS);
			return 1;
21f148e8:	e3a03001 	mov	r3, #1	; 0x1
21f148ec:	e50b3040 	str	r3, [fp, #-64]
21f148f0:	ea000047 	b	21f14a14 <do_flerase+0x3e8>
		}
		printf ("Erase Flash Bank # %ld ", bank);
21f148f4:	e59f0130 	ldr	r0, [pc, #304]	; 21f14a2c <.text+0x14a2c>
21f148f8:	e51b1018 	ldr	r1, [fp, #-24]
21f148fc:	eb001c62 	bl	21f1ba8c <printf>
		info = &flash_info[bank-1];
21f14900:	e51b2018 	ldr	r2, [fp, #-24]
21f14904:	e1a03002 	mov	r3, r2
21f14908:	e1a03183 	mov	r3, r3, lsl #3
21f1490c:	e0833002 	add	r3, r3, r2
21f14910:	e1a03083 	mov	r3, r3, lsl #1
21f14914:	e0833002 	add	r3, r3, r2
21f14918:	e1a02203 	mov	r2, r3, lsl #4
21f1491c:	e0833002 	add	r3, r3, r2
21f14920:	e1a03103 	mov	r3, r3, lsl #2
21f14924:	e1a02003 	mov	r2, r3
21f14928:	e59f3100 	ldr	r3, [pc, #256]	; 21f14a30 <.text+0x14a30>
21f1492c:	e2433c05 	sub	r3, r3, #1280	; 0x500
21f14930:	e243300c 	sub	r3, r3, #12	; 0xc
21f14934:	e0823003 	add	r3, r2, r3
21f14938:	e50b301c 	str	r3, [fp, #-28]
		rcode = flash_erase (info, 0, info->sector_count-1);
21f1493c:	e51b201c 	ldr	r2, [fp, #-28]
21f14940:	e51b301c 	ldr	r3, [fp, #-28]
21f14944:	e1d330b4 	ldrh	r3, [r3, #4]
21f14948:	e2433001 	sub	r3, r3, #1	; 0x1
21f1494c:	e1a00002 	mov	r0, r2
21f14950:	e3a01000 	mov	r1, #0	; 0x0
21f14954:	e1a02003 	mov	r2, r3
21f14958:	eb0060e9 	bl	21f2cd04 <flash_erase>
21f1495c:	e1a03000 	mov	r3, r0
21f14960:	e50b3010 	str	r3, [fp, #-16]
		return rcode;
21f14964:	e51b3010 	ldr	r3, [fp, #-16]
21f14968:	e50b3040 	str	r3, [fp, #-64]
21f1496c:	ea000028 	b	21f14a14 <do_flerase+0x3e8>
	}

	if (addr_spec(argv[1], argv[2], &addr_first, &addr_last) < 0){
21f14970:	e51b303c 	ldr	r3, [fp, #-60]
21f14974:	e2833004 	add	r3, r3, #4	; 0x4
21f14978:	e5931000 	ldr	r1, [r3]
21f1497c:	e51b303c 	ldr	r3, [fp, #-60]
21f14980:	e2833008 	add	r3, r3, #8	; 0x8
21f14984:	e5933000 	ldr	r3, [r3]
21f14988:	e24b2020 	sub	r2, fp, #32	; 0x20
21f1498c:	e24bc024 	sub	ip, fp, #36	; 0x24
21f14990:	e1a00001 	mov	r0, r1
21f14994:	e1a01003 	mov	r1, r3
21f14998:	e1a0300c 	mov	r3, ip
21f1499c:	ebfffcf9 	bl	21f13d88 <addr_spec>
21f149a0:	e1a03000 	mov	r3, r0
21f149a4:	e3530000 	cmp	r3, #0	; 0x0
21f149a8:	aa000004 	bge	21f149c0 <do_flerase+0x394>
		printf ("Bad address format\n");
21f149ac:	e59f0090 	ldr	r0, [pc, #144]	; 21f14a44 <.text+0x14a44>
21f149b0:	eb001c35 	bl	21f1ba8c <printf>
		return 1;
21f149b4:	e3a03001 	mov	r3, #1	; 0x1
21f149b8:	e50b3040 	str	r3, [fp, #-64]
21f149bc:	ea000014 	b	21f14a14 <do_flerase+0x3e8>
	}

	if (addr_first >= addr_last) {
21f149c0:	e51b2020 	ldr	r2, [fp, #-32]
21f149c4:	e51b3024 	ldr	r3, [fp, #-36]
21f149c8:	e1520003 	cmp	r2, r3
21f149cc:	3a000007 	bcc	21f149f0 <do_flerase+0x3c4>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f149d0:	e51b3030 	ldr	r3, [fp, #-48]
21f149d4:	e5933010 	ldr	r3, [r3, #16]
21f149d8:	e59f0044 	ldr	r0, [pc, #68]	; 21f14a24 <.text+0x14a24>
21f149dc:	e1a01003 	mov	r1, r3
21f149e0:	eb001c29 	bl	21f1ba8c <printf>
		return 1;
21f149e4:	e3a03001 	mov	r3, #1	; 0x1
21f149e8:	e50b3040 	str	r3, [fp, #-64]
21f149ec:	ea000008 	b	21f14a14 <do_flerase+0x3e8>
	}

	rcode = flash_sect_erase(addr_first, addr_last);
21f149f0:	e51b3020 	ldr	r3, [fp, #-32]
21f149f4:	e51b2024 	ldr	r2, [fp, #-36]
21f149f8:	e1a00003 	mov	r0, r3
21f149fc:	e1a01002 	mov	r1, r2
21f14a00:	eb000010 	bl	21f14a48 <flash_sect_erase>
21f14a04:	e1a03000 	mov	r3, r0
21f14a08:	e50b3010 	str	r3, [fp, #-16]
	return rcode;
21f14a0c:	e51b3010 	ldr	r3, [fp, #-16]
21f14a10:	e50b3040 	str	r3, [fp, #-64]
21f14a14:	e51b3040 	ldr	r3, [fp, #-64]
}
21f14a18:	e1a00003 	mov	r0, r3
21f14a1c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f14a20:	e89da800 	ldmia	sp, {fp, sp, pc}
21f14a24:	21f30bd4 	ldrcssb	r0, [r3, #180]!
21f14a28:	21f30be0 	mvncss	r0, r0, ror #23
21f14a2c:	21f30be4 	mvncss	r0, r4, ror #23
21f14a30:	21f68ca0 	mvncss	r8, r0, lsr #25
21f14a34:	21f30bfc 	ldrcssh	r0, [r3, #188]!
21f14a38:	21f30c18 	mvncss	r0, r8, lsl ip
21f14a3c:	21f30c40 	mvncss	r0, r0, asr #24
21f14a40:	21f30ba8 	mvncss	r0, r8, lsr #23
21f14a44:	21f30c48 	mvncss	r0, r8, asr #24

21f14a48 <flash_sect_erase>:

int flash_sect_erase (ulong addr_first, ulong addr_last)
{
21f14a48:	e1a0c00d 	mov	ip, sp
21f14a4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f14a50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f14a54:	e24dd028 	sub	sp, sp, #40	; 0x28
21f14a58:	e50b002c 	str	r0, [fp, #-44]
21f14a5c:	e50b1030 	str	r1, [fp, #-48]
	flash_info_t *info;
	ulong bank;
#ifdef CFG_MAX_FLASH_BANKS_DETECT
	int s_first[CFG_MAX_FLASH_BANKS_DETECT], s_last[CFG_MAX_FLASH_BANKS_DETECT];
#else
	int s_first[CFG_MAX_FLASH_BANKS], s_last[CFG_MAX_FLASH_BANKS];
#endif
	int erased = 0;
21f14a60:	e3a03000 	mov	r3, #0	; 0x0
21f14a64:	e50b3014 	str	r3, [fp, #-20]
	int planned;
	int rcode = 0;
21f14a68:	e3a03000 	mov	r3, #0	; 0x0
21f14a6c:	e50b3010 	str	r3, [fp, #-16]

	rcode = flash_fill_sect_ranges (addr_first, addr_last,
21f14a70:	e24b2020 	sub	r2, fp, #32	; 0x20
21f14a74:	e24bc024 	sub	ip, fp, #36	; 0x24
21f14a78:	e24b3028 	sub	r3, fp, #40	; 0x28
21f14a7c:	e58d3000 	str	r3, [sp]
21f14a80:	e51b002c 	ldr	r0, [fp, #-44]
21f14a84:	e51b1030 	ldr	r1, [fp, #-48]
21f14a88:	e1a0300c 	mov	r3, ip
21f14a8c:	ebfffd73 	bl	21f14060 <flash_fill_sect_ranges>
21f14a90:	e1a03000 	mov	r3, r0
21f14a94:	e50b3010 	str	r3, [fp, #-16]
					s_first, s_last, &planned );

	if (planned && (rcode == 0)) {
21f14a98:	e51b3028 	ldr	r3, [fp, #-40]
21f14a9c:	e3530000 	cmp	r3, #0	; 0x0
21f14aa0:	0a000047 	beq	21f14bc4 <flash_sect_erase+0x17c>
21f14aa4:	e51b3010 	ldr	r3, [fp, #-16]
21f14aa8:	e3530000 	cmp	r3, #0	; 0x0
21f14aac:	1a000044 	bne	21f14bc4 <flash_sect_erase+0x17c>
		for (bank=0,info=&flash_info[0];
21f14ab0:	e3a03000 	mov	r3, #0	; 0x0
21f14ab4:	e50b3018 	str	r3, [fp, #-24]
21f14ab8:	e59f3130 	ldr	r3, [pc, #304]	; 21f14bf0 <.text+0x14bf0>
21f14abc:	e50b301c 	str	r3, [fp, #-28]
		     (bank < CFG_MAX_FLASH_BANKS) && (rcode == 0);
21f14ac0:	ea000035 	b	21f14b9c <flash_sect_erase+0x154>
		     ++bank, ++info) {
			if (s_first[bank]>=0) {
21f14ac4:	e51b3018 	ldr	r3, [fp, #-24]
21f14ac8:	e3e02013 	mvn	r2, #19	; 0x13
21f14acc:	e1a03103 	mov	r3, r3, lsl #2
21f14ad0:	e24b000c 	sub	r0, fp, #12	; 0xc
21f14ad4:	e0833000 	add	r3, r3, r0
21f14ad8:	e0833002 	add	r3, r3, r2
21f14adc:	e5933000 	ldr	r3, [r3]
21f14ae0:	e3530000 	cmp	r3, #0	; 0x0
21f14ae4:	ba000025 	blt	21f14b80 <flash_sect_erase+0x138>
				erased += s_last[bank] - s_first[bank] + 1;
21f14ae8:	e51b3018 	ldr	r3, [fp, #-24]
21f14aec:	e3e02017 	mvn	r2, #23	; 0x17
21f14af0:	e1a03103 	mov	r3, r3, lsl #2
21f14af4:	e24b100c 	sub	r1, fp, #12	; 0xc
21f14af8:	e0833001 	add	r3, r3, r1
21f14afc:	e0833002 	add	r3, r3, r2
21f14b00:	e5931000 	ldr	r1, [r3]
21f14b04:	e51b3018 	ldr	r3, [fp, #-24]
21f14b08:	e3e02013 	mvn	r2, #19	; 0x13
21f14b0c:	e1a03103 	mov	r3, r3, lsl #2
21f14b10:	e24b000c 	sub	r0, fp, #12	; 0xc
21f14b14:	e0833000 	add	r3, r3, r0
21f14b18:	e0833002 	add	r3, r3, r2
21f14b1c:	e5933000 	ldr	r3, [r3]
21f14b20:	e0632001 	rsb	r2, r3, r1
21f14b24:	e51b3014 	ldr	r3, [fp, #-20]
21f14b28:	e0823003 	add	r3, r2, r3
21f14b2c:	e2833001 	add	r3, r3, #1	; 0x1
21f14b30:	e50b3014 	str	r3, [fp, #-20]
				debug ("Erase Flash from 0x%08lx to 0x%08lx "
					"in Bank # %ld ",
					info->start[s_first[bank]],
					(s_last[bank] == info->sector_count) ?
						info->start[0] + info->size - 1:
						info->start[s_last[bank]+1] - 1,
					bank+1);
				rcode = flash_erase (info, s_first[bank], s_last[bank]);
21f14b34:	e51b3018 	ldr	r3, [fp, #-24]
21f14b38:	e3e02013 	mvn	r2, #19	; 0x13
21f14b3c:	e1a03103 	mov	r3, r3, lsl #2
21f14b40:	e24b100c 	sub	r1, fp, #12	; 0xc
21f14b44:	e0833001 	add	r3, r3, r1
21f14b48:	e0833002 	add	r3, r3, r2
21f14b4c:	e5931000 	ldr	r1, [r3]
21f14b50:	e51b3018 	ldr	r3, [fp, #-24]
21f14b54:	e3e02017 	mvn	r2, #23	; 0x17
21f14b58:	e1a03103 	mov	r3, r3, lsl #2
21f14b5c:	e24b000c 	sub	r0, fp, #12	; 0xc
21f14b60:	e0833000 	add	r3, r3, r0
21f14b64:	e0833002 	add	r3, r3, r2
21f14b68:	e5933000 	ldr	r3, [r3]
21f14b6c:	e51b001c 	ldr	r0, [fp, #-28]
21f14b70:	e1a02003 	mov	r2, r3
21f14b74:	eb006062 	bl	21f2cd04 <flash_erase>
21f14b78:	e1a03000 	mov	r3, r0
21f14b7c:	e50b3010 	str	r3, [fp, #-16]
21f14b80:	e51b3018 	ldr	r3, [fp, #-24]
21f14b84:	e2833001 	add	r3, r3, #1	; 0x1
21f14b88:	e50b3018 	str	r3, [fp, #-24]
21f14b8c:	e51b301c 	ldr	r3, [fp, #-28]
21f14b90:	e2833c05 	add	r3, r3, #1280	; 0x500
21f14b94:	e283300c 	add	r3, r3, #12	; 0xc
21f14b98:	e50b301c 	str	r3, [fp, #-28]
21f14b9c:	e51b3018 	ldr	r3, [fp, #-24]
21f14ba0:	e3530000 	cmp	r3, #0	; 0x0
21f14ba4:	1a000002 	bne	21f14bb4 <flash_sect_erase+0x16c>
21f14ba8:	e51b3010 	ldr	r3, [fp, #-16]
21f14bac:	e3530000 	cmp	r3, #0	; 0x0
21f14bb0:	0affffc3 	beq	21f14ac4 <flash_sect_erase+0x7c>
			}
		}
		printf ("Erased %d sectors\n", erased);
21f14bb4:	e59f0038 	ldr	r0, [pc, #56]	; 21f14bf4 <.text+0x14bf4>
21f14bb8:	e51b1014 	ldr	r1, [fp, #-20]
21f14bbc:	eb001bb2 	bl	21f1ba8c <printf>
21f14bc0:	ea000006 	b	21f14be0 <flash_sect_erase+0x198>
	} else if (rcode == 0) {
21f14bc4:	e51b3010 	ldr	r3, [fp, #-16]
21f14bc8:	e3530000 	cmp	r3, #0	; 0x0
21f14bcc:	1a000003 	bne	21f14be0 <flash_sect_erase+0x198>
		puts ("Error: start and/or end address"
21f14bd0:	e59f0020 	ldr	r0, [pc, #32]	; 21f14bf8 <.text+0x14bf8>
21f14bd4:	eb001b99 	bl	21f1ba40 <puts>
			" not on sector boundary\n");
		rcode = 1;
21f14bd8:	e3a03001 	mov	r3, #1	; 0x1
21f14bdc:	e50b3010 	str	r3, [fp, #-16]
	}
	return rcode;
21f14be0:	e51b3010 	ldr	r3, [fp, #-16]
}
21f14be4:	e1a00003 	mov	r0, r3
21f14be8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f14bec:	e89da800 	ldmia	sp, {fp, sp, pc}
21f14bf0:	21f68ca0 	mvncss	r8, r0, lsr #25
21f14bf4:	21f30c5c 	mvncss	r0, ip, asr ip
21f14bf8:	21f30c70 	mvncss	r0, r0, ror ip

21f14bfc <do_protect>:

int do_protect (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f14bfc:	e1a0c00d 	mov	ip, sp
21f14c00:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f14c04:	e24cb004 	sub	fp, ip, #4	; 0x4
21f14c08:	e24dd054 	sub	sp, sp, #84	; 0x54
21f14c0c:	e50b003c 	str	r0, [fp, #-60]
21f14c10:	e50b1040 	str	r1, [fp, #-64]
21f14c14:	e50b2044 	str	r2, [fp, #-68]
21f14c18:	e50b3048 	str	r3, [fp, #-72]
	flash_info_t *info;
	ulong bank, addr_first, addr_last;
	int i, p, n, sect_first, sect_last;
#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	struct mtd_device *dev;
	struct part_info *part;
	u8 dev_type, dev_num, pnum;
#endif
	int rcode = 0;
21f14c1c:	e3a03000 	mov	r3, #0	; 0x0
21f14c20:	e50b3014 	str	r3, [fp, #-20]
#ifdef CONFIG_HAS_DATAFLASH
	int status;
#endif

	if (argc < 3) {
21f14c24:	e51b3044 	ldr	r3, [fp, #-68]
21f14c28:	e3530002 	cmp	r3, #2	; 0x2
21f14c2c:	ca000007 	bgt	21f14c50 <do_protect+0x54>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f14c30:	e51b303c 	ldr	r3, [fp, #-60]
21f14c34:	e5933010 	ldr	r3, [r3, #16]
21f14c38:	e59f06ac 	ldr	r0, [pc, #1708]	; 21f152ec <.text+0x152ec>
21f14c3c:	e1a01003 	mov	r1, r3
21f14c40:	eb001b91 	bl	21f1ba8c <printf>
		return 1;
21f14c44:	e3a03001 	mov	r3, #1	; 0x1
21f14c48:	e50b305c 	str	r3, [fp, #-92]
21f14c4c:	ea0001a2 	b	21f152dc <do_protect+0x6e0>
	}

	if (strcmp(argv[1], "off") == 0) {
21f14c50:	e51b3048 	ldr	r3, [fp, #-72]
21f14c54:	e2833004 	add	r3, r3, #4	; 0x4
21f14c58:	e5933000 	ldr	r3, [r3]
21f14c5c:	e1a00003 	mov	r0, r3
21f14c60:	e59f1688 	ldr	r1, [pc, #1672]	; 21f152f0 <.text+0x152f0>
21f14c64:	eb003738 	bl	21f2294c <strcmp>
21f14c68:	e1a03000 	mov	r3, r0
21f14c6c:	e3530000 	cmp	r3, #0	; 0x0
21f14c70:	1a000002 	bne	21f14c80 <do_protect+0x84>
		p = 0;
21f14c74:	e3a03000 	mov	r3, #0	; 0x0
21f14c78:	e50b301c 	str	r3, [fp, #-28]
21f14c7c:	ea000013 	b	21f14cd0 <do_protect+0xd4>
	} else if (strcmp(argv[1], "on") == 0) {
21f14c80:	e51b3048 	ldr	r3, [fp, #-72]
21f14c84:	e2833004 	add	r3, r3, #4	; 0x4
21f14c88:	e5933000 	ldr	r3, [r3]
21f14c8c:	e1a00003 	mov	r0, r3
21f14c90:	e59f165c 	ldr	r1, [pc, #1628]	; 21f152f4 <.text+0x152f4>
21f14c94:	eb00372c 	bl	21f2294c <strcmp>
21f14c98:	e1a03000 	mov	r3, r0
21f14c9c:	e3530000 	cmp	r3, #0	; 0x0
21f14ca0:	1a000002 	bne	21f14cb0 <do_protect+0xb4>
		p = 1;
21f14ca4:	e3a03001 	mov	r3, #1	; 0x1
21f14ca8:	e50b301c 	str	r3, [fp, #-28]
21f14cac:	ea000007 	b	21f14cd0 <do_protect+0xd4>
	} else {
		printf ("Usage:\n%s\n", cmdtp->usage);
21f14cb0:	e51b303c 	ldr	r3, [fp, #-60]
21f14cb4:	e5933010 	ldr	r3, [r3, #16]
21f14cb8:	e59f062c 	ldr	r0, [pc, #1580]	; 21f152ec <.text+0x152ec>
21f14cbc:	e1a01003 	mov	r1, r3
21f14cc0:	eb001b71 	bl	21f1ba8c <printf>
		return 1;
21f14cc4:	e3a03001 	mov	r3, #1	; 0x1
21f14cc8:	e50b305c 	str	r3, [fp, #-92]
21f14ccc:	ea000182 	b	21f152dc <do_protect+0x6e0>
	}

#ifdef CONFIG_HAS_DATAFLASH
	if ((strcmp(argv[2], "all") != 0) && (strcmp(argv[2], "bank") != 0)) {
21f14cd0:	e51b3048 	ldr	r3, [fp, #-72]
21f14cd4:	e2833008 	add	r3, r3, #8	; 0x8
21f14cd8:	e5933000 	ldr	r3, [r3]
21f14cdc:	e1a00003 	mov	r0, r3
21f14ce0:	e59f1610 	ldr	r1, [pc, #1552]	; 21f152f8 <.text+0x152f8>
21f14ce4:	eb003718 	bl	21f2294c <strcmp>
21f14ce8:	e1a03000 	mov	r3, r0
21f14cec:	e3530000 	cmp	r3, #0	; 0x0
21f14cf0:	0a000044 	beq	21f14e08 <do_protect+0x20c>
21f14cf4:	e51b3048 	ldr	r3, [fp, #-72]
21f14cf8:	e2833008 	add	r3, r3, #8	; 0x8
21f14cfc:	e5933000 	ldr	r3, [r3]
21f14d00:	e1a00003 	mov	r0, r3
21f14d04:	e59f15f0 	ldr	r1, [pc, #1520]	; 21f152fc <.text+0x152fc>
21f14d08:	eb00370f 	bl	21f2294c <strcmp>
21f14d0c:	e1a03000 	mov	r3, r0
21f14d10:	e3530000 	cmp	r3, #0	; 0x0
21f14d14:	0a00003b 	beq	21f14e08 <do_protect+0x20c>
		addr_first = simple_strtoul(argv[2], NULL, 16);
21f14d18:	e51b3048 	ldr	r3, [fp, #-72]
21f14d1c:	e2833008 	add	r3, r3, #8	; 0x8
21f14d20:	e5933000 	ldr	r3, [r3]
21f14d24:	e1a00003 	mov	r0, r3
21f14d28:	e3a01000 	mov	r1, #0	; 0x0
21f14d2c:	e3a02010 	mov	r2, #16	; 0x10
21f14d30:	eb003a24 	bl	21f235c8 <simple_strtoul>
21f14d34:	e1a03000 	mov	r3, r0
21f14d38:	e50b302c 	str	r3, [fp, #-44]
		addr_last  = simple_strtoul(argv[3], NULL, 16);
21f14d3c:	e51b3048 	ldr	r3, [fp, #-72]
21f14d40:	e283300c 	add	r3, r3, #12	; 0xc
21f14d44:	e5933000 	ldr	r3, [r3]
21f14d48:	e1a00003 	mov	r0, r3
21f14d4c:	e3a01000 	mov	r1, #0	; 0x0
21f14d50:	e3a02010 	mov	r2, #16	; 0x10
21f14d54:	eb003a1b 	bl	21f235c8 <simple_strtoul>
21f14d58:	e1a03000 	mov	r3, r0
21f14d5c:	e50b3030 	str	r3, [fp, #-48]

		if (addr_dataflash(addr_first) && addr_dataflash(addr_last)) {
21f14d60:	e51b302c 	ldr	r3, [fp, #-44]
21f14d64:	e1a00003 	mov	r0, r3
21f14d68:	ebffede9 	bl	21f10514 <addr_dataflash>
21f14d6c:	e1a03000 	mov	r3, r0
21f14d70:	e3530000 	cmp	r3, #0	; 0x0
21f14d74:	0a000023 	beq	21f14e08 <do_protect+0x20c>
21f14d78:	e51b3030 	ldr	r3, [fp, #-48]
21f14d7c:	e1a00003 	mov	r0, r3
21f14d80:	ebffede3 	bl	21f10514 <addr_dataflash>
21f14d84:	e1a03000 	mov	r3, r0
21f14d88:	e3530000 	cmp	r3, #0	; 0x0
21f14d8c:	0a00001d 	beq	21f14e08 <do_protect+0x20c>
			status = dataflash_real_protect(p,addr_first,addr_last);
21f14d90:	e51b302c 	ldr	r3, [fp, #-44]
21f14d94:	e51b2030 	ldr	r2, [fp, #-48]
21f14d98:	e51b001c 	ldr	r0, [fp, #-28]
21f14d9c:	e1a01003 	mov	r1, r3
21f14da0:	ebffee74 	bl	21f10778 <dataflash_real_protect>
21f14da4:	e1a03000 	mov	r3, r0
21f14da8:	e50b3010 	str	r3, [fp, #-16]
			if (status < 0){
21f14dac:	e51b3010 	ldr	r3, [fp, #-16]
21f14db0:	e3530000 	cmp	r3, #0	; 0x0
21f14db4:	aa000004 	bge	21f14dcc <do_protect+0x1d0>
				puts ("Bad DataFlash sector specification\n");
21f14db8:	e59f0540 	ldr	r0, [pc, #1344]	; 21f15300 <.text+0x15300>
21f14dbc:	eb001b1f 	bl	21f1ba40 <puts>
				return 1;
21f14dc0:	e3a03001 	mov	r3, #1	; 0x1
21f14dc4:	e50b305c 	str	r3, [fp, #-92]
21f14dc8:	ea000143 	b	21f152dc <do_protect+0x6e0>
			}
			printf("%sProtect %d DataFlash Sectors\n",
21f14dcc:	e51b301c 	ldr	r3, [fp, #-28]
21f14dd0:	e3530000 	cmp	r3, #0	; 0x0
21f14dd4:	0a000002 	beq	21f14de4 <do_protect+0x1e8>
21f14dd8:	e59f3524 	ldr	r3, [pc, #1316]	; 21f15304 <.text+0x15304>
21f14ddc:	e50b3058 	str	r3, [fp, #-88]
21f14de0:	ea000001 	b	21f14dec <do_protect+0x1f0>
21f14de4:	e59f351c 	ldr	r3, [pc, #1308]	; 21f15308 <.text+0x15308>
21f14de8:	e50b3058 	str	r3, [fp, #-88]
21f14dec:	e59f0518 	ldr	r0, [pc, #1304]	; 21f1530c <.text+0x1530c>
21f14df0:	e51b1058 	ldr	r1, [fp, #-88]
21f14df4:	e51b2010 	ldr	r2, [fp, #-16]
21f14df8:	eb001b23 	bl	21f1ba8c <printf>
				p ? "" : "Un-", status);
			return 0;
21f14dfc:	e3a03000 	mov	r3, #0	; 0x0
21f14e00:	e50b305c 	str	r3, [fp, #-92]
21f14e04:	ea000134 	b	21f152dc <do_protect+0x6e0>
		}
	}
#endif

	if (strcmp(argv[2], "all") == 0) {
21f14e08:	e51b3048 	ldr	r3, [fp, #-72]
21f14e0c:	e2833008 	add	r3, r3, #8	; 0x8
21f14e10:	e5933000 	ldr	r3, [r3]
21f14e14:	e1a00003 	mov	r0, r3
21f14e18:	e59f14d8 	ldr	r1, [pc, #1240]	; 21f152f8 <.text+0x152f8>
21f14e1c:	eb0036ca 	bl	21f2294c <strcmp>
21f14e20:	e1a03000 	mov	r3, r0
21f14e24:	e3530000 	cmp	r3, #0	; 0x0
21f14e28:	1a000042 	bne	21f14f38 <do_protect+0x33c>
		for (bank=1; bank<=CFG_MAX_FLASH_BANKS; ++bank) {
21f14e2c:	e3a03001 	mov	r3, #1	; 0x1
21f14e30:	e50b3024 	str	r3, [fp, #-36]
21f14e34:	ea000039 	b	21f14f20 <do_protect+0x324>
			info = &flash_info[bank-1];
21f14e38:	e51b2024 	ldr	r2, [fp, #-36]
21f14e3c:	e1a03002 	mov	r3, r2
21f14e40:	e1a03183 	mov	r3, r3, lsl #3
21f14e44:	e0833002 	add	r3, r3, r2
21f14e48:	e1a03083 	mov	r3, r3, lsl #1
21f14e4c:	e0833002 	add	r3, r3, r2
21f14e50:	e1a02203 	mov	r2, r3, lsl #4
21f14e54:	e0833002 	add	r3, r3, r2
21f14e58:	e1a03103 	mov	r3, r3, lsl #2
21f14e5c:	e1a02003 	mov	r2, r3
21f14e60:	e59f34a8 	ldr	r3, [pc, #1192]	; 21f15310 <.text+0x15310>
21f14e64:	e2433c05 	sub	r3, r3, #1280	; 0x500
21f14e68:	e243300c 	sub	r3, r3, #12	; 0xc
21f14e6c:	e0823003 	add	r3, r2, r3
21f14e70:	e50b3028 	str	r3, [fp, #-40]
			if (info->flash_id == FLASH_UNKNOWN) {
21f14e74:	e51b3028 	ldr	r3, [fp, #-40]
21f14e78:	e5932008 	ldr	r2, [r3, #8]
21f14e7c:	e3a03cff 	mov	r3, #65280	; 0xff00
21f14e80:	e28330ff 	add	r3, r3, #255	; 0xff
21f14e84:	e1520003 	cmp	r2, r3
21f14e88:	0a000021 	beq	21f14f14 <do_protect+0x318>
				continue;
			}
			printf ("%sProtect Flash Bank # %ld\n",
21f14e8c:	e51b301c 	ldr	r3, [fp, #-28]
21f14e90:	e3530000 	cmp	r3, #0	; 0x0
21f14e94:	0a000002 	beq	21f14ea4 <do_protect+0x2a8>
21f14e98:	e59f3464 	ldr	r3, [pc, #1124]	; 21f15304 <.text+0x15304>
21f14e9c:	e50b3054 	str	r3, [fp, #-84]
21f14ea0:	ea000001 	b	21f14eac <do_protect+0x2b0>
21f14ea4:	e59f345c 	ldr	r3, [pc, #1116]	; 21f15308 <.text+0x15308>
21f14ea8:	e50b3054 	str	r3, [fp, #-84]
21f14eac:	e59f0460 	ldr	r0, [pc, #1120]	; 21f15314 <.text+0x15314>
21f14eb0:	e51b1054 	ldr	r1, [fp, #-84]
21f14eb4:	e51b2024 	ldr	r2, [fp, #-36]
21f14eb8:	eb001af3 	bl	21f1ba8c <printf>
				p ? "" : "Un-", bank);

			for (i=0; i<info->sector_count; ++i) {
21f14ebc:	e3a03000 	mov	r3, #0	; 0x0
21f14ec0:	e50b3020 	str	r3, [fp, #-32]
21f14ec4:	ea00000c 	b	21f14efc <do_protect+0x300>
#if defined(CFG_FLASH_PROTECTION)
				if (flash_real_protect(info, i, p))
					rcode = 1;
				putc ('.');
#else
				info->protect[i] = p;
21f14ec8:	e51b0028 	ldr	r0, [fp, #-40]
21f14ecc:	e51b2020 	ldr	r2, [fp, #-32]
21f14ed0:	e51b301c 	ldr	r3, [fp, #-28]
21f14ed4:	e20310ff 	and	r1, r3, #255	; 0xff
21f14ed8:	e3a03b01 	mov	r3, #1024	; 0x400
21f14edc:	e283300c 	add	r3, r3, #12	; 0xc
21f14ee0:	e0822000 	add	r2, r2, r0
21f14ee4:	e0822003 	add	r2, r2, r3
21f14ee8:	e1a03001 	mov	r3, r1
21f14eec:	e5c23000 	strb	r3, [r2]
21f14ef0:	e51b3020 	ldr	r3, [fp, #-32]
21f14ef4:	e2833001 	add	r3, r3, #1	; 0x1
21f14ef8:	e50b3020 	str	r3, [fp, #-32]
21f14efc:	e51b3028 	ldr	r3, [fp, #-40]
21f14f00:	e1d330b4 	ldrh	r3, [r3, #4]
21f14f04:	e1a02003 	mov	r2, r3
21f14f08:	e51b3020 	ldr	r3, [fp, #-32]
21f14f0c:	e1520003 	cmp	r2, r3
21f14f10:	caffffec 	bgt	21f14ec8 <do_protect+0x2cc>
21f14f14:	e51b3024 	ldr	r3, [fp, #-36]
21f14f18:	e2833001 	add	r3, r3, #1	; 0x1
21f14f1c:	e50b3024 	str	r3, [fp, #-36]
21f14f20:	e51b3024 	ldr	r3, [fp, #-36]
21f14f24:	e3530001 	cmp	r3, #1	; 0x1
21f14f28:	9affffc2 	bls	21f14e38 <do_protect+0x23c>
#endif	/* CFG_FLASH_PROTECTION */
			}
#if defined(CFG_FLASH_PROTECTION)
			if (!rcode) puts (" done\n");
#endif	/* CFG_FLASH_PROTECTION */
		}
		return rcode;
21f14f2c:	e51b3014 	ldr	r3, [fp, #-20]
21f14f30:	e50b305c 	str	r3, [fp, #-92]
21f14f34:	ea0000e8 	b	21f152dc <do_protect+0x6e0>
	}

	if ((n = abbrev_spec(argv[2], &info, &sect_first, &sect_last)) != 0) {
21f14f38:	e51b3048 	ldr	r3, [fp, #-72]
21f14f3c:	e2833008 	add	r3, r3, #8	; 0x8
21f14f40:	e5933000 	ldr	r3, [r3]
21f14f44:	e24b2028 	sub	r2, fp, #40	; 0x28
21f14f48:	e24bc034 	sub	ip, fp, #52	; 0x34
21f14f4c:	e24be038 	sub	lr, fp, #56	; 0x38
21f14f50:	e1a00003 	mov	r0, r3
21f14f54:	e1a01002 	mov	r1, r2
21f14f58:	e1a0200c 	mov	r2, ip
21f14f5c:	e1a0300e 	mov	r3, lr
21f14f60:	ebfffae9 	bl	21f13b0c <abbrev_spec>
21f14f64:	e1a03000 	mov	r3, r0
21f14f68:	e50b3018 	str	r3, [fp, #-24]
21f14f6c:	e51b3018 	ldr	r3, [fp, #-24]
21f14f70:	e3530000 	cmp	r3, #0	; 0x0
21f14f74:	0a000047 	beq	21f15098 <do_protect+0x49c>
		if (n < 0) {
21f14f78:	e51b3018 	ldr	r3, [fp, #-24]
21f14f7c:	e3530000 	cmp	r3, #0	; 0x0
21f14f80:	aa000004 	bge	21f14f98 <do_protect+0x39c>
			puts ("Bad sector specification\n");
21f14f84:	e59f038c 	ldr	r0, [pc, #908]	; 21f15318 <.text+0x15318>
21f14f88:	eb001aac 	bl	21f1ba40 <puts>
			return 1;
21f14f8c:	e3a03001 	mov	r3, #1	; 0x1
21f14f90:	e50b305c 	str	r3, [fp, #-92]
21f14f94:	ea0000d0 	b	21f152dc <do_protect+0x6e0>
		}
		printf("%sProtect Flash Sectors %d-%d in Bank # %d\n",
21f14f98:	e51b301c 	ldr	r3, [fp, #-28]
21f14f9c:	e3530000 	cmp	r3, #0	; 0x0
21f14fa0:	0a000002 	beq	21f14fb0 <do_protect+0x3b4>
21f14fa4:	e59f3358 	ldr	r3, [pc, #856]	; 21f15304 <.text+0x15304>
21f14fa8:	e50b3050 	str	r3, [fp, #-80]
21f14fac:	ea000001 	b	21f14fb8 <do_protect+0x3bc>
21f14fb0:	e59f3350 	ldr	r3, [pc, #848]	; 21f15308 <.text+0x15308>
21f14fb4:	e50b3050 	str	r3, [fp, #-80]
21f14fb8:	e51bc034 	ldr	ip, [fp, #-52]
21f14fbc:	e51be038 	ldr	lr, [fp, #-56]
21f14fc0:	e51b3028 	ldr	r3, [fp, #-40]
21f14fc4:	e1a02003 	mov	r2, r3
21f14fc8:	e59f3340 	ldr	r3, [pc, #832]	; 21f15310 <.text+0x15310>
21f14fcc:	e0633002 	rsb	r3, r3, r2
21f14fd0:	e1a01143 	mov	r1, r3, asr #2
21f14fd4:	e1a02001 	mov	r2, r1
21f14fd8:	e1a02182 	mov	r2, r2, lsl #3
21f14fdc:	e0612002 	rsb	r2, r1, r2
21f14fe0:	e1a02102 	mov	r2, r2, lsl #2
21f14fe4:	e0822001 	add	r2, r2, r1
21f14fe8:	e1a03302 	mov	r3, r2, lsl #6
21f14fec:	e0822003 	add	r2, r2, r3
21f14ff0:	e1a02302 	mov	r2, r2, lsl #6
21f14ff4:	e0612002 	rsb	r2, r1, r2
21f14ff8:	e1a02182 	mov	r2, r2, lsl #3
21f14ffc:	e0822001 	add	r2, r2, r1
21f15000:	e1a03282 	mov	r3, r2, lsl #5
21f15004:	e0623003 	rsb	r3, r2, r3
21f15008:	e1a03183 	mov	r3, r3, lsl #3
21f1500c:	e0613003 	rsb	r3, r1, r3
21f15010:	e1a03103 	mov	r3, r3, lsl #2
21f15014:	e0613003 	rsb	r3, r1, r3
21f15018:	e1a03103 	mov	r3, r3, lsl #2
21f1501c:	e0613003 	rsb	r3, r1, r3
21f15020:	e2833001 	add	r3, r3, #1	; 0x1
21f15024:	e58d3000 	str	r3, [sp]
21f15028:	e59f02ec 	ldr	r0, [pc, #748]	; 21f1531c <.text+0x1531c>
21f1502c:	e51b1050 	ldr	r1, [fp, #-80]
21f15030:	e1a0200c 	mov	r2, ip
21f15034:	e1a0300e 	mov	r3, lr
21f15038:	eb001a93 	bl	21f1ba8c <printf>
			p ? "" : "Un-", sect_first, sect_last,
			(info-flash_info)+1);
		for (i = sect_first; i <= sect_last; i++) {
21f1503c:	e51b3034 	ldr	r3, [fp, #-52]
21f15040:	e50b3020 	str	r3, [fp, #-32]
21f15044:	ea00000c 	b	21f1507c <do_protect+0x480>
#if defined(CFG_FLASH_PROTECTION)
			if (flash_real_protect(info, i, p))
				rcode =  1;
			putc ('.');
#else
			info->protect[i] = p;
21f15048:	e51b0028 	ldr	r0, [fp, #-40]
21f1504c:	e51b2020 	ldr	r2, [fp, #-32]
21f15050:	e51b301c 	ldr	r3, [fp, #-28]
21f15054:	e20310ff 	and	r1, r3, #255	; 0xff
21f15058:	e3a03b01 	mov	r3, #1024	; 0x400
21f1505c:	e283300c 	add	r3, r3, #12	; 0xc
21f15060:	e0822000 	add	r2, r2, r0
21f15064:	e0822003 	add	r2, r2, r3
21f15068:	e1a03001 	mov	r3, r1
21f1506c:	e5c23000 	strb	r3, [r2]
21f15070:	e51b3020 	ldr	r3, [fp, #-32]
21f15074:	e2833001 	add	r3, r3, #1	; 0x1
21f15078:	e50b3020 	str	r3, [fp, #-32]
21f1507c:	e51b2038 	ldr	r2, [fp, #-56]
21f15080:	e51b3020 	ldr	r3, [fp, #-32]
21f15084:	e1530002 	cmp	r3, r2
21f15088:	daffffee 	ble	21f15048 <do_protect+0x44c>
#endif	/* CFG_FLASH_PROTECTION */
		}

#if defined(CFG_FLASH_PROTECTION)
		if (!rcode) puts (" done\n");
#endif	/* CFG_FLASH_PROTECTION */

		return rcode;
21f1508c:	e51b3014 	ldr	r3, [fp, #-20]
21f15090:	e50b305c 	str	r3, [fp, #-92]
21f15094:	ea000090 	b	21f152dc <do_protect+0x6e0>
	}

#if (CONFIG_COMMANDS & CFG_CMD_JFFS2) && defined(CONFIG_JFFS2_CMDLINE)
	/* protect on/off <part-id> */
	if ((argc == 3) && (id_parse(argv[2], NULL, &dev_type, &dev_num) == 0)) {
		mtdparts_init();
		if (find_dev_and_part(argv[2], &dev, &pnum, &part) == 0) {
			if (dev->id->type == MTD_DEV_TYPE_NOR) {
				bank = dev->id->num;
				info = &flash_info[bank];
				addr_first = part->offset + info->start[0];
				addr_last = addr_first + part->size - 1;

				printf ("%sProtect Flash Parition %s, "
						"bank %d, 0x%08lx - 0x%08lx\n",
						p ? "" : "Un", argv[1],
						bank, addr_first, addr_last);

				rcode = flash_sect_protect (p, addr_first, addr_last);
				return rcode;
			}

			printf("cannot %sprotect, not a NOR device\n",
					p ? "" : "un");
			return 1;
		}
	}
#endif

	if (argc != 4) {
21f15098:	e51b3044 	ldr	r3, [fp, #-68]
21f1509c:	e3530004 	cmp	r3, #4	; 0x4
21f150a0:	0a000007 	beq	21f150c4 <do_protect+0x4c8>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f150a4:	e51b303c 	ldr	r3, [fp, #-60]
21f150a8:	e5933010 	ldr	r3, [r3, #16]
21f150ac:	e59f0238 	ldr	r0, [pc, #568]	; 21f152ec <.text+0x152ec>
21f150b0:	e1a01003 	mov	r1, r3
21f150b4:	eb001a74 	bl	21f1ba8c <printf>
		return 1;
21f150b8:	e3a03001 	mov	r3, #1	; 0x1
21f150bc:	e50b305c 	str	r3, [fp, #-92]
21f150c0:	ea000085 	b	21f152dc <do_protect+0x6e0>
	}

	if (strcmp(argv[2], "bank") == 0) {
21f150c4:	e51b3048 	ldr	r3, [fp, #-72]
21f150c8:	e2833008 	add	r3, r3, #8	; 0x8
21f150cc:	e5933000 	ldr	r3, [r3]
21f150d0:	e1a00003 	mov	r0, r3
21f150d4:	e59f1220 	ldr	r1, [pc, #544]	; 21f152fc <.text+0x152fc>
21f150d8:	eb00361b 	bl	21f2294c <strcmp>
21f150dc:	e1a03000 	mov	r3, r0
21f150e0:	e3530000 	cmp	r3, #0	; 0x0
21f150e4:	1a000053 	bne	21f15238 <do_protect+0x63c>
		bank = simple_strtoul(argv[3], NULL, 16);
21f150e8:	e51b3048 	ldr	r3, [fp, #-72]
21f150ec:	e283300c 	add	r3, r3, #12	; 0xc
21f150f0:	e5933000 	ldr	r3, [r3]
21f150f4:	e1a00003 	mov	r0, r3
21f150f8:	e3a01000 	mov	r1, #0	; 0x0
21f150fc:	e3a02010 	mov	r2, #16	; 0x10
21f15100:	eb003930 	bl	21f235c8 <simple_strtoul>
21f15104:	e1a03000 	mov	r3, r0
21f15108:	e50b3024 	str	r3, [fp, #-36]
		if ((bank < 1) || (bank > CFG_MAX_FLASH_BANKS)) {
21f1510c:	e51b3024 	ldr	r3, [fp, #-36]
21f15110:	e3530000 	cmp	r3, #0	; 0x0
21f15114:	0a000002 	beq	21f15124 <do_protect+0x528>
21f15118:	e51b3024 	ldr	r3, [fp, #-36]
21f1511c:	e3530001 	cmp	r3, #1	; 0x1
21f15120:	9a000005 	bls	21f1513c <do_protect+0x540>
			printf ("Only FLASH Banks # 1 ... # %d supported\n",
21f15124:	e59f01f4 	ldr	r0, [pc, #500]	; 21f15320 <.text+0x15320>
21f15128:	e3a01001 	mov	r1, #1	; 0x1
21f1512c:	eb001a56 	bl	21f1ba8c <printf>
				CFG_MAX_FLASH_BANKS);
			return 1;
21f15130:	e3a03001 	mov	r3, #1	; 0x1
21f15134:	e50b305c 	str	r3, [fp, #-92]
21f15138:	ea000067 	b	21f152dc <do_protect+0x6e0>
		}
		printf ("%sProtect Flash Bank # %ld\n",
21f1513c:	e51b301c 	ldr	r3, [fp, #-28]
21f15140:	e3530000 	cmp	r3, #0	; 0x0
21f15144:	0a000002 	beq	21f15154 <do_protect+0x558>
21f15148:	e59f31b4 	ldr	r3, [pc, #436]	; 21f15304 <.text+0x15304>
21f1514c:	e50b304c 	str	r3, [fp, #-76]
21f15150:	ea000001 	b	21f1515c <do_protect+0x560>
21f15154:	e59f31ac 	ldr	r3, [pc, #428]	; 21f15308 <.text+0x15308>
21f15158:	e50b304c 	str	r3, [fp, #-76]
21f1515c:	e59f01b0 	ldr	r0, [pc, #432]	; 21f15314 <.text+0x15314>
21f15160:	e51b104c 	ldr	r1, [fp, #-76]
21f15164:	e51b2024 	ldr	r2, [fp, #-36]
21f15168:	eb001a47 	bl	21f1ba8c <printf>
			p ? "" : "Un-", bank);
		info = &flash_info[bank-1];
21f1516c:	e51b2024 	ldr	r2, [fp, #-36]
21f15170:	e1a03002 	mov	r3, r2
21f15174:	e1a03183 	mov	r3, r3, lsl #3
21f15178:	e0833002 	add	r3, r3, r2
21f1517c:	e1a03083 	mov	r3, r3, lsl #1
21f15180:	e0833002 	add	r3, r3, r2
21f15184:	e1a02203 	mov	r2, r3, lsl #4
21f15188:	e0833002 	add	r3, r3, r2
21f1518c:	e1a03103 	mov	r3, r3, lsl #2
21f15190:	e1a02003 	mov	r2, r3
21f15194:	e59f3174 	ldr	r3, [pc, #372]	; 21f15310 <.text+0x15310>
21f15198:	e2433c05 	sub	r3, r3, #1280	; 0x500
21f1519c:	e243300c 	sub	r3, r3, #12	; 0xc
21f151a0:	e0823003 	add	r3, r2, r3
21f151a4:	e50b3028 	str	r3, [fp, #-40]

		if (info->flash_id == FLASH_UNKNOWN) {
21f151a8:	e51b3028 	ldr	r3, [fp, #-40]
21f151ac:	e5932008 	ldr	r2, [r3, #8]
21f151b0:	e3a03cff 	mov	r3, #65280	; 0xff00
21f151b4:	e28330ff 	add	r3, r3, #255	; 0xff
21f151b8:	e1520003 	cmp	r2, r3
21f151bc:	1a000004 	bne	21f151d4 <do_protect+0x5d8>
			puts ("missing or unknown FLASH type\n");
21f151c0:	e59f015c 	ldr	r0, [pc, #348]	; 21f15324 <.text+0x15324>
21f151c4:	eb001a1d 	bl	21f1ba40 <puts>
			return 1;
21f151c8:	e3a03001 	mov	r3, #1	; 0x1
21f151cc:	e50b305c 	str	r3, [fp, #-92]
21f151d0:	ea000041 	b	21f152dc <do_protect+0x6e0>
		}
		for (i=0; i<info->sector_count; ++i) {
21f151d4:	e3a03000 	mov	r3, #0	; 0x0
21f151d8:	e50b3020 	str	r3, [fp, #-32]
21f151dc:	ea00000c 	b	21f15214 <do_protect+0x618>
#if defined(CFG_FLASH_PROTECTION)
			if (flash_real_protect(info, i, p))
				rcode =  1;
			putc ('.');
#else
			info->protect[i] = p;
21f151e0:	e51b0028 	ldr	r0, [fp, #-40]
21f151e4:	e51b2020 	ldr	r2, [fp, #-32]
21f151e8:	e51b301c 	ldr	r3, [fp, #-28]
21f151ec:	e20310ff 	and	r1, r3, #255	; 0xff
21f151f0:	e3a03b01 	mov	r3, #1024	; 0x400
21f151f4:	e283300c 	add	r3, r3, #12	; 0xc
21f151f8:	e0822000 	add	r2, r2, r0
21f151fc:	e0822003 	add	r2, r2, r3
21f15200:	e1a03001 	mov	r3, r1
21f15204:	e5c23000 	strb	r3, [r2]
21f15208:	e51b3020 	ldr	r3, [fp, #-32]
21f1520c:	e2833001 	add	r3, r3, #1	; 0x1
21f15210:	e50b3020 	str	r3, [fp, #-32]
21f15214:	e51b3028 	ldr	r3, [fp, #-40]
21f15218:	e1d330b4 	ldrh	r3, [r3, #4]
21f1521c:	e1a02003 	mov	r2, r3
21f15220:	e51b3020 	ldr	r3, [fp, #-32]
21f15224:	e1520003 	cmp	r2, r3
21f15228:	caffffec 	bgt	21f151e0 <do_protect+0x5e4>
#endif	/* CFG_FLASH_PROTECTION */
		}

#if defined(CFG_FLASH_PROTECTION)
		if (!rcode) puts (" done\n");
#endif	/* CFG_FLASH_PROTECTION */

		return rcode;
21f1522c:	e51b3014 	ldr	r3, [fp, #-20]
21f15230:	e50b305c 	str	r3, [fp, #-92]
21f15234:	ea000028 	b	21f152dc <do_protect+0x6e0>
	}

	if (addr_spec(argv[2], argv[3], &addr_first, &addr_last) < 0){
21f15238:	e51b3048 	ldr	r3, [fp, #-72]
21f1523c:	e2833008 	add	r3, r3, #8	; 0x8
21f15240:	e5931000 	ldr	r1, [r3]
21f15244:	e51b3048 	ldr	r3, [fp, #-72]
21f15248:	e283300c 	add	r3, r3, #12	; 0xc
21f1524c:	e5933000 	ldr	r3, [r3]
21f15250:	e24b202c 	sub	r2, fp, #44	; 0x2c
21f15254:	e24bc030 	sub	ip, fp, #48	; 0x30
21f15258:	e1a00001 	mov	r0, r1
21f1525c:	e1a01003 	mov	r1, r3
21f15260:	e1a0300c 	mov	r3, ip
21f15264:	ebfffac7 	bl	21f13d88 <addr_spec>
21f15268:	e1a03000 	mov	r3, r0
21f1526c:	e3530000 	cmp	r3, #0	; 0x0
21f15270:	aa000004 	bge	21f15288 <do_protect+0x68c>
		printf("Bad address format\n");
21f15274:	e59f00ac 	ldr	r0, [pc, #172]	; 21f15328 <.text+0x15328>
21f15278:	eb001a03 	bl	21f1ba8c <printf>
		return 1;
21f1527c:	e3a03001 	mov	r3, #1	; 0x1
21f15280:	e50b305c 	str	r3, [fp, #-92]
21f15284:	ea000014 	b	21f152dc <do_protect+0x6e0>
	}

	if (addr_first >= addr_last) {
21f15288:	e51b202c 	ldr	r2, [fp, #-44]
21f1528c:	e51b3030 	ldr	r3, [fp, #-48]
21f15290:	e1520003 	cmp	r2, r3
21f15294:	3a000007 	bcc	21f152b8 <do_protect+0x6bc>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f15298:	e51b303c 	ldr	r3, [fp, #-60]
21f1529c:	e5933010 	ldr	r3, [r3, #16]
21f152a0:	e59f0044 	ldr	r0, [pc, #68]	; 21f152ec <.text+0x152ec>
21f152a4:	e1a01003 	mov	r1, r3
21f152a8:	eb0019f7 	bl	21f1ba8c <printf>
		return 1;
21f152ac:	e3a03001 	mov	r3, #1	; 0x1
21f152b0:	e50b305c 	str	r3, [fp, #-92]
21f152b4:	ea000008 	b	21f152dc <do_protect+0x6e0>
	}
	rcode = flash_sect_protect (p, addr_first, addr_last);
21f152b8:	e51b302c 	ldr	r3, [fp, #-44]
21f152bc:	e51b2030 	ldr	r2, [fp, #-48]
21f152c0:	e51b001c 	ldr	r0, [fp, #-28]
21f152c4:	e1a01003 	mov	r1, r3
21f152c8:	eb000017 	bl	21f1532c <flash_sect_protect>
21f152cc:	e1a03000 	mov	r3, r0
21f152d0:	e50b3014 	str	r3, [fp, #-20]
	return rcode;
21f152d4:	e51b3014 	ldr	r3, [fp, #-20]
21f152d8:	e50b305c 	str	r3, [fp, #-92]
21f152dc:	e51b305c 	ldr	r3, [fp, #-92]
}
21f152e0:	e1a00003 	mov	r0, r3
21f152e4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f152e8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f152ec:	21f30bd4 	ldrcssb	r0, [r3, #180]!
21f152f0:	21f30ca8 	mvncss	r0, r8, lsr #25
21f152f4:	21f30cac 	mvncss	r0, ip, lsr #25
21f152f8:	21f30be0 	mvncss	r0, r0, ror #23
21f152fc:	21f30c40 	mvncss	r0, r0, asr #24
21f15300:	21f30cb0 	ldrcsh	r0, [r3, #192]!
21f15304:	21f30cd4 	ldrcssb	r0, [r3, #196]!
21f15308:	21f30cd8 	ldrcssb	r0, [r3, #200]!
21f1530c:	21f30cdc 	ldrcssb	r0, [r3, #204]!
21f15310:	21f68ca0 	mvncss	r8, r0, lsr #25
21f15314:	21f30cfc 	ldrcssh	r0, [r3, #204]!
21f15318:	21f30bfc 	ldrcssh	r0, [r3, #188]!
21f1531c:	21f30d18 	mvncss	r0, r8, lsl sp
21f15320:	21f30ba8 	mvncss	r0, r8, lsr #23
21f15324:	21f30d44 	mvncss	r0, r4, asr #26
21f15328:	21f30c48 	mvncss	r0, r8, asr #24

21f1532c <flash_sect_protect>:


int flash_sect_protect (int p, ulong addr_first, ulong addr_last)
{
21f1532c:	e1a0c00d 	mov	ip, sp
21f15330:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15334:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15338:	e24dd034 	sub	sp, sp, #52	; 0x34
21f1533c:	e50b0030 	str	r0, [fp, #-48]
21f15340:	e50b1034 	str	r1, [fp, #-52]
21f15344:	e50b2038 	str	r2, [fp, #-56]
	flash_info_t *info;
	ulong bank;
#ifdef CFG_MAX_FLASH_BANKS_DETECT
	int s_first[CFG_MAX_FLASH_BANKS_DETECT], s_last[CFG_MAX_FLASH_BANKS_DETECT];
#else
	int s_first[CFG_MAX_FLASH_BANKS], s_last[CFG_MAX_FLASH_BANKS];
#endif
	int protected, i;
	int planned;
	int rcode;

	rcode = flash_fill_sect_ranges( addr_first, addr_last, s_first, s_last, &planned );
21f15348:	e24b2024 	sub	r2, fp, #36	; 0x24
21f1534c:	e24bc028 	sub	ip, fp, #40	; 0x28
21f15350:	e24b302c 	sub	r3, fp, #44	; 0x2c
21f15354:	e58d3000 	str	r3, [sp]
21f15358:	e51b0034 	ldr	r0, [fp, #-52]
21f1535c:	e51b1038 	ldr	r1, [fp, #-56]
21f15360:	e1a0300c 	mov	r3, ip
21f15364:	ebfffb3d 	bl	21f14060 <flash_fill_sect_ranges>
21f15368:	e1a03000 	mov	r3, r0
21f1536c:	e50b3010 	str	r3, [fp, #-16]

	protected = 0;
21f15370:	e3a03000 	mov	r3, #0	; 0x0
21f15374:	e50b3018 	str	r3, [fp, #-24]

	if (planned && (rcode == 0)) {
21f15378:	e51b302c 	ldr	r3, [fp, #-44]
21f1537c:	e3530000 	cmp	r3, #0	; 0x0
21f15380:	0a000070 	beq	21f15548 <flash_sect_protect+0x21c>
21f15384:	e51b3010 	ldr	r3, [fp, #-16]
21f15388:	e3530000 	cmp	r3, #0	; 0x0
21f1538c:	1a00006d 	bne	21f15548 <flash_sect_protect+0x21c>
		for (bank=0,info=&flash_info[0]; bank < CFG_MAX_FLASH_BANKS; ++bank, ++info) {
21f15390:	e3a03000 	mov	r3, #0	; 0x0
21f15394:	e50b301c 	str	r3, [fp, #-28]
21f15398:	e59f31d4 	ldr	r3, [pc, #468]	; 21f15574 <.text+0x15574>
21f1539c:	e50b3020 	str	r3, [fp, #-32]
21f153a0:	ea000058 	b	21f15508 <flash_sect_protect+0x1dc>
			if (info->flash_id == FLASH_UNKNOWN) {
21f153a4:	e51b3020 	ldr	r3, [fp, #-32]
21f153a8:	e5932008 	ldr	r2, [r3, #8]
21f153ac:	e3a03cff 	mov	r3, #65280	; 0xff00
21f153b0:	e28330ff 	add	r3, r3, #255	; 0xff
21f153b4:	e1520003 	cmp	r2, r3
21f153b8:	0a00004b 	beq	21f154ec <flash_sect_protect+0x1c0>
				continue;
			}

			if (s_first[bank]>=0 && s_first[bank]<=s_last[bank]) {
21f153bc:	e51b301c 	ldr	r3, [fp, #-28]
21f153c0:	e3e02017 	mvn	r2, #23	; 0x17
21f153c4:	e1a03103 	mov	r3, r3, lsl #2
21f153c8:	e24b000c 	sub	r0, fp, #12	; 0xc
21f153cc:	e0833000 	add	r3, r3, r0
21f153d0:	e0833002 	add	r3, r3, r2
21f153d4:	e5933000 	ldr	r3, [r3]
21f153d8:	e3530000 	cmp	r3, #0	; 0x0
21f153dc:	ba000042 	blt	21f154ec <flash_sect_protect+0x1c0>
21f153e0:	e51b301c 	ldr	r3, [fp, #-28]
21f153e4:	e3e02017 	mvn	r2, #23	; 0x17
21f153e8:	e1a03103 	mov	r3, r3, lsl #2
21f153ec:	e24b100c 	sub	r1, fp, #12	; 0xc
21f153f0:	e0833001 	add	r3, r3, r1
21f153f4:	e0833002 	add	r3, r3, r2
21f153f8:	e5931000 	ldr	r1, [r3]
21f153fc:	e51b301c 	ldr	r3, [fp, #-28]
21f15400:	e3e0201b 	mvn	r2, #27	; 0x1b
21f15404:	e1a03103 	mov	r3, r3, lsl #2
21f15408:	e24b000c 	sub	r0, fp, #12	; 0xc
21f1540c:	e0833000 	add	r3, r3, r0
21f15410:	e0833002 	add	r3, r3, r2
21f15414:	e5933000 	ldr	r3, [r3]
21f15418:	e1510003 	cmp	r1, r3
21f1541c:	ca000032 	bgt	21f154ec <flash_sect_protect+0x1c0>
				debug ("%sProtecting sectors %d..%d in bank %ld\n",
					p ? "" : "Un-",
					s_first[bank], s_last[bank], bank+1);
				protected += s_last[bank] - s_first[bank] + 1;
21f15420:	e51b301c 	ldr	r3, [fp, #-28]
21f15424:	e3e0201b 	mvn	r2, #27	; 0x1b
21f15428:	e1a03103 	mov	r3, r3, lsl #2
21f1542c:	e24b100c 	sub	r1, fp, #12	; 0xc
21f15430:	e0833001 	add	r3, r3, r1
21f15434:	e0833002 	add	r3, r3, r2
21f15438:	e5931000 	ldr	r1, [r3]
21f1543c:	e51b301c 	ldr	r3, [fp, #-28]
21f15440:	e3e02017 	mvn	r2, #23	; 0x17
21f15444:	e1a03103 	mov	r3, r3, lsl #2
21f15448:	e24b000c 	sub	r0, fp, #12	; 0xc
21f1544c:	e0833000 	add	r3, r3, r0
21f15450:	e0833002 	add	r3, r3, r2
21f15454:	e5933000 	ldr	r3, [r3]
21f15458:	e0632001 	rsb	r2, r3, r1
21f1545c:	e51b3018 	ldr	r3, [fp, #-24]
21f15460:	e0823003 	add	r3, r2, r3
21f15464:	e2833001 	add	r3, r3, #1	; 0x1
21f15468:	e50b3018 	str	r3, [fp, #-24]
				for (i=s_first[bank]; i<=s_last[bank]; ++i) {
21f1546c:	e51b301c 	ldr	r3, [fp, #-28]
21f15470:	e3e02017 	mvn	r2, #23	; 0x17
21f15474:	e1a03103 	mov	r3, r3, lsl #2
21f15478:	e24b100c 	sub	r1, fp, #12	; 0xc
21f1547c:	e0833001 	add	r3, r3, r1
21f15480:	e0833002 	add	r3, r3, r2
21f15484:	e5933000 	ldr	r3, [r3]
21f15488:	e50b3014 	str	r3, [fp, #-20]
21f1548c:	ea00000c 	b	21f154c4 <flash_sect_protect+0x198>
#if defined(CFG_FLASH_PROTECTION)
					if (flash_real_protect(info, i, p))
						rcode = 1;
					putc ('.');
#else
					info->protect[i] = p;
21f15490:	e51b1014 	ldr	r1, [fp, #-20]
21f15494:	e51b3030 	ldr	r3, [fp, #-48]
21f15498:	e20300ff 	and	r0, r3, #255	; 0xff
21f1549c:	e51b2020 	ldr	r2, [fp, #-32]
21f154a0:	e3a03b01 	mov	r3, #1024	; 0x400
21f154a4:	e283300c 	add	r3, r3, #12	; 0xc
21f154a8:	e0812002 	add	r2, r1, r2
21f154ac:	e0822003 	add	r2, r2, r3
21f154b0:	e1a03000 	mov	r3, r0
21f154b4:	e5c23000 	strb	r3, [r2]
21f154b8:	e51b3014 	ldr	r3, [fp, #-20]
21f154bc:	e2833001 	add	r3, r3, #1	; 0x1
21f154c0:	e50b3014 	str	r3, [fp, #-20]
21f154c4:	e51b301c 	ldr	r3, [fp, #-28]
21f154c8:	e3e0201b 	mvn	r2, #27	; 0x1b
21f154cc:	e1a03103 	mov	r3, r3, lsl #2
21f154d0:	e24b000c 	sub	r0, fp, #12	; 0xc
21f154d4:	e0833000 	add	r3, r3, r0
21f154d8:	e0833002 	add	r3, r3, r2
21f154dc:	e5932000 	ldr	r2, [r3]
21f154e0:	e51b3014 	ldr	r3, [fp, #-20]
21f154e4:	e1520003 	cmp	r2, r3
21f154e8:	aaffffe8 	bge	21f15490 <flash_sect_protect+0x164>
21f154ec:	e51b301c 	ldr	r3, [fp, #-28]
21f154f0:	e2833001 	add	r3, r3, #1	; 0x1
21f154f4:	e50b301c 	str	r3, [fp, #-28]
21f154f8:	e51b3020 	ldr	r3, [fp, #-32]
21f154fc:	e2833c05 	add	r3, r3, #1280	; 0x500
21f15500:	e283300c 	add	r3, r3, #12	; 0xc
21f15504:	e50b3020 	str	r3, [fp, #-32]
21f15508:	e51b301c 	ldr	r3, [fp, #-28]
21f1550c:	e3530000 	cmp	r3, #0	; 0x0
21f15510:	0affffa3 	beq	21f153a4 <flash_sect_protect+0x78>
#endif	/* CFG_FLASH_PROTECTION */
				}
			}
		}
#if defined(CFG_FLASH_PROTECTION)
		puts (" done\n");
#endif	/* CFG_FLASH_PROTECTION */

		printf ("%sProtected %d sectors\n",
21f15514:	e51b3030 	ldr	r3, [fp, #-48]
21f15518:	e3530000 	cmp	r3, #0	; 0x0
21f1551c:	0a000002 	beq	21f1552c <flash_sect_protect+0x200>
21f15520:	e59f1050 	ldr	r1, [pc, #80]	; 21f15578 <.text+0x15578>
21f15524:	e50b103c 	str	r1, [fp, #-60]
21f15528:	ea000001 	b	21f15534 <flash_sect_protect+0x208>
21f1552c:	e59f3048 	ldr	r3, [pc, #72]	; 21f1557c <.text+0x1557c>
21f15530:	e50b303c 	str	r3, [fp, #-60]
21f15534:	e59f0044 	ldr	r0, [pc, #68]	; 21f15580 <.text+0x15580>
21f15538:	e51b103c 	ldr	r1, [fp, #-60]
21f1553c:	e51b2018 	ldr	r2, [fp, #-24]
21f15540:	eb001951 	bl	21f1ba8c <printf>
21f15544:	ea000006 	b	21f15564 <flash_sect_protect+0x238>
			p ? "" : "Un-", protected);
	} else if (rcode == 0) {
21f15548:	e51b3010 	ldr	r3, [fp, #-16]
21f1554c:	e3530000 	cmp	r3, #0	; 0x0
21f15550:	1a000003 	bne	21f15564 <flash_sect_protect+0x238>
		puts ("Error: start and/or end address"
21f15554:	e59f0028 	ldr	r0, [pc, #40]	; 21f15584 <.text+0x15584>
21f15558:	eb001938 	bl	21f1ba40 <puts>
			" not on sector boundary\n");
		rcode = 1;
21f1555c:	e3a03001 	mov	r3, #1	; 0x1
21f15560:	e50b3010 	str	r3, [fp, #-16]
	}
	return rcode;
21f15564:	e51b3010 	ldr	r3, [fp, #-16]
}
21f15568:	e1a00003 	mov	r0, r3
21f1556c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f15570:	e89da800 	ldmia	sp, {fp, sp, pc}
21f15574:	21f68ca0 	mvncss	r8, r0, lsr #25
21f15578:	21f30cd4 	ldrcssb	r0, [r3, #196]!
21f1557c:	21f30cd8 	ldrcssb	r0, [r3, #200]!
21f15580:	21f30d64 	mvncss	r0, r4, ror #26
21f15584:	21f30c70 	mvncss	r0, r0, ror ip

21f15588 <evalexp>:

extern int cmd_get_data_size(char* arg, int default_size);

static long evalexp(char *s, int w)
{
21f15588:	e1a0c00d 	mov	ip, sp
21f1558c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15590:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15594:	e24dd010 	sub	sp, sp, #16	; 0x10
21f15598:	e50b0018 	str	r0, [fp, #-24]
21f1559c:	e50b101c 	str	r1, [fp, #-28]
	long l, *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
21f155a0:	e51b3018 	ldr	r3, [fp, #-24]
21f155a4:	e5d33000 	ldrb	r3, [r3]
21f155a8:	e353002a 	cmp	r3, #42	; 0x2a
21f155ac:	1a00000b 	bne	21f155e0 <evalexp+0x58>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
21f155b0:	e51b3018 	ldr	r3, [fp, #-24]
21f155b4:	e2833001 	add	r3, r3, #1	; 0x1
21f155b8:	e1a00003 	mov	r0, r3
21f155bc:	e3a01000 	mov	r1, #0	; 0x0
21f155c0:	e3a02010 	mov	r2, #16	; 0x10
21f155c4:	eb0037ff 	bl	21f235c8 <simple_strtoul>
21f155c8:	e1a03000 	mov	r3, r0
21f155cc:	e50b3010 	str	r3, [fp, #-16]
		l = *p;
21f155d0:	e51b3010 	ldr	r3, [fp, #-16]
21f155d4:	e5933000 	ldr	r3, [r3]
21f155d8:	e50b3014 	str	r3, [fp, #-20]
21f155dc:	ea000005 	b	21f155f8 <evalexp+0x70>
	} else {
		l = simple_strtoul(s, NULL, 16);
21f155e0:	e51b0018 	ldr	r0, [fp, #-24]
21f155e4:	e3a01000 	mov	r1, #0	; 0x0
21f155e8:	e3a02010 	mov	r2, #16	; 0x10
21f155ec:	eb0037f5 	bl	21f235c8 <simple_strtoul>
21f155f0:	e1a03000 	mov	r3, r0
21f155f4:	e50b3014 	str	r3, [fp, #-20]
	}

	return (l & ((1 << (w * 8)) - 1));
21f155f8:	e51b301c 	ldr	r3, [fp, #-28]
21f155fc:	e1a02183 	mov	r2, r3, lsl #3
21f15600:	e3a03001 	mov	r3, #1	; 0x1
21f15604:	e1a03213 	mov	r3, r3, lsl r2
21f15608:	e2432001 	sub	r2, r3, #1	; 0x1
21f1560c:	e51b3014 	ldr	r3, [fp, #-20]
21f15610:	e0023003 	and	r3, r2, r3
}
21f15614:	e1a00003 	mov	r0, r3
21f15618:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1561c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f15620 <evalstr>:

static char * evalstr(char *s)
{
21f15620:	e1a0c00d 	mov	ip, sp
21f15624:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15628:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1562c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f15630:	e50b0010 	str	r0, [fp, #-16]
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
21f15634:	e51b3010 	ldr	r3, [fp, #-16]
21f15638:	e5d33000 	ldrb	r3, [r3]
21f1563c:	e353002a 	cmp	r3, #42	; 0x2a
21f15640:	1a000008 	bne	21f15668 <evalstr+0x48>
		return (char *)simple_strtoul(&s[1], NULL, 16);
21f15644:	e51b3010 	ldr	r3, [fp, #-16]
21f15648:	e2833001 	add	r3, r3, #1	; 0x1
21f1564c:	e1a00003 	mov	r0, r3
21f15650:	e3a01000 	mov	r1, #0	; 0x0
21f15654:	e3a02010 	mov	r2, #16	; 0x10
21f15658:	eb0037da 	bl	21f235c8 <simple_strtoul>
21f1565c:	e1a03000 	mov	r3, r0
21f15660:	e50b3014 	str	r3, [fp, #-20]
21f15664:	ea000001 	b	21f15670 <evalstr+0x50>
	} else {
		return s;
21f15668:	e51b3010 	ldr	r3, [fp, #-16]
21f1566c:	e50b3014 	str	r3, [fp, #-20]
21f15670:	e51b3014 	ldr	r3, [fp, #-20]
	}
}
21f15674:	e1a00003 	mov	r0, r3
21f15678:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1567c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f15680 <stringcomp>:

static int stringcomp(char *s, char *t, int op)
{
21f15680:	e1a0c00d 	mov	ip, sp
21f15684:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15688:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1568c:	e24dd028 	sub	sp, sp, #40	; 0x28
21f15690:	e50b0028 	str	r0, [fp, #-40]
21f15694:	e50b102c 	str	r1, [fp, #-44]
21f15698:	e50b2030 	str	r2, [fp, #-48]
	int n, p;
	char *l, *r;

	l = evalstr(s);
21f1569c:	e51b0028 	ldr	r0, [fp, #-40]
21f156a0:	ebffffde 	bl	21f15620 <evalstr>
21f156a4:	e1a03000 	mov	r3, r0
21f156a8:	e50b301c 	str	r3, [fp, #-28]
	r = evalstr(t);
21f156ac:	e51b002c 	ldr	r0, [fp, #-44]
21f156b0:	ebffffda 	bl	21f15620 <evalstr>
21f156b4:	e1a03000 	mov	r3, r0
21f156b8:	e50b3018 	str	r3, [fp, #-24]

	/* we'll do a compare based on the length of the shortest string */
	n = min(strlen(l), strlen(r));
21f156bc:	e51b001c 	ldr	r0, [fp, #-28]
21f156c0:	eb00353f 	bl	21f22bc4 <strlen>
21f156c4:	e1a03000 	mov	r3, r0
21f156c8:	e50b3014 	str	r3, [fp, #-20]
21f156cc:	e51b0018 	ldr	r0, [fp, #-24]
21f156d0:	eb00353b 	bl	21f22bc4 <strlen>
21f156d4:	e1a03000 	mov	r3, r0
21f156d8:	e50b3010 	str	r3, [fp, #-16]
21f156dc:	e51b2010 	ldr	r2, [fp, #-16]
21f156e0:	e51b3014 	ldr	r3, [fp, #-20]
21f156e4:	e1520003 	cmp	r2, r3
21f156e8:	31a03002 	movcc	r3, r2
21f156ec:	e50b3024 	str	r3, [fp, #-36]

	p = strncmp(l, r, n);
21f156f0:	e51b3024 	ldr	r3, [fp, #-36]
21f156f4:	e51b001c 	ldr	r0, [fp, #-28]
21f156f8:	e51b1018 	ldr	r1, [fp, #-24]
21f156fc:	e1a02003 	mov	r2, r3
21f15700:	eb0034bb 	bl	21f229f4 <strncmp>
21f15704:	e1a03000 	mov	r3, r0
21f15708:	e50b3020 	str	r3, [fp, #-32]
	switch (op) {
21f1570c:	e51b3030 	ldr	r3, [fp, #-48]
21f15710:	e3530005 	cmp	r3, #5	; 0x5
21f15714:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f15718:	ea000026 	b	21f157b8 <.text+0x157b8>
21f1571c:	21f15734 	mvncss	r5, r4, lsr r7
21f15720:	21f1574c 	mvncss	r5, ip, asr #14
21f15724:	21f15764 	mvncss	r5, r4, ror #14
21f15728:	21f15774 	mvncss	r5, r4, ror r7
21f1572c:	21f1578c 	mvncss	r5, ip, lsl #15
21f15730:	21f157a4 	mvncss	r5, r4, lsr #15
	case EQ: return (p == 0);
21f15734:	e51b3020 	ldr	r3, [fp, #-32]
21f15738:	e3530000 	cmp	r3, #0	; 0x0
21f1573c:	13a03000 	movne	r3, #0	; 0x0
21f15740:	03a03001 	moveq	r3, #1	; 0x1
21f15744:	e50b3034 	str	r3, [fp, #-52]
21f15748:	ea00001c 	b	21f157c0 <.text+0x157c0>
	case NE: return (p != 0);
21f1574c:	e51b3020 	ldr	r3, [fp, #-32]
21f15750:	e3530000 	cmp	r3, #0	; 0x0
21f15754:	03a03000 	moveq	r3, #0	; 0x0
21f15758:	13a03001 	movne	r3, #1	; 0x1
21f1575c:	e50b3034 	str	r3, [fp, #-52]
21f15760:	ea000016 	b	21f157c0 <.text+0x157c0>
	case LT: return (p < 0);
21f15764:	e51b3020 	ldr	r3, [fp, #-32]
21f15768:	e1a03fa3 	mov	r3, r3, lsr #31
21f1576c:	e50b3034 	str	r3, [fp, #-52]
21f15770:	ea000012 	b	21f157c0 <.text+0x157c0>
	case GT: return (p > 0);
21f15774:	e51b3020 	ldr	r3, [fp, #-32]
21f15778:	e3530000 	cmp	r3, #0	; 0x0
21f1577c:	d3a03000 	movle	r3, #0	; 0x0
21f15780:	c3a03001 	movgt	r3, #1	; 0x1
21f15784:	e50b3034 	str	r3, [fp, #-52]
21f15788:	ea00000c 	b	21f157c0 <.text+0x157c0>
	case LE: return (p <= 0);
21f1578c:	e51b3020 	ldr	r3, [fp, #-32]
21f15790:	e3530000 	cmp	r3, #0	; 0x0
21f15794:	c3a03000 	movgt	r3, #0	; 0x0
21f15798:	d3a03001 	movle	r3, #1	; 0x1
21f1579c:	e50b3034 	str	r3, [fp, #-52]
21f157a0:	ea000006 	b	21f157c0 <.text+0x157c0>
	case GE: return (p >= 0);
21f157a4:	e51b3020 	ldr	r3, [fp, #-32]
21f157a8:	e1e03003 	mvn	r3, r3
21f157ac:	e1a03fa3 	mov	r3, r3, lsr #31
21f157b0:	e50b3034 	str	r3, [fp, #-52]
21f157b4:	ea000001 	b	21f157c0 <.text+0x157c0>
	}
	return (0);
21f157b8:	e3a03000 	mov	r3, #0	; 0x0
21f157bc:	e50b3034 	str	r3, [fp, #-52]
21f157c0:	e51b3034 	ldr	r3, [fp, #-52]
}
21f157c4:	e1a00003 	mov	r0, r3
21f157c8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f157cc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f157d0 <arithcomp>:

static int arithcomp (char *s, char *t, int op, int w)
{
21f157d0:	e1a0c00d 	mov	ip, sp
21f157d4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f157d8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f157dc:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f157e0:	e50b0018 	str	r0, [fp, #-24]
21f157e4:	e50b101c 	str	r1, [fp, #-28]
21f157e8:	e50b2020 	str	r2, [fp, #-32]
21f157ec:	e50b3024 	str	r3, [fp, #-36]
	long l, r;

	l = evalexp (s, w);
21f157f0:	e51b0018 	ldr	r0, [fp, #-24]
21f157f4:	e51b1024 	ldr	r1, [fp, #-36]
21f157f8:	ebffff62 	bl	21f15588 <evalexp>
21f157fc:	e1a03000 	mov	r3, r0
21f15800:	e50b3014 	str	r3, [fp, #-20]
	r = evalexp (t, w);
21f15804:	e51b001c 	ldr	r0, [fp, #-28]
21f15808:	e51b1024 	ldr	r1, [fp, #-36]
21f1580c:	ebffff5d 	bl	21f15588 <evalexp>
21f15810:	e1a03000 	mov	r3, r0
21f15814:	e50b3010 	str	r3, [fp, #-16]

	switch (op) {
21f15818:	e51b3020 	ldr	r3, [fp, #-32]
21f1581c:	e3530005 	cmp	r3, #5	; 0x5
21f15820:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f15824:	ea00002f 	b	21f158e8 <.text+0x158e8>
21f15828:	21f15840 	mvncss	r5, r0, asr #16
21f1582c:	21f1585c 	mvncss	r5, ip, asr r8
21f15830:	21f15878 	mvncss	r5, r8, ror r8
21f15834:	21f15894 	ldrcsb	r5, [r1, #132]!
21f15838:	21f158b0 	ldrcsh	r5, [r1, #128]!
21f1583c:	21f158cc 	mvncss	r5, ip, asr #17
	case EQ: return (l == r);
21f15840:	e51b2014 	ldr	r2, [fp, #-20]
21f15844:	e51b3010 	ldr	r3, [fp, #-16]
21f15848:	e1520003 	cmp	r2, r3
21f1584c:	13a03000 	movne	r3, #0	; 0x0
21f15850:	03a03001 	moveq	r3, #1	; 0x1
21f15854:	e50b3028 	str	r3, [fp, #-40]
21f15858:	ea000024 	b	21f158f0 <.text+0x158f0>
	case NE: return (l != r);
21f1585c:	e51b2014 	ldr	r2, [fp, #-20]
21f15860:	e51b3010 	ldr	r3, [fp, #-16]
21f15864:	e1520003 	cmp	r2, r3
21f15868:	03a03000 	moveq	r3, #0	; 0x0
21f1586c:	13a03001 	movne	r3, #1	; 0x1
21f15870:	e50b3028 	str	r3, [fp, #-40]
21f15874:	ea00001d 	b	21f158f0 <.text+0x158f0>
	case LT: return (l < r);
21f15878:	e51b2014 	ldr	r2, [fp, #-20]
21f1587c:	e51b3010 	ldr	r3, [fp, #-16]
21f15880:	e1520003 	cmp	r2, r3
21f15884:	a3a03000 	movge	r3, #0	; 0x0
21f15888:	b3a03001 	movlt	r3, #1	; 0x1
21f1588c:	e50b3028 	str	r3, [fp, #-40]
21f15890:	ea000016 	b	21f158f0 <.text+0x158f0>
	case GT: return (l > r);
21f15894:	e51b2014 	ldr	r2, [fp, #-20]
21f15898:	e51b3010 	ldr	r3, [fp, #-16]
21f1589c:	e1520003 	cmp	r2, r3
21f158a0:	d3a03000 	movle	r3, #0	; 0x0
21f158a4:	c3a03001 	movgt	r3, #1	; 0x1
21f158a8:	e50b3028 	str	r3, [fp, #-40]
21f158ac:	ea00000f 	b	21f158f0 <.text+0x158f0>
	case LE: return (l <= r);
21f158b0:	e51b2014 	ldr	r2, [fp, #-20]
21f158b4:	e51b3010 	ldr	r3, [fp, #-16]
21f158b8:	e1520003 	cmp	r2, r3
21f158bc:	c3a03000 	movgt	r3, #0	; 0x0
21f158c0:	d3a03001 	movle	r3, #1	; 0x1
21f158c4:	e50b3028 	str	r3, [fp, #-40]
21f158c8:	ea000008 	b	21f158f0 <.text+0x158f0>
	case GE: return (l >= r);
21f158cc:	e51b2014 	ldr	r2, [fp, #-20]
21f158d0:	e51b3010 	ldr	r3, [fp, #-16]
21f158d4:	e1520003 	cmp	r2, r3
21f158d8:	b3a03000 	movlt	r3, #0	; 0x0
21f158dc:	a3a03001 	movge	r3, #1	; 0x1
21f158e0:	e50b3028 	str	r3, [fp, #-40]
21f158e4:	ea000001 	b	21f158f0 <.text+0x158f0>
	}
	return (0);
21f158e8:	e3a03000 	mov	r3, #0	; 0x0
21f158ec:	e50b3028 	str	r3, [fp, #-40]
21f158f0:	e51b3028 	ldr	r3, [fp, #-40]
}
21f158f4:	e1a00003 	mov	r0, r3
21f158f8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f158fc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f15900 <binary_test>:

int binary_test (char *op, char *arg1, char *arg2, int w)
{
21f15900:	e1a0c00d 	mov	ip, sp
21f15904:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f15908:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1590c:	e24dd020 	sub	sp, sp, #32	; 0x20
21f15910:	e50b0020 	str	r0, [fp, #-32]
21f15914:	e50b1024 	str	r1, [fp, #-36]
21f15918:	e50b2028 	str	r2, [fp, #-40]
21f1591c:	e50b302c 	str	r3, [fp, #-44]
	int len, i;
	op_tbl_t *optp;

	len = strlen(op);
21f15920:	e51b0020 	ldr	r0, [fp, #-32]
21f15924:	eb0034a6 	bl	21f22bc4 <strlen>
21f15928:	e1a03000 	mov	r3, r0
21f1592c:	e50b301c 	str	r3, [fp, #-28]

	for (optp = (op_tbl_t *)&op_table, i = 0;
21f15930:	e59f30f0 	ldr	r3, [pc, #240]	; 21f15a28 <.text+0x15a28>
21f15934:	e50b3014 	str	r3, [fp, #-20]
21f15938:	e3a03000 	mov	r3, #0	; 0x0
21f1593c:	e50b3018 	str	r3, [fp, #-24]
	     i < op_tbl_size;
21f15940:	ea00002c 	b	21f159f8 <binary_test+0xf8>
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
21f15944:	e51b3014 	ldr	r3, [fp, #-20]
21f15948:	e5933000 	ldr	r3, [r3]
21f1594c:	e51b201c 	ldr	r2, [fp, #-28]
21f15950:	e51b0020 	ldr	r0, [fp, #-32]
21f15954:	e1a01003 	mov	r1, r3
21f15958:	eb003425 	bl	21f229f4 <strncmp>
21f1595c:	e1a03000 	mov	r3, r0
21f15960:	e3530000 	cmp	r3, #0	; 0x0
21f15964:	1a00001d 	bne	21f159e0 <binary_test+0xe0>
21f15968:	e51b401c 	ldr	r4, [fp, #-28]
21f1596c:	e51b3014 	ldr	r3, [fp, #-20]
21f15970:	e5933000 	ldr	r3, [r3]
21f15974:	e1a00003 	mov	r0, r3
21f15978:	eb003491 	bl	21f22bc4 <strlen>
21f1597c:	e1a03000 	mov	r3, r0
21f15980:	e1540003 	cmp	r4, r3
21f15984:	1a000015 	bne	21f159e0 <binary_test+0xe0>
			if (w == 0) {
21f15988:	e51b302c 	ldr	r3, [fp, #-44]
21f1598c:	e3530000 	cmp	r3, #0	; 0x0
21f15990:	1a000008 	bne	21f159b8 <binary_test+0xb8>
				return (stringcomp(arg1, arg2, optp->opcode));
21f15994:	e51b3014 	ldr	r3, [fp, #-20]
21f15998:	e5933004 	ldr	r3, [r3, #4]
21f1599c:	e51b0024 	ldr	r0, [fp, #-36]
21f159a0:	e51b1028 	ldr	r1, [fp, #-40]
21f159a4:	e1a02003 	mov	r2, r3
21f159a8:	ebffff34 	bl	21f15680 <stringcomp>
21f159ac:	e1a03000 	mov	r3, r0
21f159b0:	e50b3030 	str	r3, [fp, #-48]
21f159b4:	ea000017 	b	21f15a18 <binary_test+0x118>
			} else {
				return (arithcomp (arg1, arg2, optp->opcode, w));
21f159b8:	e51b3014 	ldr	r3, [fp, #-20]
21f159bc:	e5933004 	ldr	r3, [r3, #4]
21f159c0:	e51b0024 	ldr	r0, [fp, #-36]
21f159c4:	e51b1028 	ldr	r1, [fp, #-40]
21f159c8:	e1a02003 	mov	r2, r3
21f159cc:	e51b302c 	ldr	r3, [fp, #-44]
21f159d0:	ebffff7e 	bl	21f157d0 <arithcomp>
21f159d4:	e1a03000 	mov	r3, r0
21f159d8:	e50b3030 	str	r3, [fp, #-48]
21f159dc:	ea00000d 	b	21f15a18 <binary_test+0x118>
21f159e0:	e51b3014 	ldr	r3, [fp, #-20]
21f159e4:	e2833008 	add	r3, r3, #8	; 0x8
21f159e8:	e50b3014 	str	r3, [fp, #-20]
21f159ec:	e51b3018 	ldr	r3, [fp, #-24]
21f159f0:	e2833001 	add	r3, r3, #1	; 0x1
21f159f4:	e50b3018 	str	r3, [fp, #-24]
21f159f8:	e51b3018 	ldr	r3, [fp, #-24]
21f159fc:	e353000c 	cmp	r3, #12	; 0xc
21f15a00:	9affffcf 	bls	21f15944 <binary_test+0x44>
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
21f15a04:	e59f0020 	ldr	r0, [pc, #32]	; 21f15a2c <.text+0x15a2c>
21f15a08:	e51b1020 	ldr	r1, [fp, #-32]
21f15a0c:	eb00181e 	bl	21f1ba8c <printf>
	return 0;	/* op code not found */
21f15a10:	e3a03000 	mov	r3, #0	; 0x0
21f15a14:	e50b3030 	str	r3, [fp, #-48]
21f15a18:	e51b3030 	ldr	r3, [fp, #-48]
}
21f15a1c:	e1a00003 	mov	r0, r3
21f15a20:	e24bd010 	sub	sp, fp, #16	; 0x10
21f15a24:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f15a28:	21f33230 	mvncss	r3, r0, lsr r2
21f15a2c:	21f30e48 	mvncss	r0, r8, asr #28

21f15a30 <do_itest>:

/* command line interface to the shell test */
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[] )
{
21f15a30:	e1a0c00d 	mov	ip, sp
21f15a34:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15a38:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15a3c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f15a40:	e50b0018 	str	r0, [fp, #-24]
21f15a44:	e50b101c 	str	r1, [fp, #-28]
21f15a48:	e50b2020 	str	r2, [fp, #-32]
21f15a4c:	e50b3024 	str	r3, [fp, #-36]
	int	value, w;

	/* Validate arguments */
	if ((argc != 4)){
21f15a50:	e51b3020 	ldr	r3, [fp, #-32]
21f15a54:	e3530004 	cmp	r3, #4	; 0x4
21f15a58:	0a000007 	beq	21f15a7c <do_itest+0x4c>
		printf("Usage:\n%s\n", cmdtp->usage);
21f15a5c:	e51b3018 	ldr	r3, [fp, #-24]
21f15a60:	e5933010 	ldr	r3, [r3, #16]
21f15a64:	e59f0118 	ldr	r0, [pc, #280]	; 21f15b84 <.text+0x15b84>
21f15a68:	e1a01003 	mov	r1, r3
21f15a6c:	eb001806 	bl	21f1ba8c <printf>
		return 1;
21f15a70:	e3a03001 	mov	r3, #1	; 0x1
21f15a74:	e50b3028 	str	r3, [fp, #-40]
21f15a78:	ea00003d 	b	21f15b74 <.text+0x15b74>
	}

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
21f15a7c:	e51b3024 	ldr	r3, [fp, #-36]
21f15a80:	e5933000 	ldr	r3, [r3]
21f15a84:	e1a00003 	mov	r0, r3
21f15a88:	e3a01004 	mov	r1, #4	; 0x4
21f15a8c:	eb00059f 	bl	21f17110 <cmd_get_data_size>
21f15a90:	e1a03000 	mov	r3, r0
21f15a94:	e50b3010 	str	r3, [fp, #-16]
21f15a98:	e51b3010 	ldr	r3, [fp, #-16]
21f15a9c:	e2833002 	add	r3, r3, #2	; 0x2
21f15aa0:	e3530006 	cmp	r3, #6	; 0x6
21f15aa4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f15aa8:	ea000028 	b	21f15b50 <.text+0x15b50>
21f15aac:	21f15b0c 	mvncss	r5, ip, lsl #22
21f15ab0:	21f15b50 	mvncss	r5, r0, asr fp
21f15ab4:	21f15b50 	mvncss	r5, r0, asr fp
21f15ab8:	21f15ac8 	mvncss	r5, r8, asr #21
21f15abc:	21f15ac8 	mvncss	r5, r8, asr #21
21f15ac0:	21f15b50 	mvncss	r5, r0, asr fp
21f15ac4:	21f15ac8 	mvncss	r5, r8, asr #21
	case 1:
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
21f15ac8:	e51b3024 	ldr	r3, [fp, #-36]
21f15acc:	e2833008 	add	r3, r3, #8	; 0x8
21f15ad0:	e5931000 	ldr	r1, [r3]
21f15ad4:	e51b3024 	ldr	r3, [fp, #-36]
21f15ad8:	e2833004 	add	r3, r3, #4	; 0x4
21f15adc:	e5932000 	ldr	r2, [r3]
21f15ae0:	e51b3024 	ldr	r3, [fp, #-36]
21f15ae4:	e283300c 	add	r3, r3, #12	; 0xc
21f15ae8:	e5933000 	ldr	r3, [r3]
21f15aec:	e1a00001 	mov	r0, r1
21f15af0:	e1a01002 	mov	r1, r2
21f15af4:	e1a02003 	mov	r2, r3
21f15af8:	e51b3010 	ldr	r3, [fp, #-16]
21f15afc:	ebffff7f 	bl	21f15900 <binary_test>
21f15b00:	e1a03000 	mov	r3, r0
21f15b04:	e50b3014 	str	r3, [fp, #-20]
		break;
21f15b08:	ea000014 	b	21f15b60 <.text+0x15b60>
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
21f15b0c:	e51b3024 	ldr	r3, [fp, #-36]
21f15b10:	e2833008 	add	r3, r3, #8	; 0x8
21f15b14:	e5931000 	ldr	r1, [r3]
21f15b18:	e51b3024 	ldr	r3, [fp, #-36]
21f15b1c:	e2833004 	add	r3, r3, #4	; 0x4
21f15b20:	e5932000 	ldr	r2, [r3]
21f15b24:	e51b3024 	ldr	r3, [fp, #-36]
21f15b28:	e283300c 	add	r3, r3, #12	; 0xc
21f15b2c:	e5933000 	ldr	r3, [r3]
21f15b30:	e1a00001 	mov	r0, r1
21f15b34:	e1a01002 	mov	r1, r2
21f15b38:	e1a02003 	mov	r2, r3
21f15b3c:	e3a03000 	mov	r3, #0	; 0x0
21f15b40:	ebffff6e 	bl	21f15900 <binary_test>
21f15b44:	e1a03000 	mov	r3, r0
21f15b48:	e50b3014 	str	r3, [fp, #-20]
		break;
21f15b4c:	ea000003 	b	21f15b60 <.text+0x15b60>
	case -1:
	default:
		puts("Invalid data width specifier\n");
21f15b50:	e59f0030 	ldr	r0, [pc, #48]	; 21f15b88 <.text+0x15b88>
21f15b54:	eb0017b9 	bl	21f1ba40 <puts>
		value = 0;
21f15b58:	e3a03000 	mov	r3, #0	; 0x0
21f15b5c:	e50b3014 	str	r3, [fp, #-20]
		break;
	}

	return !value;
21f15b60:	e51b3014 	ldr	r3, [fp, #-20]
21f15b64:	e3530000 	cmp	r3, #0	; 0x0
21f15b68:	13a03000 	movne	r3, #0	; 0x0
21f15b6c:	03a03001 	moveq	r3, #1	; 0x1
21f15b70:	e50b3028 	str	r3, [fp, #-40]
21f15b74:	e51b3028 	ldr	r3, [fp, #-40]
}
21f15b78:	e1a00003 	mov	r0, r3
21f15b7c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f15b80:	e89da800 	ldmia	sp, {fp, sp, pc}
21f15b84:	21f30e60 	mvncss	r0, r0, ror #28
21f15b88:	21f30e6c 	mvncss	r0, ip, ror #28

21f15b8c <do_load_serial_bin>:
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f15b8c:	e1a0c00d 	mov	ip, sp
21f15b90:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15b94:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15b98:	e24dd028 	sub	sp, sp, #40	; 0x28
21f15b9c:	e50b0028 	str	r0, [fp, #-40]
21f15ba0:	e50b102c 	str	r1, [fp, #-44]
21f15ba4:	e50b2030 	str	r2, [fp, #-48]
21f15ba8:	e50b3034 	str	r3, [fp, #-52]
	ulong offset = 0;
21f15bac:	e3a03000 	mov	r3, #0	; 0x0
21f15bb0:	e50b3024 	str	r3, [fp, #-36]
	ulong addr;
	int load_baudrate, current_baudrate;
	int rcode = 0;
21f15bb4:	e3a03000 	mov	r3, #0	; 0x0
21f15bb8:	e50b3014 	str	r3, [fp, #-20]
	char *s;

	/* pre-set offset from CFG_LOAD_ADDR */
	offset = CFG_LOAD_ADDR;
21f15bbc:	e3a03421 	mov	r3, #553648128	; 0x21000000
21f15bc0:	e50b3024 	str	r3, [fp, #-36]

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
21f15bc4:	e59f0214 	ldr	r0, [pc, #532]	; 21f15de0 <.text+0x15de0>
21f15bc8:	eb001412 	bl	21f1ac18 <getenv>
21f15bcc:	e1a03000 	mov	r3, r0
21f15bd0:	e50b3010 	str	r3, [fp, #-16]
21f15bd4:	e51b3010 	ldr	r3, [fp, #-16]
21f15bd8:	e3530000 	cmp	r3, #0	; 0x0
21f15bdc:	0a000005 	beq	21f15bf8 <do_load_serial_bin+0x6c>
		offset = simple_strtoul(s, NULL, 16);
21f15be0:	e51b0010 	ldr	r0, [fp, #-16]
21f15be4:	e3a01000 	mov	r1, #0	; 0x0
21f15be8:	e3a02010 	mov	r2, #16	; 0x10
21f15bec:	eb003675 	bl	21f235c8 <simple_strtoul>
21f15bf0:	e1a03000 	mov	r3, r0
21f15bf4:	e50b3024 	str	r3, [fp, #-36]
	}

	load_baudrate = current_baudrate = gd->baudrate;
21f15bf8:	e1a03008 	mov	r3, r8
21f15bfc:	e5933008 	ldr	r3, [r3, #8]
21f15c00:	e50b3018 	str	r3, [fp, #-24]
21f15c04:	e51b3018 	ldr	r3, [fp, #-24]
21f15c08:	e50b301c 	str	r3, [fp, #-28]

	if (argc >= 2) {
21f15c0c:	e51b3030 	ldr	r3, [fp, #-48]
21f15c10:	e3530001 	cmp	r3, #1	; 0x1
21f15c14:	da000008 	ble	21f15c3c <do_load_serial_bin+0xb0>
		offset = simple_strtoul(argv[1], NULL, 16);
21f15c18:	e51b3034 	ldr	r3, [fp, #-52]
21f15c1c:	e2833004 	add	r3, r3, #4	; 0x4
21f15c20:	e5933000 	ldr	r3, [r3]
21f15c24:	e1a00003 	mov	r0, r3
21f15c28:	e3a01000 	mov	r1, #0	; 0x0
21f15c2c:	e3a02010 	mov	r2, #16	; 0x10
21f15c30:	eb003664 	bl	21f235c8 <simple_strtoul>
21f15c34:	e1a03000 	mov	r3, r0
21f15c38:	e50b3024 	str	r3, [fp, #-36]
	}
	if (argc == 3) {
21f15c3c:	e51b3030 	ldr	r3, [fp, #-48]
21f15c40:	e3530003 	cmp	r3, #3	; 0x3
21f15c44:	1a00000d 	bne	21f15c80 <do_load_serial_bin+0xf4>
		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
21f15c48:	e51b3034 	ldr	r3, [fp, #-52]
21f15c4c:	e2833008 	add	r3, r3, #8	; 0x8
21f15c50:	e5933000 	ldr	r3, [r3]
21f15c54:	e1a00003 	mov	r0, r3
21f15c58:	e3a01000 	mov	r1, #0	; 0x0
21f15c5c:	e3a0200a 	mov	r2, #10	; 0xa
21f15c60:	eb003658 	bl	21f235c8 <simple_strtoul>
21f15c64:	e1a03000 	mov	r3, r0
21f15c68:	e50b301c 	str	r3, [fp, #-28]

		/* default to current baudrate */
		if (load_baudrate == 0)
21f15c6c:	e51b301c 	ldr	r3, [fp, #-28]
21f15c70:	e3530000 	cmp	r3, #0	; 0x0
21f15c74:	1a000001 	bne	21f15c80 <do_load_serial_bin+0xf4>
			load_baudrate = current_baudrate;
21f15c78:	e51b3018 	ldr	r3, [fp, #-24]
21f15c7c:	e50b301c 	str	r3, [fp, #-28]
	}

	if (load_baudrate != current_baudrate) {
21f15c80:	e51b201c 	ldr	r2, [fp, #-28]
21f15c84:	e51b3018 	ldr	r3, [fp, #-24]
21f15c88:	e1520003 	cmp	r2, r3
21f15c8c:	0a000010 	beq	21f15cd4 <do_load_serial_bin+0x148>
		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
21f15c90:	e59f014c 	ldr	r0, [pc, #332]	; 21f15de4 <.text+0x15de4>
21f15c94:	e51b101c 	ldr	r1, [fp, #-28]
21f15c98:	eb00177b 	bl	21f1ba8c <printf>
			load_baudrate);
		udelay(50000);
21f15c9c:	e3a00cc3 	mov	r0, #49920	; 0xc300
21f15ca0:	e2800050 	add	r0, r0, #80	; 0x50
21f15ca4:	ebffab7f 	bl	21f00aa8 <udelay>
		gd->baudrate = load_baudrate;
21f15ca8:	e1a02008 	mov	r2, r8
21f15cac:	e51b301c 	ldr	r3, [fp, #-28]
21f15cb0:	e5823008 	str	r3, [r2, #8]
		serial_setbrg ();
21f15cb4:	eb0061a5 	bl	21f2e350 <serial_setbrg>
		udelay(50000);
21f15cb8:	e3a00cc3 	mov	r0, #49920	; 0xc300
21f15cbc:	e2800050 	add	r0, r0, #80	; 0x50
21f15cc0:	ebffab78 	bl	21f00aa8 <udelay>
		for (;;) {
			if (getc() == '\r')
21f15cc4:	eb00171b 	bl	21f1b938 <getc>
21f15cc8:	e1a03000 	mov	r3, r0
21f15ccc:	e353000d 	cmp	r3, #13	; 0xd
21f15cd0:	1afffffb 	bne	21f15cc4 <do_load_serial_bin+0x138>
				break;
		}
	}

	if (strcmp(argv[0],"loady")==0) {
21f15cd4:	e51b3034 	ldr	r3, [fp, #-52]
21f15cd8:	e5933000 	ldr	r3, [r3]
21f15cdc:	e1a00003 	mov	r0, r3
21f15ce0:	e59f1100 	ldr	r1, [pc, #256]	; 21f15de8 <.text+0x15de8>
21f15ce4:	eb003318 	bl	21f2294c <strcmp>
21f15ce8:	e1a03000 	mov	r3, r0
21f15cec:	e3530000 	cmp	r3, #0	; 0x0
21f15cf0:	1a000008 	bne	21f15d18 <do_load_serial_bin+0x18c>
		printf ("## Ready for binary (ymodem) download "
21f15cf4:	e59f00f0 	ldr	r0, [pc, #240]	; 21f15dec <.text+0x15dec>
21f15cf8:	e51b1024 	ldr	r1, [fp, #-36]
21f15cfc:	e51b201c 	ldr	r2, [fp, #-28]
21f15d00:	eb001761 	bl	21f1ba8c <printf>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);

		addr = load_serial_ymodem (offset);
21f15d04:	e51b0024 	ldr	r0, [fp, #-36]
21f15d08:	eb000486 	bl	21f16f28 <load_serial_ymodem>
21f15d0c:	e1a03000 	mov	r3, r0
21f15d10:	e50b3020 	str	r3, [fp, #-32]
21f15d14:	ea000018 	b	21f15d7c <do_load_serial_bin+0x1f0>

	} else {

		printf ("## Ready for binary (kermit) download "
21f15d18:	e59f00d0 	ldr	r0, [pc, #208]	; 21f15df0 <.text+0x15df0>
21f15d1c:	e51b1024 	ldr	r1, [fp, #-36]
21f15d20:	e51b201c 	ldr	r2, [fp, #-28]
21f15d24:	eb001758 	bl	21f1ba8c <printf>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);
		addr = load_serial_bin (offset);
21f15d28:	e51b0024 	ldr	r0, [fp, #-36]
21f15d2c:	eb000034 	bl	21f15e04 <load_serial_bin>
21f15d30:	e1a03000 	mov	r3, r0
21f15d34:	e50b3020 	str	r3, [fp, #-32]

		if (addr == ~0) {
21f15d38:	e51b3020 	ldr	r3, [fp, #-32]
21f15d3c:	e3730001 	cmn	r3, #1	; 0x1
21f15d40:	1a000007 	bne	21f15d64 <do_load_serial_bin+0x1d8>
			load_addr = 0;
21f15d44:	e59f30a8 	ldr	r3, [pc, #168]	; 21f15df4 <.text+0x15df4>
21f15d48:	e3a02000 	mov	r2, #0	; 0x0
21f15d4c:	e5832000 	str	r2, [r3]
			printf ("## Binary (kermit) download aborted\n");
21f15d50:	e59f00a0 	ldr	r0, [pc, #160]	; 21f15df8 <.text+0x15df8>
21f15d54:	eb00174c 	bl	21f1ba8c <printf>
			rcode = 1;
21f15d58:	e3a03001 	mov	r3, #1	; 0x1
21f15d5c:	e50b3014 	str	r3, [fp, #-20]
21f15d60:	ea000005 	b	21f15d7c <do_load_serial_bin+0x1f0>
		} else {
			printf ("## Start Addr      = 0x%08lX\n", addr);
21f15d64:	e59f0090 	ldr	r0, [pc, #144]	; 21f15dfc <.text+0x15dfc>
21f15d68:	e51b1020 	ldr	r1, [fp, #-32]
21f15d6c:	eb001746 	bl	21f1ba8c <printf>
			load_addr = addr;
21f15d70:	e59f207c 	ldr	r2, [pc, #124]	; 21f15df4 <.text+0x15df4>
21f15d74:	e51b3020 	ldr	r3, [fp, #-32]
21f15d78:	e5823000 	str	r3, [r2]
		}
	}
	if (load_baudrate != current_baudrate) {
21f15d7c:	e51b201c 	ldr	r2, [fp, #-28]
21f15d80:	e51b3018 	ldr	r3, [fp, #-24]
21f15d84:	e1520003 	cmp	r2, r3
21f15d88:	0a000010 	beq	21f15dd0 <do_load_serial_bin+0x244>
		printf ("## Switch baudrate to %d bps and press ESC ...\n",
21f15d8c:	e59f006c 	ldr	r0, [pc, #108]	; 21f15e00 <.text+0x15e00>
21f15d90:	e51b1018 	ldr	r1, [fp, #-24]
21f15d94:	eb00173c 	bl	21f1ba8c <printf>
			current_baudrate);
		udelay (50000);
21f15d98:	e3a00cc3 	mov	r0, #49920	; 0xc300
21f15d9c:	e2800050 	add	r0, r0, #80	; 0x50
21f15da0:	ebffab40 	bl	21f00aa8 <udelay>
		gd->baudrate = current_baudrate;
21f15da4:	e1a02008 	mov	r2, r8
21f15da8:	e51b3018 	ldr	r3, [fp, #-24]
21f15dac:	e5823008 	str	r3, [r2, #8]
		serial_setbrg ();
21f15db0:	eb006166 	bl	21f2e350 <serial_setbrg>
		udelay (50000);
21f15db4:	e3a00cc3 	mov	r0, #49920	; 0xc300
21f15db8:	e2800050 	add	r0, r0, #80	; 0x50
21f15dbc:	ebffab39 	bl	21f00aa8 <udelay>
		for (;;) {
			if (getc() == 0x1B) /* ESC */
21f15dc0:	eb0016dc 	bl	21f1b938 <getc>
21f15dc4:	e1a03000 	mov	r3, r0
21f15dc8:	e353001b 	cmp	r3, #27	; 0x1b
21f15dcc:	1afffffb 	bne	21f15dc0 <do_load_serial_bin+0x234>
				break;
		}
	}

#ifdef CONFIG_AUTOSCRIPT
	if (load_addr) {
		char *s;

		if (((s = getenv("autoscript")) != NULL) && (strcmp(s,"yes") == 0)) {
			printf("Running autoscript at addr 0x%08lX ...\n", load_addr);
			rcode = autoscript (load_addr);
		}
	}
#endif
	return rcode;
21f15dd0:	e51b3014 	ldr	r3, [fp, #-20]
}
21f15dd4:	e1a00003 	mov	r0, r3
21f15dd8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f15ddc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f15de0:	21f30ec4 	mvncss	r0, r4, asr #29
21f15de4:	21f30ed0 	ldrcssb	r0, [r3, #224]!
21f15de8:	21f30f04 	mvncss	r0, r4, lsl #30
21f15dec:	21f30f0c 	mvncss	r0, ip, lsl #30
21f15df0:	21f30f4c 	mvncss	r0, ip, asr #30
21f15df4:	21f3322c 	mvncss	r3, ip, lsr #4
21f15df8:	21f30f8c 	mvncss	r0, ip, lsl #31
21f15dfc:	21f30fb4 	ldrcsh	r0, [r3, #244]!
21f15e00:	21f30fd4 	ldrcssb	r0, [r3, #244]!

21f15e04 <load_serial_bin>:


static ulong load_serial_bin (ulong offset)
{
21f15e04:	e1a0c00d 	mov	ip, sp
21f15e08:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15e0c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15e10:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f15e14:	e50b0038 	str	r0, [fp, #-56]
	int size, i;
	char buf[32];

	set_kerm_bin_mode ((ulong *) offset);
21f15e18:	e51b3038 	ldr	r3, [fp, #-56]
21f15e1c:	e1a00003 	mov	r0, r3
21f15e20:	eb000155 	bl	21f1637c <set_kerm_bin_mode>
	size = k_recv ();
21f15e24:	eb0002fe 	bl	21f16a24 <k_recv>
21f15e28:	e1a03000 	mov	r3, r0
21f15e2c:	e50b3014 	str	r3, [fp, #-20]

	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
21f15e30:	e3a03000 	mov	r3, #0	; 0x0
21f15e34:	e50b3010 	str	r3, [fp, #-16]
21f15e38:	ea000009 	b	21f15e64 <load_serial_bin+0x60>
		if (tstc()) {
21f15e3c:	eb0016d3 	bl	21f1b990 <tstc>
21f15e40:	e1a03000 	mov	r3, r0
21f15e44:	e3530000 	cmp	r3, #0	; 0x0
21f15e48:	0a000000 	beq	21f15e50 <load_serial_bin+0x4c>
			(void) getc();
21f15e4c:	eb0016b9 	bl	21f1b938 <getc>
		}
		udelay(1000);
21f15e50:	e3a00ffa 	mov	r0, #1000	; 0x3e8
21f15e54:	ebffab13 	bl	21f00aa8 <udelay>
21f15e58:	e51b3010 	ldr	r3, [fp, #-16]
21f15e5c:	e2833001 	add	r3, r3, #1	; 0x1
21f15e60:	e50b3010 	str	r3, [fp, #-16]
21f15e64:	e51b3010 	ldr	r3, [fp, #-16]
21f15e68:	e3530063 	cmp	r3, #99	; 0x63
21f15e6c:	dafffff2 	ble	21f15e3c <load_serial_bin+0x38>
	}

	flush_cache (offset, size);
21f15e70:	e51b3014 	ldr	r3, [fp, #-20]
21f15e74:	e51b0038 	ldr	r0, [fp, #-56]
21f15e78:	e1a01003 	mov	r1, r3
21f15e7c:	eb0063cb 	bl	21f2edb0 <flush_cache>

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
21f15e80:	e59f003c 	ldr	r0, [pc, #60]	; 21f15ec4 <.text+0x15ec4>
21f15e84:	e51b1014 	ldr	r1, [fp, #-20]
21f15e88:	e51b2014 	ldr	r2, [fp, #-20]
21f15e8c:	eb0016fe 	bl	21f1ba8c <printf>
	sprintf(buf, "%X", size);
21f15e90:	e24b3034 	sub	r3, fp, #52	; 0x34
21f15e94:	e1a00003 	mov	r0, r3
21f15e98:	e59f1028 	ldr	r1, [pc, #40]	; 21f15ec8 <.text+0x15ec8>
21f15e9c:	e51b2014 	ldr	r2, [fp, #-20]
21f15ea0:	eb003a08 	bl	21f246c8 <sprintf>
	setenv("filesize", buf);
21f15ea4:	e24b3034 	sub	r3, fp, #52	; 0x34
21f15ea8:	e59f001c 	ldr	r0, [pc, #28]	; 21f15ecc <.text+0x15ecc>
21f15eac:	e1a01003 	mov	r1, r3
21f15eb0:	eb001324 	bl	21f1ab48 <setenv>

	return offset;
21f15eb4:	e51b3038 	ldr	r3, [fp, #-56]
}
21f15eb8:	e1a00003 	mov	r0, r3
21f15ebc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f15ec0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f15ec4:	21f31004 	mvncss	r1, r4
21f15ec8:	21f3102c 	mvncss	r1, ip, lsr #32
21f15ecc:	21f31030 	mvncss	r1, r0, lsr r0

21f15ed0 <send_pad>:

void send_pad (void)
{
21f15ed0:	e1a0c00d 	mov	ip, sp
21f15ed4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15ed8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15edc:	e24dd004 	sub	sp, sp, #4	; 0x4
	int count = his_pad_count;
21f15ee0:	e59f3044 	ldr	r3, [pc, #68]	; 21f15f2c <.text+0x15f2c>
21f15ee4:	e5933000 	ldr	r3, [r3]
21f15ee8:	e50b3010 	str	r3, [fp, #-16]

	while (count-- > 0)
21f15eec:	ea000003 	b	21f15f00 <send_pad+0x30>
		putc (his_pad_char);
21f15ef0:	e59f3038 	ldr	r3, [pc, #56]	; 21f15f30 <.text+0x15f30>
21f15ef4:	e5d33000 	ldrb	r3, [r3]
21f15ef8:	e1a00003 	mov	r0, r3
21f15efc:	eb0016b9 	bl	21f1b9e8 <putc>
21f15f00:	e51b3010 	ldr	r3, [fp, #-16]
21f15f04:	e3530000 	cmp	r3, #0	; 0x0
21f15f08:	d3a03000 	movle	r3, #0	; 0x0
21f15f0c:	c3a03001 	movgt	r3, #1	; 0x1
21f15f10:	e20320ff 	and	r2, r3, #255	; 0xff
21f15f14:	e51b3010 	ldr	r3, [fp, #-16]
21f15f18:	e2433001 	sub	r3, r3, #1	; 0x1
21f15f1c:	e50b3010 	str	r3, [fp, #-16]
21f15f20:	e3520000 	cmp	r2, #0	; 0x0
21f15f24:	1afffff1 	bne	21f15ef0 <send_pad+0x20>
}
21f15f28:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f15f2c:	21f676cc 	mvncss	r7, ip, asr #13
21f15f30:	21f676d0 	ldrcssb	r7, [r6, #96]!

21f15f34 <ktrans>:

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
21f15f34:	e1a0c00d 	mov	ip, sp
21f15f38:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15f3c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15f40:	e24dd008 	sub	sp, sp, #8	; 0x8
21f15f44:	e1a03000 	mov	r3, r0
21f15f48:	e54b3010 	strb	r3, [fp, #-16]
	if ((in & 0x60) == 0x40) {
21f15f4c:	e55b3010 	ldrb	r3, [fp, #-16]
21f15f50:	e2033060 	and	r3, r3, #96	; 0x60
21f15f54:	e3530040 	cmp	r3, #64	; 0x40
21f15f58:	1a000003 	bne	21f15f6c <ktrans+0x38>
		return (char) (in & ~0x40);
21f15f5c:	e55b3010 	ldrb	r3, [fp, #-16]
21f15f60:	e20330bf 	and	r3, r3, #191	; 0xbf
21f15f64:	e50b3014 	str	r3, [fp, #-20]
21f15f68:	ea00000a 	b	21f15f98 <ktrans+0x64>
	} else if ((in & 0x7f) == 0x3f) {
21f15f6c:	e55b3010 	ldrb	r3, [fp, #-16]
21f15f70:	e203307f 	and	r3, r3, #127	; 0x7f
21f15f74:	e353003f 	cmp	r3, #63	; 0x3f
21f15f78:	1a000004 	bne	21f15f90 <ktrans+0x5c>
		return (char) (in | 0x40);
21f15f7c:	e55b3010 	ldrb	r3, [fp, #-16]
21f15f80:	e3833040 	orr	r3, r3, #64	; 0x40
21f15f84:	e20330ff 	and	r3, r3, #255	; 0xff
21f15f88:	e50b3014 	str	r3, [fp, #-20]
21f15f8c:	ea000001 	b	21f15f98 <ktrans+0x64>
	} else
		return in;
21f15f90:	e55b3010 	ldrb	r3, [fp, #-16]
21f15f94:	e50b3014 	str	r3, [fp, #-20]
21f15f98:	e51b3014 	ldr	r3, [fp, #-20]
}
21f15f9c:	e1a00003 	mov	r0, r3
21f15fa0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f15fa4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f15fa8 <chk1>:

int chk1 (char *buffer)
{
21f15fa8:	e1a0c00d 	mov	ip, sp
21f15fac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f15fb0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f15fb4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f15fb8:	e50b0014 	str	r0, [fp, #-20]
	int total = 0;
21f15fbc:	e3a03000 	mov	r3, #0	; 0x0
21f15fc0:	e50b3010 	str	r3, [fp, #-16]

	while (*buffer) {
21f15fc4:	ea000008 	b	21f15fec <chk1+0x44>
		total += *buffer++;
21f15fc8:	e51b3014 	ldr	r3, [fp, #-20]
21f15fcc:	e5d33000 	ldrb	r3, [r3]
21f15fd0:	e1a02003 	mov	r2, r3
21f15fd4:	e51b3010 	ldr	r3, [fp, #-16]
21f15fd8:	e0833002 	add	r3, r3, r2
21f15fdc:	e50b3010 	str	r3, [fp, #-16]
21f15fe0:	e51b3014 	ldr	r3, [fp, #-20]
21f15fe4:	e2833001 	add	r3, r3, #1	; 0x1
21f15fe8:	e50b3014 	str	r3, [fp, #-20]
21f15fec:	e51b3014 	ldr	r3, [fp, #-20]
21f15ff0:	e5d33000 	ldrb	r3, [r3]
21f15ff4:	e3530000 	cmp	r3, #0	; 0x0
21f15ff8:	1afffff2 	bne	21f15fc8 <chk1+0x20>
	}
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
21f15ffc:	e51b3010 	ldr	r3, [fp, #-16]
21f16000:	e1a03343 	mov	r3, r3, asr #6
21f16004:	e2032003 	and	r2, r3, #3	; 0x3
21f16008:	e51b3010 	ldr	r3, [fp, #-16]
21f1600c:	e0823003 	add	r3, r2, r3
21f16010:	e203303f 	and	r3, r3, #63	; 0x3f
}
21f16014:	e1a00003 	mov	r0, r3
21f16018:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1601c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f16020 <s1_sendpacket>:

void s1_sendpacket (char *packet)
{
21f16020:	e1a0c00d 	mov	ip, sp
21f16024:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16028:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1602c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f16030:	e50b0010 	str	r0, [fp, #-16]
	send_pad ();
21f16034:	ebffffa5 	bl	21f15ed0 <send_pad>
	while (*packet) {
21f16038:	ea000007 	b	21f1605c <s1_sendpacket+0x3c>
		putc (*packet++);
21f1603c:	e51b3010 	ldr	r3, [fp, #-16]
21f16040:	e5d33000 	ldrb	r3, [r3]
21f16044:	e1a02003 	mov	r2, r3
21f16048:	e51b3010 	ldr	r3, [fp, #-16]
21f1604c:	e2833001 	add	r3, r3, #1	; 0x1
21f16050:	e50b3010 	str	r3, [fp, #-16]
21f16054:	e1a00002 	mov	r0, r2
21f16058:	eb001662 	bl	21f1b9e8 <putc>
21f1605c:	e51b3010 	ldr	r3, [fp, #-16]
21f16060:	e5d33000 	ldrb	r3, [r3]
21f16064:	e3530000 	cmp	r3, #0	; 0x0
21f16068:	1afffff3 	bne	21f1603c <s1_sendpacket+0x1c>
	}
}
21f1606c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f16070 <send_ack>:

static char a_b[24];
void send_ack (int n)
{
21f16070:	e1a0c00d 	mov	ip, sp
21f16074:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16078:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1607c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f16080:	e50b0010 	str	r0, [fp, #-16]
	a_b[0] = START_CHAR;
21f16084:	e59f20ac 	ldr	r2, [pc, #172]	; 21f16138 <.text+0x16138>
21f16088:	e3a03001 	mov	r3, #1	; 0x1
21f1608c:	e5c23000 	strb	r3, [r2]
	a_b[1] = tochar (3);
21f16090:	e59f20a0 	ldr	r2, [pc, #160]	; 21f16138 <.text+0x16138>
21f16094:	e3a03023 	mov	r3, #35	; 0x23
21f16098:	e5c23001 	strb	r3, [r2, #1]
	a_b[2] = tochar (n);
21f1609c:	e51b3010 	ldr	r3, [fp, #-16]
21f160a0:	e20330ff 	and	r3, r3, #255	; 0xff
21f160a4:	e2833020 	add	r3, r3, #32	; 0x20
21f160a8:	e20330ff 	and	r3, r3, #255	; 0xff
21f160ac:	e20320ff 	and	r2, r3, #255	; 0xff
21f160b0:	e3a030ff 	mov	r3, #255	; 0xff
21f160b4:	e0023003 	and	r3, r2, r3
21f160b8:	e20330ff 	and	r3, r3, #255	; 0xff
21f160bc:	e59f2074 	ldr	r2, [pc, #116]	; 21f16138 <.text+0x16138>
21f160c0:	e5c23002 	strb	r3, [r2, #2]
	a_b[3] = ACK_TYPE;
21f160c4:	e59f206c 	ldr	r2, [pc, #108]	; 21f16138 <.text+0x16138>
21f160c8:	e3a03059 	mov	r3, #89	; 0x59
21f160cc:	e5c23003 	strb	r3, [r2, #3]
	a_b[4] = '\0';
21f160d0:	e59f2060 	ldr	r2, [pc, #96]	; 21f16138 <.text+0x16138>
21f160d4:	e3a03000 	mov	r3, #0	; 0x0
21f160d8:	e5c23004 	strb	r3, [r2, #4]
	a_b[4] = tochar (chk1 (&a_b[1]));
21f160dc:	e59f3058 	ldr	r3, [pc, #88]	; 21f1613c <.text+0x1613c>
21f160e0:	e1a00003 	mov	r0, r3
21f160e4:	ebffffaf 	bl	21f15fa8 <chk1>
21f160e8:	e1a03000 	mov	r3, r0
21f160ec:	e20330ff 	and	r3, r3, #255	; 0xff
21f160f0:	e2833020 	add	r3, r3, #32	; 0x20
21f160f4:	e20330ff 	and	r3, r3, #255	; 0xff
21f160f8:	e20320ff 	and	r2, r3, #255	; 0xff
21f160fc:	e3a030ff 	mov	r3, #255	; 0xff
21f16100:	e0023003 	and	r3, r2, r3
21f16104:	e20330ff 	and	r3, r3, #255	; 0xff
21f16108:	e59f2028 	ldr	r2, [pc, #40]	; 21f16138 <.text+0x16138>
21f1610c:	e5c23004 	strb	r3, [r2, #4]
	a_b[5] = his_eol;
21f16110:	e59f3028 	ldr	r3, [pc, #40]	; 21f16140 <.text+0x16140>
21f16114:	e5d33000 	ldrb	r3, [r3]
21f16118:	e59f2018 	ldr	r2, [pc, #24]	; 21f16138 <.text+0x16138>
21f1611c:	e5c23005 	strb	r3, [r2, #5]
	a_b[6] = '\0';
21f16120:	e59f2010 	ldr	r2, [pc, #16]	; 21f16138 <.text+0x16138>
21f16124:	e3a03000 	mov	r3, #0	; 0x0
21f16128:	e5c23006 	strb	r3, [r2, #6]
	s1_sendpacket (a_b);
21f1612c:	e59f0004 	ldr	r0, [pc, #4]	; 21f16138 <.text+0x16138>
21f16130:	ebffffba 	bl	21f16020 <s1_sendpacket>
}
21f16134:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f16138:	21f676f4 	ldrcssh	r7, [r6, #100]!
21f1613c:	21f676f5 	ldrcssh	r7, [r6, #101]!
21f16140:	21f676c8 	mvncss	r7, r8, asr #13

21f16144 <send_nack>:

void send_nack (int n)
{
21f16144:	e1a0c00d 	mov	ip, sp
21f16148:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1614c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f16150:	e24dd004 	sub	sp, sp, #4	; 0x4
21f16154:	e50b0010 	str	r0, [fp, #-16]
	a_b[0] = START_CHAR;
21f16158:	e59f20ac 	ldr	r2, [pc, #172]	; 21f1620c <.text+0x1620c>
21f1615c:	e3a03001 	mov	r3, #1	; 0x1
21f16160:	e5c23000 	strb	r3, [r2]
	a_b[1] = tochar (3);
21f16164:	e59f20a0 	ldr	r2, [pc, #160]	; 21f1620c <.text+0x1620c>
21f16168:	e3a03023 	mov	r3, #35	; 0x23
21f1616c:	e5c23001 	strb	r3, [r2, #1]
	a_b[2] = tochar (n);
21f16170:	e51b3010 	ldr	r3, [fp, #-16]
21f16174:	e20330ff 	and	r3, r3, #255	; 0xff
21f16178:	e2833020 	add	r3, r3, #32	; 0x20
21f1617c:	e20330ff 	and	r3, r3, #255	; 0xff
21f16180:	e20320ff 	and	r2, r3, #255	; 0xff
21f16184:	e3a030ff 	mov	r3, #255	; 0xff
21f16188:	e0023003 	and	r3, r2, r3
21f1618c:	e20330ff 	and	r3, r3, #255	; 0xff
21f16190:	e59f2074 	ldr	r2, [pc, #116]	; 21f1620c <.text+0x1620c>
21f16194:	e5c23002 	strb	r3, [r2, #2]
	a_b[3] = NACK_TYPE;
21f16198:	e59f206c 	ldr	r2, [pc, #108]	; 21f1620c <.text+0x1620c>
21f1619c:	e3a0304e 	mov	r3, #78	; 0x4e
21f161a0:	e5c23003 	strb	r3, [r2, #3]
	a_b[4] = '\0';
21f161a4:	e59f2060 	ldr	r2, [pc, #96]	; 21f1620c <.text+0x1620c>
21f161a8:	e3a03000 	mov	r3, #0	; 0x0
21f161ac:	e5c23004 	strb	r3, [r2, #4]
	a_b[4] = tochar (chk1 (&a_b[1]));
21f161b0:	e59f3058 	ldr	r3, [pc, #88]	; 21f16210 <.text+0x16210>
21f161b4:	e1a00003 	mov	r0, r3
21f161b8:	ebffff7a 	bl	21f15fa8 <chk1>
21f161bc:	e1a03000 	mov	r3, r0
21f161c0:	e20330ff 	and	r3, r3, #255	; 0xff
21f161c4:	e2833020 	add	r3, r3, #32	; 0x20
21f161c8:	e20330ff 	and	r3, r3, #255	; 0xff
21f161cc:	e20320ff 	and	r2, r3, #255	; 0xff
21f161d0:	e3a030ff 	mov	r3, #255	; 0xff
21f161d4:	e0023003 	and	r3, r2, r3
21f161d8:	e20330ff 	and	r3, r3, #255	; 0xff
21f161dc:	e59f2028 	ldr	r2, [pc, #40]	; 21f1620c <.text+0x1620c>
21f161e0:	e5c23004 	strb	r3, [r2, #4]
	a_b[5] = his_eol;
21f161e4:	e59f3028 	ldr	r3, [pc, #40]	; 21f16214 <.text+0x16214>
21f161e8:	e5d33000 	ldrb	r3, [r3]
21f161ec:	e59f2018 	ldr	r2, [pc, #24]	; 21f1620c <.text+0x1620c>
21f161f0:	e5c23005 	strb	r3, [r2, #5]
	a_b[6] = '\0';
21f161f4:	e59f2010 	ldr	r2, [pc, #16]	; 21f1620c <.text+0x1620c>
21f161f8:	e3a03000 	mov	r3, #0	; 0x0
21f161fc:	e5c23006 	strb	r3, [r2, #6]
	s1_sendpacket (a_b);
21f16200:	e59f0004 	ldr	r0, [pc, #4]	; 21f1620c <.text+0x1620c>
21f16204:	ebffff85 	bl	21f16020 <s1_sendpacket>
}
21f16208:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f1620c:	21f676f4 	ldrcssh	r7, [r6, #100]!
21f16210:	21f676f5 	ldrcssh	r7, [r6, #101]!
21f16214:	21f676c8 	mvncss	r7, r8, asr #13

21f16218 <bin_data_init>:


/* os_data_* takes an OS Open image and puts it into memory, and
   puts the boot header in an array named os_data_header

   if image is binary, no header is stored in os_data_header.
*/
void (*os_data_init) (void);
void (*os_data_char) (char new_char);
static int os_data_state, os_data_state_saved;
int os_data_count;
static int os_data_count_saved;
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;
int os_data_header[8];
static void bin_data_init (void)
{
21f16218:	e1a0c00d 	mov	ip, sp
21f1621c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16220:	e24cb004 	sub	fp, ip, #4	; 0x4
	os_data_state = 0;
21f16224:	e59f2024 	ldr	r2, [pc, #36]	; 21f16250 <.text+0x16250>
21f16228:	e3a03000 	mov	r3, #0	; 0x0
21f1622c:	e5823000 	str	r3, [r2]
	os_data_count = 0;
21f16230:	e59f201c 	ldr	r2, [pc, #28]	; 21f16254 <.text+0x16254>
21f16234:	e3a03000 	mov	r3, #0	; 0x0
21f16238:	e5823000 	str	r3, [r2]
	os_data_addr = bin_start_address;
21f1623c:	e59f3014 	ldr	r3, [pc, #20]	; 21f16258 <.text+0x16258>
21f16240:	e5932000 	ldr	r2, [r3]
21f16244:	e59f3010 	ldr	r3, [pc, #16]	; 21f1625c <.text+0x1625c>
21f16248:	e5832000 	str	r2, [r3]
}
21f1624c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f16250:	21f6770c 	mvncss	r7, ip, lsl #14
21f16254:	21f676a4 	mvncss	r7, r4, lsr #13
21f16258:	21f67720 	mvncss	r7, r0, lsr #14
21f1625c:	21f67718 	mvncss	r7, r8, lsl r7

21f16260 <os_data_save>:
static void os_data_save (void)
{
21f16260:	e1a0c00d 	mov	ip, sp
21f16264:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16268:	e24cb004 	sub	fp, ip, #4	; 0x4
	os_data_state_saved = os_data_state;
21f1626c:	e59f302c 	ldr	r3, [pc, #44]	; 21f162a0 <.text+0x162a0>
21f16270:	e5932000 	ldr	r2, [r3]
21f16274:	e59f3028 	ldr	r3, [pc, #40]	; 21f162a4 <.text+0x162a4>
21f16278:	e5832000 	str	r2, [r3]
	os_data_count_saved = os_data_count;
21f1627c:	e59f3024 	ldr	r3, [pc, #36]	; 21f162a8 <.text+0x162a8>
21f16280:	e5932000 	ldr	r2, [r3]
21f16284:	e59f3020 	ldr	r3, [pc, #32]	; 21f162ac <.text+0x162ac>
21f16288:	e5832000 	str	r2, [r3]
	os_data_addr_saved = os_data_addr;
21f1628c:	e59f301c 	ldr	r3, [pc, #28]	; 21f162b0 <.text+0x162b0>
21f16290:	e5932000 	ldr	r2, [r3]
21f16294:	e59f3018 	ldr	r3, [pc, #24]	; 21f162b4 <.text+0x162b4>
21f16298:	e5832000 	str	r2, [r3]
}
21f1629c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f162a0:	21f6770c 	mvncss	r7, ip, lsl #14
21f162a4:	21f67710 	mvncss	r7, r0, lsl r7
21f162a8:	21f676a4 	mvncss	r7, r4, lsr #13
21f162ac:	21f67714 	mvncss	r7, r4, lsl r7
21f162b0:	21f67718 	mvncss	r7, r8, lsl r7
21f162b4:	21f6771c 	mvncss	r7, ip, lsl r7

21f162b8 <os_data_restore>:
static void os_data_restore (void)
{
21f162b8:	e1a0c00d 	mov	ip, sp
21f162bc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f162c0:	e24cb004 	sub	fp, ip, #4	; 0x4
	os_data_state = os_data_state_saved;
21f162c4:	e59f302c 	ldr	r3, [pc, #44]	; 21f162f8 <.text+0x162f8>
21f162c8:	e5932000 	ldr	r2, [r3]
21f162cc:	e59f3028 	ldr	r3, [pc, #40]	; 21f162fc <.text+0x162fc>
21f162d0:	e5832000 	str	r2, [r3]
	os_data_count = os_data_count_saved;
21f162d4:	e59f3024 	ldr	r3, [pc, #36]	; 21f16300 <.text+0x16300>
21f162d8:	e5932000 	ldr	r2, [r3]
21f162dc:	e59f3020 	ldr	r3, [pc, #32]	; 21f16304 <.text+0x16304>
21f162e0:	e5832000 	str	r2, [r3]
	os_data_addr = os_data_addr_saved;
21f162e4:	e59f301c 	ldr	r3, [pc, #28]	; 21f16308 <.text+0x16308>
21f162e8:	e5932000 	ldr	r2, [r3]
21f162ec:	e59f3018 	ldr	r3, [pc, #24]	; 21f1630c <.text+0x1630c>
21f162f0:	e5832000 	str	r2, [r3]
}
21f162f4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f162f8:	21f67710 	mvncss	r7, r0, lsl r7
21f162fc:	21f6770c 	mvncss	r7, ip, lsl #14
21f16300:	21f67714 	mvncss	r7, r4, lsl r7
21f16304:	21f676a4 	mvncss	r7, r4, lsr #13
21f16308:	21f6771c 	mvncss	r7, ip, lsl r7
21f1630c:	21f67718 	mvncss	r7, r8, lsl r7

21f16310 <bin_data_char>:
static void bin_data_char (char new_char)
{
21f16310:	e1a0c00d 	mov	ip, sp
21f16314:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16318:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1631c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f16320:	e1a03000 	mov	r3, r0
21f16324:	e54b3010 	strb	r3, [fp, #-16]
	switch (os_data_state) {
21f16328:	e59f3040 	ldr	r3, [pc, #64]	; 21f16370 <.text+0x16370>
21f1632c:	e5933000 	ldr	r3, [r3]
21f16330:	e3530000 	cmp	r3, #0	; 0x0
21f16334:	0a000000 	beq	21f1633c <bin_data_char+0x2c>
21f16338:	ea00000b 	b	21f1636c <bin_data_char+0x5c>
	case 0:					/* data */
		*os_data_addr++ = new_char;
21f1633c:	e59f3030 	ldr	r3, [pc, #48]	; 21f16374 <.text+0x16374>
21f16340:	e5932000 	ldr	r2, [r3]
21f16344:	e55b3010 	ldrb	r3, [fp, #-16]
21f16348:	e5c23000 	strb	r3, [r2]
21f1634c:	e2822001 	add	r2, r2, #1	; 0x1
21f16350:	e59f301c 	ldr	r3, [pc, #28]	; 21f16374 <.text+0x16374>
21f16354:	e5832000 	str	r2, [r3]
		--os_data_count;
21f16358:	e59f3018 	ldr	r3, [pc, #24]	; 21f16378 <.text+0x16378>
21f1635c:	e5933000 	ldr	r3, [r3]
21f16360:	e2432001 	sub	r2, r3, #1	; 0x1
21f16364:	e59f300c 	ldr	r3, [pc, #12]	; 21f16378 <.text+0x16378>
21f16368:	e5832000 	str	r2, [r3]
		break;
	}
}
21f1636c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f16370:	21f6770c 	mvncss	r7, ip, lsl #14
21f16374:	21f67718 	mvncss	r7, r8, lsl r7
21f16378:	21f676a4 	mvncss	r7, r4, lsr #13

21f1637c <set_kerm_bin_mode>:
static void set_kerm_bin_mode (unsigned long *addr)
{
21f1637c:	e1a0c00d 	mov	ip, sp
21f16380:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16384:	e24cb004 	sub	fp, ip, #4	; 0x4
21f16388:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1638c:	e50b0010 	str	r0, [fp, #-16]
	bin_start_address = (char *) addr;
21f16390:	e51b2010 	ldr	r2, [fp, #-16]
21f16394:	e59f301c 	ldr	r3, [pc, #28]	; 21f163b8 <.text+0x163b8>
21f16398:	e5832000 	str	r2, [r3]
	os_data_init = bin_data_init;
21f1639c:	e59f2018 	ldr	r2, [pc, #24]	; 21f163bc <.text+0x163bc>
21f163a0:	e59f3018 	ldr	r3, [pc, #24]	; 21f163c0 <.text+0x163c0>
21f163a4:	e5823000 	str	r3, [r2]
	os_data_char = bin_data_char;
21f163a8:	e59f2014 	ldr	r2, [pc, #20]	; 21f163c4 <.text+0x163c4>
21f163ac:	e59f3014 	ldr	r3, [pc, #20]	; 21f163c8 <.text+0x163c8>
21f163b0:	e5823000 	str	r3, [r2]
}
21f163b4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f163b8:	21f67720 	mvncss	r7, r0, lsr #14
21f163bc:	21f676d4 	ldrcssb	r7, [r6, #100]!
21f163c0:	21f16218 	mvncss	r6, r8, lsl r2
21f163c4:	21f676d8 	ldrcssb	r7, [r6, #104]!
21f163c8:	21f16310 	mvncss	r6, r0, lsl r3

21f163cc <k_data_init>:


/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
void k_data_init (void)
{
21f163cc:	e1a0c00d 	mov	ip, sp
21f163d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f163d4:	e24cb004 	sub	fp, ip, #4	; 0x4
	k_data_escape = 0;
21f163d8:	e59f2018 	ldr	r2, [pc, #24]	; 21f163f8 <.text+0x163f8>
21f163dc:	e3a03000 	mov	r3, #0	; 0x0
21f163e0:	e5823000 	str	r3, [r2]
	os_data_init ();
21f163e4:	e59f3010 	ldr	r3, [pc, #16]	; 21f163fc <.text+0x163fc>
21f163e8:	e5933000 	ldr	r3, [r3]
21f163ec:	e1a0e00f 	mov	lr, pc
21f163f0:	e1a0f003 	mov	pc, r3
}
21f163f4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f163f8:	21f67724 	mvncss	r7, r4, lsr #14
21f163fc:	21f676d4 	ldrcssb	r7, [r6, #100]!

21f16400 <k_data_save>:
void k_data_save (void)
{
21f16400:	e1a0c00d 	mov	ip, sp
21f16404:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16408:	e24cb004 	sub	fp, ip, #4	; 0x4
	k_data_escape_saved = k_data_escape;
21f1640c:	e59f3010 	ldr	r3, [pc, #16]	; 21f16424 <.text+0x16424>
21f16410:	e5932000 	ldr	r2, [r3]
21f16414:	e59f300c 	ldr	r3, [pc, #12]	; 21f16428 <.text+0x16428>
21f16418:	e5832000 	str	r2, [r3]
	os_data_save ();
21f1641c:	ebffff8f 	bl	21f16260 <os_data_save>
}
21f16420:	e89da800 	ldmia	sp, {fp, sp, pc}
21f16424:	21f67724 	mvncss	r7, r4, lsr #14
21f16428:	21f67728 	mvncss	r7, r8, lsr #14

21f1642c <k_data_restore>:
void k_data_restore (void)
{
21f1642c:	e1a0c00d 	mov	ip, sp
21f16430:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16434:	e24cb004 	sub	fp, ip, #4	; 0x4
	k_data_escape = k_data_escape_saved;
21f16438:	e59f3010 	ldr	r3, [pc, #16]	; 21f16450 <.text+0x16450>
21f1643c:	e5932000 	ldr	r2, [r3]
21f16440:	e59f300c 	ldr	r3, [pc, #12]	; 21f16454 <.text+0x16454>
21f16444:	e5832000 	str	r2, [r3]
	os_data_restore ();
21f16448:	ebffff9a 	bl	21f162b8 <os_data_restore>
}
21f1644c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f16450:	21f67728 	mvncss	r7, r8, lsr #14
21f16454:	21f67724 	mvncss	r7, r4, lsr #14

21f16458 <k_data_char>:
void k_data_char (char new_char)
{
21f16458:	e1a0c00d 	mov	ip, sp
21f1645c:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f16460:	e24cb004 	sub	fp, ip, #4	; 0x4
21f16464:	e24dd004 	sub	sp, sp, #4	; 0x4
21f16468:	e1a03000 	mov	r3, r0
21f1646c:	e54b3014 	strb	r3, [fp, #-20]
	if (k_data_escape) {
21f16470:	e59f307c 	ldr	r3, [pc, #124]	; 21f164f4 <.text+0x164f4>
21f16474:	e5933000 	ldr	r3, [r3]
21f16478:	e3530000 	cmp	r3, #0	; 0x0
21f1647c:	0a00000c 	beq	21f164b4 <k_data_char+0x5c>
		/* last char was escape - translate this character */
		os_data_char (ktrans (new_char));
21f16480:	e59f3070 	ldr	r3, [pc, #112]	; 21f164f8 <.text+0x164f8>
21f16484:	e5934000 	ldr	r4, [r3]
21f16488:	e55b3014 	ldrb	r3, [fp, #-20]
21f1648c:	e1a00003 	mov	r0, r3
21f16490:	ebfffea7 	bl	21f15f34 <ktrans>
21f16494:	e1a03000 	mov	r3, r0
21f16498:	e1a00003 	mov	r0, r3
21f1649c:	e1a0e00f 	mov	lr, pc
21f164a0:	e1a0f004 	mov	pc, r4
		k_data_escape = 0;
21f164a4:	e59f2048 	ldr	r2, [pc, #72]	; 21f164f4 <.text+0x164f4>
21f164a8:	e3a03000 	mov	r3, #0	; 0x0
21f164ac:	e5823000 	str	r3, [r2]
21f164b0:	ea00000e 	b	21f164f0 <k_data_char+0x98>
	} else {
		if (new_char == his_quote) {
21f164b4:	e59f3040 	ldr	r3, [pc, #64]	; 21f164fc <.text+0x164fc>
21f164b8:	e5d32000 	ldrb	r2, [r3]
21f164bc:	e55b3014 	ldrb	r3, [fp, #-20]
21f164c0:	e1530002 	cmp	r3, r2
21f164c4:	1a000003 	bne	21f164d8 <k_data_char+0x80>
			/* this char is escape - remember */
			k_data_escape = 1;
21f164c8:	e59f2024 	ldr	r2, [pc, #36]	; 21f164f4 <.text+0x164f4>
21f164cc:	e3a03001 	mov	r3, #1	; 0x1
21f164d0:	e5823000 	str	r3, [r2]
21f164d4:	ea000005 	b	21f164f0 <k_data_char+0x98>
		} else {
			/* otherwise send this char as-is */
			os_data_char (new_char);
21f164d8:	e59f3018 	ldr	r3, [pc, #24]	; 21f164f8 <.text+0x164f8>
21f164dc:	e5932000 	ldr	r2, [r3]
21f164e0:	e55b3014 	ldrb	r3, [fp, #-20]
21f164e4:	e1a00003 	mov	r0, r3
21f164e8:	e1a0e00f 	mov	lr, pc
21f164ec:	e1a0f002 	mov	pc, r2
		}
	}
}
21f164f0:	e89da818 	ldmia	sp, {r3, r4, fp, sp, pc}
21f164f4:	21f67724 	mvncss	r7, r4, lsr #14
21f164f8:	21f676d8 	ldrcssb	r7, [r6, #104]!
21f164fc:	21f676d1 	ldrcssb	r7, [r6, #97]!

21f16500 <handle_send_packet>:

#define SEND_DATA_SIZE  20
char send_parms[SEND_DATA_SIZE];
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
21f16500:	e1a0c00d 	mov	ip, sp
21f16504:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f16508:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1650c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f16510:	e50b001c 	str	r0, [fp, #-28]
	int length = 3;
21f16514:	e3a03003 	mov	r3, #3	; 0x3
21f16518:	e50b3018 	str	r3, [fp, #-24]
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
21f1651c:	e59f24dc 	ldr	r2, [pc, #1244]	; 21f16a00 <.text+0x16a00>
21f16520:	e3a0300d 	mov	r3, #13	; 0xd
21f16524:	e5c23000 	strb	r3, [r2]
	his_pad_count = 0;
21f16528:	e59f24d4 	ldr	r2, [pc, #1236]	; 21f16a04 <.text+0x16a04>
21f1652c:	e3a03000 	mov	r3, #0	; 0x0
21f16530:	e5823000 	str	r3, [r2]
	his_pad_char = '\0';
21f16534:	e59f24cc 	ldr	r2, [pc, #1228]	; 21f16a08 <.text+0x16a08>
21f16538:	e3a03000 	mov	r3, #0	; 0x0
21f1653c:	e5c23000 	strb	r3, [r2]
	his_quote = K_ESCAPE;
21f16540:	e59f24c4 	ldr	r2, [pc, #1220]	; 21f16a0c <.text+0x16a0c>
21f16544:	e3a03023 	mov	r3, #35	; 0x23
21f16548:	e5c23000 	strb	r3, [r2]

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
21f1654c:	e59f34bc 	ldr	r3, [pc, #1212]	; 21f16a10 <.text+0x16a10>
21f16550:	e5932000 	ldr	r2, [r3]
21f16554:	e59f34b8 	ldr	r3, [pc, #1208]	; 21f16a14 <.text+0x16a14>
21f16558:	e1520003 	cmp	r2, r3
21f1655c:	1a000004 	bne	21f16574 <handle_send_packet+0x74>
		--send_ptr;
21f16560:	e59f34a8 	ldr	r3, [pc, #1192]	; 21f16a10 <.text+0x16a10>
21f16564:	e5933000 	ldr	r3, [r3]
21f16568:	e2432001 	sub	r2, r3, #1	; 0x1
21f1656c:	e59f349c 	ldr	r3, [pc, #1180]	; 21f16a10 <.text+0x16a10>
21f16570:	e5832000 	str	r2, [r3]
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
21f16574:	e59f3494 	ldr	r3, [pc, #1172]	; 21f16a10 <.text+0x16a10>
21f16578:	e5933000 	ldr	r3, [r3]
21f1657c:	e1a02003 	mov	r2, r3
21f16580:	e59f3490 	ldr	r3, [pc, #1168]	; 21f16a18 <.text+0x16a18>
21f16584:	e0633002 	rsb	r3, r3, r2
21f16588:	e50b3014 	str	r3, [fp, #-20]
	do {
		if (bytes-- <= 0)
21f1658c:	e51b3014 	ldr	r3, [fp, #-20]
21f16590:	e3530000 	cmp	r3, #0	; 0x0
21f16594:	c3a03000 	movgt	r3, #0	; 0x0
21f16598:	d3a03001 	movle	r3, #1	; 0x1
21f1659c:	e20320ff 	and	r2, r3, #255	; 0xff
21f165a0:	e51b3014 	ldr	r3, [fp, #-20]
21f165a4:	e2433001 	sub	r3, r3, #1	; 0x1
21f165a8:	e50b3014 	str	r3, [fp, #-20]
21f165ac:	e3520000 	cmp	r2, #0	; 0x0
21f165b0:	1a0000d0 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
21f165b4:	e51b3018 	ldr	r3, [fp, #-24]
21f165b8:	e2833001 	add	r3, r3, #1	; 0x1
21f165bc:	e50b3018 	str	r3, [fp, #-24]
21f165c0:	e51b1018 	ldr	r1, [fp, #-24]
21f165c4:	e59f2450 	ldr	r2, [pc, #1104]	; 21f16a1c <.text+0x16a1c>
21f165c8:	e3a0307e 	mov	r3, #126	; 0x7e
21f165cc:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f165d0:	e51b3014 	ldr	r3, [fp, #-20]
21f165d4:	e3530000 	cmp	r3, #0	; 0x0
21f165d8:	c3a03000 	movgt	r3, #0	; 0x0
21f165dc:	d3a03001 	movle	r3, #1	; 0x1
21f165e0:	e20320ff 	and	r2, r3, #255	; 0xff
21f165e4:	e51b3014 	ldr	r3, [fp, #-20]
21f165e8:	e2433001 	sub	r3, r3, #1	; 0x1
21f165ec:	e50b3014 	str	r3, [fp, #-20]
21f165f0:	e3520000 	cmp	r2, #0	; 0x0
21f165f4:	1a0000bf 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
21f165f8:	e51b3018 	ldr	r3, [fp, #-24]
21f165fc:	e2833001 	add	r3, r3, #1	; 0x1
21f16600:	e50b3018 	str	r3, [fp, #-24]
21f16604:	e51b1018 	ldr	r1, [fp, #-24]
21f16608:	e59f240c 	ldr	r2, [pc, #1036]	; 21f16a1c <.text+0x16a1c>
21f1660c:	e3a03021 	mov	r3, #33	; 0x21
21f16610:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f16614:	e51b3014 	ldr	r3, [fp, #-20]
21f16618:	e3530000 	cmp	r3, #0	; 0x0
21f1661c:	c3a03000 	movgt	r3, #0	; 0x0
21f16620:	d3a03001 	movle	r3, #1	; 0x1
21f16624:	e20320ff 	and	r2, r3, #255	; 0xff
21f16628:	e51b3014 	ldr	r3, [fp, #-20]
21f1662c:	e2433001 	sub	r3, r3, #1	; 0x1
21f16630:	e50b3014 	str	r3, [fp, #-20]
21f16634:	e3520000 	cmp	r2, #0	; 0x0
21f16638:	1a0000ae 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
21f1663c:	e59f33d4 	ldr	r3, [pc, #980]	; 21f16a18 <.text+0x16a18>
21f16640:	e5d33002 	ldrb	r3, [r3, #2]
21f16644:	e2433020 	sub	r3, r3, #32	; 0x20
21f16648:	e20320ff 	and	r2, r3, #255	; 0xff
21f1664c:	e59f33b0 	ldr	r3, [pc, #944]	; 21f16a04 <.text+0x16a04>
21f16650:	e5832000 	str	r2, [r3]
		a_b[++length] = tochar (0);
21f16654:	e51b3018 	ldr	r3, [fp, #-24]
21f16658:	e2833001 	add	r3, r3, #1	; 0x1
21f1665c:	e50b3018 	str	r3, [fp, #-24]
21f16660:	e51b1018 	ldr	r1, [fp, #-24]
21f16664:	e59f23b0 	ldr	r2, [pc, #944]	; 21f16a1c <.text+0x16a1c>
21f16668:	e3a03020 	mov	r3, #32	; 0x20
21f1666c:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f16670:	e51b3014 	ldr	r3, [fp, #-20]
21f16674:	e3530000 	cmp	r3, #0	; 0x0
21f16678:	c3a03000 	movgt	r3, #0	; 0x0
21f1667c:	d3a03001 	movle	r3, #1	; 0x1
21f16680:	e20320ff 	and	r2, r3, #255	; 0xff
21f16684:	e51b3014 	ldr	r3, [fp, #-20]
21f16688:	e2433001 	sub	r3, r3, #1	; 0x1
21f1668c:	e50b3014 	str	r3, [fp, #-20]
21f16690:	e3520000 	cmp	r2, #0	; 0x0
21f16694:	1a000097 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
21f16698:	e59f3378 	ldr	r3, [pc, #888]	; 21f16a18 <.text+0x16a18>
21f1669c:	e5d33003 	ldrb	r3, [r3, #3]
21f166a0:	e1a00003 	mov	r0, r3
21f166a4:	ebfffe22 	bl	21f15f34 <ktrans>
21f166a8:	e1a03000 	mov	r3, r0
21f166ac:	e59f2354 	ldr	r2, [pc, #852]	; 21f16a08 <.text+0x16a08>
21f166b0:	e5c23000 	strb	r3, [r2]
		a_b[++length] = 0x40;	/* He should ignore this */
21f166b4:	e51b3018 	ldr	r3, [fp, #-24]
21f166b8:	e2833001 	add	r3, r3, #1	; 0x1
21f166bc:	e50b3018 	str	r3, [fp, #-24]
21f166c0:	e51b1018 	ldr	r1, [fp, #-24]
21f166c4:	e59f2350 	ldr	r2, [pc, #848]	; 21f16a1c <.text+0x16a1c>
21f166c8:	e3a03040 	mov	r3, #64	; 0x40
21f166cc:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f166d0:	e51b3014 	ldr	r3, [fp, #-20]
21f166d4:	e3530000 	cmp	r3, #0	; 0x0
21f166d8:	c3a03000 	movgt	r3, #0	; 0x0
21f166dc:	d3a03001 	movle	r3, #1	; 0x1
21f166e0:	e20320ff 	and	r2, r3, #255	; 0xff
21f166e4:	e51b3014 	ldr	r3, [fp, #-20]
21f166e8:	e2433001 	sub	r3, r3, #1	; 0x1
21f166ec:	e50b3014 	str	r3, [fp, #-20]
21f166f0:	e3520000 	cmp	r2, #0	; 0x0
21f166f4:	1a00007f 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
21f166f8:	e59f3318 	ldr	r3, [pc, #792]	; 21f16a18 <.text+0x16a18>
21f166fc:	e5d33004 	ldrb	r3, [r3, #4]
21f16700:	e20330ff 	and	r3, r3, #255	; 0xff
21f16704:	e2433020 	sub	r3, r3, #32	; 0x20
21f16708:	e20330ff 	and	r3, r3, #255	; 0xff
21f1670c:	e20320ff 	and	r2, r3, #255	; 0xff
21f16710:	e3a030ff 	mov	r3, #255	; 0xff
21f16714:	e0023003 	and	r3, r2, r3
21f16718:	e20330ff 	and	r3, r3, #255	; 0xff
21f1671c:	e59f22dc 	ldr	r2, [pc, #732]	; 21f16a00 <.text+0x16a00>
21f16720:	e5c23000 	strb	r3, [r2]
		a_b[++length] = tochar (END_CHAR);
21f16724:	e51b3018 	ldr	r3, [fp, #-24]
21f16728:	e2833001 	add	r3, r3, #1	; 0x1
21f1672c:	e50b3018 	str	r3, [fp, #-24]
21f16730:	e51b1018 	ldr	r1, [fp, #-24]
21f16734:	e59f22e0 	ldr	r2, [pc, #736]	; 21f16a1c <.text+0x16a1c>
21f16738:	e3a0302d 	mov	r3, #45	; 0x2d
21f1673c:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f16740:	e51b3014 	ldr	r3, [fp, #-20]
21f16744:	e3530000 	cmp	r3, #0	; 0x0
21f16748:	c3a03000 	movgt	r3, #0	; 0x0
21f1674c:	d3a03001 	movle	r3, #1	; 0x1
21f16750:	e20320ff 	and	r2, r3, #255	; 0xff
21f16754:	e51b3014 	ldr	r3, [fp, #-20]
21f16758:	e2433001 	sub	r3, r3, #1	; 0x1
21f1675c:	e50b3014 	str	r3, [fp, #-20]
21f16760:	e3520000 	cmp	r2, #0	; 0x0
21f16764:	1a000063 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
21f16768:	e59f32a8 	ldr	r3, [pc, #680]	; 21f16a18 <.text+0x16a18>
21f1676c:	e5d33005 	ldrb	r3, [r3, #5]
21f16770:	e59f2294 	ldr	r2, [pc, #660]	; 21f16a0c <.text+0x16a0c>
21f16774:	e5c23000 	strb	r3, [r2]
		a_b[++length] = '#';
21f16778:	e51b3018 	ldr	r3, [fp, #-24]
21f1677c:	e2833001 	add	r3, r3, #1	; 0x1
21f16780:	e50b3018 	str	r3, [fp, #-24]
21f16784:	e51b1018 	ldr	r1, [fp, #-24]
21f16788:	e59f228c 	ldr	r2, [pc, #652]	; 21f16a1c <.text+0x16a1c>
21f1678c:	e3a03023 	mov	r3, #35	; 0x23
21f16790:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f16794:	e51b3014 	ldr	r3, [fp, #-20]
21f16798:	e3530000 	cmp	r3, #0	; 0x0
21f1679c:	c3a03000 	movgt	r3, #0	; 0x0
21f167a0:	d3a03001 	movle	r3, #1	; 0x1
21f167a4:	e20320ff 	and	r2, r3, #255	; 0xff
21f167a8:	e51b3014 	ldr	r3, [fp, #-20]
21f167ac:	e2433001 	sub	r3, r3, #1	; 0x1
21f167b0:	e50b3014 	str	r3, [fp, #-20]
21f167b4:	e3520000 	cmp	r2, #0	; 0x0
21f167b8:	1a00004e 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
21f167bc:	e51b3018 	ldr	r3, [fp, #-24]
21f167c0:	e2833001 	add	r3, r3, #1	; 0x1
21f167c4:	e50b3018 	str	r3, [fp, #-24]
21f167c8:	e51b1018 	ldr	r1, [fp, #-24]
21f167cc:	e59f2248 	ldr	r2, [pc, #584]	; 21f16a1c <.text+0x16a1c>
21f167d0:	e3a0304e 	mov	r3, #78	; 0x4e
21f167d4:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f167d8:	e51b3014 	ldr	r3, [fp, #-20]
21f167dc:	e3530000 	cmp	r3, #0	; 0x0
21f167e0:	c3a03000 	movgt	r3, #0	; 0x0
21f167e4:	d3a03001 	movle	r3, #1	; 0x1
21f167e8:	e20320ff 	and	r2, r3, #255	; 0xff
21f167ec:	e51b3014 	ldr	r3, [fp, #-20]
21f167f0:	e2433001 	sub	r3, r3, #1	; 0x1
21f167f4:	e50b3014 	str	r3, [fp, #-20]
21f167f8:	e3520000 	cmp	r2, #0	; 0x0
21f167fc:	1a00003d 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
21f16800:	e51b3018 	ldr	r3, [fp, #-24]
21f16804:	e2833001 	add	r3, r3, #1	; 0x1
21f16808:	e50b3018 	str	r3, [fp, #-24]
21f1680c:	e51b1018 	ldr	r1, [fp, #-24]
21f16810:	e59f2204 	ldr	r2, [pc, #516]	; 21f16a1c <.text+0x16a1c>
21f16814:	e3a03031 	mov	r3, #49	; 0x31
21f16818:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f1681c:	e51b3014 	ldr	r3, [fp, #-20]
21f16820:	e3530000 	cmp	r3, #0	; 0x0
21f16824:	c3a03000 	movgt	r3, #0	; 0x0
21f16828:	d3a03001 	movle	r3, #1	; 0x1
21f1682c:	e20320ff 	and	r2, r3, #255	; 0xff
21f16830:	e51b3014 	ldr	r3, [fp, #-20]
21f16834:	e2433001 	sub	r3, r3, #1	; 0x1
21f16838:	e50b3014 	str	r3, [fp, #-20]
21f1683c:	e3520000 	cmp	r2, #0	; 0x0
21f16840:	1a00002c 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
21f16844:	e51b3018 	ldr	r3, [fp, #-24]
21f16848:	e2833001 	add	r3, r3, #1	; 0x1
21f1684c:	e50b3018 	str	r3, [fp, #-24]
21f16850:	e51b1018 	ldr	r1, [fp, #-24]
21f16854:	e59f21c0 	ldr	r2, [pc, #448]	; 21f16a1c <.text+0x16a1c>
21f16858:	e3a0304e 	mov	r3, #78	; 0x4e
21f1685c:	e7c23001 	strb	r3, [r2, r1]
		if (bytes-- <= 0)
21f16860:	e51b3014 	ldr	r3, [fp, #-20]
21f16864:	e3530000 	cmp	r3, #0	; 0x0
21f16868:	c3a03000 	movgt	r3, #0	; 0x0
21f1686c:	d3a03001 	movle	r3, #1	; 0x1
21f16870:	e20320ff 	and	r2, r3, #255	; 0xff
21f16874:	e51b3014 	ldr	r3, [fp, #-20]
21f16878:	e2433001 	sub	r3, r3, #1	; 0x1
21f1687c:	e50b3014 	str	r3, [fp, #-20]
21f16880:	e3520000 	cmp	r2, #0	; 0x0
21f16884:	1a00001b 	bne	21f168f8 <handle_send_packet+0x3f8>
			break;
		/* handle CAPAS - the capabilities mask */
		/* ignore what he says - I only do long packets - I don't do windows */
		a_b[++length] = tochar (2);	/* only long packets */
21f16888:	e51b3018 	ldr	r3, [fp, #-24]
21f1688c:	e2833001 	add	r3, r3, #1	; 0x1
21f16890:	e50b3018 	str	r3, [fp, #-24]
21f16894:	e51b1018 	ldr	r1, [fp, #-24]
21f16898:	e59f217c 	ldr	r2, [pc, #380]	; 21f16a1c <.text+0x16a1c>
21f1689c:	e3a03022 	mov	r3, #34	; 0x22
21f168a0:	e7c23001 	strb	r3, [r2, r1]
		a_b[++length] = tochar (0);	/* no windows */
21f168a4:	e51b3018 	ldr	r3, [fp, #-24]
21f168a8:	e2833001 	add	r3, r3, #1	; 0x1
21f168ac:	e50b3018 	str	r3, [fp, #-24]
21f168b0:	e51b1018 	ldr	r1, [fp, #-24]
21f168b4:	e59f2160 	ldr	r2, [pc, #352]	; 21f16a1c <.text+0x16a1c>
21f168b8:	e3a03020 	mov	r3, #32	; 0x20
21f168bc:	e7c23001 	strb	r3, [r2, r1]
		a_b[++length] = tochar (94);	/* large packet msb */
21f168c0:	e51b3018 	ldr	r3, [fp, #-24]
21f168c4:	e2833001 	add	r3, r3, #1	; 0x1
21f168c8:	e50b3018 	str	r3, [fp, #-24]
21f168cc:	e51b1018 	ldr	r1, [fp, #-24]
21f168d0:	e59f2144 	ldr	r2, [pc, #324]	; 21f16a1c <.text+0x16a1c>
21f168d4:	e3a0307e 	mov	r3, #126	; 0x7e
21f168d8:	e7c23001 	strb	r3, [r2, r1]
		a_b[++length] = tochar (94);	/* large packet lsb */
21f168dc:	e51b3018 	ldr	r3, [fp, #-24]
21f168e0:	e2833001 	add	r3, r3, #1	; 0x1
21f168e4:	e50b3018 	str	r3, [fp, #-24]
21f168e8:	e51b1018 	ldr	r1, [fp, #-24]
21f168ec:	e59f2128 	ldr	r2, [pc, #296]	; 21f16a1c <.text+0x16a1c>
21f168f0:	e3a0307e 	mov	r3, #126	; 0x7e
21f168f4:	e7c23001 	strb	r3, [r2, r1]
	} while (0);

	a_b[0] = START_CHAR;
21f168f8:	e59f211c 	ldr	r2, [pc, #284]	; 21f16a1c <.text+0x16a1c>
21f168fc:	e3a03001 	mov	r3, #1	; 0x1
21f16900:	e5c23000 	strb	r3, [r2]
	a_b[1] = tochar (length);
21f16904:	e51b3018 	ldr	r3, [fp, #-24]
21f16908:	e20330ff 	and	r3, r3, #255	; 0xff
21f1690c:	e2833020 	add	r3, r3, #32	; 0x20
21f16910:	e20330ff 	and	r3, r3, #255	; 0xff
21f16914:	e20320ff 	and	r2, r3, #255	; 0xff
21f16918:	e3a030ff 	mov	r3, #255	; 0xff
21f1691c:	e0023003 	and	r3, r2, r3
21f16920:	e20330ff 	and	r3, r3, #255	; 0xff
21f16924:	e59f20f0 	ldr	r2, [pc, #240]	; 21f16a1c <.text+0x16a1c>
21f16928:	e5c23001 	strb	r3, [r2, #1]
	a_b[2] = tochar (n);
21f1692c:	e51b301c 	ldr	r3, [fp, #-28]
21f16930:	e20330ff 	and	r3, r3, #255	; 0xff
21f16934:	e2833020 	add	r3, r3, #32	; 0x20
21f16938:	e20330ff 	and	r3, r3, #255	; 0xff
21f1693c:	e20320ff 	and	r2, r3, #255	; 0xff
21f16940:	e3a030ff 	mov	r3, #255	; 0xff
21f16944:	e0023003 	and	r3, r2, r3
21f16948:	e20330ff 	and	r3, r3, #255	; 0xff
21f1694c:	e59f20c8 	ldr	r2, [pc, #200]	; 21f16a1c <.text+0x16a1c>
21f16950:	e5c23002 	strb	r3, [r2, #2]
	a_b[3] = ACK_TYPE;
21f16954:	e59f20c0 	ldr	r2, [pc, #192]	; 21f16a1c <.text+0x16a1c>
21f16958:	e3a03059 	mov	r3, #89	; 0x59
21f1695c:	e5c23003 	strb	r3, [r2, #3]
	a_b[++length] = '\0';
21f16960:	e51b3018 	ldr	r3, [fp, #-24]
21f16964:	e2833001 	add	r3, r3, #1	; 0x1
21f16968:	e50b3018 	str	r3, [fp, #-24]
21f1696c:	e51b1018 	ldr	r1, [fp, #-24]
21f16970:	e59f20a4 	ldr	r2, [pc, #164]	; 21f16a1c <.text+0x16a1c>
21f16974:	e3a03000 	mov	r3, #0	; 0x0
21f16978:	e7c23001 	strb	r3, [r2, r1]
	a_b[length] = tochar (chk1 (&a_b[1]));
21f1697c:	e51b4018 	ldr	r4, [fp, #-24]
21f16980:	e59f3098 	ldr	r3, [pc, #152]	; 21f16a20 <.text+0x16a20>
21f16984:	e1a00003 	mov	r0, r3
21f16988:	ebfffd86 	bl	21f15fa8 <chk1>
21f1698c:	e1a03000 	mov	r3, r0
21f16990:	e20330ff 	and	r3, r3, #255	; 0xff
21f16994:	e2833020 	add	r3, r3, #32	; 0x20
21f16998:	e20330ff 	and	r3, r3, #255	; 0xff
21f1699c:	e20320ff 	and	r2, r3, #255	; 0xff
21f169a0:	e3a030ff 	mov	r3, #255	; 0xff
21f169a4:	e0023003 	and	r3, r2, r3
21f169a8:	e20330ff 	and	r3, r3, #255	; 0xff
21f169ac:	e59f2068 	ldr	r2, [pc, #104]	; 21f16a1c <.text+0x16a1c>
21f169b0:	e7c23004 	strb	r3, [r2, r4]
	a_b[++length] = his_eol;
21f169b4:	e51b3018 	ldr	r3, [fp, #-24]
21f169b8:	e2833001 	add	r3, r3, #1	; 0x1
21f169bc:	e50b3018 	str	r3, [fp, #-24]
21f169c0:	e51b1018 	ldr	r1, [fp, #-24]
21f169c4:	e59f3034 	ldr	r3, [pc, #52]	; 21f16a00 <.text+0x16a00>
21f169c8:	e5d33000 	ldrb	r3, [r3]
21f169cc:	e59f2048 	ldr	r2, [pc, #72]	; 21f16a1c <.text+0x16a1c>
21f169d0:	e7c23001 	strb	r3, [r2, r1]
	a_b[++length] = '\0';
21f169d4:	e51b3018 	ldr	r3, [fp, #-24]
21f169d8:	e2833001 	add	r3, r3, #1	; 0x1
21f169dc:	e50b3018 	str	r3, [fp, #-24]
21f169e0:	e51b1018 	ldr	r1, [fp, #-24]
21f169e4:	e59f2030 	ldr	r2, [pc, #48]	; 21f16a1c <.text+0x16a1c>
21f169e8:	e3a03000 	mov	r3, #0	; 0x0
21f169ec:	e7c23001 	strb	r3, [r2, r1]
	s1_sendpacket (a_b);
21f169f0:	e59f0024 	ldr	r0, [pc, #36]	; 21f16a1c <.text+0x16a1c>
21f169f4:	ebfffd89 	bl	21f16020 <s1_sendpacket>
}
21f169f8:	e24bd010 	sub	sp, fp, #16	; 0x10
21f169fc:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f16a00:	21f676c8 	mvncss	r7, r8, asr #13
21f16a04:	21f676cc 	mvncss	r7, ip, asr #13
21f16a08:	21f676d0 	ldrcssb	r7, [r6, #96]!
21f16a0c:	21f676d1 	ldrcssb	r7, [r6, #97]!
21f16a10:	21f676f0 	ldrcssh	r7, [r6, #96]!
21f16a14:	21f676ef 	mvncss	r7, pc, ror #13
21f16a18:	21f676dc 	ldrcssb	r7, [r6, #108]!
21f16a1c:	21f676f4 	ldrcssh	r7, [r6, #100]!
21f16a20:	21f676f5 	ldrcssh	r7, [r6, #101]!

21f16a24 <k_recv>:

/* k_recv receives a OS Open image file over kermit line */
static int k_recv (void)
{
21f16a24:	e1a0c00d 	mov	ip, sp
21f16a28:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16a2c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f16a30:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	char new_char;
	char k_state, k_state_saved;
	int sum;
	int done;
	int length;
	int n, last_n;
	int z = 0;
21f16a34:	e3a03000 	mov	r3, #0	; 0x0
21f16a38:	e50b3018 	str	r3, [fp, #-24]
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
21f16a3c:	e59f247c 	ldr	r2, [pc, #1148]	; 21f16ec0 <.text+0x16ec0>
21f16a40:	e3a0300d 	mov	r3, #13	; 0xd
21f16a44:	e5c23000 	strb	r3, [r2]
	his_pad_count = 0;
21f16a48:	e59f2474 	ldr	r2, [pc, #1140]	; 21f16ec4 <.text+0x16ec4>
21f16a4c:	e3a03000 	mov	r3, #0	; 0x0
21f16a50:	e5823000 	str	r3, [r2]
	his_pad_char = '\0';
21f16a54:	e59f246c 	ldr	r2, [pc, #1132]	; 21f16ec8 <.text+0x16ec8>
21f16a58:	e3a03000 	mov	r3, #0	; 0x0
21f16a5c:	e5c23000 	strb	r3, [r2]
	his_quote = K_ESCAPE;
21f16a60:	e59f2464 	ldr	r2, [pc, #1124]	; 21f16ecc <.text+0x16ecc>
21f16a64:	e3a03023 	mov	r3, #35	; 0x23
21f16a68:	e5c23000 	strb	r3, [r2]

	/* initialize the k_recv and k_data state machine */
	done = 0;
21f16a6c:	e3a03000 	mov	r3, #0	; 0x0
21f16a70:	e50b3028 	str	r3, [fp, #-40]
	k_state = 0;
21f16a74:	e3a03000 	mov	r3, #0	; 0x0
21f16a78:	e54b302e 	strb	r3, [fp, #-46]
	k_data_init ();
21f16a7c:	ebfffe52 	bl	21f163cc <k_data_init>
	k_state_saved = k_state;
21f16a80:	e55b302e 	ldrb	r3, [fp, #-46]
21f16a84:	e54b302d 	strb	r3, [fp, #-45]
	k_data_save ();
21f16a88:	ebfffe5c 	bl	21f16400 <k_data_save>
	n = 0;				/* just to get rid of a warning */
21f16a8c:	e3a03000 	mov	r3, #0	; 0x0
21f16a90:	e50b3020 	str	r3, [fp, #-32]
	last_n = -1;
21f16a94:	e3e03000 	mvn	r3, #0	; 0x0
21f16a98:	e50b301c 	str	r3, [fp, #-28]

	/* expect this "type" sequence (but don't check):
	   S: send initiate
	   F: file header
	   D: data (multiple)
	   Z: end of file
	   B: break transmission
	 */

	/* enter main loop */
	while (!done) {
21f16a9c:	ea0000f9 	b	21f16e88 <k_recv+0x464>
		/* set the send packet pointer to begining of send packet parms */
		send_ptr = send_parms;
21f16aa0:	e59f2428 	ldr	r2, [pc, #1064]	; 21f16ed0 <.text+0x16ed0>
21f16aa4:	e59f3428 	ldr	r3, [pc, #1064]	; 21f16ed4 <.text+0x16ed4>
21f16aa8:	e5823000 	str	r3, [r2]

		/* With each packet, start summing the bytes starting with the length.
		   Save the current sequence number.
		   Note the type of the packet.
		   If a character less than SPACE (0x20) is received - error.
		 */

#if 0
		/* OLD CODE, Prior to checking sequence numbers */
		/* first have all state machines save current states */
		k_state_saved = k_state;
		k_data_save ();
#endif

		/* get a packet */
		/* wait for the starting character or ^C */
		for (;;) {
			switch (getc ()) {
21f16aac:	eb0013a1 	bl	21f1b938 <getc>
21f16ab0:	e50b0038 	str	r0, [fp, #-56]
21f16ab4:	e51b3038 	ldr	r3, [fp, #-56]
21f16ab8:	e3530001 	cmp	r3, #1	; 0x1
21f16abc:	0a000006 	beq	21f16adc <k_recv+0xb8>
21f16ac0:	e51b3038 	ldr	r3, [fp, #-56]
21f16ac4:	e3530003 	cmp	r3, #3	; 0x3
21f16ac8:	0a000000 	beq	21f16ad0 <k_recv+0xac>
21f16acc:	eafffff6 	b	21f16aac <k_recv+0x88>
			case START_CHAR:	/* start packet */
				goto START;
			case ETX_CHAR:		/* ^C waiting for packet */
				return (0);
21f16ad0:	e3a03000 	mov	r3, #0	; 0x0
21f16ad4:	e50b3034 	str	r3, [fp, #-52]
21f16ad8:	ea0000f4 	b	21f16eb0 <k_recv+0x48c>
			default:
				;
			}
		}
START:
		/* get length of packet */
		sum = 0;
21f16adc:	e3a03000 	mov	r3, #0	; 0x0
21f16ae0:	e50b302c 	str	r3, [fp, #-44]
		new_char = getc ();
21f16ae4:	eb001393 	bl	21f1b938 <getc>
21f16ae8:	e1a03000 	mov	r3, r0
21f16aec:	e54b302f 	strb	r3, [fp, #-47]
		if ((new_char & 0xE0) == 0)
21f16af0:	e55b302f 	ldrb	r3, [fp, #-47]
21f16af4:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16af8:	e3530000 	cmp	r3, #0	; 0x0
21f16afc:	0a0000cb 	beq	21f16e30 <k_recv+0x40c>
			goto packet_error;
		sum += new_char & 0xff;
21f16b00:	e55b202f 	ldrb	r2, [fp, #-47]
21f16b04:	e51b302c 	ldr	r3, [fp, #-44]
21f16b08:	e0833002 	add	r3, r3, r2
21f16b0c:	e50b302c 	str	r3, [fp, #-44]
		length = untochar (new_char);
21f16b10:	e55b302f 	ldrb	r3, [fp, #-47]
21f16b14:	e2433020 	sub	r3, r3, #32	; 0x20
21f16b18:	e20330ff 	and	r3, r3, #255	; 0xff
21f16b1c:	e50b3024 	str	r3, [fp, #-36]
		/* get sequence number */
		new_char = getc ();
21f16b20:	eb001384 	bl	21f1b938 <getc>
21f16b24:	e1a03000 	mov	r3, r0
21f16b28:	e54b302f 	strb	r3, [fp, #-47]
		if ((new_char & 0xE0) == 0)
21f16b2c:	e55b302f 	ldrb	r3, [fp, #-47]
21f16b30:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16b34:	e3530000 	cmp	r3, #0	; 0x0
21f16b38:	0a0000bc 	beq	21f16e30 <k_recv+0x40c>
			goto packet_error;
		sum += new_char & 0xff;
21f16b3c:	e55b202f 	ldrb	r2, [fp, #-47]
21f16b40:	e51b302c 	ldr	r3, [fp, #-44]
21f16b44:	e0833002 	add	r3, r3, r2
21f16b48:	e50b302c 	str	r3, [fp, #-44]
		n = untochar (new_char);
21f16b4c:	e55b302f 	ldrb	r3, [fp, #-47]
21f16b50:	e2433020 	sub	r3, r3, #32	; 0x20
21f16b54:	e20330ff 	and	r3, r3, #255	; 0xff
21f16b58:	e50b3020 	str	r3, [fp, #-32]
		--length;
21f16b5c:	e51b3024 	ldr	r3, [fp, #-36]
21f16b60:	e2433001 	sub	r3, r3, #1	; 0x1
21f16b64:	e50b3024 	str	r3, [fp, #-36]

		/* NEW CODE - check sequence numbers for retried packets */
		/* Note - this new code assumes that the sequence number is correctly
		 * received.  Handling an invalid sequence number adds another layer
		 * of complexity that may not be needed - yet!  At this time, I'm hoping
		 * that I don't need to buffer the incoming data packets and can write
		 * the data into memory in real time.
		 */
		if (n == last_n) {
21f16b68:	e51b2020 	ldr	r2, [fp, #-32]
21f16b6c:	e51b301c 	ldr	r3, [fp, #-28]
21f16b70:	e1520003 	cmp	r2, r3
21f16b74:	1a000003 	bne	21f16b88 <k_recv+0x164>
			/* same sequence number, restore the previous state */
			k_state = k_state_saved;
21f16b78:	e55b302d 	ldrb	r3, [fp, #-45]
21f16b7c:	e54b302e 	strb	r3, [fp, #-46]
			k_data_restore ();
21f16b80:	ebfffe29 	bl	21f1642c <k_data_restore>
21f16b84:	ea000004 	b	21f16b9c <k_recv+0x178>
		} else {
			/* new sequence number, checkpoint the download */
			last_n = n;
21f16b88:	e51b3020 	ldr	r3, [fp, #-32]
21f16b8c:	e50b301c 	str	r3, [fp, #-28]
			k_state_saved = k_state;
21f16b90:	e55b302e 	ldrb	r3, [fp, #-46]
21f16b94:	e54b302d 	strb	r3, [fp, #-45]
			k_data_save ();
21f16b98:	ebfffe18 	bl	21f16400 <k_data_save>
		}
		/* END NEW CODE */

		/* get packet type */
		new_char = getc ();
21f16b9c:	eb001365 	bl	21f1b938 <getc>
21f16ba0:	e1a03000 	mov	r3, r0
21f16ba4:	e54b302f 	strb	r3, [fp, #-47]
		if ((new_char & 0xE0) == 0)
21f16ba8:	e55b302f 	ldrb	r3, [fp, #-47]
21f16bac:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16bb0:	e3530000 	cmp	r3, #0	; 0x0
21f16bb4:	0a00009d 	beq	21f16e30 <k_recv+0x40c>
			goto packet_error;
		sum += new_char & 0xff;
21f16bb8:	e55b202f 	ldrb	r2, [fp, #-47]
21f16bbc:	e51b302c 	ldr	r3, [fp, #-44]
21f16bc0:	e0833002 	add	r3, r3, r2
21f16bc4:	e50b302c 	str	r3, [fp, #-44]
		k_state = new_char;
21f16bc8:	e55b302f 	ldrb	r3, [fp, #-47]
21f16bcc:	e54b302e 	strb	r3, [fp, #-46]
		--length;
21f16bd0:	e51b3024 	ldr	r3, [fp, #-36]
21f16bd4:	e2433001 	sub	r3, r3, #1	; 0x1
21f16bd8:	e50b3024 	str	r3, [fp, #-36]
		/* check for extended length */
		if (length == -2) {
21f16bdc:	e51b3024 	ldr	r3, [fp, #-36]
21f16be0:	e3730002 	cmn	r3, #2	; 0x2
21f16be4:	1a00006e 	bne	21f16da4 <k_recv+0x380>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
21f16be8:	eb001352 	bl	21f1b938 <getc>
21f16bec:	e1a03000 	mov	r3, r0
21f16bf0:	e54b302f 	strb	r3, [fp, #-47]
			if ((new_char & 0xE0) == 0)
21f16bf4:	e55b302f 	ldrb	r3, [fp, #-47]
21f16bf8:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16bfc:	e3530000 	cmp	r3, #0	; 0x0
21f16c00:	0a00008a 	beq	21f16e30 <k_recv+0x40c>
				goto packet_error;
			sum += new_char & 0xff;
21f16c04:	e55b202f 	ldrb	r2, [fp, #-47]
21f16c08:	e51b302c 	ldr	r3, [fp, #-44]
21f16c0c:	e0833002 	add	r3, r3, r2
21f16c10:	e50b302c 	str	r3, [fp, #-44]
			len_hi = untochar (new_char);
21f16c14:	e55b302f 	ldrb	r3, [fp, #-47]
21f16c18:	e2433020 	sub	r3, r3, #32	; 0x20
21f16c1c:	e20330ff 	and	r3, r3, #255	; 0xff
21f16c20:	e50b3010 	str	r3, [fp, #-16]
			new_char = getc ();
21f16c24:	eb001343 	bl	21f1b938 <getc>
21f16c28:	e1a03000 	mov	r3, r0
21f16c2c:	e54b302f 	strb	r3, [fp, #-47]
			if ((new_char & 0xE0) == 0)
21f16c30:	e55b302f 	ldrb	r3, [fp, #-47]
21f16c34:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16c38:	e3530000 	cmp	r3, #0	; 0x0
21f16c3c:	0a00007b 	beq	21f16e30 <k_recv+0x40c>
				goto packet_error;
			sum += new_char & 0xff;
21f16c40:	e55b202f 	ldrb	r2, [fp, #-47]
21f16c44:	e51b302c 	ldr	r3, [fp, #-44]
21f16c48:	e0833002 	add	r3, r3, r2
21f16c4c:	e50b302c 	str	r3, [fp, #-44]
			len_lo = untochar (new_char);
21f16c50:	e55b302f 	ldrb	r3, [fp, #-47]
21f16c54:	e2433020 	sub	r3, r3, #32	; 0x20
21f16c58:	e20330ff 	and	r3, r3, #255	; 0xff
21f16c5c:	e50b3014 	str	r3, [fp, #-20]
			length = len_hi * 95 + len_lo;
21f16c60:	e51b2010 	ldr	r2, [fp, #-16]
21f16c64:	e1a03002 	mov	r3, r2
21f16c68:	e1a03083 	mov	r3, r3, lsl #1
21f16c6c:	e0833002 	add	r3, r3, r2
21f16c70:	e1a03283 	mov	r3, r3, lsl #5
21f16c74:	e0622003 	rsb	r2, r2, r3
21f16c78:	e51b3014 	ldr	r3, [fp, #-20]
21f16c7c:	e0823003 	add	r3, r2, r3
21f16c80:	e50b3024 	str	r3, [fp, #-36]
			/* check header checksum */
			new_char = getc ();
21f16c84:	eb00132b 	bl	21f1b938 <getc>
21f16c88:	e1a03000 	mov	r3, r0
21f16c8c:	e54b302f 	strb	r3, [fp, #-47]
			if ((new_char & 0xE0) == 0)
21f16c90:	e55b302f 	ldrb	r3, [fp, #-47]
21f16c94:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16c98:	e3530000 	cmp	r3, #0	; 0x0
21f16c9c:	0a000063 	beq	21f16e30 <k_recv+0x40c>
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
21f16ca0:	e51b302c 	ldr	r3, [fp, #-44]
21f16ca4:	e1a03343 	mov	r3, r3, asr #6
21f16ca8:	e20330ff 	and	r3, r3, #255	; 0xff
21f16cac:	e20330ff 	and	r3, r3, #255	; 0xff
21f16cb0:	e2033003 	and	r3, r3, #3	; 0x3
21f16cb4:	e51b202c 	ldr	r2, [fp, #-44]
21f16cb8:	e20220ff 	and	r2, r2, #255	; 0xff
21f16cbc:	e1a01003 	mov	r1, r3
21f16cc0:	e1a03002 	mov	r3, r2
21f16cc4:	e0813003 	add	r3, r1, r3
21f16cc8:	e20330ff 	and	r3, r3, #255	; 0xff
21f16ccc:	e20330ff 	and	r3, r3, #255	; 0xff
21f16cd0:	e203303f 	and	r3, r3, #63	; 0x3f
21f16cd4:	e2833020 	add	r3, r3, #32	; 0x20
21f16cd8:	e20330ff 	and	r3, r3, #255	; 0xff
21f16cdc:	e20320ff 	and	r2, r3, #255	; 0xff
21f16ce0:	e55b302f 	ldrb	r3, [fp, #-47]
21f16ce4:	e1530002 	cmp	r3, r2
21f16ce8:	1a000050 	bne	21f16e30 <k_recv+0x40c>
				goto packet_error;
			sum += new_char & 0xff;
21f16cec:	e55b302f 	ldrb	r3, [fp, #-47]
21f16cf0:	e51b202c 	ldr	r2, [fp, #-44]
21f16cf4:	e0823003 	add	r3, r2, r3
21f16cf8:	e50b302c 	str	r3, [fp, #-44]
21f16cfc:	ea000028 	b	21f16da4 <k_recv+0x380>
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
21f16d00:	eb00130c 	bl	21f1b938 <getc>
21f16d04:	e1a03000 	mov	r3, r0
21f16d08:	e54b302f 	strb	r3, [fp, #-47]
			if ((new_char & 0xE0) == 0)
21f16d0c:	e55b302f 	ldrb	r3, [fp, #-47]
21f16d10:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16d14:	e3530000 	cmp	r3, #0	; 0x0
21f16d18:	0a000044 	beq	21f16e30 <k_recv+0x40c>
				goto packet_error;
			sum += new_char & 0xff;
21f16d1c:	e55b202f 	ldrb	r2, [fp, #-47]
21f16d20:	e51b302c 	ldr	r3, [fp, #-44]
21f16d24:	e0833002 	add	r3, r3, r2
21f16d28:	e50b302c 	str	r3, [fp, #-44]
			--length;
21f16d2c:	e51b3024 	ldr	r3, [fp, #-36]
21f16d30:	e2433001 	sub	r3, r3, #1	; 0x1
21f16d34:	e50b3024 	str	r3, [fp, #-36]
			if (k_state == DATA_TYPE) {
21f16d38:	e55b302e 	ldrb	r3, [fp, #-46]
21f16d3c:	e3530044 	cmp	r3, #68	; 0x44
21f16d40:	1a000003 	bne	21f16d54 <k_recv+0x330>
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
21f16d44:	e55b302f 	ldrb	r3, [fp, #-47]
21f16d48:	e1a00003 	mov	r0, r3
21f16d4c:	ebfffdc1 	bl	21f16458 <k_data_char>
21f16d50:	ea000013 	b	21f16da4 <k_recv+0x380>
			} else if (k_state == SEND_TYPE) {
21f16d54:	e55b302e 	ldrb	r3, [fp, #-46]
21f16d58:	e3530053 	cmp	r3, #83	; 0x53
21f16d5c:	1a000010 	bne	21f16da4 <k_recv+0x380>
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
21f16d60:	e59f3168 	ldr	r3, [pc, #360]	; 21f16ed0 <.text+0x16ed0>
21f16d64:	e5932000 	ldr	r2, [r3]
21f16d68:	e55b302f 	ldrb	r3, [fp, #-47]
21f16d6c:	e5c23000 	strb	r3, [r2]
21f16d70:	e2822001 	add	r2, r2, #1	; 0x1
21f16d74:	e59f3154 	ldr	r3, [pc, #340]	; 21f16ed0 <.text+0x16ed0>
21f16d78:	e5832000 	str	r2, [r3]
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
21f16d7c:	e59f314c 	ldr	r3, [pc, #332]	; 21f16ed0 <.text+0x16ed0>
21f16d80:	e5932000 	ldr	r2, [r3]
21f16d84:	e59f314c 	ldr	r3, [pc, #332]	; 21f16ed8 <.text+0x16ed8>
21f16d88:	e1520003 	cmp	r2, r3
21f16d8c:	3a000004 	bcc	21f16da4 <k_recv+0x380>
					--send_ptr;
21f16d90:	e59f3138 	ldr	r3, [pc, #312]	; 21f16ed0 <.text+0x16ed0>
21f16d94:	e5933000 	ldr	r3, [r3]
21f16d98:	e2432001 	sub	r2, r3, #1	; 0x1
21f16d9c:	e59f312c 	ldr	r3, [pc, #300]	; 21f16ed0 <.text+0x16ed0>
21f16da0:	e5832000 	str	r2, [r3]
21f16da4:	e51b3024 	ldr	r3, [fp, #-36]
21f16da8:	e3530001 	cmp	r3, #1	; 0x1
21f16dac:	caffffd3 	bgt	21f16d00 <k_recv+0x2dc>
			}
		}
		/* get and validate checksum character */
		new_char = getc ();
21f16db0:	eb0012e0 	bl	21f1b938 <getc>
21f16db4:	e1a03000 	mov	r3, r0
21f16db8:	e54b302f 	strb	r3, [fp, #-47]
		if ((new_char & 0xE0) == 0)
21f16dbc:	e55b302f 	ldrb	r3, [fp, #-47]
21f16dc0:	e20330e0 	and	r3, r3, #224	; 0xe0
21f16dc4:	e3530000 	cmp	r3, #0	; 0x0
21f16dc8:	0a000018 	beq	21f16e30 <k_recv+0x40c>
			goto packet_error;
		if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
21f16dcc:	e51b302c 	ldr	r3, [fp, #-44]
21f16dd0:	e1a03343 	mov	r3, r3, asr #6
21f16dd4:	e20330ff 	and	r3, r3, #255	; 0xff
21f16dd8:	e20330ff 	and	r3, r3, #255	; 0xff
21f16ddc:	e2033003 	and	r3, r3, #3	; 0x3
21f16de0:	e51b202c 	ldr	r2, [fp, #-44]
21f16de4:	e20220ff 	and	r2, r2, #255	; 0xff
21f16de8:	e1a01003 	mov	r1, r3
21f16dec:	e1a03002 	mov	r3, r2
21f16df0:	e0813003 	add	r3, r1, r3
21f16df4:	e20330ff 	and	r3, r3, #255	; 0xff
21f16df8:	e20330ff 	and	r3, r3, #255	; 0xff
21f16dfc:	e203303f 	and	r3, r3, #63	; 0x3f
21f16e00:	e2833020 	add	r3, r3, #32	; 0x20
21f16e04:	e20330ff 	and	r3, r3, #255	; 0xff
21f16e08:	e20320ff 	and	r2, r3, #255	; 0xff
21f16e0c:	e55b302f 	ldrb	r3, [fp, #-47]
21f16e10:	e1530002 	cmp	r3, r2
21f16e14:	1a000005 	bne	21f16e30 <k_recv+0x40c>
			goto packet_error;
		/* get END_CHAR */
		new_char = getc ();
21f16e18:	eb0012c6 	bl	21f1b938 <getc>
21f16e1c:	e1a03000 	mov	r3, r0
21f16e20:	e54b302f 	strb	r3, [fp, #-47]
		if (new_char != END_CHAR) {
21f16e24:	e55b302f 	ldrb	r3, [fp, #-47]
21f16e28:	e353000d 	cmp	r3, #13	; 0xd
21f16e2c:	0a000005 	beq	21f16e48 <k_recv+0x424>
		  packet_error:
			/* restore state machines */
			k_state = k_state_saved;
21f16e30:	e55b302d 	ldrb	r3, [fp, #-45]
21f16e34:	e54b302e 	strb	r3, [fp, #-46]
			k_data_restore ();
21f16e38:	ebfffd7b 	bl	21f1642c <k_data_restore>
			/* send a negative acknowledge packet in */
			send_nack (n);
21f16e3c:	e51b0020 	ldr	r0, [fp, #-32]
21f16e40:	ebfffcbf 	bl	21f16144 <send_nack>
21f16e44:	ea00000c 	b	21f16e7c <k_recv+0x458>
		} else if (k_state == SEND_TYPE) {
21f16e48:	e55b302e 	ldrb	r3, [fp, #-46]
21f16e4c:	e3530053 	cmp	r3, #83	; 0x53
21f16e50:	1a000002 	bne	21f16e60 <k_recv+0x43c>
			/* crack the protocol parms, build an appropriate ack packet */
			handle_send_packet (n);
21f16e54:	e51b0020 	ldr	r0, [fp, #-32]
21f16e58:	ebfffda8 	bl	21f16500 <handle_send_packet>
21f16e5c:	ea000006 	b	21f16e7c <k_recv+0x458>
		} else {
			/* send simple acknowledge packet in */
			send_ack (n);
21f16e60:	e51b0020 	ldr	r0, [fp, #-32]
21f16e64:	ebfffc81 	bl	21f16070 <send_ack>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
21f16e68:	e55b302e 	ldrb	r3, [fp, #-46]
21f16e6c:	e3530042 	cmp	r3, #66	; 0x42
21f16e70:	1a000001 	bne	21f16e7c <k_recv+0x458>
				done = 1;
21f16e74:	e3a03001 	mov	r3, #1	; 0x1
21f16e78:	e50b3028 	str	r3, [fp, #-40]
		}
		++z;
21f16e7c:	e51b3018 	ldr	r3, [fp, #-24]
21f16e80:	e2833001 	add	r3, r3, #1	; 0x1
21f16e84:	e50b3018 	str	r3, [fp, #-24]
21f16e88:	e51b3028 	ldr	r3, [fp, #-40]
21f16e8c:	e3530000 	cmp	r3, #0	; 0x0
21f16e90:	0affff02 	beq	21f16aa0 <k_recv+0x7c>
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
21f16e94:	e59f3040 	ldr	r3, [pc, #64]	; 21f16edc <.text+0x16edc>
21f16e98:	e5933000 	ldr	r3, [r3]
21f16e9c:	e1a02003 	mov	r2, r3
21f16ea0:	e59f3038 	ldr	r3, [pc, #56]	; 21f16ee0 <.text+0x16ee0>
21f16ea4:	e5933000 	ldr	r3, [r3]
21f16ea8:	e0633002 	rsb	r3, r3, r2
21f16eac:	e50b3034 	str	r3, [fp, #-52]
21f16eb0:	e51b3034 	ldr	r3, [fp, #-52]
}
21f16eb4:	e1a00003 	mov	r0, r3
21f16eb8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f16ebc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f16ec0:	21f676c8 	mvncss	r7, r8, asr #13
21f16ec4:	21f676cc 	mvncss	r7, ip, asr #13
21f16ec8:	21f676d0 	ldrcssb	r7, [r6, #96]!
21f16ecc:	21f676d1 	ldrcssb	r7, [r6, #97]!
21f16ed0:	21f676f0 	ldrcssh	r7, [r6, #96]!
21f16ed4:	21f676dc 	ldrcssb	r7, [r6, #108]!
21f16ed8:	21f676f0 	ldrcssh	r7, [r6, #96]!
21f16edc:	21f67718 	mvncss	r7, r8, lsl r7
21f16ee0:	21f67720 	mvncss	r7, r0, lsr #14

21f16ee4 <getcxmodem>:

static int getcxmodem(void) {
21f16ee4:	e1a0c00d 	mov	ip, sp
21f16ee8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16eec:	e24cb004 	sub	fp, ip, #4	; 0x4
21f16ef0:	e24dd004 	sub	sp, sp, #4	; 0x4
	if (tstc())
21f16ef4:	eb0012a5 	bl	21f1b990 <tstc>
21f16ef8:	e1a03000 	mov	r3, r0
21f16efc:	e3530000 	cmp	r3, #0	; 0x0
21f16f00:	0a000003 	beq	21f16f14 <getcxmodem+0x30>
		return (getc());
21f16f04:	eb00128b 	bl	21f1b938 <getc>
21f16f08:	e1a03000 	mov	r3, r0
21f16f0c:	e50b3010 	str	r3, [fp, #-16]
21f16f10:	ea000001 	b	21f16f1c <getcxmodem+0x38>
	return -1;
21f16f14:	e3e03000 	mvn	r3, #0	; 0x0
21f16f18:	e50b3010 	str	r3, [fp, #-16]
21f16f1c:	e51b3010 	ldr	r3, [fp, #-16]
}
21f16f20:	e1a00003 	mov	r0, r3
21f16f24:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f16f28 <load_serial_ymodem>:
static ulong load_serial_ymodem (ulong offset)
{
21f16f28:	e1a0c00d 	mov	ip, sp
21f16f2c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f16f30:	e24cb004 	sub	fp, ip, #4	; 0x4
21f16f34:	e24ddd11 	sub	sp, sp, #1088	; 0x440
21f16f38:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f16f3c:	e50b0454 	str	r0, [fp, #-1108]
	int size;
	char buf[32];
	int err;
	int res;
	connection_info_t info;
	char ymodemBuf[1024];
	ulong store_addr = ~0;
21f16f40:	e3e03000 	mvn	r3, #0	; 0x0
21f16f44:	e50b3018 	str	r3, [fp, #-24]
	ulong addr = 0;
21f16f48:	e3a03000 	mov	r3, #0	; 0x0
21f16f4c:	e50b3014 	str	r3, [fp, #-20]

	size = 0;
21f16f50:	e3a03000 	mov	r3, #0	; 0x0
21f16f54:	e50b3020 	str	r3, [fp, #-32]
	info.mode = xyzModem_ymodem;
21f16f58:	e3a03002 	mov	r3, #2	; 0x2
21f16f5c:	e50b304c 	str	r3, [fp, #-76]
	res = xyzModem_stream_open (&info, &err);
21f16f60:	e24b3050 	sub	r3, fp, #80	; 0x50
21f16f64:	e24b2044 	sub	r2, fp, #68	; 0x44
21f16f68:	e1a00003 	mov	r0, r3
21f16f6c:	e1a01002 	mov	r1, r2
21f16f70:	eb002a16 	bl	21f217d0 <xyzModem_stream_open>
21f16f74:	e1a03000 	mov	r3, r0
21f16f78:	e50b301c 	str	r3, [fp, #-28]
	if (!res) {
21f16f7c:	e51b301c 	ldr	r3, [fp, #-28]
21f16f80:	e3530000 	cmp	r3, #0	; 0x0
21f16f84:	0a00002b 	beq	21f17038 <load_serial_ymodem+0x110>
21f16f88:	ea000037 	b	21f1706c <load_serial_ymodem+0x144>

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
21f16f8c:	e51b2014 	ldr	r2, [fp, #-20]
21f16f90:	e51b3454 	ldr	r3, [fp, #-1108]
21f16f94:	e0823003 	add	r3, r2, r3
21f16f98:	e50b3018 	str	r3, [fp, #-24]
			size += res;
21f16f9c:	e51b2020 	ldr	r2, [fp, #-32]
21f16fa0:	e51b301c 	ldr	r3, [fp, #-28]
21f16fa4:	e0823003 	add	r3, r2, r3
21f16fa8:	e50b3020 	str	r3, [fp, #-32]
			addr += res;
21f16fac:	e51b201c 	ldr	r2, [fp, #-28]
21f16fb0:	e51b3014 	ldr	r3, [fp, #-20]
21f16fb4:	e0833002 	add	r3, r3, r2
21f16fb8:	e50b3014 	str	r3, [fp, #-20]
#ifndef CFG_NO_FLASH
			if (addr2info (store_addr)) {
21f16fbc:	e51b0018 	ldr	r0, [fp, #-24]
21f16fc0:	eb002105 	bl	21f1f3dc <addr2info>
21f16fc4:	e1a03000 	mov	r3, r0
21f16fc8:	e3530000 	cmp	r3, #0	; 0x0
21f16fcc:	0a000010 	beq	21f17014 <load_serial_ymodem+0xec>
				int rc;

				rc = flash_write ((char *) ymodemBuf,
21f16fd0:	e51b201c 	ldr	r2, [fp, #-28]
21f16fd4:	e24b3d11 	sub	r3, fp, #1088	; 0x440
21f16fd8:	e243300c 	sub	r3, r3, #12	; 0xc
21f16fdc:	e2433004 	sub	r3, r3, #4	; 0x4
21f16fe0:	e1a00003 	mov	r0, r3
21f16fe4:	e51b1018 	ldr	r1, [fp, #-24]
21f16fe8:	eb00212d 	bl	21f1f4a4 <flash_write>
21f16fec:	e1a03000 	mov	r3, r0
21f16ff0:	e50b3010 	str	r3, [fp, #-16]
						  store_addr, res);
				if (rc != 0) {
21f16ff4:	e51b3010 	ldr	r3, [fp, #-16]
21f16ff8:	e3530000 	cmp	r3, #0	; 0x0
21f16ffc:	0a00000d 	beq	21f17038 <load_serial_ymodem+0x110>
					flash_perror (rc);
21f17000:	e51b0010 	ldr	r0, [fp, #-16]
21f17004:	eb0021d2 	bl	21f1f754 <flash_perror>
					return (~0);
21f17008:	e3e03000 	mvn	r3, #0	; 0x0
21f1700c:	e50b3458 	str	r3, [fp, #-1112]
21f17010:	ea000035 	b	21f170ec <load_serial_ymodem+0x1c4>
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
21f17014:	e51b3018 	ldr	r3, [fp, #-24]
21f17018:	e51bc01c 	ldr	ip, [fp, #-28]
21f1701c:	e24b2d11 	sub	r2, fp, #1088	; 0x440
21f17020:	e242200c 	sub	r2, r2, #12	; 0xc
21f17024:	e2422004 	sub	r2, r2, #4	; 0x4
21f17028:	e1a00003 	mov	r0, r3
21f1702c:	e1a01002 	mov	r1, r2
21f17030:	e1a0200c 	mov	r2, ip
21f17034:	eb003064 	bl	21f231cc <memcpy>
21f17038:	e24b3d11 	sub	r3, fp, #1088	; 0x440
21f1703c:	e243300c 	sub	r3, r3, #12	; 0xc
21f17040:	e2433004 	sub	r3, r3, #4	; 0x4
21f17044:	e24b2044 	sub	r2, fp, #68	; 0x44
21f17048:	e1a00003 	mov	r0, r3
21f1704c:	e3a01b01 	mov	r1, #1024	; 0x400
21f17050:	eb002a91 	bl	21f21a9c <xyzModem_stream_read>
21f17054:	e1a03000 	mov	r3, r0
21f17058:	e50b301c 	str	r3, [fp, #-28]
21f1705c:	e51b301c 	ldr	r3, [fp, #-28]
21f17060:	e3530000 	cmp	r3, #0	; 0x0
21f17064:	caffffc8 	bgt	21f16f8c <load_serial_ymodem+0x64>
21f17068:	ea000006 	b	21f17088 <load_serial_ymodem+0x160>
					res);
			}

		}
	} else {
		printf ("%s\n", xyzModem_error (err));
21f1706c:	e51b3044 	ldr	r3, [fp, #-68]
21f17070:	e1a00003 	mov	r0, r3
21f17074:	eb002c36 	bl	21f22154 <xyzModem_error>
21f17078:	e1a03000 	mov	r3, r0
21f1707c:	e59f0078 	ldr	r0, [pc, #120]	; 21f170fc <.text+0x170fc>
21f17080:	e1a01003 	mov	r1, r3
21f17084:	eb001280 	bl	21f1ba8c <printf>
	}

	xyzModem_stream_close (&err);
21f17088:	e24b3044 	sub	r3, fp, #68	; 0x44
21f1708c:	e1a00003 	mov	r0, r3
21f17090:	eb002bb3 	bl	21f21f64 <xyzModem_stream_close>
	xyzModem_stream_terminate (false, &getcxmodem);
21f17094:	e3a00000 	mov	r0, #0	; 0x0
21f17098:	e59f1060 	ldr	r1, [pc, #96]	; 21f17100 <.text+0x17100>
21f1709c:	eb002bd3 	bl	21f21ff0 <xyzModem_stream_terminate>


	flush_cache (offset, size);
21f170a0:	e51b3020 	ldr	r3, [fp, #-32]
21f170a4:	e51b0454 	ldr	r0, [fp, #-1108]
21f170a8:	e1a01003 	mov	r1, r3
21f170ac:	eb005f3f 	bl	21f2edb0 <flush_cache>

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
21f170b0:	e59f004c 	ldr	r0, [pc, #76]	; 21f17104 <.text+0x17104>
21f170b4:	e51b1020 	ldr	r1, [fp, #-32]
21f170b8:	e51b2020 	ldr	r2, [fp, #-32]
21f170bc:	eb001272 	bl	21f1ba8c <printf>
	sprintf (buf, "%X", size);
21f170c0:	e24b3040 	sub	r3, fp, #64	; 0x40
21f170c4:	e1a00003 	mov	r0, r3
21f170c8:	e59f1038 	ldr	r1, [pc, #56]	; 21f17108 <.text+0x17108>
21f170cc:	e51b2020 	ldr	r2, [fp, #-32]
21f170d0:	eb00357c 	bl	21f246c8 <sprintf>
	setenv ("filesize", buf);
21f170d4:	e24b3040 	sub	r3, fp, #64	; 0x40
21f170d8:	e59f002c 	ldr	r0, [pc, #44]	; 21f1710c <.text+0x1710c>
21f170dc:	e1a01003 	mov	r1, r3
21f170e0:	eb000e98 	bl	21f1ab48 <setenv>

	return offset;
21f170e4:	e51b3454 	ldr	r3, [fp, #-1108]
21f170e8:	e50b3458 	str	r3, [fp, #-1112]
21f170ec:	e51b3458 	ldr	r3, [fp, #-1112]
}
21f170f0:	e1a00003 	mov	r0, r3
21f170f4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f170f8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f170fc:	21f3103c 	mvncss	r1, ip, lsr r0
21f17100:	21f16ee4 	mvncss	r6, r4, ror #29
21f17104:	21f31004 	mvncss	r1, r4
21f17108:	21f3102c 	mvncss	r1, ip, lsr #32
21f1710c:	21f31030 	mvncss	r1, r0, lsr r0

21f17110 <cmd_get_data_size>:
			CFG_CMD_ITEST	| \
			CFG_CMD_PCI	| \
			CMD_CMD_PORTIO	) )
int cmd_get_data_size(char* arg, int default_size)
{
21f17110:	e1a0c00d 	mov	ip, sp
21f17114:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f17118:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1711c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f17120:	e50b0014 	str	r0, [fp, #-20]
21f17124:	e50b1018 	str	r1, [fp, #-24]
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
21f17128:	e51b0014 	ldr	r0, [fp, #-20]
21f1712c:	eb002ea4 	bl	21f22bc4 <strlen>
21f17130:	e1a03000 	mov	r3, r0
21f17134:	e50b3010 	str	r3, [fp, #-16]
	if (len > 2 && arg[len-2] == '.') {
21f17138:	e51b3010 	ldr	r3, [fp, #-16]
21f1713c:	e3530002 	cmp	r3, #2	; 0x2
21f17140:	da000034 	ble	21f17218 <.text+0x17218>
21f17144:	e51b2010 	ldr	r2, [fp, #-16]
21f17148:	e51b3014 	ldr	r3, [fp, #-20]
21f1714c:	e0823003 	add	r3, r2, r3
21f17150:	e2433002 	sub	r3, r3, #2	; 0x2
21f17154:	e5d33000 	ldrb	r3, [r3]
21f17158:	e353002e 	cmp	r3, #46	; 0x2e
21f1715c:	1a00002d 	bne	21f17218 <.text+0x17218>
		switch(arg[len-1]) {
21f17160:	e51b2010 	ldr	r2, [fp, #-16]
21f17164:	e51b3014 	ldr	r3, [fp, #-20]
21f17168:	e0823003 	add	r3, r2, r3
21f1716c:	e2433001 	sub	r3, r3, #1	; 0x1
21f17170:	e5d33000 	ldrb	r3, [r3]
21f17174:	e2433062 	sub	r3, r3, #98	; 0x62
21f17178:	e3530015 	cmp	r3, #21	; 0x15
21f1717c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f17180:	ea000021 	b	21f1720c <.text+0x1720c>
21f17184:	21f171dc 	ldrcssb	r7, [r1, #28]!
21f17188:	21f1720c 	mvncss	r7, ip, lsl #4
21f1718c:	21f1720c 	mvncss	r7, ip, lsl #4
21f17190:	21f1720c 	mvncss	r7, ip, lsl #4
21f17194:	21f1720c 	mvncss	r7, ip, lsl #4
21f17198:	21f1720c 	mvncss	r7, ip, lsl #4
21f1719c:	21f1720c 	mvncss	r7, ip, lsl #4
21f171a0:	21f1720c 	mvncss	r7, ip, lsl #4
21f171a4:	21f1720c 	mvncss	r7, ip, lsl #4
21f171a8:	21f1720c 	mvncss	r7, ip, lsl #4
21f171ac:	21f171f4 	ldrcssh	r7, [r1, #20]!
21f171b0:	21f1720c 	mvncss	r7, ip, lsl #4
21f171b4:	21f1720c 	mvncss	r7, ip, lsl #4
21f171b8:	21f1720c 	mvncss	r7, ip, lsl #4
21f171bc:	21f1720c 	mvncss	r7, ip, lsl #4
21f171c0:	21f1720c 	mvncss	r7, ip, lsl #4
21f171c4:	21f1720c 	mvncss	r7, ip, lsl #4
21f171c8:	21f17200 	mvncss	r7, r0, lsl #4
21f171cc:	21f1720c 	mvncss	r7, ip, lsl #4
21f171d0:	21f1720c 	mvncss	r7, ip, lsl #4
21f171d4:	21f1720c 	mvncss	r7, ip, lsl #4
21f171d8:	21f171e8 	mvncss	r7, r8, ror #3
		case 'b':
			return 1;
21f171dc:	e3a03001 	mov	r3, #1	; 0x1
21f171e0:	e50b301c 	str	r3, [fp, #-28]
21f171e4:	ea00000d 	b	21f17220 <.text+0x17220>
		case 'w':
			return 2;
21f171e8:	e3a03002 	mov	r3, #2	; 0x2
21f171ec:	e50b301c 	str	r3, [fp, #-28]
21f171f0:	ea00000a 	b	21f17220 <.text+0x17220>
		case 'l':
			return 4;
21f171f4:	e3a03004 	mov	r3, #4	; 0x4
21f171f8:	e50b301c 	str	r3, [fp, #-28]
21f171fc:	ea000007 	b	21f17220 <.text+0x17220>
		case 's':
			return -2;
21f17200:	e3e03001 	mvn	r3, #1	; 0x1
21f17204:	e50b301c 	str	r3, [fp, #-28]
21f17208:	ea000004 	b	21f17220 <.text+0x17220>
		default:
			return -1;
21f1720c:	e3e03000 	mvn	r3, #0	; 0x0
21f17210:	e50b301c 	str	r3, [fp, #-28]
21f17214:	ea000001 	b	21f17220 <.text+0x17220>
		}
	}
	return default_size;
21f17218:	e51b3018 	ldr	r3, [fp, #-24]
21f1721c:	e50b301c 	str	r3, [fp, #-28]
21f17220:	e51b301c 	ldr	r3, [fp, #-28]
}
21f17224:	e1a00003 	mov	r0, r3
21f17228:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1722c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f17230 <do_mem_md>:
#endif

#if (CONFIG_COMMANDS & CFG_CMD_MEMORY)

#ifdef	CMD_MEM_DEBUG
#define	PRINTF(fmt,args...)	printf (fmt ,##args)
#else
#define PRINTF(fmt,args...)
#endif

static int mod_mem(cmd_tbl_t *, int, int, int, char *[]);

/* Display values from last command.
 * Memory modify remembered values are different from display memory.
 */
uint	dp_last_addr, dp_last_size;
uint	dp_last_length = 0x40;
uint	mm_last_addr, mm_last_size;

static	ulong	base_address = 0;

/* Memory Display
 *
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f17230:	e1a0c00d 	mov	ip, sp
21f17234:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f17238:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1723c:	e24dd054 	sub	sp, sp, #84	; 0x54
21f17240:	e50b0050 	str	r0, [fp, #-80]
21f17244:	e50b1054 	str	r1, [fp, #-84]
21f17248:	e50b2058 	str	r2, [fp, #-88]
21f1724c:	e50b305c 	str	r3, [fp, #-92]
	ulong	addr, length;
	ulong	i, nbytes, linebytes;
	u_char	*cp;
	int	size;
	int rc = 0;
21f17250:	e3a03000 	mov	r3, #0	; 0x0
21f17254:	e50b3020 	str	r3, [fp, #-32]

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
21f17258:	e59f3440 	ldr	r3, [pc, #1088]	; 21f176a0 <.text+0x176a0>
21f1725c:	e5933000 	ldr	r3, [r3]
21f17260:	e50b303c 	str	r3, [fp, #-60]
	size = dp_last_size;
21f17264:	e59f3438 	ldr	r3, [pc, #1080]	; 21f176a4 <.text+0x176a4>
21f17268:	e5933000 	ldr	r3, [r3]
21f1726c:	e50b3024 	str	r3, [fp, #-36]
	length = dp_last_length;
21f17270:	e59f3430 	ldr	r3, [pc, #1072]	; 21f176a8 <.text+0x176a8>
21f17274:	e5933000 	ldr	r3, [r3]
21f17278:	e50b3038 	str	r3, [fp, #-56]

	if (argc < 2) {
21f1727c:	e51b3058 	ldr	r3, [fp, #-88]
21f17280:	e3530001 	cmp	r3, #1	; 0x1
21f17284:	ca000007 	bgt	21f172a8 <do_mem_md+0x78>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f17288:	e51b3050 	ldr	r3, [fp, #-80]
21f1728c:	e5933010 	ldr	r3, [r3, #16]
21f17290:	e59f0414 	ldr	r0, [pc, #1044]	; 21f176ac <.text+0x176ac>
21f17294:	e1a01003 	mov	r1, r3
21f17298:	eb0011fb 	bl	21f1ba8c <printf>
		return 1;
21f1729c:	e3a03001 	mov	r3, #1	; 0x1
21f172a0:	e50b3060 	str	r3, [fp, #-96]
21f172a4:	ea0000f9 	b	21f17690 <do_mem_md+0x460>
	}

	if ((flag & CMD_FLAG_REPEAT) == 0) {
21f172a8:	e51b3054 	ldr	r3, [fp, #-84]
21f172ac:	e2233001 	eor	r3, r3, #1	; 0x1
21f172b0:	e2033001 	and	r3, r3, #1	; 0x1
21f172b4:	e20330ff 	and	r3, r3, #255	; 0xff
21f172b8:	e3530000 	cmp	r3, #0	; 0x0
21f172bc:	0a000026 	beq	21f1735c <do_mem_md+0x12c>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
21f172c0:	e51b305c 	ldr	r3, [fp, #-92]
21f172c4:	e5933000 	ldr	r3, [r3]
21f172c8:	e1a00003 	mov	r0, r3
21f172cc:	e3a01004 	mov	r1, #4	; 0x4
21f172d0:	ebffff8e 	bl	21f17110 <cmd_get_data_size>
21f172d4:	e1a03000 	mov	r3, r0
21f172d8:	e50b3024 	str	r3, [fp, #-36]
21f172dc:	e51b3024 	ldr	r3, [fp, #-36]
21f172e0:	e3530000 	cmp	r3, #0	; 0x0
21f172e4:	aa000002 	bge	21f172f4 <do_mem_md+0xc4>
			return 1;
21f172e8:	e3a03001 	mov	r3, #1	; 0x1
21f172ec:	e50b3060 	str	r3, [fp, #-96]
21f172f0:	ea0000e6 	b	21f17690 <do_mem_md+0x460>

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
21f172f4:	e51b305c 	ldr	r3, [fp, #-92]
21f172f8:	e2833004 	add	r3, r3, #4	; 0x4
21f172fc:	e5933000 	ldr	r3, [r3]
21f17300:	e1a00003 	mov	r0, r3
21f17304:	e3a01000 	mov	r1, #0	; 0x0
21f17308:	e3a02010 	mov	r2, #16	; 0x10
21f1730c:	eb0030ad 	bl	21f235c8 <simple_strtoul>
21f17310:	e1a03000 	mov	r3, r0
21f17314:	e50b303c 	str	r3, [fp, #-60]
		addr += base_address;
21f17318:	e59f3390 	ldr	r3, [pc, #912]	; 21f176b0 <.text+0x176b0>
21f1731c:	e5932000 	ldr	r2, [r3]
21f17320:	e51b303c 	ldr	r3, [fp, #-60]
21f17324:	e0833002 	add	r3, r3, r2
21f17328:	e50b303c 	str	r3, [fp, #-60]

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
21f1732c:	e51b3058 	ldr	r3, [fp, #-88]
21f17330:	e3530002 	cmp	r3, #2	; 0x2
21f17334:	da000008 	ble	21f1735c <do_mem_md+0x12c>
			length = simple_strtoul(argv[2], NULL, 16);
21f17338:	e51b305c 	ldr	r3, [fp, #-92]
21f1733c:	e2833008 	add	r3, r3, #8	; 0x8
21f17340:	e5933000 	ldr	r3, [r3]
21f17344:	e1a00003 	mov	r0, r3
21f17348:	e3a01000 	mov	r1, #0	; 0x0
21f1734c:	e3a02010 	mov	r2, #16	; 0x10
21f17350:	eb00309c 	bl	21f235c8 <simple_strtoul>
21f17354:	e1a03000 	mov	r3, r0
21f17358:	e50b3038 	str	r3, [fp, #-56]
	}

	/* Print the lines.
	 *
	 * We buffer all read data, so we can make sure data is read only
	 * once, and all accesses are with the specified bus width.
	 */
	nbytes = length * size;
21f1735c:	e51b3024 	ldr	r3, [fp, #-36]
21f17360:	e51b2038 	ldr	r2, [fp, #-56]
21f17364:	e0030392 	mul	r3, r2, r3
21f17368:	e50b3030 	str	r3, [fp, #-48]
	do {
		char	linebuf[DISP_LINE_LEN];
		uint	*uip = (uint   *)linebuf;
21f1736c:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f17370:	e50b301c 	str	r3, [fp, #-28]
		ushort	*usp = (ushort *)linebuf;
21f17374:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f17378:	e50b3018 	str	r3, [fp, #-24]
		u_char	*ucp = (u_char *)linebuf;
21f1737c:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f17380:	e50b3014 	str	r3, [fp, #-20]
#ifdef CONFIG_HAS_DATAFLASH
		int rc;
#endif
		printf("%08lx:", addr);
21f17384:	e59f0328 	ldr	r0, [pc, #808]	; 21f176b4 <.text+0x176b4>
21f17388:	e51b103c 	ldr	r1, [fp, #-60]
21f1738c:	eb0011be 	bl	21f1ba8c <printf>
		linebytes = (nbytes>DISP_LINE_LEN)?DISP_LINE_LEN:nbytes;
21f17390:	e51b3030 	ldr	r3, [fp, #-48]
21f17394:	e3530010 	cmp	r3, #16	; 0x10
21f17398:	23a03010 	movcs	r3, #16	; 0x10
21f1739c:	e50b302c 	str	r3, [fp, #-44]

#ifdef CONFIG_HAS_DATAFLASH
		if ((rc = read_dataflash(addr, (linebytes/size)*size, linebuf)) == DATAFLASH_OK){
21f173a0:	e51b3024 	ldr	r3, [fp, #-36]
21f173a4:	e51b002c 	ldr	r0, [fp, #-44]
21f173a8:	e1a01003 	mov	r1, r3
21f173ac:	ebffb9c0 	bl	21f05ab4 <__udivsi3>
21f173b0:	e1a03000 	mov	r3, r0
21f173b4:	e1a02003 	mov	r2, r3
21f173b8:	e51b3024 	ldr	r3, [fp, #-36]
21f173bc:	e0030392 	mul	r3, r2, r3
21f173c0:	e24b204c 	sub	r2, fp, #76	; 0x4c
21f173c4:	e51b003c 	ldr	r0, [fp, #-60]
21f173c8:	e1a01003 	mov	r1, r3
21f173cc:	ebffe591 	bl	21f10a18 <read_dataflash>
21f173d0:	e1a03000 	mov	r3, r0
21f173d4:	e50b3010 	str	r3, [fp, #-16]
21f173d8:	e51b3010 	ldr	r3, [fp, #-16]
21f173dc:	e3530001 	cmp	r3, #1	; 0x1
21f173e0:	1a000031 	bne	21f174ac <do_mem_md+0x27c>
			/* if outside dataflash */
			/*if (rc != 1) {
				dataflash_perror (rc);
				return (1);
			}*/
			for (i=0; i<linebytes; i+= size) {
21f173e4:	e3a03000 	mov	r3, #0	; 0x0
21f173e8:	e50b3034 	str	r3, [fp, #-52]
21f173ec:	ea000029 	b	21f17498 <do_mem_md+0x268>
				if (size == 4) {
21f173f0:	e51b3024 	ldr	r3, [fp, #-36]
21f173f4:	e3530004 	cmp	r3, #4	; 0x4
21f173f8:	1a000008 	bne	21f17420 <do_mem_md+0x1f0>
					printf(" %08x", *uip++);
21f173fc:	e51b301c 	ldr	r3, [fp, #-28]
21f17400:	e5932000 	ldr	r2, [r3]
21f17404:	e51b301c 	ldr	r3, [fp, #-28]
21f17408:	e2833004 	add	r3, r3, #4	; 0x4
21f1740c:	e50b301c 	str	r3, [fp, #-28]
21f17410:	e59f02a0 	ldr	r0, [pc, #672]	; 21f176b8 <.text+0x176b8>
21f17414:	e1a01002 	mov	r1, r2
21f17418:	eb00119b 	bl	21f1ba8c <printf>
21f1741c:	ea000015 	b	21f17478 <do_mem_md+0x248>
				} else if (size == 2) {
21f17420:	e51b3024 	ldr	r3, [fp, #-36]
21f17424:	e3530002 	cmp	r3, #2	; 0x2
21f17428:	1a000009 	bne	21f17454 <do_mem_md+0x224>
					printf(" %04x", *usp++);
21f1742c:	e51b3018 	ldr	r3, [fp, #-24]
21f17430:	e1d330b0 	ldrh	r3, [r3]
21f17434:	e1a02003 	mov	r2, r3
21f17438:	e51b3018 	ldr	r3, [fp, #-24]
21f1743c:	e2833002 	add	r3, r3, #2	; 0x2
21f17440:	e50b3018 	str	r3, [fp, #-24]
21f17444:	e59f0270 	ldr	r0, [pc, #624]	; 21f176bc <.text+0x176bc>
21f17448:	e1a01002 	mov	r1, r2
21f1744c:	eb00118e 	bl	21f1ba8c <printf>
21f17450:	ea000008 	b	21f17478 <do_mem_md+0x248>
				} else {
					printf(" %02x", *ucp++);
21f17454:	e51b3014 	ldr	r3, [fp, #-20]
21f17458:	e5d33000 	ldrb	r3, [r3]
21f1745c:	e1a02003 	mov	r2, r3
21f17460:	e51b3014 	ldr	r3, [fp, #-20]
21f17464:	e2833001 	add	r3, r3, #1	; 0x1
21f17468:	e50b3014 	str	r3, [fp, #-20]
21f1746c:	e59f024c 	ldr	r0, [pc, #588]	; 21f176c0 <.text+0x176c0>
21f17470:	e1a01002 	mov	r1, r2
21f17474:	eb001184 	bl	21f1ba8c <printf>
				}
				addr += size;
21f17478:	e51b2024 	ldr	r2, [fp, #-36]
21f1747c:	e51b303c 	ldr	r3, [fp, #-60]
21f17480:	e0833002 	add	r3, r3, r2
21f17484:	e50b303c 	str	r3, [fp, #-60]
21f17488:	e51b2024 	ldr	r2, [fp, #-36]
21f1748c:	e51b3034 	ldr	r3, [fp, #-52]
21f17490:	e0833002 	add	r3, r3, r2
21f17494:	e50b3034 	str	r3, [fp, #-52]
21f17498:	e51b2034 	ldr	r2, [fp, #-52]
21f1749c:	e51b302c 	ldr	r3, [fp, #-44]
21f174a0:	e1520003 	cmp	r2, r3
21f174a4:	3affffd1 	bcc	21f173f0 <do_mem_md+0x1c0>
21f174a8:	ea00003c 	b	21f175a0 <do_mem_md+0x370>
			}

		} else {	/* addr does not correspond to DataFlash */
#endif
		for (i=0; i<linebytes; i+= size) {
21f174ac:	e3a03000 	mov	r3, #0	; 0x0
21f174b0:	e50b3034 	str	r3, [fp, #-52]
21f174b4:	ea000035 	b	21f17590 <do_mem_md+0x360>
			if (size == 4) {
21f174b8:	e51b3024 	ldr	r3, [fp, #-36]
21f174bc:	e3530004 	cmp	r3, #4	; 0x4
21f174c0:	1a00000c 	bne	21f174f8 <do_mem_md+0x2c8>
				printf(" %08x", (*uip++ = *((uint *)addr)));
21f174c4:	e51b303c 	ldr	r3, [fp, #-60]
21f174c8:	e5932000 	ldr	r2, [r3]
21f174cc:	e51b301c 	ldr	r3, [fp, #-28]
21f174d0:	e5832000 	str	r2, [r3]
21f174d4:	e51b301c 	ldr	r3, [fp, #-28]
21f174d8:	e5932000 	ldr	r2, [r3]
21f174dc:	e51b301c 	ldr	r3, [fp, #-28]
21f174e0:	e2833004 	add	r3, r3, #4	; 0x4
21f174e4:	e50b301c 	str	r3, [fp, #-28]
21f174e8:	e59f01c8 	ldr	r0, [pc, #456]	; 21f176b8 <.text+0x176b8>
21f174ec:	e1a01002 	mov	r1, r2
21f174f0:	eb001165 	bl	21f1ba8c <printf>
21f174f4:	ea00001d 	b	21f17570 <do_mem_md+0x340>
			} else if (size == 2) {
21f174f8:	e51b3024 	ldr	r3, [fp, #-36]
21f174fc:	e3530002 	cmp	r3, #2	; 0x2
21f17500:	1a00000d 	bne	21f1753c <do_mem_md+0x30c>
				printf(" %04x", (*usp++ = *((ushort *)addr)));
21f17504:	e51b303c 	ldr	r3, [fp, #-60]
21f17508:	e1d320b0 	ldrh	r2, [r3]
21f1750c:	e51b3018 	ldr	r3, [fp, #-24]
21f17510:	e1c320b0 	strh	r2, [r3]
21f17514:	e51b3018 	ldr	r3, [fp, #-24]
21f17518:	e1d330b0 	ldrh	r3, [r3]
21f1751c:	e1a02003 	mov	r2, r3
21f17520:	e51b3018 	ldr	r3, [fp, #-24]
21f17524:	e2833002 	add	r3, r3, #2	; 0x2
21f17528:	e50b3018 	str	r3, [fp, #-24]
21f1752c:	e59f0188 	ldr	r0, [pc, #392]	; 21f176bc <.text+0x176bc>
21f17530:	e1a01002 	mov	r1, r2
21f17534:	eb001154 	bl	21f1ba8c <printf>
21f17538:	ea00000c 	b	21f17570 <do_mem_md+0x340>
			} else {
				printf(" %02x", (*ucp++ = *((u_char *)addr)));
21f1753c:	e51b303c 	ldr	r3, [fp, #-60]
21f17540:	e5d33000 	ldrb	r3, [r3]
21f17544:	e51b2014 	ldr	r2, [fp, #-20]
21f17548:	e5c23000 	strb	r3, [r2]
21f1754c:	e51b3014 	ldr	r3, [fp, #-20]
21f17550:	e5d33000 	ldrb	r3, [r3]
21f17554:	e1a02003 	mov	r2, r3
21f17558:	e51b3014 	ldr	r3, [fp, #-20]
21f1755c:	e2833001 	add	r3, r3, #1	; 0x1
21f17560:	e50b3014 	str	r3, [fp, #-20]
21f17564:	e59f0154 	ldr	r0, [pc, #340]	; 21f176c0 <.text+0x176c0>
21f17568:	e1a01002 	mov	r1, r2
21f1756c:	eb001146 	bl	21f1ba8c <printf>
			}
			addr += size;
21f17570:	e51b2024 	ldr	r2, [fp, #-36]
21f17574:	e51b303c 	ldr	r3, [fp, #-60]
21f17578:	e0833002 	add	r3, r3, r2
21f1757c:	e50b303c 	str	r3, [fp, #-60]
21f17580:	e51b2024 	ldr	r2, [fp, #-36]
21f17584:	e51b3034 	ldr	r3, [fp, #-52]
21f17588:	e0833002 	add	r3, r3, r2
21f1758c:	e50b3034 	str	r3, [fp, #-52]
21f17590:	e51b2034 	ldr	r2, [fp, #-52]
21f17594:	e51b302c 	ldr	r3, [fp, #-44]
21f17598:	e1520003 	cmp	r2, r3
21f1759c:	3affffc5 	bcc	21f174b8 <do_mem_md+0x288>
		}
#ifdef CONFIG_HAS_DATAFLASH
		}
#endif
		puts ("    ");
21f175a0:	e59f011c 	ldr	r0, [pc, #284]	; 21f176c4 <.text+0x176c4>
21f175a4:	eb001125 	bl	21f1ba40 <puts>
		cp = (u_char *)linebuf;
21f175a8:	e24b304c 	sub	r3, fp, #76	; 0x4c
21f175ac:	e50b3028 	str	r3, [fp, #-40]
		for (i=0; i<linebytes; i++) {
21f175b0:	e3a03000 	mov	r3, #0	; 0x0
21f175b4:	e50b3034 	str	r3, [fp, #-52]
21f175b8:	ea000015 	b	21f17614 <do_mem_md+0x3e4>
			if ((*cp < 0x20) || (*cp > 0x7e))
21f175bc:	e51b3028 	ldr	r3, [fp, #-40]
21f175c0:	e5d33000 	ldrb	r3, [r3]
21f175c4:	e353001f 	cmp	r3, #31	; 0x1f
21f175c8:	9a000003 	bls	21f175dc <do_mem_md+0x3ac>
21f175cc:	e51b3028 	ldr	r3, [fp, #-40]
21f175d0:	e5d33000 	ldrb	r3, [r3]
21f175d4:	e353007e 	cmp	r3, #126	; 0x7e
21f175d8:	9a000002 	bls	21f175e8 <do_mem_md+0x3b8>
				putc ('.');
21f175dc:	e3a0002e 	mov	r0, #46	; 0x2e
21f175e0:	eb001100 	bl	21f1b9e8 <putc>
21f175e4:	ea000004 	b	21f175fc <do_mem_md+0x3cc>
			else
				printf("%c", *cp);
21f175e8:	e51b3028 	ldr	r3, [fp, #-40]
21f175ec:	e5d33000 	ldrb	r3, [r3]
21f175f0:	e59f00d0 	ldr	r0, [pc, #208]	; 21f176c8 <.text+0x176c8>
21f175f4:	e1a01003 	mov	r1, r3
21f175f8:	eb001123 	bl	21f1ba8c <printf>
			cp++;
21f175fc:	e51b3028 	ldr	r3, [fp, #-40]
21f17600:	e2833001 	add	r3, r3, #1	; 0x1
21f17604:	e50b3028 	str	r3, [fp, #-40]
21f17608:	e51b3034 	ldr	r3, [fp, #-52]
21f1760c:	e2833001 	add	r3, r3, #1	; 0x1
21f17610:	e50b3034 	str	r3, [fp, #-52]
21f17614:	e51b2034 	ldr	r2, [fp, #-52]
21f17618:	e51b302c 	ldr	r3, [fp, #-44]
21f1761c:	e1520003 	cmp	r2, r3
21f17620:	3affffe5 	bcc	21f175bc <do_mem_md+0x38c>
		}
		putc ('\n');
21f17624:	e3a0000a 	mov	r0, #10	; 0xa
21f17628:	eb0010ee 	bl	21f1b9e8 <putc>
		nbytes -= linebytes;
21f1762c:	e51b2030 	ldr	r2, [fp, #-48]
21f17630:	e51b302c 	ldr	r3, [fp, #-44]
21f17634:	e0633002 	rsb	r3, r3, r2
21f17638:	e50b3030 	str	r3, [fp, #-48]
		if (ctrlc()) {
21f1763c:	eb00113b 	bl	21f1bb30 <ctrlc>
21f17640:	e1a03000 	mov	r3, r0
21f17644:	e3530000 	cmp	r3, #0	; 0x0
21f17648:	0a000002 	beq	21f17658 <do_mem_md+0x428>
			rc = 1;
21f1764c:	e3a03001 	mov	r3, #1	; 0x1
21f17650:	e50b3010 	str	r3, [fp, #-16]
			break;
21f17654:	ea000002 	b	21f17664 <do_mem_md+0x434>
		}
	} while (nbytes > 0);
21f17658:	e51b3030 	ldr	r3, [fp, #-48]
21f1765c:	e3530000 	cmp	r3, #0	; 0x0
21f17660:	1affff41 	bne	21f1736c <do_mem_md+0x13c>

	dp_last_addr = addr;
21f17664:	e59f2034 	ldr	r2, [pc, #52]	; 21f176a0 <.text+0x176a0>
21f17668:	e51b303c 	ldr	r3, [fp, #-60]
21f1766c:	e5823000 	str	r3, [r2]
	dp_last_length = length;
21f17670:	e59f2030 	ldr	r2, [pc, #48]	; 21f176a8 <.text+0x176a8>
21f17674:	e51b3038 	ldr	r3, [fp, #-56]
21f17678:	e5823000 	str	r3, [r2]
	dp_last_size = size;
21f1767c:	e51b2024 	ldr	r2, [fp, #-36]
21f17680:	e59f301c 	ldr	r3, [pc, #28]	; 21f176a4 <.text+0x176a4>
21f17684:	e5832000 	str	r2, [r3]
	return (rc);
21f17688:	e51b3020 	ldr	r3, [fp, #-32]
21f1768c:	e50b3060 	str	r3, [fp, #-96]
21f17690:	e51b3060 	ldr	r3, [fp, #-96]
}
21f17694:	e1a00003 	mov	r0, r3
21f17698:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1769c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f176a0:	21f6772c 	mvncss	r7, ip, lsr #14
21f176a4:	21f67730 	mvncss	r7, r0, lsr r7
21f176a8:	21f33298 	ldrcsb	r3, [r3, #40]!
21f176ac:	21f310c0 	mvncss	r1, r0, asr #1
21f176b0:	21f6773c 	mvncss	r7, ip, lsr r7
21f176b4:	21f310cc 	mvncss	r1, ip, asr #1
21f176b8:	21f310d4 	ldrcssb	r1, [r3, #4]!
21f176bc:	21f310dc 	ldrcssb	r1, [r3, #12]!
21f176c0:	21f310e4 	mvncss	r1, r4, ror #1
21f176c4:	21f310ec 	mvncss	r1, ip, ror #1
21f176c8:	21f310f4 	ldrcssh	r1, [r3, #4]!

21f176cc <do_mem_mm>:

int do_mem_mm ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f176cc:	e1a0c00d 	mov	ip, sp
21f176d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f176d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f176d8:	e24dd014 	sub	sp, sp, #20	; 0x14
21f176dc:	e50b0010 	str	r0, [fp, #-16]
21f176e0:	e50b1014 	str	r1, [fp, #-20]
21f176e4:	e50b2018 	str	r2, [fp, #-24]
21f176e8:	e50b301c 	str	r3, [fp, #-28]
	return mod_mem (cmdtp, 1, flag, argc, argv);
21f176ec:	e51b301c 	ldr	r3, [fp, #-28]
21f176f0:	e58d3000 	str	r3, [sp]
21f176f4:	e51b0010 	ldr	r0, [fp, #-16]
21f176f8:	e3a01001 	mov	r1, #1	; 0x1
21f176fc:	e51b2014 	ldr	r2, [fp, #-20]
21f17700:	e51b3018 	ldr	r3, [fp, #-24]
21f17704:	eb0003f6 	bl	21f186e4 <mod_mem>
21f17708:	e1a03000 	mov	r3, r0
}
21f1770c:	e1a00003 	mov	r0, r3
21f17710:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f17714:	e89da800 	ldmia	sp, {fp, sp, pc}

21f17718 <do_mem_nm>:
int do_mem_nm ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f17718:	e1a0c00d 	mov	ip, sp
21f1771c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f17720:	e24cb004 	sub	fp, ip, #4	; 0x4
21f17724:	e24dd014 	sub	sp, sp, #20	; 0x14
21f17728:	e50b0010 	str	r0, [fp, #-16]
21f1772c:	e50b1014 	str	r1, [fp, #-20]
21f17730:	e50b2018 	str	r2, [fp, #-24]
21f17734:	e50b301c 	str	r3, [fp, #-28]
	return mod_mem (cmdtp, 0, flag, argc, argv);
21f17738:	e51b301c 	ldr	r3, [fp, #-28]
21f1773c:	e58d3000 	str	r3, [sp]
21f17740:	e51b0010 	ldr	r0, [fp, #-16]
21f17744:	e3a01000 	mov	r1, #0	; 0x0
21f17748:	e51b2014 	ldr	r2, [fp, #-20]
21f1774c:	e51b3018 	ldr	r3, [fp, #-24]
21f17750:	eb0003e3 	bl	21f186e4 <mod_mem>
21f17754:	e1a03000 	mov	r3, r0
}
21f17758:	e1a00003 	mov	r0, r3
21f1775c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f17760:	e89da800 	ldmia	sp, {fp, sp, pc}

21f17764 <do_mem_mw>:

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f17764:	e1a0c00d 	mov	ip, sp
21f17768:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1776c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f17770:	e24dd024 	sub	sp, sp, #36	; 0x24
21f17774:	e50b0020 	str	r0, [fp, #-32]
21f17778:	e50b1024 	str	r1, [fp, #-36]
21f1777c:	e50b2028 	str	r2, [fp, #-40]
21f17780:	e50b302c 	str	r3, [fp, #-44]
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4)) {
21f17784:	e51b3028 	ldr	r3, [fp, #-40]
21f17788:	e3530002 	cmp	r3, #2	; 0x2
21f1778c:	da000002 	ble	21f1779c <do_mem_mw+0x38>
21f17790:	e51b3028 	ldr	r3, [fp, #-40]
21f17794:	e3530004 	cmp	r3, #4	; 0x4
21f17798:	da000007 	ble	21f177bc <do_mem_mw+0x58>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f1779c:	e51b3020 	ldr	r3, [fp, #-32]
21f177a0:	e5933010 	ldr	r3, [r3, #16]
21f177a4:	e59f0170 	ldr	r0, [pc, #368]	; 21f1791c <.text+0x1791c>
21f177a8:	e1a01003 	mov	r1, r3
21f177ac:	eb0010b6 	bl	21f1ba8c <printf>
		return 1;
21f177b0:	e3a03001 	mov	r3, #1	; 0x1
21f177b4:	e50b3030 	str	r3, [fp, #-48]
21f177b8:	ea000053 	b	21f1790c <do_mem_mw+0x1a8>
	}

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
21f177bc:	e51b302c 	ldr	r3, [fp, #-44]
21f177c0:	e5933000 	ldr	r3, [r3]
21f177c4:	e1a00003 	mov	r0, r3
21f177c8:	e3a01004 	mov	r1, #4	; 0x4
21f177cc:	ebfffe4f 	bl	21f17110 <cmd_get_data_size>
21f177d0:	e1a03000 	mov	r3, r0
21f177d4:	e50b3010 	str	r3, [fp, #-16]
21f177d8:	e51b3010 	ldr	r3, [fp, #-16]
21f177dc:	e3530000 	cmp	r3, #0	; 0x0
21f177e0:	ca000002 	bgt	21f177f0 <do_mem_mw+0x8c>
		return 1;
21f177e4:	e3a03001 	mov	r3, #1	; 0x1
21f177e8:	e50b3030 	str	r3, [fp, #-48]
21f177ec:	ea000046 	b	21f1790c <do_mem_mw+0x1a8>

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
21f177f0:	e51b302c 	ldr	r3, [fp, #-44]
21f177f4:	e2833004 	add	r3, r3, #4	; 0x4
21f177f8:	e5933000 	ldr	r3, [r3]
21f177fc:	e1a00003 	mov	r0, r3
21f17800:	e3a01000 	mov	r1, #0	; 0x0
21f17804:	e3a02010 	mov	r2, #16	; 0x10
21f17808:	eb002f6e 	bl	21f235c8 <simple_strtoul>
21f1780c:	e1a03000 	mov	r3, r0
21f17810:	e50b301c 	str	r3, [fp, #-28]
	addr += base_address;
21f17814:	e59f3104 	ldr	r3, [pc, #260]	; 21f17920 <.text+0x17920>
21f17818:	e5932000 	ldr	r2, [r3]
21f1781c:	e51b301c 	ldr	r3, [fp, #-28]
21f17820:	e0833002 	add	r3, r3, r2
21f17824:	e50b301c 	str	r3, [fp, #-28]

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
21f17828:	e51b302c 	ldr	r3, [fp, #-44]
21f1782c:	e2833008 	add	r3, r3, #8	; 0x8
21f17830:	e5933000 	ldr	r3, [r3]
21f17834:	e1a00003 	mov	r0, r3
21f17838:	e3a01000 	mov	r1, #0	; 0x0
21f1783c:	e3a02010 	mov	r2, #16	; 0x10
21f17840:	eb002f60 	bl	21f235c8 <simple_strtoul>
21f17844:	e1a03000 	mov	r3, r0
21f17848:	e50b3018 	str	r3, [fp, #-24]

	/* Count ? */
	if (argc == 4) {
21f1784c:	e51b3028 	ldr	r3, [fp, #-40]
21f17850:	e3530004 	cmp	r3, #4	; 0x4
21f17854:	1a000009 	bne	21f17880 <do_mem_mw+0x11c>
		count = simple_strtoul(argv[3], NULL, 16);
21f17858:	e51b302c 	ldr	r3, [fp, #-44]
21f1785c:	e283300c 	add	r3, r3, #12	; 0xc
21f17860:	e5933000 	ldr	r3, [r3]
21f17864:	e1a00003 	mov	r0, r3
21f17868:	e3a01000 	mov	r1, #0	; 0x0
21f1786c:	e3a02010 	mov	r2, #16	; 0x10
21f17870:	eb002f54 	bl	21f235c8 <simple_strtoul>
21f17874:	e1a03000 	mov	r3, r0
21f17878:	e50b3014 	str	r3, [fp, #-20]
21f1787c:	ea00001a 	b	21f178ec <do_mem_mw+0x188>
	} else {
		count = 1;
21f17880:	e3a03001 	mov	r3, #1	; 0x1
21f17884:	e50b3014 	str	r3, [fp, #-20]
21f17888:	ea000017 	b	21f178ec <do_mem_mw+0x188>
	}

	while (count-- > 0) {
		if (size == 4)
21f1788c:	e51b3010 	ldr	r3, [fp, #-16]
21f17890:	e3530004 	cmp	r3, #4	; 0x4
21f17894:	1a000003 	bne	21f178a8 <do_mem_mw+0x144>
			*((ulong  *)addr) = (ulong )writeval;
21f17898:	e51b201c 	ldr	r2, [fp, #-28]
21f1789c:	e51b3018 	ldr	r3, [fp, #-24]
21f178a0:	e5823000 	str	r3, [r2]
21f178a4:	ea00000c 	b	21f178dc <do_mem_mw+0x178>
		else if (size == 2)
21f178a8:	e51b3010 	ldr	r3, [fp, #-16]
21f178ac:	e3530002 	cmp	r3, #2	; 0x2
21f178b0:	1a000005 	bne	21f178cc <do_mem_mw+0x168>
			*((ushort *)addr) = (ushort)writeval;
21f178b4:	e51b201c 	ldr	r2, [fp, #-28]
21f178b8:	e51b3018 	ldr	r3, [fp, #-24]
21f178bc:	e1a03803 	mov	r3, r3, lsl #16
21f178c0:	e1a03823 	mov	r3, r3, lsr #16
21f178c4:	e1c230b0 	strh	r3, [r2]
21f178c8:	ea000003 	b	21f178dc <do_mem_mw+0x178>
		else
			*((u_char *)addr) = (u_char)writeval;
21f178cc:	e51b201c 	ldr	r2, [fp, #-28]
21f178d0:	e51b3018 	ldr	r3, [fp, #-24]
21f178d4:	e20330ff 	and	r3, r3, #255	; 0xff
21f178d8:	e5c23000 	strb	r3, [r2]
		addr += size;
21f178dc:	e51b3010 	ldr	r3, [fp, #-16]
21f178e0:	e51b201c 	ldr	r2, [fp, #-28]
21f178e4:	e0823003 	add	r3, r2, r3
21f178e8:	e50b301c 	str	r3, [fp, #-28]
21f178ec:	e51b3014 	ldr	r3, [fp, #-20]
21f178f0:	e2433001 	sub	r3, r3, #1	; 0x1
21f178f4:	e50b3014 	str	r3, [fp, #-20]
21f178f8:	e51b3014 	ldr	r3, [fp, #-20]
21f178fc:	e3730001 	cmn	r3, #1	; 0x1
21f17900:	1affffe1 	bne	21f1788c <do_mem_mw+0x128>
	}
	return 0;
21f17904:	e3a03000 	mov	r3, #0	; 0x0
21f17908:	e50b3030 	str	r3, [fp, #-48]
21f1790c:	e51b3030 	ldr	r3, [fp, #-48]
}
21f17910:	e1a00003 	mov	r0, r3
21f17914:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f17918:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1791c:	21f310c0 	mvncss	r1, r0, asr #1
21f17920:	21f6773c 	mvncss	r7, ip, lsr r7

21f17924 <do_mem_cmp>:

#ifdef CONFIG_MX_CYCLIC
int do_mem_mdc ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	int i;
	ulong count;

	if (argc < 4) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	count = simple_strtoul(argv[3], NULL, 10);

	for (;;) {
		do_mem_md (NULL, 0, 3, argv);

		/* delay for <count> ms... */
		for (i=0; i<count; i++)
			udelay (1000);

		/* check for ctrl-c to abort... */
		if (ctrlc()) {
			puts("Abort\n");
			return 0;
		}
	}

	return 0;
}

int do_mem_mwc ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	int i;
	ulong count;

	if (argc < 4) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	count = simple_strtoul(argv[3], NULL, 10);

	for (;;) {
		do_mem_mw (NULL, 0, 3, argv);

		/* delay for <count> ms... */
		for (i=0; i<count; i++)
			udelay (1000);

		/* check for ctrl-c to abort... */
		if (ctrlc()) {
			puts("Abort\n");
			return 0;
		}
	}

	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f17924:	e1a0c00d 	mov	ip, sp
21f17928:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f1792c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f17930:	e24dd04c 	sub	sp, sp, #76	; 0x4c
21f17934:	e50b003c 	str	r0, [fp, #-60]
21f17938:	e50b1040 	str	r1, [fp, #-64]
21f1793c:	e50b2044 	str	r2, [fp, #-68]
21f17940:	e50b3048 	str	r3, [fp, #-72]
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
21f17944:	e3a03000 	mov	r3, #0	; 0x0
21f17948:	e50b3024 	str	r3, [fp, #-36]

	if (argc != 4) {
21f1794c:	e51b3044 	ldr	r3, [fp, #-68]
21f17950:	e3530004 	cmp	r3, #4	; 0x4
21f17954:	0a000007 	beq	21f17978 <do_mem_cmp+0x54>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f17958:	e51b303c 	ldr	r3, [fp, #-60]
21f1795c:	e5933010 	ldr	r3, [r3, #16]
21f17960:	e59f02fc 	ldr	r0, [pc, #764]	; 21f17c64 <.text+0x17c64>
21f17964:	e1a01003 	mov	r1, r3
21f17968:	eb001047 	bl	21f1ba8c <printf>
		return 1;
21f1796c:	e3a03001 	mov	r3, #1	; 0x1
21f17970:	e50b3058 	str	r3, [fp, #-88]
21f17974:	ea0000b6 	b	21f17c54 <do_mem_cmp+0x330>
	}

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
21f17978:	e51b3048 	ldr	r3, [fp, #-72]
21f1797c:	e5933000 	ldr	r3, [r3]
21f17980:	e1a00003 	mov	r0, r3
21f17984:	e3a01004 	mov	r1, #4	; 0x4
21f17988:	ebfffde0 	bl	21f17110 <cmd_get_data_size>
21f1798c:	e1a03000 	mov	r3, r0
21f17990:	e50b3028 	str	r3, [fp, #-40]
21f17994:	e51b3028 	ldr	r3, [fp, #-40]
21f17998:	e3530000 	cmp	r3, #0	; 0x0
21f1799c:	aa000002 	bge	21f179ac <do_mem_cmp+0x88>
		return 1;
21f179a0:	e3a03001 	mov	r3, #1	; 0x1
21f179a4:	e50b3058 	str	r3, [fp, #-88]
21f179a8:	ea0000a9 	b	21f17c54 <do_mem_cmp+0x330>

	addr1 = simple_strtoul(argv[1], NULL, 16);
21f179ac:	e51b3048 	ldr	r3, [fp, #-72]
21f179b0:	e2833004 	add	r3, r3, #4	; 0x4
21f179b4:	e5933000 	ldr	r3, [r3]
21f179b8:	e1a00003 	mov	r0, r3
21f179bc:	e3a01000 	mov	r1, #0	; 0x0
21f179c0:	e3a02010 	mov	r2, #16	; 0x10
21f179c4:	eb002eff 	bl	21f235c8 <simple_strtoul>
21f179c8:	e1a03000 	mov	r3, r0
21f179cc:	e50b3038 	str	r3, [fp, #-56]
	addr1 += base_address;
21f179d0:	e59f3290 	ldr	r3, [pc, #656]	; 21f17c68 <.text+0x17c68>
21f179d4:	e5932000 	ldr	r2, [r3]
21f179d8:	e51b3038 	ldr	r3, [fp, #-56]
21f179dc:	e0833002 	add	r3, r3, r2
21f179e0:	e50b3038 	str	r3, [fp, #-56]

	addr2 = simple_strtoul(argv[2], NULL, 16);
21f179e4:	e51b3048 	ldr	r3, [fp, #-72]
21f179e8:	e2833008 	add	r3, r3, #8	; 0x8
21f179ec:	e5933000 	ldr	r3, [r3]
21f179f0:	e1a00003 	mov	r0, r3
21f179f4:	e3a01000 	mov	r1, #0	; 0x0
21f179f8:	e3a02010 	mov	r2, #16	; 0x10
21f179fc:	eb002ef1 	bl	21f235c8 <simple_strtoul>
21f17a00:	e1a03000 	mov	r3, r0
21f17a04:	e50b3034 	str	r3, [fp, #-52]
	addr2 += base_address;
21f17a08:	e59f3258 	ldr	r3, [pc, #600]	; 21f17c68 <.text+0x17c68>
21f17a0c:	e5932000 	ldr	r2, [r3]
21f17a10:	e51b3034 	ldr	r3, [fp, #-52]
21f17a14:	e0833002 	add	r3, r3, r2
21f17a18:	e50b3034 	str	r3, [fp, #-52]

	count = simple_strtoul(argv[3], NULL, 16);
21f17a1c:	e51b3048 	ldr	r3, [fp, #-72]
21f17a20:	e283300c 	add	r3, r3, #12	; 0xc
21f17a24:	e5933000 	ldr	r3, [r3]
21f17a28:	e1a00003 	mov	r0, r3
21f17a2c:	e3a01000 	mov	r1, #0	; 0x0
21f17a30:	e3a02010 	mov	r2, #16	; 0x10
21f17a34:	eb002ee3 	bl	21f235c8 <simple_strtoul>
21f17a38:	e1a03000 	mov	r3, r0
21f17a3c:	e50b3030 	str	r3, [fp, #-48]

#ifdef CONFIG_HAS_DATAFLASH
	if (addr_dataflash(addr1) | addr_dataflash(addr2)){
21f17a40:	e51b0038 	ldr	r0, [fp, #-56]
21f17a44:	ebffe2b2 	bl	21f10514 <addr_dataflash>
21f17a48:	e1a04000 	mov	r4, r0
21f17a4c:	e51b0034 	ldr	r0, [fp, #-52]
21f17a50:	ebffe2af 	bl	21f10514 <addr_dataflash>
21f17a54:	e1a03000 	mov	r3, r0
21f17a58:	e1843003 	orr	r3, r4, r3
21f17a5c:	e3530000 	cmp	r3, #0	; 0x0
21f17a60:	0a000004 	beq	21f17a78 <do_mem_cmp+0x154>
		puts ("Comparison with DataFlash space not supported.\n\r");
21f17a64:	e59f0200 	ldr	r0, [pc, #512]	; 21f17c6c <.text+0x17c6c>
21f17a68:	eb000ff4 	bl	21f1ba40 <puts>
		return 0;
21f17a6c:	e3a03000 	mov	r3, #0	; 0x0
21f17a70:	e50b3058 	str	r3, [fp, #-88]
21f17a74:	ea000076 	b	21f17c54 <do_mem_cmp+0x330>
	}
#endif

	ngood = 0;
21f17a78:	e3a03000 	mov	r3, #0	; 0x0
21f17a7c:	e50b302c 	str	r3, [fp, #-44]

	while (count-- > 0) {
21f17a80:	ea00004e 	b	21f17bc0 <do_mem_cmp+0x29c>
		if (size == 4) {
21f17a84:	e51b3028 	ldr	r3, [fp, #-40]
21f17a88:	e3530004 	cmp	r3, #4	; 0x4
21f17a8c:	1a000013 	bne	21f17ae0 <do_mem_cmp+0x1bc>
			ulong word1 = *(ulong *)addr1;
21f17a90:	e51b3038 	ldr	r3, [fp, #-56]
21f17a94:	e5933000 	ldr	r3, [r3]
21f17a98:	e50b3020 	str	r3, [fp, #-32]
			ulong word2 = *(ulong *)addr2;
21f17a9c:	e51b3034 	ldr	r3, [fp, #-52]
21f17aa0:	e5933000 	ldr	r3, [r3]
21f17aa4:	e50b301c 	str	r3, [fp, #-28]
			if (word1 != word2) {
21f17aa8:	e51b2020 	ldr	r2, [fp, #-32]
21f17aac:	e51b301c 	ldr	r3, [fp, #-28]
21f17ab0:	e1520003 	cmp	r2, r3
21f17ab4:	0a000036 	beq	21f17b94 <do_mem_cmp+0x270>
				printf("word at 0x%08lx (0x%08lx) "
21f17ab8:	e51b301c 	ldr	r3, [fp, #-28]
21f17abc:	e58d3000 	str	r3, [sp]
21f17ac0:	e59f01a8 	ldr	r0, [pc, #424]	; 21f17c70 <.text+0x17c70>
21f17ac4:	e51b1038 	ldr	r1, [fp, #-56]
21f17ac8:	e51b2020 	ldr	r2, [fp, #-32]
21f17acc:	e51b3034 	ldr	r3, [fp, #-52]
21f17ad0:	eb000fed 	bl	21f1ba8c <printf>
					"!= word at 0x%08lx (0x%08lx)\n",
					addr1, word1, addr2, word2);
				rcode = 1;
21f17ad4:	e3a03001 	mov	r3, #1	; 0x1
21f17ad8:	e50b3024 	str	r3, [fp, #-36]
				break;
21f17adc:	ea00003d 	b	21f17bd8 <do_mem_cmp+0x2b4>
			}
		}
		else if (size == 2) {
21f17ae0:	e51b3028 	ldr	r3, [fp, #-40]
21f17ae4:	e3530002 	cmp	r3, #2	; 0x2
21f17ae8:	1a000014 	bne	21f17b40 <do_mem_cmp+0x21c>
			ushort hword1 = *(ushort *)addr1;
21f17aec:	e51b3038 	ldr	r3, [fp, #-56]
21f17af0:	e1d330b0 	ldrh	r3, [r3]
21f17af4:	e14b31b6 	strh	r3, [fp, #-22]
			ushort hword2 = *(ushort *)addr2;
21f17af8:	e51b3034 	ldr	r3, [fp, #-52]
21f17afc:	e1d330b0 	ldrh	r3, [r3]
21f17b00:	e14b31b4 	strh	r3, [fp, #-20]
			if (hword1 != hword2) {
21f17b04:	e15b21b6 	ldrh	r2, [fp, #-22]
21f17b08:	e15b31b4 	ldrh	r3, [fp, #-20]
21f17b0c:	e1520003 	cmp	r2, r3
21f17b10:	0a00001f 	beq	21f17b94 <do_mem_cmp+0x270>
				printf("halfword at 0x%08lx (0x%04x) "
21f17b14:	e15b31b6 	ldrh	r3, [fp, #-22]
21f17b18:	e15b21b4 	ldrh	r2, [fp, #-20]
21f17b1c:	e58d2000 	str	r2, [sp]
21f17b20:	e59f014c 	ldr	r0, [pc, #332]	; 21f17c74 <.text+0x17c74>
21f17b24:	e51b1038 	ldr	r1, [fp, #-56]
21f17b28:	e1a02003 	mov	r2, r3
21f17b2c:	e51b3034 	ldr	r3, [fp, #-52]
21f17b30:	eb000fd5 	bl	21f1ba8c <printf>
					"!= halfword at 0x%08lx (0x%04x)\n",
					addr1, hword1, addr2, hword2);
				rcode = 1;
21f17b34:	e3a03001 	mov	r3, #1	; 0x1
21f17b38:	e50b3024 	str	r3, [fp, #-36]
				break;
21f17b3c:	ea000025 	b	21f17bd8 <do_mem_cmp+0x2b4>
			}
		}
		else {
			u_char byte1 = *(u_char *)addr1;
21f17b40:	e51b3038 	ldr	r3, [fp, #-56]
21f17b44:	e5d33000 	ldrb	r3, [r3]
21f17b48:	e54b3012 	strb	r3, [fp, #-18]
			u_char byte2 = *(u_char *)addr2;
21f17b4c:	e51b3034 	ldr	r3, [fp, #-52]
21f17b50:	e5d33000 	ldrb	r3, [r3]
21f17b54:	e54b3011 	strb	r3, [fp, #-17]
			if (byte1 != byte2) {
21f17b58:	e55b2012 	ldrb	r2, [fp, #-18]
21f17b5c:	e55b3011 	ldrb	r3, [fp, #-17]
21f17b60:	e1520003 	cmp	r2, r3
21f17b64:	0a00000a 	beq	21f17b94 <do_mem_cmp+0x270>
				printf("byte at 0x%08lx (0x%02x) "
21f17b68:	e55b3012 	ldrb	r3, [fp, #-18]
21f17b6c:	e55b2011 	ldrb	r2, [fp, #-17]
21f17b70:	e58d2000 	str	r2, [sp]
21f17b74:	e59f00fc 	ldr	r0, [pc, #252]	; 21f17c78 <.text+0x17c78>
21f17b78:	e51b1038 	ldr	r1, [fp, #-56]
21f17b7c:	e1a02003 	mov	r2, r3
21f17b80:	e51b3034 	ldr	r3, [fp, #-52]
21f17b84:	eb000fc0 	bl	21f1ba8c <printf>
					"!= byte at 0x%08lx (0x%02x)\n",
					addr1, byte1, addr2, byte2);
				rcode = 1;
21f17b88:	e3a03001 	mov	r3, #1	; 0x1
21f17b8c:	e50b3024 	str	r3, [fp, #-36]
				break;
21f17b90:	ea000010 	b	21f17bd8 <do_mem_cmp+0x2b4>
			}
		}
		ngood++;
21f17b94:	e51b302c 	ldr	r3, [fp, #-44]
21f17b98:	e2833001 	add	r3, r3, #1	; 0x1
21f17b9c:	e50b302c 	str	r3, [fp, #-44]
		addr1 += size;
21f17ba0:	e51b2028 	ldr	r2, [fp, #-40]
21f17ba4:	e51b3038 	ldr	r3, [fp, #-56]
21f17ba8:	e0833002 	add	r3, r3, r2
21f17bac:	e50b3038 	str	r3, [fp, #-56]
		addr2 += size;
21f17bb0:	e51b2028 	ldr	r2, [fp, #-40]
21f17bb4:	e51b3034 	ldr	r3, [fp, #-52]
21f17bb8:	e0833002 	add	r3, r3, r2
21f17bbc:	e50b3034 	str	r3, [fp, #-52]
21f17bc0:	e51b3030 	ldr	r3, [fp, #-48]
21f17bc4:	e2433001 	sub	r3, r3, #1	; 0x1
21f17bc8:	e50b3030 	str	r3, [fp, #-48]
21f17bcc:	e51b3030 	ldr	r3, [fp, #-48]
21f17bd0:	e3730001 	cmn	r3, #1	; 0x1
21f17bd4:	1affffaa 	bne	21f17a84 <do_mem_cmp+0x160>
	}

	printf("Total of %ld %s%s were the same\n",
21f17bd8:	e51b3028 	ldr	r3, [fp, #-40]
21f17bdc:	e3530004 	cmp	r3, #4	; 0x4
21f17be0:	0a00000a 	beq	21f17c10 <do_mem_cmp+0x2ec>
21f17be4:	e51b3028 	ldr	r3, [fp, #-40]
21f17be8:	e3530002 	cmp	r3, #2	; 0x2
21f17bec:	1a000002 	bne	21f17bfc <do_mem_cmp+0x2d8>
21f17bf0:	e59f3084 	ldr	r3, [pc, #132]	; 21f17c7c <.text+0x17c7c>
21f17bf4:	e50b3050 	str	r3, [fp, #-80]
21f17bf8:	ea000001 	b	21f17c04 <do_mem_cmp+0x2e0>
21f17bfc:	e59f307c 	ldr	r3, [pc, #124]	; 21f17c80 <.text+0x17c80>
21f17c00:	e50b3050 	str	r3, [fp, #-80]
21f17c04:	e51b3050 	ldr	r3, [fp, #-80]
21f17c08:	e50b3054 	str	r3, [fp, #-84]
21f17c0c:	ea000001 	b	21f17c18 <do_mem_cmp+0x2f4>
21f17c10:	e59f306c 	ldr	r3, [pc, #108]	; 21f17c84 <.text+0x17c84>
21f17c14:	e50b3054 	str	r3, [fp, #-84]
21f17c18:	e51b302c 	ldr	r3, [fp, #-44]
21f17c1c:	e3530001 	cmp	r3, #1	; 0x1
21f17c20:	1a000002 	bne	21f17c30 <do_mem_cmp+0x30c>
21f17c24:	e59f305c 	ldr	r3, [pc, #92]	; 21f17c88 <.text+0x17c88>
21f17c28:	e50b304c 	str	r3, [fp, #-76]
21f17c2c:	ea000001 	b	21f17c38 <do_mem_cmp+0x314>
21f17c30:	e59f3054 	ldr	r3, [pc, #84]	; 21f17c8c <.text+0x17c8c>
21f17c34:	e50b304c 	str	r3, [fp, #-76]
21f17c38:	e59f0050 	ldr	r0, [pc, #80]	; 21f17c90 <.text+0x17c90>
21f17c3c:	e51b102c 	ldr	r1, [fp, #-44]
21f17c40:	e51b2054 	ldr	r2, [fp, #-84]
21f17c44:	e51b304c 	ldr	r3, [fp, #-76]
21f17c48:	eb000f8f 	bl	21f1ba8c <printf>
		ngood, size == 4 ? "word" : size == 2 ? "halfword" : "byte",
		ngood == 1 ? "" : "s");
	return rcode;
21f17c4c:	e51b3024 	ldr	r3, [fp, #-36]
21f17c50:	e50b3058 	str	r3, [fp, #-88]
21f17c54:	e51b3058 	ldr	r3, [fp, #-88]
}
21f17c58:	e1a00003 	mov	r0, r3
21f17c5c:	e24bd010 	sub	sp, fp, #16	; 0x10
21f17c60:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f17c64:	21f310c0 	mvncss	r1, r0, asr #1
21f17c68:	21f6773c 	mvncss	r7, ip, lsr r7
21f17c6c:	21f310f8 	ldrcssh	r1, [r3, #8]!
21f17c70:	21f3112c 	mvncss	r1, ip, lsr #2
21f17c74:	21f31164 	mvncss	r1, r4, ror #2
21f17c78:	21f311a4 	mvncss	r1, r4, lsr #3
21f17c7c:	21f311dc 	ldrcssb	r1, [r3, #28]!
21f17c80:	21f311e8 	mvncss	r1, r8, ror #3
21f17c84:	21f311f0 	ldrcssh	r1, [r3, #16]!
21f17c88:	21f311f8 	ldrcssh	r1, [r3, #24]!
21f17c8c:	21f311fc 	ldrcssh	r1, [r3, #28]!
21f17c90:	21f31200 	mvncss	r1, r0, lsl #4

21f17c94 <do_mem_cp>:

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f17c94:	e1a0c00d 	mov	ip, sp
21f17c98:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f17c9c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f17ca0:	e24dd040 	sub	sp, sp, #64	; 0x40
21f17ca4:	e50b0034 	str	r0, [fp, #-52]
21f17ca8:	e50b1038 	str	r1, [fp, #-56]
21f17cac:	e50b203c 	str	r2, [fp, #-60]
21f17cb0:	e50b3040 	str	r3, [fp, #-64]
	ulong	addr, dest, count;
	int	size;

	if (argc != 4) {
21f17cb4:	e51b303c 	ldr	r3, [fp, #-60]
21f17cb8:	e3530004 	cmp	r3, #4	; 0x4
21f17cbc:	0a000007 	beq	21f17ce0 <do_mem_cp+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f17cc0:	e51b3034 	ldr	r3, [fp, #-52]
21f17cc4:	e5933010 	ldr	r3, [r3, #16]
21f17cc8:	e59f04d4 	ldr	r0, [pc, #1236]	; 21f181a4 <.text+0x181a4>
21f17ccc:	e1a01003 	mov	r1, r3
21f17cd0:	eb000f6d 	bl	21f1ba8c <printf>
		return 1;
21f17cd4:	e3a03001 	mov	r3, #1	; 0x1
21f17cd8:	e50b3044 	str	r3, [fp, #-68]
21f17cdc:	ea00012c 	b	21f18194 <do_mem_cp+0x500>
	}

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
21f17ce0:	e51b3040 	ldr	r3, [fp, #-64]
21f17ce4:	e5933000 	ldr	r3, [r3]
21f17ce8:	e1a00003 	mov	r0, r3
21f17cec:	e3a01004 	mov	r1, #4	; 0x4
21f17cf0:	ebfffd06 	bl	21f17110 <cmd_get_data_size>
21f17cf4:	e1a03000 	mov	r3, r0
21f17cf8:	e50b3024 	str	r3, [fp, #-36]
21f17cfc:	e51b3024 	ldr	r3, [fp, #-36]
21f17d00:	e3530000 	cmp	r3, #0	; 0x0
21f17d04:	aa000002 	bge	21f17d14 <do_mem_cp+0x80>
		return 1;
21f17d08:	e3a03001 	mov	r3, #1	; 0x1
21f17d0c:	e50b3044 	str	r3, [fp, #-68]
21f17d10:	ea00011f 	b	21f18194 <do_mem_cp+0x500>

	addr = simple_strtoul(argv[1], NULL, 16);
21f17d14:	e51b3040 	ldr	r3, [fp, #-64]
21f17d18:	e2833004 	add	r3, r3, #4	; 0x4
21f17d1c:	e5933000 	ldr	r3, [r3]
21f17d20:	e1a00003 	mov	r0, r3
21f17d24:	e3a01000 	mov	r1, #0	; 0x0
21f17d28:	e3a02010 	mov	r2, #16	; 0x10
21f17d2c:	eb002e25 	bl	21f235c8 <simple_strtoul>
21f17d30:	e1a03000 	mov	r3, r0
21f17d34:	e50b3030 	str	r3, [fp, #-48]
	addr += base_address;
21f17d38:	e59f3468 	ldr	r3, [pc, #1128]	; 21f181a8 <.text+0x181a8>
21f17d3c:	e5932000 	ldr	r2, [r3]
21f17d40:	e51b3030 	ldr	r3, [fp, #-48]
21f17d44:	e0833002 	add	r3, r3, r2
21f17d48:	e50b3030 	str	r3, [fp, #-48]

	dest = simple_strtoul(argv[2], NULL, 16);
21f17d4c:	e51b3040 	ldr	r3, [fp, #-64]
21f17d50:	e2833008 	add	r3, r3, #8	; 0x8
21f17d54:	e5933000 	ldr	r3, [r3]
21f17d58:	e1a00003 	mov	r0, r3
21f17d5c:	e3a01000 	mov	r1, #0	; 0x0
21f17d60:	e3a02010 	mov	r2, #16	; 0x10
21f17d64:	eb002e17 	bl	21f235c8 <simple_strtoul>
21f17d68:	e1a03000 	mov	r3, r0
21f17d6c:	e50b302c 	str	r3, [fp, #-44]
	dest += base_address;
21f17d70:	e59f3430 	ldr	r3, [pc, #1072]	; 21f181a8 <.text+0x181a8>
21f17d74:	e5932000 	ldr	r2, [r3]
21f17d78:	e51b302c 	ldr	r3, [fp, #-44]
21f17d7c:	e0833002 	add	r3, r3, r2
21f17d80:	e50b302c 	str	r3, [fp, #-44]

	count = simple_strtoul(argv[3], NULL, 16);
21f17d84:	e51b3040 	ldr	r3, [fp, #-64]
21f17d88:	e283300c 	add	r3, r3, #12	; 0xc
21f17d8c:	e5933000 	ldr	r3, [r3]
21f17d90:	e1a00003 	mov	r0, r3
21f17d94:	e3a01000 	mov	r1, #0	; 0x0
21f17d98:	e3a02010 	mov	r2, #16	; 0x10
21f17d9c:	eb002e09 	bl	21f235c8 <simple_strtoul>
21f17da0:	e1a03000 	mov	r3, r0
21f17da4:	e50b3028 	str	r3, [fp, #-40]

	if (count == 0) {
21f17da8:	e51b3028 	ldr	r3, [fp, #-40]
21f17dac:	e3530000 	cmp	r3, #0	; 0x0
21f17db0:	1a000004 	bne	21f17dc8 <do_mem_cp+0x134>
		puts ("Zero length ???\n");
21f17db4:	e59f03f0 	ldr	r0, [pc, #1008]	; 21f181ac <.text+0x181ac>
21f17db8:	eb000f20 	bl	21f1ba40 <puts>
		return 1;
21f17dbc:	e3a03001 	mov	r3, #1	; 0x1
21f17dc0:	e50b3044 	str	r3, [fp, #-68]
21f17dc4:	ea0000f2 	b	21f18194 <do_mem_cp+0x500>
	}

#ifndef CFG_NO_FLASH
	/* check if we are copying to Flash */
	if ( (addr2info(dest) != NULL)
21f17dc8:	e51b002c 	ldr	r0, [fp, #-44]
21f17dcc:	eb001d82 	bl	21f1f3dc <addr2info>
21f17dd0:	e1a03000 	mov	r3, r0
21f17dd4:	e3530000 	cmp	r3, #0	; 0x0
21f17dd8:	0a00001d 	beq	21f17e54 <do_mem_cp+0x1c0>
21f17ddc:	e51b0030 	ldr	r0, [fp, #-48]
21f17de0:	ebffe1cb 	bl	21f10514 <addr_dataflash>
21f17de4:	e1a03000 	mov	r3, r0
21f17de8:	e3530000 	cmp	r3, #0	; 0x0
21f17dec:	1a000018 	bne	21f17e54 <do_mem_cp+0x1c0>
#ifdef CONFIG_HAS_DATAFLASH
	   && (!addr_dataflash(addr))
#endif
	   ) {
		int rc;

		puts ("Copy to Flash... ");
21f17df0:	e59f03b8 	ldr	r0, [pc, #952]	; 21f181b0 <.text+0x181b0>
21f17df4:	eb000f11 	bl	21f1ba40 <puts>

		rc = flash_write ((char *)addr, dest, count*size);
21f17df8:	e51b1030 	ldr	r1, [fp, #-48]
21f17dfc:	e51b2024 	ldr	r2, [fp, #-36]
21f17e00:	e51b3028 	ldr	r3, [fp, #-40]
21f17e04:	e0030392 	mul	r3, r2, r3
21f17e08:	e1a00001 	mov	r0, r1
21f17e0c:	e51b102c 	ldr	r1, [fp, #-44]
21f17e10:	e1a02003 	mov	r2, r3
21f17e14:	eb001da2 	bl	21f1f4a4 <flash_write>
21f17e18:	e1a03000 	mov	r3, r0
21f17e1c:	e50b3020 	str	r3, [fp, #-32]
		if (rc != 0) {
21f17e20:	e51b3020 	ldr	r3, [fp, #-32]
21f17e24:	e3530000 	cmp	r3, #0	; 0x0
21f17e28:	0a000004 	beq	21f17e40 <do_mem_cp+0x1ac>
			flash_perror (rc);
21f17e2c:	e51b0020 	ldr	r0, [fp, #-32]
21f17e30:	eb001e47 	bl	21f1f754 <flash_perror>
			return (1);
21f17e34:	e3a03001 	mov	r3, #1	; 0x1
21f17e38:	e50b3044 	str	r3, [fp, #-68]
21f17e3c:	ea0000d4 	b	21f18194 <do_mem_cp+0x500>
		}
		puts ("done\n");
21f17e40:	e59f036c 	ldr	r0, [pc, #876]	; 21f181b4 <.text+0x181b4>
21f17e44:	eb000efd 	bl	21f1ba40 <puts>
		return 0;
21f17e48:	e3a03000 	mov	r3, #0	; 0x0
21f17e4c:	e50b3044 	str	r3, [fp, #-68]
21f17e50:	ea0000cf 	b	21f18194 <do_mem_cp+0x500>
	}
#endif

#if (CONFIG_COMMANDS & CFG_CMD_MMC)
	if (mmc2info(dest)) {
21f17e54:	e51b002c 	ldr	r0, [fp, #-44]
21f17e58:	ebffb64d 	bl	21f05794 <mmc2info>
21f17e5c:	e1a03000 	mov	r3, r0
21f17e60:	e3530000 	cmp	r3, #0	; 0x0
21f17e64:	0a000026 	beq	21f17f04 <do_mem_cp+0x270>
		int rc;

		puts ("Copy to MMC... ");
21f17e68:	e59f0348 	ldr	r0, [pc, #840]	; 21f181b8 <.text+0x181b8>
21f17e6c:	eb000ef3 	bl	21f1ba40 <puts>
		switch (rc = mmc_write ((uchar *)addr, dest, count*size)) {
21f17e70:	e51b1030 	ldr	r1, [fp, #-48]
21f17e74:	e51b2024 	ldr	r2, [fp, #-36]
21f17e78:	e51b3028 	ldr	r3, [fp, #-40]
21f17e7c:	e0030392 	mul	r3, r2, r3
21f17e80:	e1a00001 	mov	r0, r1
21f17e84:	e51b102c 	ldr	r1, [fp, #-44]
21f17e88:	e1a02003 	mov	r2, r3
21f17e8c:	ebffb5de 	bl	21f0560c <mmc_write>
21f17e90:	e1a03000 	mov	r3, r0
21f17e94:	e50b301c 	str	r3, [fp, #-28]
21f17e98:	e51b301c 	ldr	r3, [fp, #-28]
21f17e9c:	e50b3048 	str	r3, [fp, #-72]
21f17ea0:	e51b3048 	ldr	r3, [fp, #-72]
21f17ea4:	e3730001 	cmn	r3, #1	; 0x1
21f17ea8:	0a000008 	beq	21f17ed0 <do_mem_cp+0x23c>
21f17eac:	e51b3048 	ldr	r3, [fp, #-72]
21f17eb0:	e3530000 	cmp	r3, #0	; 0x0
21f17eb4:	0a000000 	beq	21f17ebc <do_mem_cp+0x228>
21f17eb8:	ea000009 	b	21f17ee4 <do_mem_cp+0x250>
		case 0:
			putc ('\n');
21f17ebc:	e3a0000a 	mov	r0, #10	; 0xa
21f17ec0:	eb000ec8 	bl	21f1b9e8 <putc>
			return 1;
21f17ec4:	e3a03001 	mov	r3, #1	; 0x1
21f17ec8:	e50b3044 	str	r3, [fp, #-68]
21f17ecc:	ea0000b0 	b	21f18194 <do_mem_cp+0x500>
		case -1:
			puts ("failed\n");
21f17ed0:	e59f02e4 	ldr	r0, [pc, #740]	; 21f181bc <.text+0x181bc>
21f17ed4:	eb000ed9 	bl	21f1ba40 <puts>
			return 1;
21f17ed8:	e3a03001 	mov	r3, #1	; 0x1
21f17edc:	e50b3044 	str	r3, [fp, #-68]
21f17ee0:	ea0000ab 	b	21f18194 <do_mem_cp+0x500>
		default:
			printf ("%s[%d] FIXME: rc=%d\n",__FILE__,__LINE__,rc);
21f17ee4:	e59f02d4 	ldr	r0, [pc, #724]	; 21f181c0 <.text+0x181c0>
21f17ee8:	e59f12d4 	ldr	r1, [pc, #724]	; 21f181c4 <.text+0x181c4>
21f17eec:	e3a02f72 	mov	r2, #456	; 0x1c8
21f17ef0:	e51b301c 	ldr	r3, [fp, #-28]
21f17ef4:	eb000ee4 	bl	21f1ba8c <printf>
			return 1;
21f17ef8:	e3a03001 	mov	r3, #1	; 0x1
21f17efc:	e50b3044 	str	r3, [fp, #-68]
21f17f00:	ea0000a3 	b	21f18194 <do_mem_cp+0x500>
		}
		puts ("done\n");
		return 0;
	}

	if (mmc2info(addr)) {
21f17f04:	e51b0030 	ldr	r0, [fp, #-48]
21f17f08:	ebffb621 	bl	21f05794 <mmc2info>
21f17f0c:	e1a03000 	mov	r3, r0
21f17f10:	e3530000 	cmp	r3, #0	; 0x0
21f17f14:	0a000026 	beq	21f17fb4 <do_mem_cp+0x320>
		int rc;

		puts ("Copy from MMC... ");
21f17f18:	e59f02a8 	ldr	r0, [pc, #680]	; 21f181c8 <.text+0x181c8>
21f17f1c:	eb000ec7 	bl	21f1ba40 <puts>
		switch (rc = mmc_read (addr, (uchar *)dest, count*size)) {
21f17f20:	e51b102c 	ldr	r1, [fp, #-44]
21f17f24:	e51b2024 	ldr	r2, [fp, #-36]
21f17f28:	e51b3028 	ldr	r3, [fp, #-40]
21f17f2c:	e0030392 	mul	r3, r2, r3
21f17f30:	e51b0030 	ldr	r0, [fp, #-48]
21f17f34:	e1a02003 	mov	r2, r3
21f17f38:	ebffb4d1 	bl	21f05284 <mmc_read>
21f17f3c:	e1a03000 	mov	r3, r0
21f17f40:	e50b3018 	str	r3, [fp, #-24]
21f17f44:	e51b3018 	ldr	r3, [fp, #-24]
21f17f48:	e50b304c 	str	r3, [fp, #-76]
21f17f4c:	e51b304c 	ldr	r3, [fp, #-76]
21f17f50:	e3730001 	cmn	r3, #1	; 0x1
21f17f54:	0a000008 	beq	21f17f7c <do_mem_cp+0x2e8>
21f17f58:	e51b304c 	ldr	r3, [fp, #-76]
21f17f5c:	e3530000 	cmp	r3, #0	; 0x0
21f17f60:	0a000000 	beq	21f17f68 <do_mem_cp+0x2d4>
21f17f64:	ea000009 	b	21f17f90 <do_mem_cp+0x2fc>
		case 0:
			putc ('\n');
21f17f68:	e3a0000a 	mov	r0, #10	; 0xa
21f17f6c:	eb000e9d 	bl	21f1b9e8 <putc>
			return 1;
21f17f70:	e3a03001 	mov	r3, #1	; 0x1
21f17f74:	e50b3044 	str	r3, [fp, #-68]
21f17f78:	ea000085 	b	21f18194 <do_mem_cp+0x500>
		case -1:
			puts ("failed\n");
21f17f7c:	e59f0238 	ldr	r0, [pc, #568]	; 21f181bc <.text+0x181bc>
21f17f80:	eb000eae 	bl	21f1ba40 <puts>
			return 1;
21f17f84:	e3a03001 	mov	r3, #1	; 0x1
21f17f88:	e50b3044 	str	r3, [fp, #-68]
21f17f8c:	ea000080 	b	21f18194 <do_mem_cp+0x500>
		default:
			printf ("%s[%d] FIXME: rc=%d\n",__FILE__,__LINE__,rc);
21f17f90:	e59f0228 	ldr	r0, [pc, #552]	; 21f181c0 <.text+0x181c0>
21f17f94:	e59f1228 	ldr	r1, [pc, #552]	; 21f181c4 <.text+0x181c4>
21f17f98:	e3a02f76 	mov	r2, #472	; 0x1d8
21f17f9c:	e2822003 	add	r2, r2, #3	; 0x3
21f17fa0:	e51b3018 	ldr	r3, [fp, #-24]
21f17fa4:	eb000eb8 	bl	21f1ba8c <printf>
			return 1;
21f17fa8:	e3a03001 	mov	r3, #1	; 0x1
21f17fac:	e50b3044 	str	r3, [fp, #-68]
21f17fb0:	ea000077 	b	21f18194 <do_mem_cp+0x500>
		}
		puts ("done\n");
		return 0;
	}
#endif

#ifdef CONFIG_HAS_DATAFLASH
	/* Check if we are copying from RAM or Flash to DataFlash */
	if (addr_dataflash(dest) && !addr_dataflash(addr)){
21f17fb4:	e51b002c 	ldr	r0, [fp, #-44]
21f17fb8:	ebffe155 	bl	21f10514 <addr_dataflash>
21f17fbc:	e1a03000 	mov	r3, r0
21f17fc0:	e3530000 	cmp	r3, #0	; 0x0
21f17fc4:	0a00001c 	beq	21f1803c <do_mem_cp+0x3a8>
21f17fc8:	e51b0030 	ldr	r0, [fp, #-48]
21f17fcc:	ebffe150 	bl	21f10514 <addr_dataflash>
21f17fd0:	e1a03000 	mov	r3, r0
21f17fd4:	e3530000 	cmp	r3, #0	; 0x0
21f17fd8:	1a000017 	bne	21f1803c <do_mem_cp+0x3a8>
		int rc;

		puts ("Copy to DataFlash... ");
21f17fdc:	e59f01e8 	ldr	r0, [pc, #488]	; 21f181cc <.text+0x181cc>
21f17fe0:	eb000e96 	bl	21f1ba40 <puts>

		rc = write_dataflash (dest, addr, count*size);
21f17fe4:	e51b2024 	ldr	r2, [fp, #-36]
21f17fe8:	e51b3028 	ldr	r3, [fp, #-40]
21f17fec:	e0030392 	mul	r3, r2, r3
21f17ff0:	e51b002c 	ldr	r0, [fp, #-44]
21f17ff4:	e51b1030 	ldr	r1, [fp, #-48]
21f17ff8:	e1a02003 	mov	r2, r3
21f17ffc:	ebffe2b3 	bl	21f10ad0 <write_dataflash>
21f18000:	e1a03000 	mov	r3, r0
21f18004:	e50b3014 	str	r3, [fp, #-20]

		if (rc != 1) {
21f18008:	e51b3014 	ldr	r3, [fp, #-20]
21f1800c:	e3530001 	cmp	r3, #1	; 0x1
21f18010:	0a000004 	beq	21f18028 <do_mem_cp+0x394>
			dataflash_perror (rc);
21f18014:	e51b0014 	ldr	r0, [fp, #-20]
21f18018:	ebffe2eb 	bl	21f10bcc <dataflash_perror>
			return (1);
21f1801c:	e3a03001 	mov	r3, #1	; 0x1
21f18020:	e50b3044 	str	r3, [fp, #-68]
21f18024:	ea00005a 	b	21f18194 <do_mem_cp+0x500>
		}
		puts ("done\n");
21f18028:	e59f0184 	ldr	r0, [pc, #388]	; 21f181b4 <.text+0x181b4>
21f1802c:	eb000e83 	bl	21f1ba40 <puts>
		return 0;
21f18030:	e3a03000 	mov	r3, #0	; 0x0
21f18034:	e50b3044 	str	r3, [fp, #-68]
21f18038:	ea000055 	b	21f18194 <do_mem_cp+0x500>
	}

	/* Check if we are copying from DataFlash to RAM */
	if (addr_dataflash(addr) && !addr_dataflash(dest) && (addr2info(dest)==NULL) ){
21f1803c:	e51b0030 	ldr	r0, [fp, #-48]
21f18040:	ebffe133 	bl	21f10514 <addr_dataflash>
21f18044:	e1a03000 	mov	r3, r0
21f18048:	e3530000 	cmp	r3, #0	; 0x0
21f1804c:	0a00001d 	beq	21f180c8 <do_mem_cp+0x434>
21f18050:	e51b002c 	ldr	r0, [fp, #-44]
21f18054:	ebffe12e 	bl	21f10514 <addr_dataflash>
21f18058:	e1a03000 	mov	r3, r0
21f1805c:	e3530000 	cmp	r3, #0	; 0x0
21f18060:	1a000018 	bne	21f180c8 <do_mem_cp+0x434>
21f18064:	e51b002c 	ldr	r0, [fp, #-44]
21f18068:	eb001cdb 	bl	21f1f3dc <addr2info>
21f1806c:	e1a03000 	mov	r3, r0
21f18070:	e3530000 	cmp	r3, #0	; 0x0
21f18074:	1a000013 	bne	21f180c8 <do_mem_cp+0x434>
		int rc;
		rc = read_dataflash(addr, count * size, (char *) dest);
21f18078:	e51b2024 	ldr	r2, [fp, #-36]
21f1807c:	e51b3028 	ldr	r3, [fp, #-40]
21f18080:	e0030392 	mul	r3, r2, r3
21f18084:	e51b202c 	ldr	r2, [fp, #-44]
21f18088:	e51b0030 	ldr	r0, [fp, #-48]
21f1808c:	e1a01003 	mov	r1, r3
21f18090:	ebffe260 	bl	21f10a18 <read_dataflash>
21f18094:	e1a03000 	mov	r3, r0
21f18098:	e50b3010 	str	r3, [fp, #-16]
		if (rc != 1) {
21f1809c:	e51b3010 	ldr	r3, [fp, #-16]
21f180a0:	e3530001 	cmp	r3, #1	; 0x1
21f180a4:	0a000004 	beq	21f180bc <do_mem_cp+0x428>
			dataflash_perror (rc);
21f180a8:	e51b0010 	ldr	r0, [fp, #-16]
21f180ac:	ebffe2c6 	bl	21f10bcc <dataflash_perror>
			return (1);
21f180b0:	e3a03001 	mov	r3, #1	; 0x1
21f180b4:	e50b3044 	str	r3, [fp, #-68]
21f180b8:	ea000035 	b	21f18194 <do_mem_cp+0x500>
		}
		return 0;
21f180bc:	e3a03000 	mov	r3, #0	; 0x0
21f180c0:	e50b3044 	str	r3, [fp, #-68]
21f180c4:	ea000032 	b	21f18194 <do_mem_cp+0x500>
	}

	if (addr_dataflash(addr) && addr_dataflash(dest)){
21f180c8:	e51b0030 	ldr	r0, [fp, #-48]
21f180cc:	ebffe110 	bl	21f10514 <addr_dataflash>
21f180d0:	e1a03000 	mov	r3, r0
21f180d4:	e3530000 	cmp	r3, #0	; 0x0
21f180d8:	0a000025 	beq	21f18174 <do_mem_cp+0x4e0>
21f180dc:	e51b002c 	ldr	r0, [fp, #-44]
21f180e0:	ebffe10b 	bl	21f10514 <addr_dataflash>
21f180e4:	e1a03000 	mov	r3, r0
21f180e8:	e3530000 	cmp	r3, #0	; 0x0
21f180ec:	0a000020 	beq	21f18174 <do_mem_cp+0x4e0>
		puts ("Unsupported combination of source/destination.\n\r");
21f180f0:	e59f00d8 	ldr	r0, [pc, #216]	; 21f181d0 <.text+0x181d0>
21f180f4:	eb000e51 	bl	21f1ba40 <puts>
		return 1;
21f180f8:	e3a03001 	mov	r3, #1	; 0x1
21f180fc:	e50b3044 	str	r3, [fp, #-68]
21f18100:	ea000023 	b	21f18194 <do_mem_cp+0x500>
	}
#endif

	while (count-- > 0) {
		if (size == 4)
21f18104:	e51b3024 	ldr	r3, [fp, #-36]
21f18108:	e3530004 	cmp	r3, #4	; 0x4
21f1810c:	1a000004 	bne	21f18124 <do_mem_cp+0x490>
			*((ulong  *)dest) = *((ulong  *)addr);
21f18110:	e51b302c 	ldr	r3, [fp, #-44]
21f18114:	e51b2030 	ldr	r2, [fp, #-48]
21f18118:	e5922000 	ldr	r2, [r2]
21f1811c:	e5832000 	str	r2, [r3]
21f18120:	ea00000b 	b	21f18154 <do_mem_cp+0x4c0>
		else if (size == 2)
21f18124:	e51b3024 	ldr	r3, [fp, #-36]
21f18128:	e3530002 	cmp	r3, #2	; 0x2
21f1812c:	1a000004 	bne	21f18144 <do_mem_cp+0x4b0>
			*((ushort *)dest) = *((ushort *)addr);
21f18130:	e51b302c 	ldr	r3, [fp, #-44]
21f18134:	e51b2030 	ldr	r2, [fp, #-48]
21f18138:	e1d220b0 	ldrh	r2, [r2]
21f1813c:	e1c320b0 	strh	r2, [r3]
21f18140:	ea000003 	b	21f18154 <do_mem_cp+0x4c0>
		else
			*((u_char *)dest) = *((u_char *)addr);
21f18144:	e51b202c 	ldr	r2, [fp, #-44]
21f18148:	e51b3030 	ldr	r3, [fp, #-48]
21f1814c:	e5d33000 	ldrb	r3, [r3]
21f18150:	e5c23000 	strb	r3, [r2]
		addr += size;
21f18154:	e51b2024 	ldr	r2, [fp, #-36]
21f18158:	e51b3030 	ldr	r3, [fp, #-48]
21f1815c:	e0833002 	add	r3, r3, r2
21f18160:	e50b3030 	str	r3, [fp, #-48]
		dest += size;
21f18164:	e51b2024 	ldr	r2, [fp, #-36]
21f18168:	e51b302c 	ldr	r3, [fp, #-44]
21f1816c:	e0833002 	add	r3, r3, r2
21f18170:	e50b302c 	str	r3, [fp, #-44]
21f18174:	e51b3028 	ldr	r3, [fp, #-40]
21f18178:	e2433001 	sub	r3, r3, #1	; 0x1
21f1817c:	e50b3028 	str	r3, [fp, #-40]
21f18180:	e51b3028 	ldr	r3, [fp, #-40]
21f18184:	e3730001 	cmn	r3, #1	; 0x1
21f18188:	1affffdd 	bne	21f18104 <do_mem_cp+0x470>
	}
	return 0;
21f1818c:	e3a03000 	mov	r3, #0	; 0x0
21f18190:	e50b3044 	str	r3, [fp, #-68]
21f18194:	e51b3044 	ldr	r3, [fp, #-68]
}
21f18198:	e1a00003 	mov	r0, r3
21f1819c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f181a0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f181a4:	21f310c0 	mvncss	r1, r0, asr #1
21f181a8:	21f6773c 	mvncss	r7, ip, lsr r7
21f181ac:	21f31224 	mvncss	r1, r4, lsr #4
21f181b0:	21f31238 	mvncss	r1, r8, lsr r2
21f181b4:	21f3124c 	mvncss	r1, ip, asr #4
21f181b8:	21f31254 	mvncss	r1, r4, asr r2
21f181bc:	21f31264 	mvncss	r1, r4, ror #4
21f181c0:	21f3126c 	mvncss	r1, ip, ror #4
21f181c4:	21f31284 	mvncss	r1, r4, lsl #5
21f181c8:	21f31290 	ldrcsb	r1, [r3, #32]!
21f181cc:	21f312a4 	mvncss	r1, r4, lsr #5
21f181d0:	21f312bc 	ldrcsh	r1, [r3, #44]!

21f181d4 <do_mem_base>:

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f181d4:	e1a0c00d 	mov	ip, sp
21f181d8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f181dc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f181e0:	e24dd010 	sub	sp, sp, #16	; 0x10
21f181e4:	e50b0010 	str	r0, [fp, #-16]
21f181e8:	e50b1014 	str	r1, [fp, #-20]
21f181ec:	e50b2018 	str	r2, [fp, #-24]
21f181f0:	e50b301c 	str	r3, [fp, #-28]
	if (argc > 1) {
21f181f4:	e51b3018 	ldr	r3, [fp, #-24]
21f181f8:	e3530001 	cmp	r3, #1	; 0x1
21f181fc:	da000009 	ble	21f18228 <do_mem_base+0x54>
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
21f18200:	e51b301c 	ldr	r3, [fp, #-28]
21f18204:	e2833004 	add	r3, r3, #4	; 0x4
21f18208:	e5933000 	ldr	r3, [r3]
21f1820c:	e1a00003 	mov	r0, r3
21f18210:	e3a01000 	mov	r1, #0	; 0x0
21f18214:	e3a02010 	mov	r2, #16	; 0x10
21f18218:	eb002cea 	bl	21f235c8 <simple_strtoul>
21f1821c:	e1a02000 	mov	r2, r0
21f18220:	e59f3024 	ldr	r3, [pc, #36]	; 21f1824c <.text+0x1824c>
21f18224:	e5832000 	str	r2, [r3]
	}
	/* Print the current base address.
	*/
	printf("Base Address: 0x%08lx\n", base_address);
21f18228:	e59f301c 	ldr	r3, [pc, #28]	; 21f1824c <.text+0x1824c>
21f1822c:	e5933000 	ldr	r3, [r3]
21f18230:	e59f0018 	ldr	r0, [pc, #24]	; 21f18250 <.text+0x18250>
21f18234:	e1a01003 	mov	r1, r3
21f18238:	eb000e13 	bl	21f1ba8c <printf>
	return 0;
21f1823c:	e3a03000 	mov	r3, #0	; 0x0
}
21f18240:	e1a00003 	mov	r0, r3
21f18244:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f18248:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1824c:	21f6773c 	mvncss	r7, ip, lsr r7
21f18250:	21f312f0 	ldrcssh	r1, [r3, #32]!

21f18254 <do_mem_loop>:

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f18254:	e1a0c00d 	mov	ip, sp
21f18258:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1825c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f18260:	e24dd034 	sub	sp, sp, #52	; 0x34
21f18264:	e50b0030 	str	r0, [fp, #-48]
21f18268:	e50b1034 	str	r1, [fp, #-52]
21f1826c:	e50b2038 	str	r2, [fp, #-56]
21f18270:	e50b303c 	str	r3, [fp, #-60]
	ulong	addr, length, i, junk;
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3) {
21f18274:	e51b3038 	ldr	r3, [fp, #-56]
21f18278:	e3530002 	cmp	r3, #2	; 0x2
21f1827c:	ca000007 	bgt	21f182a0 <do_mem_loop+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f18280:	e51b3030 	ldr	r3, [fp, #-48]
21f18284:	e5933010 	ldr	r3, [r3, #16]
21f18288:	e59f0210 	ldr	r0, [pc, #528]	; 21f184a0 <.text+0x184a0>
21f1828c:	e1a01003 	mov	r1, r3
21f18290:	eb000dfd 	bl	21f1ba8c <printf>
		return 1;
21f18294:	e3a03001 	mov	r3, #1	; 0x1
21f18298:	e50b3040 	str	r3, [fp, #-64]
21f1829c:	ea00007b 	b	21f18490 <do_mem_loop+0x23c>
	}

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
21f182a0:	e51b303c 	ldr	r3, [fp, #-60]
21f182a4:	e5933000 	ldr	r3, [r3]
21f182a8:	e1a00003 	mov	r0, r3
21f182ac:	e3a01004 	mov	r1, #4	; 0x4
21f182b0:	ebfffb96 	bl	21f17110 <cmd_get_data_size>
21f182b4:	e1a03000 	mov	r3, r0
21f182b8:	e50b301c 	str	r3, [fp, #-28]
21f182bc:	e51b301c 	ldr	r3, [fp, #-28]
21f182c0:	e3530000 	cmp	r3, #0	; 0x0
21f182c4:	aa000002 	bge	21f182d4 <do_mem_loop+0x80>
		return 1;
21f182c8:	e3a03001 	mov	r3, #1	; 0x1
21f182cc:	e50b3040 	str	r3, [fp, #-64]
21f182d0:	ea00006e 	b	21f18490 <do_mem_loop+0x23c>

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
21f182d4:	e51b303c 	ldr	r3, [fp, #-60]
21f182d8:	e2833004 	add	r3, r3, #4	; 0x4
21f182dc:	e5933000 	ldr	r3, [r3]
21f182e0:	e1a00003 	mov	r0, r3
21f182e4:	e3a01000 	mov	r1, #0	; 0x0
21f182e8:	e3a02010 	mov	r2, #16	; 0x10
21f182ec:	eb002cb5 	bl	21f235c8 <simple_strtoul>
21f182f0:	e1a03000 	mov	r3, r0
21f182f4:	e50b302c 	str	r3, [fp, #-44]

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
21f182f8:	e51b303c 	ldr	r3, [fp, #-60]
21f182fc:	e2833008 	add	r3, r3, #8	; 0x8
21f18300:	e5933000 	ldr	r3, [r3]
21f18304:	e1a00003 	mov	r0, r3
21f18308:	e3a01000 	mov	r1, #0	; 0x0
21f1830c:	e3a02010 	mov	r2, #16	; 0x10
21f18310:	eb002cac 	bl	21f235c8 <simple_strtoul>
21f18314:	e1a03000 	mov	r3, r0
21f18318:	e50b3028 	str	r3, [fp, #-40]

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
21f1831c:	e51b3028 	ldr	r3, [fp, #-40]
21f18320:	e3530001 	cmp	r3, #1	; 0x1
21f18324:	1a00001a 	bne	21f18394 <do_mem_loop+0x140>
		if (size == 4) {
21f18328:	e51b301c 	ldr	r3, [fp, #-28]
21f1832c:	e3530004 	cmp	r3, #4	; 0x4
21f18330:	1a000005 	bne	21f1834c <do_mem_loop+0xf8>
			longp = (uint *)addr;
21f18334:	e51b302c 	ldr	r3, [fp, #-44]
21f18338:	e50b3018 	str	r3, [fp, #-24]
			for (;;)
				i = *longp;
21f1833c:	e51b3018 	ldr	r3, [fp, #-24]
21f18340:	e5933000 	ldr	r3, [r3]
21f18344:	e50b3024 	str	r3, [fp, #-36]
21f18348:	eafffffb 	b	21f1833c <do_mem_loop+0xe8>
		}
		if (size == 2) {
21f1834c:	e51b301c 	ldr	r3, [fp, #-28]
21f18350:	e3530002 	cmp	r3, #2	; 0x2
21f18354:	1a000007 	bne	21f18378 <do_mem_loop+0x124>
			shortp = (ushort *)addr;
21f18358:	e51b302c 	ldr	r3, [fp, #-44]
21f1835c:	e50b3014 	str	r3, [fp, #-20]
			for (;;)
				i = *shortp;
21f18360:	e51b3014 	ldr	r3, [fp, #-20]
21f18364:	e1d330b0 	ldrh	r3, [r3]
21f18368:	e1a03803 	mov	r3, r3, lsl #16
21f1836c:	e1a03823 	mov	r3, r3, lsr #16
21f18370:	e50b3024 	str	r3, [fp, #-36]
21f18374:	eafffff9 	b	21f18360 <do_mem_loop+0x10c>
		}
		cp = (u_char *)addr;
21f18378:	e51b302c 	ldr	r3, [fp, #-44]
21f1837c:	e50b3010 	str	r3, [fp, #-16]
		for (;;)
			i = *cp;
21f18380:	e51b3010 	ldr	r3, [fp, #-16]
21f18384:	e5d33000 	ldrb	r3, [r3]
21f18388:	e20330ff 	and	r3, r3, #255	; 0xff
21f1838c:	e50b3024 	str	r3, [fp, #-36]
21f18390:	eafffffa 	b	21f18380 <do_mem_loop+0x12c>
	}

	if (size == 4) {
21f18394:	e51b301c 	ldr	r3, [fp, #-28]
21f18398:	e3530004 	cmp	r3, #4	; 0x4
21f1839c:	1a000011 	bne	21f183e8 <do_mem_loop+0x194>
		for (;;) {
			longp = (uint *)addr;
21f183a0:	e51b302c 	ldr	r3, [fp, #-44]
21f183a4:	e50b3018 	str	r3, [fp, #-24]
			i = length;
21f183a8:	e51b3028 	ldr	r3, [fp, #-40]
21f183ac:	e50b3024 	str	r3, [fp, #-36]
			while (i-- > 0)
21f183b0:	ea000005 	b	21f183cc <do_mem_loop+0x178>
				junk = *longp++;
21f183b4:	e51b3018 	ldr	r3, [fp, #-24]
21f183b8:	e5933000 	ldr	r3, [r3]
21f183bc:	e50b3020 	str	r3, [fp, #-32]
21f183c0:	e51b3018 	ldr	r3, [fp, #-24]
21f183c4:	e2833004 	add	r3, r3, #4	; 0x4
21f183c8:	e50b3018 	str	r3, [fp, #-24]
21f183cc:	e51b3024 	ldr	r3, [fp, #-36]
21f183d0:	e2433001 	sub	r3, r3, #1	; 0x1
21f183d4:	e50b3024 	str	r3, [fp, #-36]
21f183d8:	e51b3024 	ldr	r3, [fp, #-36]
21f183dc:	e3730001 	cmn	r3, #1	; 0x1
21f183e0:	1afffff3 	bne	21f183b4 <do_mem_loop+0x160>
21f183e4:	eaffffed 	b	21f183a0 <do_mem_loop+0x14c>
		}
	}
	if (size == 2) {
21f183e8:	e51b301c 	ldr	r3, [fp, #-28]
21f183ec:	e3530002 	cmp	r3, #2	; 0x2
21f183f0:	1a000013 	bne	21f18444 <do_mem_loop+0x1f0>
		for (;;) {
			shortp = (ushort *)addr;
21f183f4:	e51b302c 	ldr	r3, [fp, #-44]
21f183f8:	e50b3014 	str	r3, [fp, #-20]
			i = length;
21f183fc:	e51b3028 	ldr	r3, [fp, #-40]
21f18400:	e50b3024 	str	r3, [fp, #-36]
			while (i-- > 0)
21f18404:	ea000007 	b	21f18428 <do_mem_loop+0x1d4>
				junk = *shortp++;
21f18408:	e51b3014 	ldr	r3, [fp, #-20]
21f1840c:	e1d330b0 	ldrh	r3, [r3]
21f18410:	e1a03803 	mov	r3, r3, lsl #16
21f18414:	e1a03823 	mov	r3, r3, lsr #16
21f18418:	e50b3020 	str	r3, [fp, #-32]
21f1841c:	e51b3014 	ldr	r3, [fp, #-20]
21f18420:	e2833002 	add	r3, r3, #2	; 0x2
21f18424:	e50b3014 	str	r3, [fp, #-20]
21f18428:	e51b3024 	ldr	r3, [fp, #-36]
21f1842c:	e2433001 	sub	r3, r3, #1	; 0x1
21f18430:	e50b3024 	str	r3, [fp, #-36]
21f18434:	e51b3024 	ldr	r3, [fp, #-36]
21f18438:	e3730001 	cmn	r3, #1	; 0x1
21f1843c:	1afffff1 	bne	21f18408 <do_mem_loop+0x1b4>
21f18440:	eaffffeb 	b	21f183f4 <do_mem_loop+0x1a0>
		}
	}
	for (;;) {
		cp = (u_char *)addr;
21f18444:	e51b302c 	ldr	r3, [fp, #-44]
21f18448:	e50b3010 	str	r3, [fp, #-16]
		i = length;
21f1844c:	e51b3028 	ldr	r3, [fp, #-40]
21f18450:	e50b3024 	str	r3, [fp, #-36]
		while (i-- > 0)
21f18454:	ea000006 	b	21f18474 <do_mem_loop+0x220>
			junk = *cp++;
21f18458:	e51b3010 	ldr	r3, [fp, #-16]
21f1845c:	e5d33000 	ldrb	r3, [r3]
21f18460:	e20330ff 	and	r3, r3, #255	; 0xff
21f18464:	e50b3020 	str	r3, [fp, #-32]
21f18468:	e51b3010 	ldr	r3, [fp, #-16]
21f1846c:	e2833001 	add	r3, r3, #1	; 0x1
21f18470:	e50b3010 	str	r3, [fp, #-16]
21f18474:	e51b3024 	ldr	r3, [fp, #-36]
21f18478:	e2433001 	sub	r3, r3, #1	; 0x1
21f1847c:	e50b3024 	str	r3, [fp, #-36]
21f18480:	e51b3024 	ldr	r3, [fp, #-36]
21f18484:	e3730001 	cmn	r3, #1	; 0x1
21f18488:	1afffff2 	bne	21f18458 <do_mem_loop+0x204>
21f1848c:	eaffffec 	b	21f18444 <do_mem_loop+0x1f0>
21f18490:	e51b3040 	ldr	r3, [fp, #-64]
	}
}
21f18494:	e1a00003 	mov	r0, r3
21f18498:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1849c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f184a0:	21f310c0 	mvncss	r1, r0, asr #1

21f184a4 <do_mem_mtest>:

#ifdef CONFIG_LOOPW
int do_mem_loopw (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	ulong	addr, length, i, data;
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 4) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);

	/* data to write */
	data = simple_strtoul(argv[3], NULL, 16);

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
		if (size == 4) {
			longp = (uint *)addr;
			for (;;)
				*longp = data;
					}
		if (size == 2) {
			shortp = (ushort *)addr;
			for (;;)
				*shortp = data;
		}
		cp = (u_char *)addr;
		for (;;)
			*cp = data;
	}

	if (size == 4) {
		for (;;) {
			longp = (uint *)addr;
			i = length;
			while (i-- > 0)
				*longp++ = data;
		}
	}
	if (size == 2) {
		for (;;) {
			shortp = (ushort *)addr;
			i = length;
			while (i-- > 0)
				*shortp++ = data;
		}
	}
	for (;;) {
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
			*cp++ = data;
	}
}
#endif /* CONFIG_LOOPW */

/*
 * Perform a memory test. A more complete alternative test can be
 * configured using CFG_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 */
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f184a4:	e1a0c00d 	mov	ip, sp
21f184a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f184ac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f184b0:	e24dd034 	sub	sp, sp, #52	; 0x34
21f184b4:	e50b0030 	str	r0, [fp, #-48]
21f184b8:	e50b1034 	str	r1, [fp, #-52]
21f184bc:	e50b2038 	str	r2, [fp, #-56]
21f184c0:	e50b303c 	str	r3, [fp, #-60]
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;

#if defined(CFG_ALT_MEMTEST)
	vu_long	addr_mask;
	vu_long	offset;
	vu_long	test_offset;
	vu_long	pattern;
	vu_long	temp;
	vu_long	anti_pattern;
	vu_long	num_words;
#if defined(CFG_MEMTEST_SCRATCH)
	vu_long *dummy = (vu_long*)CFG_MEMTEST_SCRATCH;
#else
	vu_long *dummy = 0;	/* yes, this is address 0x0, not NULL */
#endif
	int	j;
	int iterations = 1;

	static const ulong bitpattern[] = {
		0x00000001,	/* single bit */
		0x00000003,	/* two adjacent bits */
		0x00000007,	/* three adjacent bits */
		0x0000000F,	/* four adjacent bits */
		0x00000005,	/* two non-adjacent bits */
		0x00000015,	/* three non-adjacent bits */
		0x00000055,	/* four non-adjacent bits */
		0xaaaaaaaa,	/* alternating 1/0 */
	};
#else
	ulong	incr;
	ulong	pattern;
	int     rcode = 0;
21f184c4:	e3a03000 	mov	r3, #0	; 0x0
21f184c8:	e50b3010 	str	r3, [fp, #-16]
#endif

	if (argc > 1) {
21f184cc:	e51b3038 	ldr	r3, [fp, #-56]
21f184d0:	e3530001 	cmp	r3, #1	; 0x1
21f184d4:	da000009 	ble	21f18500 <do_mem_mtest+0x5c>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
21f184d8:	e51b303c 	ldr	r3, [fp, #-60]
21f184dc:	e2833004 	add	r3, r3, #4	; 0x4
21f184e0:	e5933000 	ldr	r3, [r3]
21f184e4:	e1a00003 	mov	r0, r3
21f184e8:	e3a01000 	mov	r1, #0	; 0x0
21f184ec:	e3a02010 	mov	r2, #16	; 0x10
21f184f0:	eb002c34 	bl	21f235c8 <simple_strtoul>
21f184f4:	e1a03000 	mov	r3, r0
21f184f8:	e50b3028 	str	r3, [fp, #-40]
21f184fc:	ea000001 	b	21f18508 <do_mem_mtest+0x64>
	} else {
		start = (ulong *)CFG_MEMTEST_START;
21f18500:	e3a03202 	mov	r3, #536870912	; 0x20000000
21f18504:	e50b3028 	str	r3, [fp, #-40]
	}

	if (argc > 2) {
21f18508:	e51b3038 	ldr	r3, [fp, #-56]
21f1850c:	e3530002 	cmp	r3, #2	; 0x2
21f18510:	da000009 	ble	21f1853c <do_mem_mtest+0x98>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
21f18514:	e51b303c 	ldr	r3, [fp, #-60]
21f18518:	e2833008 	add	r3, r3, #8	; 0x8
21f1851c:	e5933000 	ldr	r3, [r3]
21f18520:	e1a00003 	mov	r0, r3
21f18524:	e3a01000 	mov	r1, #0	; 0x0
21f18528:	e3a02010 	mov	r2, #16	; 0x10
21f1852c:	eb002c25 	bl	21f235c8 <simple_strtoul>
21f18530:	e1a03000 	mov	r3, r0
21f18534:	e50b3024 	str	r3, [fp, #-36]
21f18538:	ea000002 	b	21f18548 <do_mem_mtest+0xa4>
	} else {
		end = (ulong *)(CFG_MEMTEST_END);
21f1853c:	e3a03587 	mov	r3, #566231040	; 0x21c00000
21f18540:	e283370f 	add	r3, r3, #3932160	; 0x3c0000
21f18544:	e50b3024 	str	r3, [fp, #-36]
	}

	if (argc > 3) {
21f18548:	e51b3038 	ldr	r3, [fp, #-56]
21f1854c:	e3530003 	cmp	r3, #3	; 0x3
21f18550:	da000009 	ble	21f1857c <do_mem_mtest+0xd8>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
21f18554:	e51b303c 	ldr	r3, [fp, #-60]
21f18558:	e283300c 	add	r3, r3, #12	; 0xc
21f1855c:	e5933000 	ldr	r3, [r3]
21f18560:	e1a00003 	mov	r0, r3
21f18564:	e3a01000 	mov	r1, #0	; 0x0
21f18568:	e3a02010 	mov	r2, #16	; 0x10
21f1856c:	eb002c15 	bl	21f235c8 <simple_strtoul>
21f18570:	e1a03000 	mov	r3, r0
21f18574:	e50b3014 	str	r3, [fp, #-20]
21f18578:	ea000001 	b	21f18584 <do_mem_mtest+0xe0>
	} else {
		pattern = 0;
21f1857c:	e3a03000 	mov	r3, #0	; 0x0
21f18580:	e50b3014 	str	r3, [fp, #-20]
	}

#if defined(CFG_ALT_MEMTEST)
	printf ("Testing %08x ... %08x:\n", (uint)start, (uint)end);
	PRINTF("%s:%d: start 0x%p end 0x%p\n",
		__FUNCTION__, __LINE__, start, end);

	for (;;) {
		if (ctrlc()) {
			putc ('\n');
			return 1;
		}

		printf("Iteration: %6d\r", iterations);
		PRINTF("Iteration: %6d\n", iterations);
		iterations++;

		/*
		 * Data line test: write a pattern to the first
		 * location, write the 1's complement to a 'parking'
		 * address (changes the state of the data bus so a
		 * floating bus doen't give a false OK), and then
		 * read the value back. Note that we read it back
		 * into a variable because the next time we read it,
		 * it might be right (been there, tough to explain to
		 * the quality guys why it prints a failure when the
		 * "is" and "should be" are obviously the same in the
		 * error message).
		 *
		 * Rather than exhaustively testing, we test some
		 * patterns by shifting '1' bits through a field of
		 * '0's and '0' bits through a field of '1's (i.e.
		 * pattern and ~pattern).
		 */
		addr = start;
		for (j = 0; j < sizeof(bitpattern)/sizeof(bitpattern[0]); j++) {
		    val = bitpattern[j];
		    for(; val != 0; val <<= 1) {
			*addr  = val;
			*dummy  = ~val; /* clear the test data off of the bus */
			readback = *addr;
			if(readback != val) {
			     printf ("FAILURE (data line): "
				"expected %08lx, actual %08lx\n",
					  val, readback);
			}
			*addr  = ~val;
			*dummy  = val;
			readback = *addr;
			if(readback != ~val) {
			    printf ("FAILURE (data line): "
				"Is %08lx, should be %08lx\n",
					readback, ~val);
			}
		    }
		}

		/*
		 * Based on code whose Original Author and Copyright
		 * information follows: Copyright (c) 1998 by Michael
		 * Barr. This software is placed into the public
		 * domain and may be used for any purpose. However,
		 * this notice must not be changed or removed and no
		 * warranty is either expressed or implied by its
		 * publication or distribution.
		 */

		/*
		 * Address line test
		 *
		 * Description: Test the address bus wiring in a
		 *              memory region by performing a walking
		 *              1's test on the relevant bits of the
		 *              address and checking for aliasing.
		 *              This test will find single-bit
		 *              address failures such as stuck -high,
		 *              stuck-low, and shorted pins. The base
		 *              address and size of the region are
		 *              selected by the caller.
		 *
		 * Notes:	For best results, the selected base
		 *              address should have enough LSB 0's to
		 *              guarantee single address bit changes.
		 *              For example, to test a 64-Kbyte
		 *              region, select a base address on a
		 *              64-Kbyte boundary. Also, select the
		 *              region size as a power-of-two if at
		 *              all possible.
		 *
		 * Returns:     0 if the test succeeds, 1 if the test fails.
		 *
		 * ## NOTE ##	Be sure to specify start and end
		 *              addresses such that addr_mask has
		 *              lots of bits set. For example an
		 *              address range of 01000000 02000000 is
		 *              bad while a range of 01000000
		 *              01ffffff is perfect.
		 */
		addr_mask = ((ulong)end - (ulong)start)/sizeof(vu_long);
		pattern = (vu_long) 0xaaaaaaaa;
		anti_pattern = (vu_long) 0x55555555;

		PRINTF("%s:%d: addr mask = 0x%.8lx\n",
			__FUNCTION__, __LINE__,
			addr_mask);
		/*
		 * Write the default pattern at each of the
		 * power-of-two offsets.
		 */
		for (offset = 1; (offset & addr_mask) != 0; offset <<= 1) {
			start[offset] = pattern;
		}

		/*
		 * Check for address bits stuck high.
		 */
		test_offset = 0;
		start[test_offset] = anti_pattern;

		for (offset = 1; (offset & addr_mask) != 0; offset <<= 1) {
		    temp = start[offset];
		    if (temp != pattern) {
			printf ("\nFAILURE: Address bit stuck high @ 0x%.8lx:"
				" expected 0x%.8lx, actual 0x%.8lx\n",
				(ulong)&start[offset], pattern, temp);
			return 1;
		    }
		}
		start[test_offset] = pattern;

		/*
		 * Check for addr bits stuck low or shorted.
		 */
		for (test_offset = 1; (test_offset & addr_mask) != 0; test_offset <<= 1) {
		    start[test_offset] = anti_pattern;

		    for (offset = 1; (offset & addr_mask) != 0; offset <<= 1) {
			temp = start[offset];
			if ((temp != pattern) && (offset != test_offset)) {
			    printf ("\nFAILURE: Address bit stuck low or shorted @"
				" 0x%.8lx: expected 0x%.8lx, actual 0x%.8lx\n",
				(ulong)&start[offset], pattern, temp);
			    return 1;
			}
		    }
		    start[test_offset] = pattern;
		}

		/*
		 * Description: Test the integrity of a physical
		 *		memory device by performing an
		 *		increment/decrement test over the
		 *		entire region. In the process every
		 *		storage bit in the device is tested
		 *		as a zero and a one. The base address
		 *		and the size of the region are
		 *		selected by the caller.
		 *
		 * Returns:     0 if the test succeeds, 1 if the test fails.
		 */
		num_words = ((ulong)end - (ulong)start)/sizeof(vu_long) + 1;

		/*
		 * Fill memory with a known pattern.
		 */
		for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
			start[offset] = pattern;
		}

		/*
		 * Check each location and invert it for the second pass.
		 */
		for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
		    temp = start[offset];
		    if (temp != pattern) {
			printf ("\nFAILURE (read/write) @ 0x%.8lx:"
				" expected 0x%.8lx, actual 0x%.8lx)\n",
				(ulong)&start[offset], pattern, temp);
			return 1;
		    }

		    anti_pattern = ~pattern;
		    start[offset] = anti_pattern;
		}

		/*
		 * Check each location for the inverted pattern and zero it.
		 */
		for (pattern = 1, offset = 0; offset < num_words; pattern++, offset++) {
		    anti_pattern = ~pattern;
		    temp = start[offset];
		    if (temp != anti_pattern) {
			printf ("\nFAILURE (read/write): @ 0x%.8lx:"
				" expected 0x%.8lx, actual 0x%.8lx)\n",
				(ulong)&start[offset], anti_pattern, temp);
			return 1;
		    }
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
21f18584:	e3a03001 	mov	r3, #1	; 0x1
21f18588:	e50b3018 	str	r3, [fp, #-24]
	for (;;) {
		if (ctrlc()) {
21f1858c:	eb000d67 	bl	21f1bb30 <ctrlc>
21f18590:	e1a03000 	mov	r3, r0
21f18594:	e3530000 	cmp	r3, #0	; 0x0
21f18598:	0a000004 	beq	21f185b0 <do_mem_mtest+0x10c>
			putc ('\n');
21f1859c:	e3a0000a 	mov	r0, #10	; 0xa
21f185a0:	eb000d10 	bl	21f1b9e8 <putc>
			return 1;
21f185a4:	e3a03001 	mov	r3, #1	; 0x1
21f185a8:	e50b3040 	str	r3, [fp, #-64]
21f185ac:	ea000045 	b	21f186c8 <do_mem_mtest+0x224>
		}

		printf ("\rPattern %08lX  Writing..."
21f185b0:	e59f011c 	ldr	r0, [pc, #284]	; 21f186d4 <.text+0x186d4>
21f185b4:	e51b1014 	ldr	r1, [fp, #-20]
21f185b8:	e59f2118 	ldr	r2, [pc, #280]	; 21f186d8 <.text+0x186d8>
21f185bc:	eb000d32 	bl	21f1ba8c <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
21f185c0:	e51b3028 	ldr	r3, [fp, #-40]
21f185c4:	e50b302c 	str	r3, [fp, #-44]
21f185c8:	e51b3014 	ldr	r3, [fp, #-20]
21f185cc:	e50b3020 	str	r3, [fp, #-32]
21f185d0:	ea000009 	b	21f185fc <do_mem_mtest+0x158>
			*addr = val;
21f185d4:	e51b202c 	ldr	r2, [fp, #-44]
21f185d8:	e51b3020 	ldr	r3, [fp, #-32]
21f185dc:	e5823000 	str	r3, [r2]
			val  += incr;
21f185e0:	e51b2020 	ldr	r2, [fp, #-32]
21f185e4:	e51b3018 	ldr	r3, [fp, #-24]
21f185e8:	e0823003 	add	r3, r2, r3
21f185ec:	e50b3020 	str	r3, [fp, #-32]
21f185f0:	e51b302c 	ldr	r3, [fp, #-44]
21f185f4:	e2833004 	add	r3, r3, #4	; 0x4
21f185f8:	e50b302c 	str	r3, [fp, #-44]
21f185fc:	e51b202c 	ldr	r2, [fp, #-44]
21f18600:	e51b3024 	ldr	r3, [fp, #-36]
21f18604:	e1520003 	cmp	r2, r3
21f18608:	3afffff1 	bcc	21f185d4 <do_mem_mtest+0x130>
		}

		puts ("Reading...");
21f1860c:	e59f00c8 	ldr	r0, [pc, #200]	; 21f186dc <.text+0x186dc>
21f18610:	eb000d0a 	bl	21f1ba40 <puts>

		for (addr=start,val=pattern; addr<end; addr++) {
21f18614:	e51b3028 	ldr	r3, [fp, #-40]
21f18618:	e50b302c 	str	r3, [fp, #-44]
21f1861c:	e51b3014 	ldr	r3, [fp, #-20]
21f18620:	e50b3020 	str	r3, [fp, #-32]
21f18624:	ea000015 	b	21f18680 <do_mem_mtest+0x1dc>
			readback = *addr;
21f18628:	e51b302c 	ldr	r3, [fp, #-44]
21f1862c:	e5933000 	ldr	r3, [r3]
21f18630:	e50b301c 	str	r3, [fp, #-28]
			if (readback != val) {
21f18634:	e51b201c 	ldr	r2, [fp, #-28]
21f18638:	e51b3020 	ldr	r3, [fp, #-32]
21f1863c:	e1520003 	cmp	r2, r3
21f18640:	0a000007 	beq	21f18664 <do_mem_mtest+0x1c0>
				printf ("\nMem error @ 0x%08X: "
21f18644:	e51b302c 	ldr	r3, [fp, #-44]
21f18648:	e59f0090 	ldr	r0, [pc, #144]	; 21f186e0 <.text+0x186e0>
21f1864c:	e1a01003 	mov	r1, r3
21f18650:	e51b201c 	ldr	r2, [fp, #-28]
21f18654:	e51b3020 	ldr	r3, [fp, #-32]
21f18658:	eb000d0b 	bl	21f1ba8c <printf>
					"found %08lX, expected %08lX\n",
					(uint)addr, readback, val);
				rcode = 1;
21f1865c:	e3a03001 	mov	r3, #1	; 0x1
21f18660:	e50b3010 	str	r3, [fp, #-16]
			}
			val += incr;
21f18664:	e51b2020 	ldr	r2, [fp, #-32]
21f18668:	e51b3018 	ldr	r3, [fp, #-24]
21f1866c:	e0823003 	add	r3, r2, r3
21f18670:	e50b3020 	str	r3, [fp, #-32]
21f18674:	e51b302c 	ldr	r3, [fp, #-44]
21f18678:	e2833004 	add	r3, r3, #4	; 0x4
21f1867c:	e50b302c 	str	r3, [fp, #-44]
21f18680:	e51b202c 	ldr	r2, [fp, #-44]
21f18684:	e51b3024 	ldr	r3, [fp, #-36]
21f18688:	e1520003 	cmp	r2, r3
21f1868c:	3affffe5 	bcc	21f18628 <do_mem_mtest+0x184>
		}

		/*
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
21f18690:	e51b3014 	ldr	r3, [fp, #-20]
21f18694:	e3530000 	cmp	r3, #0	; 0x0
21f18698:	aa000003 	bge	21f186ac <do_mem_mtest+0x208>
			pattern = -pattern;	/* complement & increment */
21f1869c:	e51b3014 	ldr	r3, [fp, #-20]
21f186a0:	e2633000 	rsb	r3, r3, #0	; 0x0
21f186a4:	e50b3014 	str	r3, [fp, #-20]
21f186a8:	ea000002 	b	21f186b8 <do_mem_mtest+0x214>
		}
		else {
			pattern = ~pattern;
21f186ac:	e51b3014 	ldr	r3, [fp, #-20]
21f186b0:	e1e03003 	mvn	r3, r3
21f186b4:	e50b3014 	str	r3, [fp, #-20]
		}
		incr = -incr;
21f186b8:	e51b3018 	ldr	r3, [fp, #-24]
21f186bc:	e2633000 	rsb	r3, r3, #0	; 0x0
21f186c0:	e50b3018 	str	r3, [fp, #-24]
	}
21f186c4:	eaffffb0 	b	21f1858c <do_mem_mtest+0xe8>
	return rcode;
#endif
}
21f186c8:	e51b0040 	ldr	r0, [fp, #-64]
21f186cc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f186d0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f186d4:	21f31308 	mvncss	r1, r8, lsl #6
21f186d8:	21f311f8 	ldrcssh	r1, [r3, #24]!
21f186dc:	21f31334 	mvncss	r1, r4, lsr r3
21f186e0:	21f31340 	mvncss	r1, r0, asr #6

21f186e4 <mod_mem>:


/* Modify memory.
 *
 * Syntax:
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char *argv[])
{
21f186e4:	e1a0c00d 	mov	ip, sp
21f186e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f186ec:	e24cb004 	sub	fp, ip, #4	; 0x4
21f186f0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f186f4:	e50b0024 	str	r0, [fp, #-36]
21f186f8:	e50b1028 	str	r1, [fp, #-40]
21f186fc:	e50b202c 	str	r2, [fp, #-44]
21f18700:	e50b3030 	str	r3, [fp, #-48]
	ulong	addr, i;
	int	nbytes, size;
	extern char console_buffer[];

	if (argc != 2) {
21f18704:	e51b3030 	ldr	r3, [fp, #-48]
21f18708:	e3530002 	cmp	r3, #2	; 0x2
21f1870c:	0a000007 	beq	21f18730 <mod_mem+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f18710:	e51b3024 	ldr	r3, [fp, #-36]
21f18714:	e5933010 	ldr	r3, [r3, #16]
21f18718:	e59f02a4 	ldr	r0, [pc, #676]	; 21f189c4 <.text+0x189c4>
21f1871c:	e1a01003 	mov	r1, r3
21f18720:	eb000cd9 	bl	21f1ba8c <printf>
		return 1;
21f18724:	e3a02001 	mov	r2, #1	; 0x1
21f18728:	e50b2038 	str	r2, [fp, #-56]
21f1872c:	ea0000a0 	b	21f189b4 <mod_mem+0x2d0>
	}

#ifdef CONFIG_BOOT_RETRY_TIME
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
21f18730:	e59f3290 	ldr	r3, [pc, #656]	; 21f189c8 <.text+0x189c8>
21f18734:	e5933000 	ldr	r3, [r3]
21f18738:	e50b301c 	str	r3, [fp, #-28]
	size = mm_last_size;
21f1873c:	e59f3288 	ldr	r3, [pc, #648]	; 21f189cc <.text+0x189cc>
21f18740:	e5933000 	ldr	r3, [r3]
21f18744:	e50b3010 	str	r3, [fp, #-16]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
21f18748:	e51b302c 	ldr	r3, [fp, #-44]
21f1874c:	e2233001 	eor	r3, r3, #1	; 0x1
21f18750:	e2033001 	and	r3, r3, #1	; 0x1
21f18754:	e20330ff 	and	r3, r3, #255	; 0xff
21f18758:	e3530000 	cmp	r3, #0	; 0x0
21f1875c:	0a00001a 	beq	21f187cc <mod_mem+0xe8>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
21f18760:	e59b3004 	ldr	r3, [fp, #4]
21f18764:	e5933000 	ldr	r3, [r3]
21f18768:	e1a00003 	mov	r0, r3
21f1876c:	e3a01004 	mov	r1, #4	; 0x4
21f18770:	ebfffa66 	bl	21f17110 <cmd_get_data_size>
21f18774:	e1a03000 	mov	r3, r0
21f18778:	e50b3010 	str	r3, [fp, #-16]
21f1877c:	e51b3010 	ldr	r3, [fp, #-16]
21f18780:	e3530000 	cmp	r3, #0	; 0x0
21f18784:	aa000002 	bge	21f18794 <mod_mem+0xb0>
			return 1;
21f18788:	e3a03001 	mov	r3, #1	; 0x1
21f1878c:	e50b3038 	str	r3, [fp, #-56]
21f18790:	ea000087 	b	21f189b4 <mod_mem+0x2d0>

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
21f18794:	e59b3004 	ldr	r3, [fp, #4]
21f18798:	e2833004 	add	r3, r3, #4	; 0x4
21f1879c:	e5933000 	ldr	r3, [r3]
21f187a0:	e1a00003 	mov	r0, r3
21f187a4:	e3a01000 	mov	r1, #0	; 0x0
21f187a8:	e3a02010 	mov	r2, #16	; 0x10
21f187ac:	eb002b85 	bl	21f235c8 <simple_strtoul>
21f187b0:	e1a03000 	mov	r3, r0
21f187b4:	e50b301c 	str	r3, [fp, #-28]
		addr += base_address;
21f187b8:	e59f3210 	ldr	r3, [pc, #528]	; 21f189d0 <.text+0x189d0>
21f187bc:	e5932000 	ldr	r2, [r3]
21f187c0:	e51b301c 	ldr	r3, [fp, #-28]
21f187c4:	e0833002 	add	r3, r3, r2
21f187c8:	e50b301c 	str	r3, [fp, #-28]
	}

#ifdef CONFIG_HAS_DATAFLASH
	if (addr_dataflash(addr)){
21f187cc:	e51b001c 	ldr	r0, [fp, #-28]
21f187d0:	ebffdf4f 	bl	21f10514 <addr_dataflash>
21f187d4:	e1a03000 	mov	r3, r0
21f187d8:	e3530000 	cmp	r3, #0	; 0x0
21f187dc:	0a000004 	beq	21f187f4 <mod_mem+0x110>
		puts ("Can't modify DataFlash in place. Use cp instead.\n\r");
21f187e0:	e59f01ec 	ldr	r0, [pc, #492]	; 21f189d4 <.text+0x189d4>
21f187e4:	eb000c95 	bl	21f1ba40 <puts>
		return 0;
21f187e8:	e3a02000 	mov	r2, #0	; 0x0
21f187ec:	e50b2038 	str	r2, [fp, #-56]
21f187f0:	ea00006f 	b	21f189b4 <mod_mem+0x2d0>
	}
#endif

	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
21f187f4:	e59f01dc 	ldr	r0, [pc, #476]	; 21f189d8 <.text+0x189d8>
21f187f8:	e51b101c 	ldr	r1, [fp, #-28]
21f187fc:	eb000ca2 	bl	21f1ba8c <printf>
		if (size == 4)
21f18800:	e51b3010 	ldr	r3, [fp, #-16]
21f18804:	e3530004 	cmp	r3, #4	; 0x4
21f18808:	1a000005 	bne	21f18824 <mod_mem+0x140>
			printf(" %08x", *((uint   *)addr));
21f1880c:	e51b301c 	ldr	r3, [fp, #-28]
21f18810:	e5933000 	ldr	r3, [r3]
21f18814:	e59f01c0 	ldr	r0, [pc, #448]	; 21f189dc <.text+0x189dc>
21f18818:	e1a01003 	mov	r1, r3
21f1881c:	eb000c9a 	bl	21f1ba8c <printf>
21f18820:	ea00000d 	b	21f1885c <mod_mem+0x178>
		else if (size == 2)
21f18824:	e51b3010 	ldr	r3, [fp, #-16]
21f18828:	e3530002 	cmp	r3, #2	; 0x2
21f1882c:	1a000005 	bne	21f18848 <mod_mem+0x164>
			printf(" %04x", *((ushort *)addr));
21f18830:	e51b301c 	ldr	r3, [fp, #-28]
21f18834:	e1d330b0 	ldrh	r3, [r3]
21f18838:	e59f01a0 	ldr	r0, [pc, #416]	; 21f189e0 <.text+0x189e0>
21f1883c:	e1a01003 	mov	r1, r3
21f18840:	eb000c91 	bl	21f1ba8c <printf>
21f18844:	ea000004 	b	21f1885c <mod_mem+0x178>
		else
			printf(" %02x", *((u_char *)addr));
21f18848:	e51b301c 	ldr	r3, [fp, #-28]
21f1884c:	e5d33000 	ldrb	r3, [r3]
21f18850:	e59f018c 	ldr	r0, [pc, #396]	; 21f189e4 <.text+0x189e4>
21f18854:	e1a01003 	mov	r1, r3
21f18858:	eb000c8b 	bl	21f1ba8c <printf>

		nbytes = readline (" ? ");
21f1885c:	e59f0184 	ldr	r0, [pc, #388]	; 21f189e8 <.text+0x189e8>
21f18860:	ebffe1a3 	bl	21f10ef4 <readline>
21f18864:	e1a03000 	mov	r3, r0
21f18868:	e50b3014 	str	r3, [fp, #-20]
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
21f1886c:	e51b3014 	ldr	r3, [fp, #-20]
21f18870:	e3530000 	cmp	r3, #0	; 0x0
21f18874:	0a000006 	beq	21f18894 <mod_mem+0x1b0>
21f18878:	e51b3014 	ldr	r3, [fp, #-20]
21f1887c:	e3530001 	cmp	r3, #1	; 0x1
21f18880:	1a000016 	bne	21f188e0 <mod_mem+0x1fc>
21f18884:	e59f3160 	ldr	r3, [pc, #352]	; 21f189ec <.text+0x189ec>
21f18888:	e5d33000 	ldrb	r3, [r3]
21f1888c:	e353002d 	cmp	r3, #45	; 0x2d
21f18890:	1a000012 	bne	21f188e0 <mod_mem+0x1fc>
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
21f18894:	e51b3028 	ldr	r3, [fp, #-40]
21f18898:	e3530000 	cmp	r3, #0	; 0x0
21f1889c:	0a00000c 	beq	21f188d4 <mod_mem+0x1f0>
				addr += nbytes ? -size : size;
21f188a0:	e51b3014 	ldr	r3, [fp, #-20]
21f188a4:	e3530000 	cmp	r3, #0	; 0x0
21f188a8:	0a000003 	beq	21f188bc <mod_mem+0x1d8>
21f188ac:	e51b3010 	ldr	r3, [fp, #-16]
21f188b0:	e2633000 	rsb	r3, r3, #0	; 0x0
21f188b4:	e50b3034 	str	r3, [fp, #-52]
21f188b8:	ea000001 	b	21f188c4 <mod_mem+0x1e0>
21f188bc:	e51b3010 	ldr	r3, [fp, #-16]
21f188c0:	e50b3034 	str	r3, [fp, #-52]
21f188c4:	e51b301c 	ldr	r3, [fp, #-28]
21f188c8:	e51b2034 	ldr	r2, [fp, #-52]
21f188cc:	e0833002 	add	r3, r3, r2
21f188d0:	e50b301c 	str	r3, [fp, #-28]
			nbytes = 1;
21f188d4:	e3a03001 	mov	r3, #1	; 0x1
21f188d8:	e50b3014 	str	r3, [fp, #-20]
21f188dc:	ea000029 	b	21f18988 <mod_mem+0x2a4>
#ifdef CONFIG_BOOT_RETRY_TIME
			reset_cmd_timeout(); /* good enough to not time out */
#endif
		}
#ifdef CONFIG_BOOT_RETRY_TIME
		else if (nbytes == -2) {
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
21f188e0:	e24b3020 	sub	r3, fp, #32	; 0x20
21f188e4:	e59f0100 	ldr	r0, [pc, #256]	; 21f189ec <.text+0x189ec>
21f188e8:	e1a01003 	mov	r1, r3
21f188ec:	e3a02010 	mov	r2, #16	; 0x10
21f188f0:	eb002b34 	bl	21f235c8 <simple_strtoul>
21f188f4:	e1a03000 	mov	r3, r0
21f188f8:	e50b3018 	str	r3, [fp, #-24]
			nbytes = endp - console_buffer;
21f188fc:	e51b3020 	ldr	r3, [fp, #-32]
21f18900:	e1a02003 	mov	r2, r3
21f18904:	e59f30e0 	ldr	r3, [pc, #224]	; 21f189ec <.text+0x189ec>
21f18908:	e0633002 	rsb	r3, r3, r2
21f1890c:	e50b3014 	str	r3, [fp, #-20]
			if (nbytes) {
21f18910:	e51b3014 	ldr	r3, [fp, #-20]
21f18914:	e3530000 	cmp	r3, #0	; 0x0
21f18918:	0a00001a 	beq	21f18988 <mod_mem+0x2a4>
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
21f1891c:	e51b3010 	ldr	r3, [fp, #-16]
21f18920:	e3530004 	cmp	r3, #4	; 0x4
21f18924:	1a000003 	bne	21f18938 <mod_mem+0x254>
					*((uint   *)addr) = i;
21f18928:	e51b201c 	ldr	r2, [fp, #-28]
21f1892c:	e51b3018 	ldr	r3, [fp, #-24]
21f18930:	e5823000 	str	r3, [r2]
21f18934:	ea00000c 	b	21f1896c <mod_mem+0x288>
				else if (size == 2)
21f18938:	e51b3010 	ldr	r3, [fp, #-16]
21f1893c:	e3530002 	cmp	r3, #2	; 0x2
21f18940:	1a000005 	bne	21f1895c <mod_mem+0x278>
					*((ushort *)addr) = i;
21f18944:	e51b201c 	ldr	r2, [fp, #-28]
21f18948:	e51b3018 	ldr	r3, [fp, #-24]
21f1894c:	e1a03803 	mov	r3, r3, lsl #16
21f18950:	e1a03823 	mov	r3, r3, lsr #16
21f18954:	e1c230b0 	strh	r3, [r2]
21f18958:	ea000003 	b	21f1896c <mod_mem+0x288>
				else
					*((u_char *)addr) = i;
21f1895c:	e51b201c 	ldr	r2, [fp, #-28]
21f18960:	e51b3018 	ldr	r3, [fp, #-24]
21f18964:	e20330ff 	and	r3, r3, #255	; 0xff
21f18968:	e5c23000 	strb	r3, [r2]
				if (incrflag)
21f1896c:	e51b3028 	ldr	r3, [fp, #-40]
21f18970:	e3530000 	cmp	r3, #0	; 0x0
21f18974:	0a000003 	beq	21f18988 <mod_mem+0x2a4>
					addr += size;
21f18978:	e51b3010 	ldr	r3, [fp, #-16]
21f1897c:	e51b201c 	ldr	r2, [fp, #-28]
21f18980:	e0823003 	add	r3, r2, r3
21f18984:	e50b301c 	str	r3, [fp, #-28]
			}
		}
	} while (nbytes);
21f18988:	e51b3014 	ldr	r3, [fp, #-20]
21f1898c:	e3530000 	cmp	r3, #0	; 0x0
21f18990:	1affff97 	bne	21f187f4 <mod_mem+0x110>

	mm_last_addr = addr;
21f18994:	e59f202c 	ldr	r2, [pc, #44]	; 21f189c8 <.text+0x189c8>
21f18998:	e51b301c 	ldr	r3, [fp, #-28]
21f1899c:	e5823000 	str	r3, [r2]
	mm_last_size = size;
21f189a0:	e51b2010 	ldr	r2, [fp, #-16]
21f189a4:	e59f3020 	ldr	r3, [pc, #32]	; 21f189cc <.text+0x189cc>
21f189a8:	e5832000 	str	r2, [r3]
	return 0;
21f189ac:	e3a03000 	mov	r3, #0	; 0x0
21f189b0:	e50b3038 	str	r3, [fp, #-56]
21f189b4:	e51b3038 	ldr	r3, [fp, #-56]
}
21f189b8:	e1a00003 	mov	r0, r3
21f189bc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f189c0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f189c4:	21f310c0 	mvncss	r1, r0, asr #1
21f189c8:	21f67734 	mvncss	r7, r4, lsr r7
21f189cc:	21f67738 	mvncss	r7, r8, lsr r7
21f189d0:	21f6773c 	mvncss	r7, ip, lsr r7
21f189d4:	21f31374 	mvncss	r1, r4, ror r3
21f189d8:	21f310cc 	mvncss	r1, ip, asr #1
21f189dc:	21f310d4 	ldrcssb	r1, [r3, #4]!
21f189e0:	21f310dc 	ldrcssb	r1, [r3, #12]!
21f189e4:	21f310e4 	mvncss	r1, r4, ror #1
21f189e8:	21f313a8 	mvncss	r1, r8, lsr #7
21f189ec:	21f67464 	mvncss	r7, r4, ror #8

21f189f0 <do_mem_crc>:

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f189f0:	e1a0c00d 	mov	ip, sp
21f189f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f189f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f189fc:	e24dd024 	sub	sp, sp, #36	; 0x24
21f18a00:	e50b0020 	str	r0, [fp, #-32]
21f18a04:	e50b1024 	str	r1, [fp, #-36]
21f18a08:	e50b2028 	str	r2, [fp, #-40]
21f18a0c:	e50b302c 	str	r3, [fp, #-44]
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3) {
21f18a10:	e51b3028 	ldr	r3, [fp, #-40]
21f18a14:	e3530002 	cmp	r3, #2	; 0x2
21f18a18:	ca000007 	bgt	21f18a3c <do_mem_crc+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f18a1c:	e51b3020 	ldr	r3, [fp, #-32]
21f18a20:	e5933010 	ldr	r3, [r3, #16]
21f18a24:	e59f0100 	ldr	r0, [pc, #256]	; 21f18b2c <.text+0x18b2c>
21f18a28:	e1a01003 	mov	r1, r3
21f18a2c:	eb000c16 	bl	21f1ba8c <printf>
		return 1;
21f18a30:	e3a03001 	mov	r3, #1	; 0x1
21f18a34:	e50b3030 	str	r3, [fp, #-48]
21f18a38:	ea000037 	b	21f18b1c <do_mem_crc+0x12c>
	}

	addr = simple_strtoul (argv[1], NULL, 16);
21f18a3c:	e51b302c 	ldr	r3, [fp, #-44]
21f18a40:	e2833004 	add	r3, r3, #4	; 0x4
21f18a44:	e5933000 	ldr	r3, [r3]
21f18a48:	e1a00003 	mov	r0, r3
21f18a4c:	e3a01000 	mov	r1, #0	; 0x0
21f18a50:	e3a02010 	mov	r2, #16	; 0x10
21f18a54:	eb002adb 	bl	21f235c8 <simple_strtoul>
21f18a58:	e1a03000 	mov	r3, r0
21f18a5c:	e50b301c 	str	r3, [fp, #-28]
	addr += base_address;
21f18a60:	e59f30c8 	ldr	r3, [pc, #200]	; 21f18b30 <.text+0x18b30>
21f18a64:	e5932000 	ldr	r2, [r3]
21f18a68:	e51b301c 	ldr	r3, [fp, #-28]
21f18a6c:	e0833002 	add	r3, r3, r2
21f18a70:	e50b301c 	str	r3, [fp, #-28]

	length = simple_strtoul (argv[2], NULL, 16);
21f18a74:	e51b302c 	ldr	r3, [fp, #-44]
21f18a78:	e2833008 	add	r3, r3, #8	; 0x8
21f18a7c:	e5933000 	ldr	r3, [r3]
21f18a80:	e1a00003 	mov	r0, r3
21f18a84:	e3a01000 	mov	r1, #0	; 0x0
21f18a88:	e3a02010 	mov	r2, #16	; 0x10
21f18a8c:	eb002acd 	bl	21f235c8 <simple_strtoul>
21f18a90:	e1a03000 	mov	r3, r0
21f18a94:	e50b3018 	str	r3, [fp, #-24]

	crc = crc32 (0, (const uchar *) addr, length);
21f18a98:	e51b301c 	ldr	r3, [fp, #-28]
21f18a9c:	e3a00000 	mov	r0, #0	; 0x0
21f18aa0:	e1a01003 	mov	r1, r3
21f18aa4:	e51b2018 	ldr	r2, [fp, #-24]
21f18aa8:	eb002612 	bl	21f222f8 <crc32>
21f18aac:	e1a03000 	mov	r3, r0
21f18ab0:	e50b3014 	str	r3, [fp, #-20]

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
21f18ab4:	e51b201c 	ldr	r2, [fp, #-28]
21f18ab8:	e51b3018 	ldr	r3, [fp, #-24]
21f18abc:	e0823003 	add	r3, r2, r3
21f18ac0:	e2433001 	sub	r3, r3, #1	; 0x1
21f18ac4:	e59f0068 	ldr	r0, [pc, #104]	; 21f18b34 <.text+0x18b34>
21f18ac8:	e51b101c 	ldr	r1, [fp, #-28]
21f18acc:	e1a02003 	mov	r2, r3
21f18ad0:	e51b3014 	ldr	r3, [fp, #-20]
21f18ad4:	eb000bec 	bl	21f1ba8c <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
21f18ad8:	e51b3028 	ldr	r3, [fp, #-40]
21f18adc:	e3530003 	cmp	r3, #3	; 0x3
21f18ae0:	da00000b 	ble	21f18b14 <do_mem_crc+0x124>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
21f18ae4:	e51b302c 	ldr	r3, [fp, #-44]
21f18ae8:	e283300c 	add	r3, r3, #12	; 0xc
21f18aec:	e5933000 	ldr	r3, [r3]
21f18af0:	e1a00003 	mov	r0, r3
21f18af4:	e3a01000 	mov	r1, #0	; 0x0
21f18af8:	e3a02010 	mov	r2, #16	; 0x10
21f18afc:	eb002ab1 	bl	21f235c8 <simple_strtoul>
21f18b00:	e1a03000 	mov	r3, r0
21f18b04:	e50b3010 	str	r3, [fp, #-16]
		*ptr = crc;
21f18b08:	e51b2010 	ldr	r2, [fp, #-16]
21f18b0c:	e51b3014 	ldr	r3, [fp, #-20]
21f18b10:	e5823000 	str	r3, [r2]
	}

	return 0;
21f18b14:	e3a03000 	mov	r3, #0	; 0x0
21f18b18:	e50b3030 	str	r3, [fp, #-48]
21f18b1c:	e51b3030 	ldr	r3, [fp, #-48]
}
21f18b20:	e1a00003 	mov	r0, r3
21f18b24:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f18b28:	e89da800 	ldmia	sp, {fp, sp, pc}
21f18b2c:	21f310c0 	mvncss	r1, r0, asr #1
21f18b30:	21f6773c 	mvncss	r7, ip, lsr r7
21f18b34:	21f313ac 	mvncss	r1, ip, lsr #7

21f18b38 <MII_dump_0_to_5>:
void MII_dump_0_to_5(
	ushort regvals[6],
	uchar reglo,
	uchar reghi)
{
21f18b38:	e1a0c00d 	mov	ip, sp
21f18b3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f18b40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f18b44:	e24dd010 	sub	sp, sp, #16	; 0x10
21f18b48:	e50b0014 	str	r0, [fp, #-20]
21f18b4c:	e1a03001 	mov	r3, r1
21f18b50:	e54b3018 	strb	r3, [fp, #-24]
21f18b54:	e1a03002 	mov	r3, r2
21f18b58:	e54b301c 	strb	r3, [fp, #-28]
	ulong i;

	for (i = 0; i < 6; i++) {
21f18b5c:	e3a03000 	mov	r3, #0	; 0x0
21f18b60:	e50b3010 	str	r3, [fp, #-16]
21f18b64:	ea00001d 	b	21f18be0 <MII_dump_0_to_5+0xa8>
		if ((reglo <= i) && (i <= reghi))
21f18b68:	e55b2018 	ldrb	r2, [fp, #-24]
21f18b6c:	e51b3010 	ldr	r3, [fp, #-16]
21f18b70:	e1520003 	cmp	r2, r3
21f18b74:	8a000016 	bhi	21f18bd4 <MII_dump_0_to_5+0x9c>
21f18b78:	e55b201c 	ldrb	r2, [fp, #-28]
21f18b7c:	e51b3010 	ldr	r3, [fp, #-16]
21f18b80:	e1520003 	cmp	r2, r3
21f18b84:	3a000012 	bcc	21f18bd4 <MII_dump_0_to_5+0x9c>
			dump_reg(regvals[i], &reg_0_5_desc_tbl[i],
21f18b88:	e51b3010 	ldr	r3, [fp, #-16]
21f18b8c:	e1a03083 	mov	r3, r3, lsl #1
21f18b90:	e1a02003 	mov	r2, r3
21f18b94:	e51b3014 	ldr	r3, [fp, #-20]
21f18b98:	e0823003 	add	r3, r2, r3
21f18b9c:	e1d330b0 	ldrh	r3, [r3]
21f18ba0:	e1a00003 	mov	r0, r3
21f18ba4:	e51b3010 	ldr	r3, [fp, #-16]
21f18ba8:	e1a03183 	mov	r3, r3, lsl #3
21f18bac:	e1a02003 	mov	r2, r3
21f18bb0:	e59f303c 	ldr	r3, [pc, #60]	; 21f18bf4 <.text+0x18bf4>
21f18bb4:	e0821003 	add	r1, r2, r3
21f18bb8:	e51b3010 	ldr	r3, [fp, #-16]
21f18bbc:	e1a03183 	mov	r3, r3, lsl #3
21f18bc0:	e1a02003 	mov	r2, r3
21f18bc4:	e59f302c 	ldr	r3, [pc, #44]	; 21f18bf8 <.text+0x18bf8>
21f18bc8:	e0823003 	add	r3, r2, r3
21f18bcc:	e1a02003 	mov	r2, r3
21f18bd0:	eb000009 	bl	21f18bfc <dump_reg>
21f18bd4:	e51b3010 	ldr	r3, [fp, #-16]
21f18bd8:	e2833001 	add	r3, r3, #1	; 0x1
21f18bdc:	e50b3010 	str	r3, [fp, #-16]
21f18be0:	e51b3010 	ldr	r3, [fp, #-16]
21f18be4:	e3530005 	cmp	r3, #5	; 0x5
21f18be8:	9affffde 	bls	21f18b68 <MII_dump_0_to_5+0x30>
				&desc_and_len_tbl[i]);
	}
}
21f18bec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f18bf0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f18bf4:	21f3329c 	ldrcsb	r3, [r3, #44]!
21f18bf8:	21f33554 	mvncss	r3, r4, asr r5

21f18bfc <dump_reg>:

static void dump_reg(
	ushort             regval,
	MII_reg_desc_t   * prd,
	MII_field_desc_and_len_t * pdl)
{
21f18bfc:	e1a0c00d 	mov	ip, sp
21f18c00:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f18c04:	e24cb004 	sub	fp, ip, #4	; 0x4
21f18c08:	e24dd018 	sub	sp, sp, #24	; 0x18
21f18c0c:	e1a03000 	mov	r3, r0
21f18c10:	e50b1020 	str	r1, [fp, #-32]
21f18c14:	e50b2024 	str	r2, [fp, #-36]
21f18c18:	e14b31bc 	strh	r3, [fp, #-28]
	ulong i;
	ushort mask_in_place;
	MII_field_desc_t * pdesc;

	printf("%u.     (%04hx)                 -- %s --\n",
21f18c1c:	e51b3020 	ldr	r3, [fp, #-32]
21f18c20:	e1d330b0 	ldrh	r3, [r3]
21f18c24:	e1a02003 	mov	r2, r3
21f18c28:	e15bc1bc 	ldrh	ip, [fp, #-28]
21f18c2c:	e51b3020 	ldr	r3, [fp, #-32]
21f18c30:	e5933004 	ldr	r3, [r3, #4]
21f18c34:	e59f0170 	ldr	r0, [pc, #368]	; 21f18dac <.text+0x18dac>
21f18c38:	e1a01002 	mov	r1, r2
21f18c3c:	e1a0200c 	mov	r2, ip
21f18c40:	eb000b91 	bl	21f1ba8c <printf>
		prd->regno, regval, prd->name);

	for (i = 0; i < pdl->len; i++) {
21f18c44:	e3a03000 	mov	r3, #0	; 0x0
21f18c48:	e50b3018 	str	r3, [fp, #-24]
21f18c4c:	ea00004c 	b	21f18d84 <dump_reg+0x188>
		pdesc = &pdl->pdesc[i];
21f18c50:	e51b3024 	ldr	r3, [fp, #-36]
21f18c54:	e5931000 	ldr	r1, [r3]
21f18c58:	e51b2018 	ldr	r2, [fp, #-24]
21f18c5c:	e1a03002 	mov	r3, r2
21f18c60:	e1a03083 	mov	r3, r3, lsl #1
21f18c64:	e0833002 	add	r3, r3, r2
21f18c68:	e1a03103 	mov	r3, r3, lsl #2
21f18c6c:	e0813003 	add	r3, r1, r3
21f18c70:	e50b3010 	str	r3, [fp, #-16]

		mask_in_place = pdesc->mask << pdesc->lo;
21f18c74:	e51b3010 	ldr	r3, [fp, #-16]
21f18c78:	e1d330b4 	ldrh	r3, [r3, #4]
21f18c7c:	e1a02003 	mov	r2, r3
21f18c80:	e51b3010 	ldr	r3, [fp, #-16]
21f18c84:	e1d330b2 	ldrh	r3, [r3, #2]
21f18c88:	e1a03312 	mov	r3, r2, lsl r3
21f18c8c:	e14b31b2 	strh	r3, [fp, #-18]

		printf("  (%04hx:%04hx) %u.",
21f18c90:	e15b11b2 	ldrh	r1, [fp, #-18]
21f18c94:	e15b21bc 	ldrh	r2, [fp, #-28]
21f18c98:	e15b31b2 	ldrh	r3, [fp, #-18]
21f18c9c:	e0023003 	and	r3, r2, r3
21f18ca0:	e1a03803 	mov	r3, r3, lsl #16
21f18ca4:	e1a03823 	mov	r3, r3, lsr #16
21f18ca8:	e1a02003 	mov	r2, r3
21f18cac:	e51b3020 	ldr	r3, [fp, #-32]
21f18cb0:	e1d330b0 	ldrh	r3, [r3]
21f18cb4:	e59f00f4 	ldr	r0, [pc, #244]	; 21f18db0 <.text+0x18db0>
21f18cb8:	eb000b73 	bl	21f1ba8c <printf>
			mask_in_place,
			regval & mask_in_place,
			prd->regno);

		if (special_field(prd->regno, pdesc, regval)) {
21f18cbc:	e51b3020 	ldr	r3, [fp, #-32]
21f18cc0:	e1d330b0 	ldrh	r3, [r3]
21f18cc4:	e15b21bc 	ldrh	r2, [fp, #-28]
21f18cc8:	e1a00003 	mov	r0, r3
21f18ccc:	e51b1010 	ldr	r1, [fp, #-16]
21f18cd0:	eb00003b 	bl	21f18dc4 <special_field>
21f18cd4:	e1a03000 	mov	r3, r0
21f18cd8:	e3530000 	cmp	r3, #0	; 0x0
21f18cdc:	1a000023 	bne	21f18d70 <dump_reg+0x174>
		}
		else {
			if (pdesc->hi == pdesc->lo)
21f18ce0:	e51b3010 	ldr	r3, [fp, #-16]
21f18ce4:	e1d320b0 	ldrh	r2, [r3]
21f18ce8:	e51b3010 	ldr	r3, [fp, #-16]
21f18cec:	e1d330b2 	ldrh	r3, [r3, #2]
21f18cf0:	e1520003 	cmp	r2, r3
21f18cf4:	1a000005 	bne	21f18d10 <dump_reg+0x114>
				printf("%2u   ", pdesc->lo);
21f18cf8:	e51b3010 	ldr	r3, [fp, #-16]
21f18cfc:	e1d330b2 	ldrh	r3, [r3, #2]
21f18d00:	e59f00ac 	ldr	r0, [pc, #172]	; 21f18db4 <.text+0x18db4>
21f18d04:	e1a01003 	mov	r1, r3
21f18d08:	eb000b5f 	bl	21f1ba8c <printf>
21f18d0c:	ea000008 	b	21f18d34 <dump_reg+0x138>
			else
				printf("%2u-%2u", pdesc->hi, pdesc->lo);
21f18d10:	e51b3010 	ldr	r3, [fp, #-16]
21f18d14:	e1d330b0 	ldrh	r3, [r3]
21f18d18:	e1a02003 	mov	r2, r3
21f18d1c:	e51b3010 	ldr	r3, [fp, #-16]
21f18d20:	e1d330b2 	ldrh	r3, [r3, #2]
21f18d24:	e59f008c 	ldr	r0, [pc, #140]	; 21f18db8 <.text+0x18db8>
21f18d28:	e1a01002 	mov	r1, r2
21f18d2c:	e1a02003 	mov	r2, r3
21f18d30:	eb000b55 	bl	21f1ba8c <printf>
			printf(" = %5u    %s",
21f18d34:	e15b21bc 	ldrh	r2, [fp, #-28]
21f18d38:	e15b31b2 	ldrh	r3, [fp, #-18]
21f18d3c:	e0023003 	and	r3, r2, r3
21f18d40:	e1a03803 	mov	r3, r3, lsl #16
21f18d44:	e1a03823 	mov	r3, r3, lsr #16
21f18d48:	e1a02003 	mov	r2, r3
21f18d4c:	e51b3010 	ldr	r3, [fp, #-16]
21f18d50:	e1d330b2 	ldrh	r3, [r3, #2]
21f18d54:	e1a02352 	mov	r2, r2, asr r3
21f18d58:	e51b3010 	ldr	r3, [fp, #-16]
21f18d5c:	e5933008 	ldr	r3, [r3, #8]
21f18d60:	e59f0054 	ldr	r0, [pc, #84]	; 21f18dbc <.text+0x18dbc>
21f18d64:	e1a01002 	mov	r1, r2
21f18d68:	e1a02003 	mov	r2, r3
21f18d6c:	eb000b46 	bl	21f1ba8c <printf>
				(regval & mask_in_place) >> pdesc->lo,
				pdesc->name);
		}
		printf("\n");
21f18d70:	e59f0048 	ldr	r0, [pc, #72]	; 21f18dc0 <.text+0x18dc0>
21f18d74:	eb000b44 	bl	21f1ba8c <printf>
21f18d78:	e51b3018 	ldr	r3, [fp, #-24]
21f18d7c:	e2833001 	add	r3, r3, #1	; 0x1
21f18d80:	e50b3018 	str	r3, [fp, #-24]
21f18d84:	e51b3024 	ldr	r3, [fp, #-36]
21f18d88:	e1d330b4 	ldrh	r3, [r3, #4]
21f18d8c:	e1a02003 	mov	r2, r3
21f18d90:	e51b3018 	ldr	r3, [fp, #-24]
21f18d94:	e1520003 	cmp	r2, r3
21f18d98:	8affffac 	bhi	21f18c50 <dump_reg+0x54>

	}
	printf("\n");
21f18d9c:	e59f001c 	ldr	r0, [pc, #28]	; 21f18dc0 <.text+0x18dc0>
21f18da0:	eb000b39 	bl	21f1ba8c <printf>
}
21f18da4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f18da8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f18dac:	21f3192c 	mvncss	r1, ip, lsr #18
21f18db0:	21f31958 	mvncss	r1, r8, asr r9
21f18db4:	21f3196c 	mvncss	r1, ip, ror #18
21f18db8:	21f31974 	mvncss	r1, r4, ror r9
21f18dbc:	21f3197c 	mvncss	r1, ip, ror r9
21f18dc0:	21f3198c 	mvncss	r1, ip, lsl #19

21f18dc4 <special_field>:

/* Special fields:
** 0.6,13
** 0.8
** 2.15-0
** 3.15-0
** 4.4-0
** 5.4-0
*/

static int special_field(
	ushort regno,
	MII_field_desc_t * pdesc,
	ushort regval)
{
21f18dc4:	e1a0c00d 	mov	ip, sp
21f18dc8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f18dcc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f18dd0:	e24dd068 	sub	sp, sp, #104	; 0x68
21f18dd4:	e50b101c 	str	r1, [fp, #-28]
21f18dd8:	e1a03002 	mov	r3, r2
21f18ddc:	e14b01b8 	strh	r0, [fp, #-24]
21f18de0:	e14b32b0 	strh	r3, [fp, #-32]
	if ((regno == 0) && (pdesc->lo == 6)) {
21f18de4:	e15b31b8 	ldrh	r3, [fp, #-24]
21f18de8:	e3530000 	cmp	r3, #0	; 0x0
21f18dec:	1a000036 	bne	21f18ecc <special_field+0x108>
21f18df0:	e51b301c 	ldr	r3, [fp, #-28]
21f18df4:	e1d330b2 	ldrh	r3, [r3, #2]
21f18df8:	e3530006 	cmp	r3, #6	; 0x6
21f18dfc:	1a000032 	bne	21f18ecc <special_field+0x108>
		ushort speed_bits = regval & PHY_BMCR_SPEED_MASK;
21f18e00:	e15b32b0 	ldrh	r3, [fp, #-32]
21f18e04:	e2033d81 	and	r3, r3, #8256	; 0x2040
21f18e08:	e14b31b2 	strh	r3, [fp, #-18]
		printf("%2u,%2u =   b%u%u    speed selection = %s Mbps",
21f18e0c:	e15b32b0 	ldrh	r3, [fp, #-32]
21f18e10:	e1a03323 	mov	r3, r3, lsr #6
21f18e14:	e1a03803 	mov	r3, r3, lsl #16
21f18e18:	e1a03823 	mov	r3, r3, lsr #16
21f18e1c:	e2033001 	and	r3, r3, #1	; 0x1
21f18e20:	e50b306c 	str	r3, [fp, #-108]
21f18e24:	e15b32b0 	ldrh	r3, [fp, #-32]
21f18e28:	e1a036a3 	mov	r3, r3, lsr #13
21f18e2c:	e1a03803 	mov	r3, r3, lsl #16
21f18e30:	e1a03823 	mov	r3, r3, lsr #16
21f18e34:	e2033001 	and	r3, r3, #1	; 0x1
21f18e38:	e50b3068 	str	r3, [fp, #-104]
21f18e3c:	e15b31b2 	ldrh	r3, [fp, #-18]
21f18e40:	e3530040 	cmp	r3, #64	; 0x40
21f18e44:	0a000012 	beq	21f18e94 <special_field+0xd0>
21f18e48:	e15b31b2 	ldrh	r3, [fp, #-18]
21f18e4c:	e3530a02 	cmp	r3, #8192	; 0x2000
21f18e50:	0a00000a 	beq	21f18e80 <special_field+0xbc>
21f18e54:	e15b31b2 	ldrh	r3, [fp, #-18]
21f18e58:	e3530000 	cmp	r3, #0	; 0x0
21f18e5c:	1a000002 	bne	21f18e6c <special_field+0xa8>
21f18e60:	e59f32b8 	ldr	r3, [pc, #696]	; 21f19120 <.text+0x19120>
21f18e64:	e50b305c 	str	r3, [fp, #-92]
21f18e68:	ea000001 	b	21f18e74 <special_field+0xb0>
21f18e6c:	e59f32b0 	ldr	r3, [pc, #688]	; 21f19124 <.text+0x19124>
21f18e70:	e50b305c 	str	r3, [fp, #-92]
21f18e74:	e51b305c 	ldr	r3, [fp, #-92]
21f18e78:	e50b3060 	str	r3, [fp, #-96]
21f18e7c:	ea000001 	b	21f18e88 <special_field+0xc4>
21f18e80:	e59f32a0 	ldr	r3, [pc, #672]	; 21f19128 <.text+0x19128>
21f18e84:	e50b3060 	str	r3, [fp, #-96]
21f18e88:	e51b3060 	ldr	r3, [fp, #-96]
21f18e8c:	e50b3064 	str	r3, [fp, #-100]
21f18e90:	ea000001 	b	21f18e9c <special_field+0xd8>
21f18e94:	e59f3290 	ldr	r3, [pc, #656]	; 21f1912c <.text+0x1912c>
21f18e98:	e50b3064 	str	r3, [fp, #-100]
21f18e9c:	e51b3068 	ldr	r3, [fp, #-104]
21f18ea0:	e58d3000 	str	r3, [sp]
21f18ea4:	e51b3064 	ldr	r3, [fp, #-100]
21f18ea8:	e58d3004 	str	r3, [sp, #4]
21f18eac:	e59f027c 	ldr	r0, [pc, #636]	; 21f19130 <.text+0x19130>
21f18eb0:	e3a01006 	mov	r1, #6	; 0x6
21f18eb4:	e3a0200d 	mov	r2, #13	; 0xd
21f18eb8:	e51b306c 	ldr	r3, [fp, #-108]
21f18ebc:	eb000af2 	bl	21f1ba8c <printf>
			6, 13,
			(regval >>  6) & 1,
			(regval >> 13) & 1,
			speed_bits == PHY_BMCR_1000_MBPS ? "1000" :
			speed_bits == PHY_BMCR_100_MBPS  ? "100" :
			speed_bits == PHY_BMCR_10_MBPS   ? "10" :
			"???");
		return 1;
21f18ec0:	e3a03001 	mov	r3, #1	; 0x1
21f18ec4:	e50b3058 	str	r3, [fp, #-88]
21f18ec8:	ea000090 	b	21f19110 <special_field+0x34c>
	}

	else if ((regno == 0) && (pdesc->lo == 8)) {
21f18ecc:	e15b31b8 	ldrh	r3, [fp, #-24]
21f18ed0:	e3530000 	cmp	r3, #0	; 0x0
21f18ed4:	1a000021 	bne	21f18f60 <special_field+0x19c>
21f18ed8:	e51b301c 	ldr	r3, [fp, #-28]
21f18edc:	e1d330b2 	ldrh	r3, [r3, #2]
21f18ee0:	e3530008 	cmp	r3, #8	; 0x8
21f18ee4:	1a00001d 	bne	21f18f60 <special_field+0x19c>
		printf("%2u    = %5u    duplex = %s",
21f18ee8:	e51b301c 	ldr	r3, [fp, #-28]
21f18eec:	e1d330b2 	ldrh	r3, [r3, #2]
21f18ef0:	e50b3054 	str	r3, [fp, #-84]
21f18ef4:	e15b22b0 	ldrh	r2, [fp, #-32]
21f18ef8:	e51b301c 	ldr	r3, [fp, #-28]
21f18efc:	e1d330b2 	ldrh	r3, [r3, #2]
21f18f00:	e1a03352 	mov	r3, r2, asr r3
21f18f04:	e2033001 	and	r3, r3, #1	; 0x1
21f18f08:	e50b3050 	str	r3, [fp, #-80]
21f18f0c:	e15b22b0 	ldrh	r2, [fp, #-32]
21f18f10:	e51b301c 	ldr	r3, [fp, #-28]
21f18f14:	e1d330b2 	ldrh	r3, [r3, #2]
21f18f18:	e1a03352 	mov	r3, r2, asr r3
21f18f1c:	e2033001 	and	r3, r3, #1	; 0x1
21f18f20:	e20330ff 	and	r3, r3, #255	; 0xff
21f18f24:	e3530000 	cmp	r3, #0	; 0x0
21f18f28:	0a000002 	beq	21f18f38 <special_field+0x174>
21f18f2c:	e59f3200 	ldr	r3, [pc, #512]	; 21f19134 <.text+0x19134>
21f18f30:	e50b304c 	str	r3, [fp, #-76]
21f18f34:	ea000001 	b	21f18f40 <special_field+0x17c>
21f18f38:	e59f31f8 	ldr	r3, [pc, #504]	; 21f19138 <.text+0x19138>
21f18f3c:	e50b304c 	str	r3, [fp, #-76]
21f18f40:	e59f01f4 	ldr	r0, [pc, #500]	; 21f1913c <.text+0x1913c>
21f18f44:	e51b1054 	ldr	r1, [fp, #-84]
21f18f48:	e51b2050 	ldr	r2, [fp, #-80]
21f18f4c:	e51b304c 	ldr	r3, [fp, #-76]
21f18f50:	eb000acd 	bl	21f1ba8c <printf>
			pdesc->lo,
			(regval >>  pdesc->lo) & 1,
			((regval >> pdesc->lo) & 1) ? "full" : "half");
		return 1;
21f18f54:	e3a03001 	mov	r3, #1	; 0x1
21f18f58:	e50b3058 	str	r3, [fp, #-88]
21f18f5c:	ea00006b 	b	21f19110 <special_field+0x34c>
	}

	else if ((regno == 4) && (pdesc->lo == 0)) {
21f18f60:	e15b31b8 	ldrh	r3, [fp, #-24]
21f18f64:	e3530004 	cmp	r3, #4	; 0x4
21f18f68:	1a000031 	bne	21f19034 <special_field+0x270>
21f18f6c:	e51b301c 	ldr	r3, [fp, #-28]
21f18f70:	e1d330b2 	ldrh	r3, [r3, #2]
21f18f74:	e3530000 	cmp	r3, #0	; 0x0
21f18f78:	1a00002d 	bne	21f19034 <special_field+0x270>
		ushort sel_bits = (regval >> pdesc->lo) & pdesc->mask;
21f18f7c:	e15b22b0 	ldrh	r2, [fp, #-32]
21f18f80:	e51b301c 	ldr	r3, [fp, #-28]
21f18f84:	e1d330b2 	ldrh	r3, [r3, #2]
21f18f88:	e1a03352 	mov	r3, r2, asr r3
21f18f8c:	e1a03803 	mov	r3, r3, lsl #16
21f18f90:	e1a02823 	mov	r2, r3, lsr #16
21f18f94:	e51b301c 	ldr	r3, [fp, #-28]
21f18f98:	e1d330b4 	ldrh	r3, [r3, #4]
21f18f9c:	e0023003 	and	r3, r2, r3
21f18fa0:	e1a03803 	mov	r3, r3, lsl #16
21f18fa4:	e1a03823 	mov	r3, r3, lsr #16
21f18fa8:	e14b31b0 	strh	r3, [fp, #-16]
		printf("%2u-%2u = %5u    selector = %s",
21f18fac:	e51b301c 	ldr	r3, [fp, #-28]
21f18fb0:	e1d330b0 	ldrh	r3, [r3]
21f18fb4:	e50b3048 	str	r3, [fp, #-72]
21f18fb8:	e51b301c 	ldr	r3, [fp, #-28]
21f18fbc:	e1d330b2 	ldrh	r3, [r3, #2]
21f18fc0:	e50b3044 	str	r3, [fp, #-68]
21f18fc4:	e15b31b0 	ldrh	r3, [fp, #-16]
21f18fc8:	e50b3040 	str	r3, [fp, #-64]
21f18fcc:	e15b31b0 	ldrh	r3, [fp, #-16]
21f18fd0:	e3530001 	cmp	r3, #1	; 0x1
21f18fd4:	0a00000a 	beq	21f19004 <special_field+0x240>
21f18fd8:	e15b31b0 	ldrh	r3, [fp, #-16]
21f18fdc:	e3530002 	cmp	r3, #2	; 0x2
21f18fe0:	1a000002 	bne	21f18ff0 <special_field+0x22c>
21f18fe4:	e59f3154 	ldr	r3, [pc, #340]	; 21f19140 <.text+0x19140>
21f18fe8:	e50b3038 	str	r3, [fp, #-56]
21f18fec:	ea000001 	b	21f18ff8 <special_field+0x234>
21f18ff0:	e59f312c 	ldr	r3, [pc, #300]	; 21f19124 <.text+0x19124>
21f18ff4:	e50b3038 	str	r3, [fp, #-56]
21f18ff8:	e51b3038 	ldr	r3, [fp, #-56]
21f18ffc:	e50b303c 	str	r3, [fp, #-60]
21f19000:	ea000001 	b	21f1900c <special_field+0x248>
21f19004:	e59f3138 	ldr	r3, [pc, #312]	; 21f19144 <.text+0x19144>
21f19008:	e50b303c 	str	r3, [fp, #-60]
21f1900c:	e51b303c 	ldr	r3, [fp, #-60]
21f19010:	e58d3000 	str	r3, [sp]
21f19014:	e59f012c 	ldr	r0, [pc, #300]	; 21f19148 <.text+0x19148>
21f19018:	e51b1048 	ldr	r1, [fp, #-72]
21f1901c:	e51b2044 	ldr	r2, [fp, #-68]
21f19020:	e51b3040 	ldr	r3, [fp, #-64]
21f19024:	eb000a98 	bl	21f1ba8c <printf>
			pdesc->hi, pdesc->lo, sel_bits,
			sel_bits == PHY_ANLPAR_PSB_802_3 ?
				"IEEE 802.3" :
			sel_bits == PHY_ANLPAR_PSB_802_9 ?
				"IEEE 802.9 ISLAN-16T" :
			"???");
		return 1;
21f19028:	e3a03001 	mov	r3, #1	; 0x1
21f1902c:	e50b3058 	str	r3, [fp, #-88]
21f19030:	ea000036 	b	21f19110 <special_field+0x34c>
	}

	else if ((regno == 5) && (pdesc->lo == 0)) {
21f19034:	e15b31b8 	ldrh	r3, [fp, #-24]
21f19038:	e3530005 	cmp	r3, #5	; 0x5
21f1903c:	1a000031 	bne	21f19108 <special_field+0x344>
21f19040:	e51b301c 	ldr	r3, [fp, #-28]
21f19044:	e1d330b2 	ldrh	r3, [r3, #2]
21f19048:	e3530000 	cmp	r3, #0	; 0x0
21f1904c:	1a00002d 	bne	21f19108 <special_field+0x344>
		ushort sel_bits = (regval >> pdesc->lo) & pdesc->mask;
21f19050:	e15b22b0 	ldrh	r2, [fp, #-32]
21f19054:	e51b301c 	ldr	r3, [fp, #-28]
21f19058:	e1d330b2 	ldrh	r3, [r3, #2]
21f1905c:	e1a03352 	mov	r3, r2, asr r3
21f19060:	e1a03803 	mov	r3, r3, lsl #16
21f19064:	e1a02823 	mov	r2, r3, lsr #16
21f19068:	e51b301c 	ldr	r3, [fp, #-28]
21f1906c:	e1d330b4 	ldrh	r3, [r3, #4]
21f19070:	e0023003 	and	r3, r2, r3
21f19074:	e1a03803 	mov	r3, r3, lsl #16
21f19078:	e1a03823 	mov	r3, r3, lsr #16
21f1907c:	e14b30be 	strh	r3, [fp, #-14]
		printf("%2u-%2u =     %u    selector = %s",
21f19080:	e51b301c 	ldr	r3, [fp, #-28]
21f19084:	e1d330b0 	ldrh	r3, [r3]
21f19088:	e50b3034 	str	r3, [fp, #-52]
21f1908c:	e51b301c 	ldr	r3, [fp, #-28]
21f19090:	e1d330b2 	ldrh	r3, [r3, #2]
21f19094:	e50b3030 	str	r3, [fp, #-48]
21f19098:	e15b30be 	ldrh	r3, [fp, #-14]
21f1909c:	e50b302c 	str	r3, [fp, #-44]
21f190a0:	e15b30be 	ldrh	r3, [fp, #-14]
21f190a4:	e3530001 	cmp	r3, #1	; 0x1
21f190a8:	0a00000a 	beq	21f190d8 <special_field+0x314>
21f190ac:	e15b30be 	ldrh	r3, [fp, #-14]
21f190b0:	e3530002 	cmp	r3, #2	; 0x2
21f190b4:	1a000002 	bne	21f190c4 <special_field+0x300>
21f190b8:	e59f3080 	ldr	r3, [pc, #128]	; 21f19140 <.text+0x19140>
21f190bc:	e50b3024 	str	r3, [fp, #-36]
21f190c0:	ea000001 	b	21f190cc <special_field+0x308>
21f190c4:	e59f3058 	ldr	r3, [pc, #88]	; 21f19124 <.text+0x19124>
21f190c8:	e50b3024 	str	r3, [fp, #-36]
21f190cc:	e51b3024 	ldr	r3, [fp, #-36]
21f190d0:	e50b3028 	str	r3, [fp, #-40]
21f190d4:	ea000001 	b	21f190e0 <special_field+0x31c>
21f190d8:	e59f3064 	ldr	r3, [pc, #100]	; 21f19144 <.text+0x19144>
21f190dc:	e50b3028 	str	r3, [fp, #-40]
21f190e0:	e51b3028 	ldr	r3, [fp, #-40]
21f190e4:	e58d3000 	str	r3, [sp]
21f190e8:	e59f005c 	ldr	r0, [pc, #92]	; 21f1914c <.text+0x1914c>
21f190ec:	e51b1034 	ldr	r1, [fp, #-52]
21f190f0:	e51b2030 	ldr	r2, [fp, #-48]
21f190f4:	e51b302c 	ldr	r3, [fp, #-44]
21f190f8:	eb000a63 	bl	21f1ba8c <printf>
			pdesc->hi, pdesc->lo, sel_bits,
			sel_bits == PHY_ANLPAR_PSB_802_3 ?
				"IEEE 802.3" :
			sel_bits == PHY_ANLPAR_PSB_802_9 ?
				"IEEE 802.9 ISLAN-16T" :
			"???");
		return 1;
21f190fc:	e3a03001 	mov	r3, #1	; 0x1
21f19100:	e50b3058 	str	r3, [fp, #-88]
21f19104:	ea000001 	b	21f19110 <special_field+0x34c>
	}

	return 0;
21f19108:	e3a03000 	mov	r3, #0	; 0x0
21f1910c:	e50b3058 	str	r3, [fp, #-88]
21f19110:	e51b3058 	ldr	r3, [fp, #-88]
}
21f19114:	e1a00003 	mov	r0, r3
21f19118:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1911c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f19120:	21f31990 	ldrcsb	r1, [r3, #144]!
21f19124:	21f31994 	ldrcsb	r1, [r3, #148]!
21f19128:	21f31998 	ldrcsb	r1, [r3, #152]!
21f1912c:	21f3199c 	ldrcsb	r1, [r3, #156]!
21f19130:	21f319a4 	mvncss	r1, r4, lsr #19
21f19134:	21f319d4 	ldrcssb	r1, [r3, #148]!
21f19138:	21f319dc 	ldrcssb	r1, [r3, #156]!
21f1913c:	21f319e4 	mvncss	r1, r4, ror #19
21f19140:	21f31a00 	mvncss	r1, r0, lsl #20
21f19144:	21f31a18 	mvncss	r1, r8, lsl sl
21f19148:	21f31a24 	mvncss	r1, r4, lsr #20
21f1914c:	21f31a44 	mvncss	r1, r4, asr #20

21f19150 <extract_range>:

char last_op[2];
uint last_data;
uint last_addr_lo;
uint last_addr_hi;
uint last_reg_lo;
uint last_reg_hi;

static void extract_range(
	char * input,
	unsigned char * plo,
	unsigned char * phi)
{
21f19150:	e1a0c00d 	mov	ip, sp
21f19154:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f19158:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1915c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f19160:	e50b0014 	str	r0, [fp, #-20]
21f19164:	e50b1018 	str	r1, [fp, #-24]
21f19168:	e50b201c 	str	r2, [fp, #-28]
	char * end;
	*plo = simple_strtoul(input, &end, 16);
21f1916c:	e24b3010 	sub	r3, fp, #16	; 0x10
21f19170:	e51b0014 	ldr	r0, [fp, #-20]
21f19174:	e1a01003 	mov	r1, r3
21f19178:	e3a02010 	mov	r2, #16	; 0x10
21f1917c:	eb002911 	bl	21f235c8 <simple_strtoul>
21f19180:	e1a03000 	mov	r3, r0
21f19184:	e20330ff 	and	r3, r3, #255	; 0xff
21f19188:	e51b2018 	ldr	r2, [fp, #-24]
21f1918c:	e5c23000 	strb	r3, [r2]
	if (*end == '-') {
21f19190:	e51b3010 	ldr	r3, [fp, #-16]
21f19194:	e5d33000 	ldrb	r3, [r3]
21f19198:	e353002d 	cmp	r3, #45	; 0x2d
21f1919c:	1a00000c 	bne	21f191d4 <extract_range+0x84>
		end++;
21f191a0:	e51b3010 	ldr	r3, [fp, #-16]
21f191a4:	e2833001 	add	r3, r3, #1	; 0x1
21f191a8:	e50b3010 	str	r3, [fp, #-16]
		*phi = simple_strtoul(end, NULL, 16);
21f191ac:	e51b3010 	ldr	r3, [fp, #-16]
21f191b0:	e1a00003 	mov	r0, r3
21f191b4:	e3a01000 	mov	r1, #0	; 0x0
21f191b8:	e3a02010 	mov	r2, #16	; 0x10
21f191bc:	eb002901 	bl	21f235c8 <simple_strtoul>
21f191c0:	e1a03000 	mov	r3, r0
21f191c4:	e20330ff 	and	r3, r3, #255	; 0xff
21f191c8:	e51b201c 	ldr	r2, [fp, #-28]
21f191cc:	e5c23000 	strb	r3, [r2]
21f191d0:	ea000003 	b	21f191e4 <extract_range+0x94>
	}
	else {
		*phi = *plo;
21f191d4:	e51b3018 	ldr	r3, [fp, #-24]
21f191d8:	e5d33000 	ldrb	r3, [r3]
21f191dc:	e51b201c 	ldr	r2, [fp, #-28]
21f191e0:	e5c23000 	strb	r3, [r2]
	}
}
21f191e4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f191e8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f191ec <do_mii>:

/* ---------------------------------------------------------------- */
int do_mii (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
21f191ec:	e1a0c00d 	mov	ip, sp
21f191f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f191f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f191f8:	e24dd068 	sub	sp, sp, #104	; 0x68
21f191fc:	e50b0040 	str	r0, [fp, #-64]
21f19200:	e50b1044 	str	r1, [fp, #-68]
21f19204:	e50b2048 	str	r2, [fp, #-72]
21f19208:	e50b304c 	str	r3, [fp, #-76]
	char		op[2];
	unsigned char	addrlo, addrhi, reglo, reghi;
	unsigned char	addr, reg;
	unsigned short	data;
	int		rcode = 0;
21f1920c:	e3a03000 	mov	r3, #0	; 0x0
21f19210:	e50b301c 	str	r3, [fp, #-28]
	char		*devname;

#ifdef CONFIG_8xx
	mii_init ();
#endif

	/*
	 * We use the last specified parameters, unless new ones are
	 * entered.
	 */
	op[0] = last_op[0];
21f19214:	e59f368c 	ldr	r3, [pc, #1676]	; 21f198a8 <.text+0x198a8>
21f19218:	e5d33000 	ldrb	r3, [r3]
21f1921c:	e54b3020 	strb	r3, [fp, #-32]
	op[1] = last_op[1];
21f19220:	e59f3680 	ldr	r3, [pc, #1664]	; 21f198a8 <.text+0x198a8>
21f19224:	e5d33001 	ldrb	r3, [r3, #1]
21f19228:	e54b301f 	strb	r3, [fp, #-31]
	addrlo = last_addr_lo;
21f1922c:	e59f3678 	ldr	r3, [pc, #1656]	; 21f198ac <.text+0x198ac>
21f19230:	e5933000 	ldr	r3, [r3]
21f19234:	e20330ff 	and	r3, r3, #255	; 0xff
21f19238:	e54b3021 	strb	r3, [fp, #-33]
	addrhi = last_addr_hi;
21f1923c:	e59f366c 	ldr	r3, [pc, #1644]	; 21f198b0 <.text+0x198b0>
21f19240:	e5933000 	ldr	r3, [r3]
21f19244:	e20330ff 	and	r3, r3, #255	; 0xff
21f19248:	e54b3022 	strb	r3, [fp, #-34]
	reglo  = last_reg_lo;
21f1924c:	e59f3660 	ldr	r3, [pc, #1632]	; 21f198b4 <.text+0x198b4>
21f19250:	e5933000 	ldr	r3, [r3]
21f19254:	e20330ff 	and	r3, r3, #255	; 0xff
21f19258:	e54b3023 	strb	r3, [fp, #-35]
	reghi  = last_reg_hi;
21f1925c:	e59f3654 	ldr	r3, [pc, #1620]	; 21f198b8 <.text+0x198b8>
21f19260:	e5933000 	ldr	r3, [r3]
21f19264:	e20330ff 	and	r3, r3, #255	; 0xff
21f19268:	e54b3024 	strb	r3, [fp, #-36]
	data   = last_data;
21f1926c:	e59f3648 	ldr	r3, [pc, #1608]	; 21f198bc <.text+0x198bc>
21f19270:	e5933000 	ldr	r3, [r3]
21f19274:	e1a03803 	mov	r3, r3, lsl #16
21f19278:	e1a03823 	mov	r3, r3, lsr #16
21f1927c:	e14b32b6 	strh	r3, [fp, #-38]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
21f19280:	e51b3044 	ldr	r3, [fp, #-68]
21f19284:	e2233001 	eor	r3, r3, #1	; 0x1
21f19288:	e2033001 	and	r3, r3, #1	; 0x1
21f1928c:	e20330ff 	and	r3, r3, #255	; 0xff
21f19290:	e3530000 	cmp	r3, #0	; 0x0
21f19294:	0a00003b 	beq	21f19388 <do_mii+0x19c>
		op[0] = argv[1][0];
21f19298:	e51b304c 	ldr	r3, [fp, #-76]
21f1929c:	e2833004 	add	r3, r3, #4	; 0x4
21f192a0:	e5933000 	ldr	r3, [r3]
21f192a4:	e5d33000 	ldrb	r3, [r3]
21f192a8:	e54b3020 	strb	r3, [fp, #-32]
		if (strlen(argv[1]) > 1)
21f192ac:	e51b304c 	ldr	r3, [fp, #-76]
21f192b0:	e2833004 	add	r3, r3, #4	; 0x4
21f192b4:	e5933000 	ldr	r3, [r3]
21f192b8:	e1a00003 	mov	r0, r3
21f192bc:	eb002640 	bl	21f22bc4 <strlen>
21f192c0:	e1a03000 	mov	r3, r0
21f192c4:	e3530001 	cmp	r3, #1	; 0x1
21f192c8:	9a000006 	bls	21f192e8 <do_mii+0xfc>
			op[1] = argv[1][1];
21f192cc:	e51b304c 	ldr	r3, [fp, #-76]
21f192d0:	e2833004 	add	r3, r3, #4	; 0x4
21f192d4:	e5933000 	ldr	r3, [r3]
21f192d8:	e2833001 	add	r3, r3, #1	; 0x1
21f192dc:	e5d33000 	ldrb	r3, [r3]
21f192e0:	e54b301f 	strb	r3, [fp, #-31]
21f192e4:	ea000001 	b	21f192f0 <do_mii+0x104>
		else
			op[1] = '\0';
21f192e8:	e3a03000 	mov	r3, #0	; 0x0
21f192ec:	e54b301f 	strb	r3, [fp, #-31]

		if (argc >= 3)
21f192f0:	e51b3048 	ldr	r3, [fp, #-72]
21f192f4:	e3530002 	cmp	r3, #2	; 0x2
21f192f8:	da000008 	ble	21f19320 <do_mii+0x134>
			extract_range(argv[2], &addrlo, &addrhi);
21f192fc:	e51b304c 	ldr	r3, [fp, #-76]
21f19300:	e2833008 	add	r3, r3, #8	; 0x8
21f19304:	e5933000 	ldr	r3, [r3]
21f19308:	e24b2021 	sub	r2, fp, #33	; 0x21
21f1930c:	e24bc022 	sub	ip, fp, #34	; 0x22
21f19310:	e1a00003 	mov	r0, r3
21f19314:	e1a01002 	mov	r1, r2
21f19318:	e1a0200c 	mov	r2, ip
21f1931c:	ebffff8b 	bl	21f19150 <extract_range>
		if (argc >= 4)
21f19320:	e51b3048 	ldr	r3, [fp, #-72]
21f19324:	e3530003 	cmp	r3, #3	; 0x3
21f19328:	da000008 	ble	21f19350 <do_mii+0x164>
			extract_range(argv[3], &reglo, &reghi);
21f1932c:	e51b304c 	ldr	r3, [fp, #-76]
21f19330:	e283300c 	add	r3, r3, #12	; 0xc
21f19334:	e5933000 	ldr	r3, [r3]
21f19338:	e24b2023 	sub	r2, fp, #35	; 0x23
21f1933c:	e24bc024 	sub	ip, fp, #36	; 0x24
21f19340:	e1a00003 	mov	r0, r3
21f19344:	e1a01002 	mov	r1, r2
21f19348:	e1a0200c 	mov	r2, ip
21f1934c:	ebffff7f 	bl	21f19150 <extract_range>
		if (argc >= 5)
21f19350:	e51b3048 	ldr	r3, [fp, #-72]
21f19354:	e3530004 	cmp	r3, #4	; 0x4
21f19358:	da00000a 	ble	21f19388 <do_mii+0x19c>
			data = simple_strtoul (argv[4], NULL, 16);
21f1935c:	e51b304c 	ldr	r3, [fp, #-76]
21f19360:	e2833010 	add	r3, r3, #16	; 0x10
21f19364:	e5933000 	ldr	r3, [r3]
21f19368:	e1a00003 	mov	r0, r3
21f1936c:	e3a01000 	mov	r1, #0	; 0x0
21f19370:	e3a02010 	mov	r2, #16	; 0x10
21f19374:	eb002893 	bl	21f235c8 <simple_strtoul>
21f19378:	e1a03000 	mov	r3, r0
21f1937c:	e1a03803 	mov	r3, r3, lsl #16
21f19380:	e1a03823 	mov	r3, r3, lsr #16
21f19384:	e14b32b6 	strh	r3, [fp, #-38]
	}

	/* use current device */
	devname = miiphy_get_current_dev();
21f19388:	eb001c88 	bl	21f205b0 <miiphy_get_current_dev>
21f1938c:	e1a03000 	mov	r3, r0
21f19390:	e50b3018 	str	r3, [fp, #-24]

	/*
	 * check info/read/write.
	 */
	if (op[0] == 'i') {
21f19394:	e55b3020 	ldrb	r3, [fp, #-32]
21f19398:	e3530069 	cmp	r3, #105	; 0x69
21f1939c:	1a000047 	bne	21f194c0 <do_mii+0x2d4>
		unsigned char j, start, end;
		unsigned int oui;
		unsigned char model;
		unsigned char rev;

		/*
		 * Look for any and all PHYs.  Valid addresses are 0..31.
		 */
		if (argc >= 3) {
21f193a0:	e51b3048 	ldr	r3, [fp, #-72]
21f193a4:	e3530002 	cmp	r3, #2	; 0x2
21f193a8:	da000004 	ble	21f193c0 <do_mii+0x1d4>
			start = addrlo; end = addrhi;
21f193ac:	e55b3021 	ldrb	r3, [fp, #-33]
21f193b0:	e54b3012 	strb	r3, [fp, #-18]
21f193b4:	e55b3022 	ldrb	r3, [fp, #-34]
21f193b8:	e54b3011 	strb	r3, [fp, #-17]
21f193bc:	ea000003 	b	21f193d0 <do_mii+0x1e4>
		} else {
			start = 0; end = 31;
21f193c0:	e3a03000 	mov	r3, #0	; 0x0
21f193c4:	e54b3012 	strb	r3, [fp, #-18]
21f193c8:	e3a0301f 	mov	r3, #31	; 0x1f
21f193cc:	e54b3011 	strb	r3, [fp, #-17]
		}

		for (j = start; j <= end; j++) {
21f193d0:	e55b3012 	ldrb	r3, [fp, #-18]
21f193d4:	e54b3013 	strb	r3, [fp, #-19]
21f193d8:	ea000033 	b	21f194ac <do_mii+0x2c0>
			if (miiphy_info (devname, j, &oui, &model, &rev) == 0) {
21f193dc:	e55b2013 	ldrb	r2, [fp, #-19]
21f193e0:	e24bc02c 	sub	ip, fp, #44	; 0x2c
21f193e4:	e24be02d 	sub	lr, fp, #45	; 0x2d
21f193e8:	e24b302e 	sub	r3, fp, #46	; 0x2e
21f193ec:	e58d3000 	str	r3, [sp]
21f193f0:	e51b0018 	ldr	r0, [fp, #-24]
21f193f4:	e1a01002 	mov	r1, r2
21f193f8:	e1a0200c 	mov	r2, ip
21f193fc:	e1a0300e 	mov	r3, lr
21f19400:	eb001d63 	bl	21f20994 <miiphy_info>
21f19404:	e1a03000 	mov	r3, r0
21f19408:	e3530000 	cmp	r3, #0	; 0x0
21f1940c:	1a000023 	bne	21f194a0 <do_mii+0x2b4>
				printf("PHY 0x%02X: "
21f19410:	e55b3013 	ldrb	r3, [fp, #-19]
21f19414:	e50b3068 	str	r3, [fp, #-104]
21f19418:	e51b302c 	ldr	r3, [fp, #-44]
21f1941c:	e50b3064 	str	r3, [fp, #-100]
21f19420:	e55b302d 	ldrb	r3, [fp, #-45]
21f19424:	e50b3060 	str	r3, [fp, #-96]
21f19428:	e55b302e 	ldrb	r3, [fp, #-46]
21f1942c:	e50b305c 	str	r3, [fp, #-92]
21f19430:	e55b3013 	ldrb	r3, [fp, #-19]
21f19434:	e51b0018 	ldr	r0, [fp, #-24]
21f19438:	e1a01003 	mov	r1, r3
21f1943c:	eb001df7 	bl	21f20c20 <miiphy_speed>
21f19440:	e50b0058 	str	r0, [fp, #-88]
21f19444:	e55b3013 	ldrb	r3, [fp, #-19]
21f19448:	e51b0018 	ldr	r0, [fp, #-24]
21f1944c:	e1a01003 	mov	r1, r3
21f19450:	eb001e38 	bl	21f20d38 <miiphy_duplex>
21f19454:	e1a03000 	mov	r3, r0
21f19458:	e353002c 	cmp	r3, #44	; 0x2c
21f1945c:	1a000002 	bne	21f1946c <do_mii+0x280>
21f19460:	e59f3458 	ldr	r3, [pc, #1112]	; 21f198c0 <.text+0x198c0>
21f19464:	e50b3054 	str	r3, [fp, #-84]
21f19468:	ea000001 	b	21f19474 <do_mii+0x288>
21f1946c:	e59f3450 	ldr	r3, [pc, #1104]	; 21f198c4 <.text+0x198c4>
21f19470:	e50b3054 	str	r3, [fp, #-84]
21f19474:	e51b305c 	ldr	r3, [fp, #-92]
21f19478:	e58d3000 	str	r3, [sp]
21f1947c:	e51b3058 	ldr	r3, [fp, #-88]
21f19480:	e58d3004 	str	r3, [sp, #4]
21f19484:	e51b3054 	ldr	r3, [fp, #-84]
21f19488:	e58d3008 	str	r3, [sp, #8]
21f1948c:	e59f0434 	ldr	r0, [pc, #1076]	; 21f198c8 <.text+0x198c8>
21f19490:	e51b1068 	ldr	r1, [fp, #-104]
21f19494:	e51b2064 	ldr	r2, [fp, #-100]
21f19498:	e51b3060 	ldr	r3, [fp, #-96]
21f1949c:	eb00097a 	bl	21f1ba8c <printf>
21f194a0:	e55b3013 	ldrb	r3, [fp, #-19]
21f194a4:	e2833001 	add	r3, r3, #1	; 0x1
21f194a8:	e54b3013 	strb	r3, [fp, #-19]
21f194ac:	e55b2013 	ldrb	r2, [fp, #-19]
21f194b0:	e55b3011 	ldrb	r3, [fp, #-17]
21f194b4:	e1520003 	cmp	r2, r3
21f194b8:	9affffc7 	bls	21f193dc <do_mii+0x1f0>
21f194bc:	ea0000d9 	b	21f19828 <do_mii+0x63c>
					"OUI = 0x%04X, "
					"Model = 0x%02X, "
					"Rev = 0x%02X, "
					"%3dbaseT, %s\n",
					j, oui, model, rev,
					miiphy_speed (devname, j),
					(miiphy_duplex (devname, j) == FULL)
						? "FDX" : "HDX");
			}
		}
	} else if (op[0] == 'r') {
21f194c0:	e55b3020 	ldrb	r3, [fp, #-32]
21f194c4:	e3530072 	cmp	r3, #114	; 0x72
21f194c8:	1a000043 	bne	21f195dc <do_mii+0x3f0>
		for (addr = addrlo; addr <= addrhi; addr++) {
21f194cc:	e55b3021 	ldrb	r3, [fp, #-33]
21f194d0:	e54b301e 	strb	r3, [fp, #-30]
21f194d4:	ea00003b 	b	21f195c8 <do_mii+0x3dc>
			for (reg = reglo; reg <= reghi; reg++) {
21f194d8:	e55b3023 	ldrb	r3, [fp, #-35]
21f194dc:	e54b301d 	strb	r3, [fp, #-29]
21f194e0:	ea000027 	b	21f19584 <do_mii+0x398>
				data = 0xffff;
21f194e4:	e3e03000 	mvn	r3, #0	; 0x0
21f194e8:	e14b32b6 	strh	r3, [fp, #-38]
				if (miiphy_read (devname, addr, reg, &data) != 0) {
21f194ec:	e55b301e 	ldrb	r3, [fp, #-30]
21f194f0:	e55b201d 	ldrb	r2, [fp, #-29]
21f194f4:	e24bc026 	sub	ip, fp, #38	; 0x26
21f194f8:	e51b0018 	ldr	r0, [fp, #-24]
21f194fc:	e1a01003 	mov	r1, r3
21f19500:	e1a0300c 	mov	r3, ip
21f19504:	eb001c3c 	bl	21f205fc <miiphy_read>
21f19508:	e1a03000 	mov	r3, r0
21f1950c:	e3530000 	cmp	r3, #0	; 0x0
21f19510:	0a000007 	beq	21f19534 <do_mii+0x348>
					printf(
21f19514:	e55b301e 	ldrb	r3, [fp, #-30]
21f19518:	e55b201d 	ldrb	r2, [fp, #-29]
21f1951c:	e59f03a8 	ldr	r0, [pc, #936]	; 21f198cc <.text+0x198cc>
21f19520:	e1a01003 	mov	r1, r3
21f19524:	eb000958 	bl	21f1ba8c <printf>
					"Error reading from the PHY addr=%02x reg=%02x\n",
						addr, reg);
					rcode = 1;
21f19528:	e3a03001 	mov	r3, #1	; 0x1
21f1952c:	e50b301c 	str	r3, [fp, #-28]
21f19530:	ea000010 	b	21f19578 <do_mii+0x38c>
				} else {
					if ((addrlo != addrhi) || (reglo != reghi))
21f19534:	e55b2021 	ldrb	r2, [fp, #-33]
21f19538:	e55b3022 	ldrb	r3, [fp, #-34]
21f1953c:	e1520003 	cmp	r2, r3
21f19540:	1a000003 	bne	21f19554 <do_mii+0x368>
21f19544:	e55b2023 	ldrb	r2, [fp, #-35]
21f19548:	e55b3024 	ldrb	r3, [fp, #-36]
21f1954c:	e1520003 	cmp	r2, r3
21f19550:	0a000004 	beq	21f19568 <do_mii+0x37c>
						printf("addr=%02x reg=%02x data=",
21f19554:	e55b301e 	ldrb	r3, [fp, #-30]
21f19558:	e55b201d 	ldrb	r2, [fp, #-29]
21f1955c:	e59f036c 	ldr	r0, [pc, #876]	; 21f198d0 <.text+0x198d0>
21f19560:	e1a01003 	mov	r1, r3
21f19564:	eb000948 	bl	21f1ba8c <printf>
							(uint)addr, (uint)reg);
					printf("%04X\n", data & 0x0000FFFF);
21f19568:	e15b32b6 	ldrh	r3, [fp, #-38]
21f1956c:	e59f0360 	ldr	r0, [pc, #864]	; 21f198d4 <.text+0x198d4>
21f19570:	e1a01003 	mov	r1, r3
21f19574:	eb000944 	bl	21f1ba8c <printf>
21f19578:	e55b301d 	ldrb	r3, [fp, #-29]
21f1957c:	e2833001 	add	r3, r3, #1	; 0x1
21f19580:	e54b301d 	strb	r3, [fp, #-29]
21f19584:	e55b2024 	ldrb	r2, [fp, #-36]
21f19588:	e55b301d 	ldrb	r3, [fp, #-29]
21f1958c:	e1530002 	cmp	r3, r2
21f19590:	9affffd3 	bls	21f194e4 <do_mii+0x2f8>
				}
			}
			if ((addrlo != addrhi) && (reglo != reghi))
21f19594:	e55b2021 	ldrb	r2, [fp, #-33]
21f19598:	e55b3022 	ldrb	r3, [fp, #-34]
21f1959c:	e1520003 	cmp	r2, r3
21f195a0:	0a000005 	beq	21f195bc <do_mii+0x3d0>
21f195a4:	e55b2023 	ldrb	r2, [fp, #-35]
21f195a8:	e55b3024 	ldrb	r3, [fp, #-36]
21f195ac:	e1520003 	cmp	r2, r3
21f195b0:	0a000001 	beq	21f195bc <do_mii+0x3d0>
				printf("\n");
21f195b4:	e59f031c 	ldr	r0, [pc, #796]	; 21f198d8 <.text+0x198d8>
21f195b8:	eb000933 	bl	21f1ba8c <printf>
21f195bc:	e55b301e 	ldrb	r3, [fp, #-30]
21f195c0:	e2833001 	add	r3, r3, #1	; 0x1
21f195c4:	e54b301e 	strb	r3, [fp, #-30]
21f195c8:	e55b2022 	ldrb	r2, [fp, #-34]
21f195cc:	e55b301e 	ldrb	r3, [fp, #-30]
21f195d0:	e1530002 	cmp	r3, r2
21f195d4:	9affffbf 	bls	21f194d8 <do_mii+0x2ec>
21f195d8:	ea000092 	b	21f19828 <do_mii+0x63c>
		}
	} else if (op[0] == 'w') {
21f195dc:	e55b3020 	ldrb	r3, [fp, #-32]
21f195e0:	e3530077 	cmp	r3, #119	; 0x77
21f195e4:	1a000025 	bne	21f19680 <do_mii+0x494>
		for (addr = addrlo; addr <= addrhi; addr++) {
21f195e8:	e55b3021 	ldrb	r3, [fp, #-33]
21f195ec:	e54b301e 	strb	r3, [fp, #-30]
21f195f0:	ea00001d 	b	21f1966c <do_mii+0x480>
			for (reg = reglo; reg <= reghi; reg++) {
21f195f4:	e55b3023 	ldrb	r3, [fp, #-35]
21f195f8:	e54b301d 	strb	r3, [fp, #-29]
21f195fc:	ea000013 	b	21f19650 <do_mii+0x464>
				if (miiphy_write (devname, addr, reg, data) != 0) {
21f19600:	e55b201e 	ldrb	r2, [fp, #-30]
21f19604:	e55bc01d 	ldrb	ip, [fp, #-29]
21f19608:	e15b32b6 	ldrh	r3, [fp, #-38]
21f1960c:	e51b0018 	ldr	r0, [fp, #-24]
21f19610:	e1a01002 	mov	r1, r2
21f19614:	e1a0200c 	mov	r2, ip
21f19618:	eb001c4f 	bl	21f2075c <miiphy_write>
21f1961c:	e1a03000 	mov	r3, r0
21f19620:	e3530000 	cmp	r3, #0	; 0x0
21f19624:	0a000006 	beq	21f19644 <do_mii+0x458>
					printf("Error writing to the PHY addr=%02x reg=%02x\n",
21f19628:	e55b301e 	ldrb	r3, [fp, #-30]
21f1962c:	e55b201d 	ldrb	r2, [fp, #-29]
21f19630:	e59f02a4 	ldr	r0, [pc, #676]	; 21f198dc <.text+0x198dc>
21f19634:	e1a01003 	mov	r1, r3
21f19638:	eb000913 	bl	21f1ba8c <printf>
						addr, reg);
					rcode = 1;
21f1963c:	e3a03001 	mov	r3, #1	; 0x1
21f19640:	e50b301c 	str	r3, [fp, #-28]
21f19644:	e55b301d 	ldrb	r3, [fp, #-29]
21f19648:	e2833001 	add	r3, r3, #1	; 0x1
21f1964c:	e54b301d 	strb	r3, [fp, #-29]
21f19650:	e55b2024 	ldrb	r2, [fp, #-36]
21f19654:	e55b301d 	ldrb	r3, [fp, #-29]
21f19658:	e1530002 	cmp	r3, r2
21f1965c:	9affffe7 	bls	21f19600 <do_mii+0x414>
21f19660:	e55b301e 	ldrb	r3, [fp, #-30]
21f19664:	e2833001 	add	r3, r3, #1	; 0x1
21f19668:	e54b301e 	strb	r3, [fp, #-30]
21f1966c:	e55b2022 	ldrb	r2, [fp, #-34]
21f19670:	e55b301e 	ldrb	r3, [fp, #-30]
21f19674:	e1530002 	cmp	r3, r2
21f19678:	9affffdd 	bls	21f195f4 <do_mii+0x408>
21f1967c:	ea000069 	b	21f19828 <do_mii+0x63c>
				}
			}
		}
	} else if (strncmp(op, "du", 2) == 0) {
21f19680:	e24b3020 	sub	r3, fp, #32	; 0x20
21f19684:	e1a00003 	mov	r0, r3
21f19688:	e59f1250 	ldr	r1, [pc, #592]	; 21f198e0 <.text+0x198e0>
21f1968c:	e3a02002 	mov	r2, #2	; 0x2
21f19690:	eb0024d7 	bl	21f229f4 <strncmp>
21f19694:	e1a03000 	mov	r3, r0
21f19698:	e3530000 	cmp	r3, #0	; 0x0
21f1969c:	1a000046 	bne	21f197bc <do_mii+0x5d0>
		ushort regs[6];
		int ok = 1;
21f196a0:	e3a03001 	mov	r3, #1	; 0x1
21f196a4:	e50b3010 	str	r3, [fp, #-16]
		if ((reglo > 5) || (reghi > 5)) {
21f196a8:	e55b3023 	ldrb	r3, [fp, #-35]
21f196ac:	e3530005 	cmp	r3, #5	; 0x5
21f196b0:	8a000002 	bhi	21f196c0 <do_mii+0x4d4>
21f196b4:	e55b3024 	ldrb	r3, [fp, #-36]
21f196b8:	e3530005 	cmp	r3, #5	; 0x5
21f196bc:	9a000004 	bls	21f196d4 <do_mii+0x4e8>
			printf(
21f196c0:	e59f021c 	ldr	r0, [pc, #540]	; 21f198e4 <.text+0x198e4>
21f196c4:	eb0008f0 	bl	21f1ba8c <printf>
				"The MII dump command only formats the "
				"standard MII registers, 0-5.\n");
			return 1;
21f196c8:	e3a03001 	mov	r3, #1	; 0x1
21f196cc:	e50b3050 	str	r3, [fp, #-80]
21f196d0:	ea000070 	b	21f19898 <do_mii+0x6ac>
		}
		for (addr = addrlo; addr <= addrhi; addr++) {
21f196d4:	e55b3021 	ldrb	r3, [fp, #-33]
21f196d8:	e54b301e 	strb	r3, [fp, #-30]
21f196dc:	ea000031 	b	21f197a8 <do_mii+0x5bc>
			for (reg = reglo; reg < reghi + 1; reg++) {
21f196e0:	e55b3023 	ldrb	r3, [fp, #-35]
21f196e4:	e54b301d 	strb	r3, [fp, #-29]
21f196e8:	ea000018 	b	21f19750 <do_mii+0x564>
				if (miiphy_read(devname, addr, reg, &regs[reg]) != 0) {
21f196ec:	e55b101e 	ldrb	r1, [fp, #-30]
21f196f0:	e55bc01d 	ldrb	ip, [fp, #-29]
21f196f4:	e55b301d 	ldrb	r3, [fp, #-29]
21f196f8:	e1a03083 	mov	r3, r3, lsl #1
21f196fc:	e1a02003 	mov	r2, r3
21f19700:	e24b303a 	sub	r3, fp, #58	; 0x3a
21f19704:	e0833002 	add	r3, r3, r2
21f19708:	e51b0018 	ldr	r0, [fp, #-24]
21f1970c:	e1a0200c 	mov	r2, ip
21f19710:	eb001bb9 	bl	21f205fc <miiphy_read>
21f19714:	e1a03000 	mov	r3, r0
21f19718:	e3530000 	cmp	r3, #0	; 0x0
21f1971c:	0a000008 	beq	21f19744 <do_mii+0x558>
					ok = 0;
21f19720:	e3a03000 	mov	r3, #0	; 0x0
21f19724:	e50b3010 	str	r3, [fp, #-16]
					printf(
21f19728:	e55b301e 	ldrb	r3, [fp, #-30]
21f1972c:	e55b201d 	ldrb	r2, [fp, #-29]
21f19730:	e59f0194 	ldr	r0, [pc, #404]	; 21f198cc <.text+0x198cc>
21f19734:	e1a01003 	mov	r1, r3
21f19738:	eb0008d3 	bl	21f1ba8c <printf>
					"Error reading from the PHY addr=%02x reg=%02x\n",
						addr, reg);
					rcode = 1;
21f1973c:	e3a03001 	mov	r3, #1	; 0x1
21f19740:	e50b301c 	str	r3, [fp, #-28]
21f19744:	e55b301d 	ldrb	r3, [fp, #-29]
21f19748:	e2833001 	add	r3, r3, #1	; 0x1
21f1974c:	e54b301d 	strb	r3, [fp, #-29]
21f19750:	e55b201d 	ldrb	r2, [fp, #-29]
21f19754:	e55b3024 	ldrb	r3, [fp, #-36]
21f19758:	e2833001 	add	r3, r3, #1	; 0x1
21f1975c:	e1520003 	cmp	r2, r3
21f19760:	baffffe1 	blt	21f196ec <do_mii+0x500>
				}
			}
			if (ok)
21f19764:	e51b3010 	ldr	r3, [fp, #-16]
21f19768:	e3530000 	cmp	r3, #0	; 0x0
21f1976c:	0a000008 	beq	21f19794 <do_mii+0x5a8>
				MII_dump_0_to_5(regs, reglo, reghi);
21f19770:	e55b3023 	ldrb	r3, [fp, #-35]
21f19774:	e1a02003 	mov	r2, r3
21f19778:	e55b3024 	ldrb	r3, [fp, #-36]
21f1977c:	e1a0c003 	mov	ip, r3
21f19780:	e24b303a 	sub	r3, fp, #58	; 0x3a
21f19784:	e1a00003 	mov	r0, r3
21f19788:	e1a01002 	mov	r1, r2
21f1978c:	e1a0200c 	mov	r2, ip
21f19790:	ebfffce8 	bl	21f18b38 <MII_dump_0_to_5>
			printf("\n");
21f19794:	e59f013c 	ldr	r0, [pc, #316]	; 21f198d8 <.text+0x198d8>
21f19798:	eb0008bb 	bl	21f1ba8c <printf>
21f1979c:	e55b301e 	ldrb	r3, [fp, #-30]
21f197a0:	e2833001 	add	r3, r3, #1	; 0x1
21f197a4:	e54b301e 	strb	r3, [fp, #-30]
21f197a8:	e55b2022 	ldrb	r2, [fp, #-34]
21f197ac:	e55b301e 	ldrb	r3, [fp, #-30]
21f197b0:	e1530002 	cmp	r3, r2
21f197b4:	9affffc9 	bls	21f196e0 <do_mii+0x4f4>
21f197b8:	ea00001a 	b	21f19828 <do_mii+0x63c>
		}
	} else if (strncmp(op, "de", 2) == 0) {
21f197bc:	e24b3020 	sub	r3, fp, #32	; 0x20
21f197c0:	e1a00003 	mov	r0, r3
21f197c4:	e59f111c 	ldr	r1, [pc, #284]	; 21f198e8 <.text+0x198e8>
21f197c8:	e3a02002 	mov	r2, #2	; 0x2
21f197cc:	eb002488 	bl	21f229f4 <strncmp>
21f197d0:	e1a03000 	mov	r3, r0
21f197d4:	e3530000 	cmp	r3, #0	; 0x0
21f197d8:	1a00000a 	bne	21f19808 <do_mii+0x61c>
		if (argc == 2)
21f197dc:	e51b3048 	ldr	r3, [fp, #-72]
21f197e0:	e3530002 	cmp	r3, #2	; 0x2
21f197e4:	1a000001 	bne	21f197f0 <do_mii+0x604>
			miiphy_listdev ();
21f197e8:	eb001c35 	bl	21f208c4 <miiphy_listdev>
21f197ec:	ea00000d 	b	21f19828 <do_mii+0x63c>
		else
			miiphy_set_current_dev (argv[2]);
21f197f0:	e51b304c 	ldr	r3, [fp, #-76]
21f197f4:	e2833008 	add	r3, r3, #8	; 0x8
21f197f8:	e5933000 	ldr	r3, [r3]
21f197fc:	e1a00003 	mov	r0, r3
21f19800:	eb001b36 	bl	21f204e0 <miiphy_set_current_dev>
21f19804:	ea000007 	b	21f19828 <do_mii+0x63c>
	} else {
		printf("Usage:\n%s\n", cmdtp->usage);
21f19808:	e51b3040 	ldr	r3, [fp, #-64]
21f1980c:	e5933010 	ldr	r3, [r3, #16]
21f19810:	e59f00d4 	ldr	r0, [pc, #212]	; 21f198ec <.text+0x198ec>
21f19814:	e1a01003 	mov	r1, r3
21f19818:	eb00089b 	bl	21f1ba8c <printf>
		return 1;
21f1981c:	e3a03001 	mov	r3, #1	; 0x1
21f19820:	e50b3050 	str	r3, [fp, #-80]
21f19824:	ea00001b 	b	21f19898 <do_mii+0x6ac>
	}

	/*
	 * Save the parameters for repeats.
	 */
	last_op[0] = op[0];
21f19828:	e55b3020 	ldrb	r3, [fp, #-32]
21f1982c:	e59f2074 	ldr	r2, [pc, #116]	; 21f198a8 <.text+0x198a8>
21f19830:	e5c23000 	strb	r3, [r2]
	last_op[1] = op[1];
21f19834:	e55b301f 	ldrb	r3, [fp, #-31]
21f19838:	e59f2068 	ldr	r2, [pc, #104]	; 21f198a8 <.text+0x198a8>
21f1983c:	e5c23001 	strb	r3, [r2, #1]
	last_addr_lo = addrlo;
21f19840:	e55b3021 	ldrb	r3, [fp, #-33]
21f19844:	e1a02003 	mov	r2, r3
21f19848:	e59f305c 	ldr	r3, [pc, #92]	; 21f198ac <.text+0x198ac>
21f1984c:	e5832000 	str	r2, [r3]
	last_addr_hi = addrhi;
21f19850:	e55b3022 	ldrb	r3, [fp, #-34]
21f19854:	e1a02003 	mov	r2, r3
21f19858:	e59f3050 	ldr	r3, [pc, #80]	; 21f198b0 <.text+0x198b0>
21f1985c:	e5832000 	str	r2, [r3]
	last_reg_lo  = reglo;
21f19860:	e55b3023 	ldrb	r3, [fp, #-35]
21f19864:	e1a02003 	mov	r2, r3
21f19868:	e59f3044 	ldr	r3, [pc, #68]	; 21f198b4 <.text+0x198b4>
21f1986c:	e5832000 	str	r2, [r3]
	last_reg_hi  = reghi;
21f19870:	e55b3024 	ldrb	r3, [fp, #-36]
21f19874:	e1a02003 	mov	r2, r3
21f19878:	e59f3038 	ldr	r3, [pc, #56]	; 21f198b8 <.text+0x198b8>
21f1987c:	e5832000 	str	r2, [r3]
	last_data    = data;
21f19880:	e15b32b6 	ldrh	r3, [fp, #-38]
21f19884:	e1a02003 	mov	r2, r3
21f19888:	e59f302c 	ldr	r3, [pc, #44]	; 21f198bc <.text+0x198bc>
21f1988c:	e5832000 	str	r2, [r3]

	return rcode;
21f19890:	e51b301c 	ldr	r3, [fp, #-28]
21f19894:	e50b3050 	str	r3, [fp, #-80]
21f19898:	e51b3050 	ldr	r3, [fp, #-80]
}
21f1989c:	e1a00003 	mov	r0, r3
21f198a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f198a4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f198a8:	21f67740 	mvncss	r7, r0, asr #14
21f198ac:	21f67748 	mvncss	r7, r8, asr #14
21f198b0:	21f6774c 	mvncss	r7, ip, asr #14
21f198b4:	21f67750 	mvncss	r7, r0, asr r7
21f198b8:	21f67754 	mvncss	r7, r4, asr r7
21f198bc:	21f67744 	mvncss	r7, r4, asr #14
21f198c0:	21f31a68 	mvncss	r1, r8, ror #20
21f198c4:	21f31a6c 	mvncss	r1, ip, ror #20
21f198c8:	21f31a70 	mvncss	r1, r0, ror sl
21f198cc:	21f31ab8 	ldrcsh	r1, [r3, #168]!
21f198d0:	21f31ae8 	mvncss	r1, r8, ror #21
21f198d4:	21f31b04 	mvncss	r1, r4, lsl #22
21f198d8:	21f3198c 	mvncss	r1, ip, lsl #19
21f198dc:	21f31b0c 	mvncss	r1, ip, lsl #22
21f198e0:	21f31b3c 	mvncss	r1, ip, lsr fp
21f198e4:	21f31b40 	mvncss	r1, r0, asr #22
21f198e8:	21f31b84 	mvncss	r1, r4, lsl #23
21f198ec:	21f31b88 	mvncss	r1, r8, lsl #23

21f198f0 <do_mmc>:

#include <mmc.h>

int do_mmc (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f198f0:	e1a0c00d 	mov	ip, sp
21f198f4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f198f8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f198fc:	e24dd014 	sub	sp, sp, #20	; 0x14
21f19900:	e50b0010 	str	r0, [fp, #-16]
21f19904:	e50b1014 	str	r1, [fp, #-20]
21f19908:	e50b2018 	str	r2, [fp, #-24]
21f1990c:	e50b301c 	str	r3, [fp, #-28]
	if (mmc_init (1) != 0) {
21f19910:	e3a00001 	mov	r0, #1	; 0x1
21f19914:	ebffaee4 	bl	21f054ac <mmc_init>
21f19918:	e1a03000 	mov	r3, r0
21f1991c:	e3530000 	cmp	r3, #0	; 0x0
21f19920:	0a000004 	beq	21f19938 <do_mmc+0x48>
		printf ("No MMC card found\n");
21f19924:	e59f0024 	ldr	r0, [pc, #36]	; 21f19950 <.text+0x19950>
21f19928:	eb000857 	bl	21f1ba8c <printf>
		return 1;
21f1992c:	e3a03001 	mov	r3, #1	; 0x1
21f19930:	e50b3020 	str	r3, [fp, #-32]
21f19934:	ea000001 	b	21f19940 <do_mmc+0x50>
	}
	return 0;
21f19938:	e3a03000 	mov	r3, #0	; 0x0
21f1993c:	e50b3020 	str	r3, [fp, #-32]
21f19940:	e51b3020 	ldr	r3, [fp, #-32]
}
21f19944:	e1a00003 	mov	r0, r3
21f19948:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1994c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f19950:	21f31bb8 	ldrcsh	r1, [r3, #184]!

21f19954 <do_bootp>:

static int netboot_common (proto_t, cmd_tbl_t *, int , char *[]);

int do_bootp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f19954:	e1a0c00d 	mov	ip, sp
21f19958:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1995c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f19960:	e24dd010 	sub	sp, sp, #16	; 0x10
21f19964:	e50b0010 	str	r0, [fp, #-16]
21f19968:	e50b1014 	str	r1, [fp, #-20]
21f1996c:	e50b2018 	str	r2, [fp, #-24]
21f19970:	e50b301c 	str	r3, [fp, #-28]
	return netboot_common (BOOTP, cmdtp, argc, argv);
21f19974:	e3a00000 	mov	r0, #0	; 0x0
21f19978:	e51b1010 	ldr	r1, [fp, #-16]
21f1997c:	e51b2018 	ldr	r2, [fp, #-24]
21f19980:	e51b301c 	ldr	r3, [fp, #-28]
21f19984:	eb0000b8 	bl	21f19c6c <netboot_common>
21f19988:	e1a03000 	mov	r3, r0
}
21f1998c:	e1a00003 	mov	r0, r3
21f19990:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f19994:	e89da800 	ldmia	sp, {fp, sp, pc}

21f19998 <do_tftpb>:

U_BOOT_CMD(
	bootp,	3,	1,	do_bootp,
	"bootp\t- boot image via network using BootP/TFTP protocol\n",
	"[loadAddress] [bootfilename]\n"
);

int do_tftpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f19998:	e1a0c00d 	mov	ip, sp
21f1999c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f199a0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f199a4:	e24dd010 	sub	sp, sp, #16	; 0x10
21f199a8:	e50b0010 	str	r0, [fp, #-16]
21f199ac:	e50b1014 	str	r1, [fp, #-20]
21f199b0:	e50b2018 	str	r2, [fp, #-24]
21f199b4:	e50b301c 	str	r3, [fp, #-28]
	return netboot_common (TFTP, cmdtp, argc, argv);
21f199b8:	e3a00003 	mov	r0, #3	; 0x3
21f199bc:	e51b1010 	ldr	r1, [fp, #-16]
21f199c0:	e51b2018 	ldr	r2, [fp, #-24]
21f199c4:	e51b301c 	ldr	r3, [fp, #-28]
21f199c8:	eb0000a7 	bl	21f19c6c <netboot_common>
21f199cc:	e1a03000 	mov	r3, r0
}
21f199d0:	e1a00003 	mov	r0, r3
21f199d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f199d8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f199dc <do_rarpb>:

U_BOOT_CMD(
	tftpboot,	3,	1,	do_tftpb,
	"tftpboot- boot image via network using TFTP protocol\n",
	"[loadAddress] [bootfilename]\n"
);

int do_rarpb (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f199dc:	e1a0c00d 	mov	ip, sp
21f199e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f199e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f199e8:	e24dd010 	sub	sp, sp, #16	; 0x10
21f199ec:	e50b0010 	str	r0, [fp, #-16]
21f199f0:	e50b1014 	str	r1, [fp, #-20]
21f199f4:	e50b2018 	str	r2, [fp, #-24]
21f199f8:	e50b301c 	str	r3, [fp, #-28]
	return netboot_common (RARP, cmdtp, argc, argv);
21f199fc:	e3a00001 	mov	r0, #1	; 0x1
21f19a00:	e51b1010 	ldr	r1, [fp, #-16]
21f19a04:	e51b2018 	ldr	r2, [fp, #-24]
21f19a08:	e51b301c 	ldr	r3, [fp, #-28]
21f19a0c:	eb000096 	bl	21f19c6c <netboot_common>
21f19a10:	e1a03000 	mov	r3, r0
}
21f19a14:	e1a00003 	mov	r0, r3
21f19a18:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f19a1c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f19a20 <do_dhcp>:

U_BOOT_CMD(
	rarpboot,	3,	1,	do_rarpb,
	"rarpboot- boot image via network using RARP/TFTP protocol\n",
	"[loadAddress] [bootfilename]\n"
);

#if (CONFIG_COMMANDS & CFG_CMD_DHCP)
int do_dhcp (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f19a20:	e1a0c00d 	mov	ip, sp
21f19a24:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f19a28:	e24cb004 	sub	fp, ip, #4	; 0x4
21f19a2c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f19a30:	e50b0010 	str	r0, [fp, #-16]
21f19a34:	e50b1014 	str	r1, [fp, #-20]
21f19a38:	e50b2018 	str	r2, [fp, #-24]
21f19a3c:	e50b301c 	str	r3, [fp, #-28]
	return netboot_common(DHCP, cmdtp, argc, argv);
21f19a40:	e3a00004 	mov	r0, #4	; 0x4
21f19a44:	e51b1010 	ldr	r1, [fp, #-16]
21f19a48:	e51b2018 	ldr	r2, [fp, #-24]
21f19a4c:	e51b301c 	ldr	r3, [fp, #-28]
21f19a50:	eb000085 	bl	21f19c6c <netboot_common>
21f19a54:	e1a03000 	mov	r3, r0
}
21f19a58:	e1a00003 	mov	r0, r3
21f19a5c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f19a60:	e89da800 	ldmia	sp, {fp, sp, pc}

21f19a64 <do_nfs>:

U_BOOT_CMD(
	dhcp,	3,	1,	do_dhcp,
	"dhcp\t- invoke DHCP client to obtain IP/boot params\n",
	"\n"
);
#endif	/* CFG_CMD_DHCP */

#if (CONFIG_COMMANDS & CFG_CMD_NFS)
int do_nfs (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f19a64:	e1a0c00d 	mov	ip, sp
21f19a68:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f19a6c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f19a70:	e24dd010 	sub	sp, sp, #16	; 0x10
21f19a74:	e50b0010 	str	r0, [fp, #-16]
21f19a78:	e50b1014 	str	r1, [fp, #-20]
21f19a7c:	e50b2018 	str	r2, [fp, #-24]
21f19a80:	e50b301c 	str	r3, [fp, #-28]
	return netboot_common(NFS, cmdtp, argc, argv);
21f19a84:	e3a00007 	mov	r0, #7	; 0x7
21f19a88:	e51b1010 	ldr	r1, [fp, #-16]
21f19a8c:	e51b2018 	ldr	r2, [fp, #-24]
21f19a90:	e51b301c 	ldr	r3, [fp, #-28]
21f19a94:	eb000074 	bl	21f19c6c <netboot_common>
21f19a98:	e1a03000 	mov	r3, r0
}
21f19a9c:	e1a00003 	mov	r0, r3
21f19aa0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f19aa4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f19aa8 <netboot_update_env>:

U_BOOT_CMD(
	nfs,	3,	1,	do_nfs,
	"nfs\t- boot image via network using NFS protocol\n",
	"[loadAddress] [host ip addr:bootfilename]\n"
);
#endif	/* CFG_CMD_NFS */

static void netboot_update_env (void)
{
21f19aa8:	e1a0c00d 	mov	ip, sp
21f19aac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f19ab0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f19ab4:	e24dd018 	sub	sp, sp, #24	; 0x18
	char tmp[22];

	if (NetOurGatewayIP) {
21f19ab8:	e59f316c 	ldr	r3, [pc, #364]	; 21f19c2c <.text+0x19c2c>
21f19abc:	e5933000 	ldr	r3, [r3]
21f19ac0:	e3530000 	cmp	r3, #0	; 0x0
21f19ac4:	0a000009 	beq	21f19af0 <netboot_update_env+0x48>
		ip_to_string (NetOurGatewayIP, tmp);
21f19ac8:	e59f315c 	ldr	r3, [pc, #348]	; 21f19c2c <.text+0x19c2c>
21f19acc:	e5933000 	ldr	r3, [r3]
21f19ad0:	e24b2022 	sub	r2, fp, #34	; 0x22
21f19ad4:	e1a00003 	mov	r0, r3
21f19ad8:	e1a01002 	mov	r1, r2
21f19adc:	ebffc30a 	bl	21f0a70c <ip_to_string>
		setenv ("gatewayip", tmp);
21f19ae0:	e24b3022 	sub	r3, fp, #34	; 0x22
21f19ae4:	e59f0144 	ldr	r0, [pc, #324]	; 21f19c30 <.text+0x19c30>
21f19ae8:	e1a01003 	mov	r1, r3
21f19aec:	eb000415 	bl	21f1ab48 <setenv>
	}

	if (NetOurSubnetMask) {
21f19af0:	e59f313c 	ldr	r3, [pc, #316]	; 21f19c34 <.text+0x19c34>
21f19af4:	e5933000 	ldr	r3, [r3]
21f19af8:	e3530000 	cmp	r3, #0	; 0x0
21f19afc:	0a000009 	beq	21f19b28 <netboot_update_env+0x80>
		ip_to_string (NetOurSubnetMask, tmp);
21f19b00:	e59f312c 	ldr	r3, [pc, #300]	; 21f19c34 <.text+0x19c34>
21f19b04:	e5933000 	ldr	r3, [r3]
21f19b08:	e24b2022 	sub	r2, fp, #34	; 0x22
21f19b0c:	e1a00003 	mov	r0, r3
21f19b10:	e1a01002 	mov	r1, r2
21f19b14:	ebffc2fc 	bl	21f0a70c <ip_to_string>
		setenv ("netmask", tmp);
21f19b18:	e24b3022 	sub	r3, fp, #34	; 0x22
21f19b1c:	e59f0114 	ldr	r0, [pc, #276]	; 21f19c38 <.text+0x19c38>
21f19b20:	e1a01003 	mov	r1, r3
21f19b24:	eb000407 	bl	21f1ab48 <setenv>
	}

	if (NetOurHostName[0])
21f19b28:	e59f310c 	ldr	r3, [pc, #268]	; 21f19c3c <.text+0x19c3c>
21f19b2c:	e5d33000 	ldrb	r3, [r3]
21f19b30:	e3530000 	cmp	r3, #0	; 0x0
21f19b34:	0a000002 	beq	21f19b44 <netboot_update_env+0x9c>
		setenv ("hostname", NetOurHostName);
21f19b38:	e59f0100 	ldr	r0, [pc, #256]	; 21f19c40 <.text+0x19c40>
21f19b3c:	e59f10f8 	ldr	r1, [pc, #248]	; 21f19c3c <.text+0x19c3c>
21f19b40:	eb000400 	bl	21f1ab48 <setenv>

	if (NetOurRootPath[0])
21f19b44:	e59f30f8 	ldr	r3, [pc, #248]	; 21f19c44 <.text+0x19c44>
21f19b48:	e5d33000 	ldrb	r3, [r3]
21f19b4c:	e3530000 	cmp	r3, #0	; 0x0
21f19b50:	0a000002 	beq	21f19b60 <netboot_update_env+0xb8>
		setenv ("rootpath", NetOurRootPath);
21f19b54:	e59f00ec 	ldr	r0, [pc, #236]	; 21f19c48 <.text+0x19c48>
21f19b58:	e59f10e4 	ldr	r1, [pc, #228]	; 21f19c44 <.text+0x19c44>
21f19b5c:	eb0003f9 	bl	21f1ab48 <setenv>

	if (NetOurIP) {
21f19b60:	e59f30e4 	ldr	r3, [pc, #228]	; 21f19c4c <.text+0x19c4c>
21f19b64:	e5933000 	ldr	r3, [r3]
21f19b68:	e3530000 	cmp	r3, #0	; 0x0
21f19b6c:	0a000009 	beq	21f19b98 <netboot_update_env+0xf0>
		ip_to_string (NetOurIP, tmp);
21f19b70:	e59f30d4 	ldr	r3, [pc, #212]	; 21f19c4c <.text+0x19c4c>
21f19b74:	e5933000 	ldr	r3, [r3]
21f19b78:	e24b2022 	sub	r2, fp, #34	; 0x22
21f19b7c:	e1a00003 	mov	r0, r3
21f19b80:	e1a01002 	mov	r1, r2
21f19b84:	ebffc2e0 	bl	21f0a70c <ip_to_string>
		setenv ("ipaddr", tmp);
21f19b88:	e24b3022 	sub	r3, fp, #34	; 0x22
21f19b8c:	e59f00bc 	ldr	r0, [pc, #188]	; 21f19c50 <.text+0x19c50>
21f19b90:	e1a01003 	mov	r1, r3
21f19b94:	eb0003eb 	bl	21f1ab48 <setenv>
	}

	if (NetServerIP) {
21f19b98:	e59f30b4 	ldr	r3, [pc, #180]	; 21f19c54 <.text+0x19c54>
21f19b9c:	e5933000 	ldr	r3, [r3]
21f19ba0:	e3530000 	cmp	r3, #0	; 0x0
21f19ba4:	0a000009 	beq	21f19bd0 <netboot_update_env+0x128>
		ip_to_string (NetServerIP, tmp);
21f19ba8:	e59f30a4 	ldr	r3, [pc, #164]	; 21f19c54 <.text+0x19c54>
21f19bac:	e5933000 	ldr	r3, [r3]
21f19bb0:	e24b2022 	sub	r2, fp, #34	; 0x22
21f19bb4:	e1a00003 	mov	r0, r3
21f19bb8:	e1a01002 	mov	r1, r2
21f19bbc:	ebffc2d2 	bl	21f0a70c <ip_to_string>
		setenv ("serverip", tmp);
21f19bc0:	e24b3022 	sub	r3, fp, #34	; 0x22
21f19bc4:	e59f008c 	ldr	r0, [pc, #140]	; 21f19c58 <.text+0x19c58>
21f19bc8:	e1a01003 	mov	r1, r3
21f19bcc:	eb0003dd 	bl	21f1ab48 <setenv>
	}

	if (NetOurDNSIP) {
21f19bd0:	e59f3084 	ldr	r3, [pc, #132]	; 21f19c5c <.text+0x19c5c>
21f19bd4:	e5933000 	ldr	r3, [r3]
21f19bd8:	e3530000 	cmp	r3, #0	; 0x0
21f19bdc:	0a000009 	beq	21f19c08 <netboot_update_env+0x160>
		ip_to_string (NetOurDNSIP, tmp);
21f19be0:	e59f3074 	ldr	r3, [pc, #116]	; 21f19c5c <.text+0x19c5c>
21f19be4:	e5933000 	ldr	r3, [r3]
21f19be8:	e24b2022 	sub	r2, fp, #34	; 0x22
21f19bec:	e1a00003 	mov	r0, r3
21f19bf0:	e1a01002 	mov	r1, r2
21f19bf4:	ebffc2c4 	bl	21f0a70c <ip_to_string>
		setenv ("dnsip", tmp);
21f19bf8:	e24b3022 	sub	r3, fp, #34	; 0x22
21f19bfc:	e59f005c 	ldr	r0, [pc, #92]	; 21f19c60 <.text+0x19c60>
21f19c00:	e1a01003 	mov	r1, r3
21f19c04:	eb0003cf 	bl	21f1ab48 <setenv>
	}
#if (CONFIG_BOOTP_MASK & CONFIG_BOOTP_DNS2)
	if (NetOurDNS2IP) {
		ip_to_string (NetOurDNS2IP, tmp);
		setenv ("dnsip2", tmp);
	}
#endif
	if (NetOurNISDomain[0])
21f19c08:	e59f3054 	ldr	r3, [pc, #84]	; 21f19c64 <.text+0x19c64>
21f19c0c:	e5d33000 	ldrb	r3, [r3]
21f19c10:	e3530000 	cmp	r3, #0	; 0x0
21f19c14:	0a000002 	beq	21f19c24 <netboot_update_env+0x17c>
		setenv ("domain", NetOurNISDomain);
21f19c18:	e59f0048 	ldr	r0, [pc, #72]	; 21f19c68 <.text+0x19c68>
21f19c1c:	e59f1040 	ldr	r1, [pc, #64]	; 21f19c64 <.text+0x19c64>
21f19c20:	eb0003c8 	bl	21f1ab48 <setenv>

#if (CONFIG_COMMANDS & CFG_CMD_SNTP) && (CONFIG_BOOTP_MASK & CONFIG_BOOTP_TIMEOFFSET)
	if (NetTimeOffset) {
		sprintf (tmp, "%d", NetTimeOffset);
		setenv ("timeoffset", tmp);
	}
#endif
#if (CONFIG_COMMANDS & CFG_CMD_SNTP) && (CONFIG_BOOTP_MASK & CONFIG_BOOTP_NTPSERVER)
	if (NetNtpServerIP) {
		ip_to_string (NetNtpServerIP, tmp);
		setenv ("ntpserverip", tmp);
	}
#endif
}
21f19c24:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f19c28:	e89da800 	ldmia	sp, {fp, sp, pc}
21f19c2c:	21f644b4 	ldrcsh	r4, [r6, #68]!
21f19c30:	21f31d34 	mvncss	r1, r4, lsr sp
21f19c34:	21f644b0 	ldrcsh	r4, [r6, #64]!
21f19c38:	21f31d40 	mvncss	r1, r0, asr #26
21f19c3c:	21f644dc 	ldrcssb	r4, [r6, #76]!
21f19c40:	21f31d48 	mvncss	r1, r8, asr #26
21f19c44:	21f644fc 	ldrcssh	r4, [r6, #76]!
21f19c48:	21f31d54 	mvncss	r1, r4, asr sp
21f19c4c:	21f6455c 	mvncss	r4, ip, asr r5
21f19c50:	21f31d60 	mvncss	r1, r0, ror #26
21f19c54:	21f64560 	mvncss	r4, r0, ror #10
21f19c58:	21f31d68 	mvncss	r1, r8, ror #26
21f19c5c:	21f644b8 	ldrcsh	r4, [r6, #72]!
21f19c60:	21f31d74 	mvncss	r1, r4, ror sp
21f19c64:	21f644bc 	ldrcsh	r4, [r6, #76]!
21f19c68:	21f31d7c 	mvncss	r1, ip, ror sp

21f19c6c <netboot_common>:

static int
netboot_common (proto_t proto, cmd_tbl_t *cmdtp, int argc, char *argv[])
{
21f19c6c:	e1a0c00d 	mov	ip, sp
21f19c70:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f19c74:	e24cb004 	sub	fp, ip, #4	; 0x4
21f19c78:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f19c7c:	e50b0024 	str	r0, [fp, #-36]
21f19c80:	e50b1028 	str	r1, [fp, #-40]
21f19c84:	e50b202c 	str	r2, [fp, #-44]
21f19c88:	e50b3030 	str	r3, [fp, #-48]
	char *s;
	int   rcode = 0;
21f19c8c:	e3a03000 	mov	r3, #0	; 0x0
21f19c90:	e50b3014 	str	r3, [fp, #-20]
	int   size;

	/* pre-set load_addr */
	if ((s = getenv("loadaddr")) != NULL) {
21f19c94:	e59f0218 	ldr	r0, [pc, #536]	; 21f19eb4 <.text+0x19eb4>
21f19c98:	eb0003de 	bl	21f1ac18 <getenv>
21f19c9c:	e1a03000 	mov	r3, r0
21f19ca0:	e50b3018 	str	r3, [fp, #-24]
21f19ca4:	e51b3018 	ldr	r3, [fp, #-24]
21f19ca8:	e3530000 	cmp	r3, #0	; 0x0
21f19cac:	0a000006 	beq	21f19ccc <netboot_common+0x60>
		load_addr = simple_strtoul(s, NULL, 16);
21f19cb0:	e51b0018 	ldr	r0, [fp, #-24]
21f19cb4:	e3a01000 	mov	r1, #0	; 0x0
21f19cb8:	e3a02010 	mov	r2, #16	; 0x10
21f19cbc:	eb002641 	bl	21f235c8 <simple_strtoul>
21f19cc0:	e1a02000 	mov	r2, r0
21f19cc4:	e59f31ec 	ldr	r3, [pc, #492]	; 21f19eb8 <.text+0x19eb8>
21f19cc8:	e5832000 	str	r2, [r3]
	}

	switch (argc) {
21f19ccc:	e51b302c 	ldr	r3, [fp, #-44]
21f19cd0:	e50b3038 	str	r3, [fp, #-56]
21f19cd4:	e51b3038 	ldr	r3, [fp, #-56]
21f19cd8:	e3530002 	cmp	r3, #2	; 0x2
21f19cdc:	0a000006 	beq	21f19cfc <netboot_common+0x90>
21f19ce0:	e51b3038 	ldr	r3, [fp, #-56]
21f19ce4:	e3530003 	cmp	r3, #3	; 0x3
21f19ce8:	0a00001c 	beq	21f19d60 <netboot_common+0xf4>
21f19cec:	e51b3038 	ldr	r3, [fp, #-56]
21f19cf0:	e3530001 	cmp	r3, #1	; 0x1
21f19cf4:	0a000033 	beq	21f19dc8 <netboot_common+0x15c>
21f19cf8:	ea00002a 	b	21f19da8 <netboot_common+0x13c>
	case 1:
		break;

	case 2:	/* only one arg - accept two forms:
		 * just load address, or just boot file name.
		 * The latter form must be written "filename" here.
		 */
		if (argv[1][0] == '"') {	/* just boot filename */
21f19cfc:	e51b3030 	ldr	r3, [fp, #-48]
21f19d00:	e2833004 	add	r3, r3, #4	; 0x4
21f19d04:	e5933000 	ldr	r3, [r3]
21f19d08:	e5d33000 	ldrb	r3, [r3]
21f19d0c:	e3530022 	cmp	r3, #34	; 0x22
21f19d10:	1a000007 	bne	21f19d34 <netboot_common+0xc8>
			copy_filename (BootFile, argv[1], sizeof(BootFile));
21f19d14:	e51b3030 	ldr	r3, [fp, #-48]
21f19d18:	e2833004 	add	r3, r3, #4	; 0x4
21f19d1c:	e5933000 	ldr	r3, [r3]
21f19d20:	e59f0194 	ldr	r0, [pc, #404]	; 21f19ebc <.text+0x19ebc>
21f19d24:	e1a01003 	mov	r1, r3
21f19d28:	e3a02080 	mov	r2, #128	; 0x80
21f19d2c:	ebffc243 	bl	21f0a640 <copy_filename>
21f19d30:	ea000024 	b	21f19dc8 <netboot_common+0x15c>
		} else {			/* load address	*/
			load_addr = simple_strtoul(argv[1], NULL, 16);
21f19d34:	e51b3030 	ldr	r3, [fp, #-48]
21f19d38:	e2833004 	add	r3, r3, #4	; 0x4
21f19d3c:	e5933000 	ldr	r3, [r3]
21f19d40:	e1a00003 	mov	r0, r3
21f19d44:	e3a01000 	mov	r1, #0	; 0x0
21f19d48:	e3a02010 	mov	r2, #16	; 0x10
21f19d4c:	eb00261d 	bl	21f235c8 <simple_strtoul>
21f19d50:	e1a02000 	mov	r2, r0
21f19d54:	e59f315c 	ldr	r3, [pc, #348]	; 21f19eb8 <.text+0x19eb8>
21f19d58:	e5832000 	str	r2, [r3]
21f19d5c:	ea000019 	b	21f19dc8 <netboot_common+0x15c>
		}
		break;

	case 3:	load_addr = simple_strtoul(argv[1], NULL, 16);
21f19d60:	e51b3030 	ldr	r3, [fp, #-48]
21f19d64:	e2833004 	add	r3, r3, #4	; 0x4
21f19d68:	e5933000 	ldr	r3, [r3]
21f19d6c:	e1a00003 	mov	r0, r3
21f19d70:	e3a01000 	mov	r1, #0	; 0x0
21f19d74:	e3a02010 	mov	r2, #16	; 0x10
21f19d78:	eb002612 	bl	21f235c8 <simple_strtoul>
21f19d7c:	e1a02000 	mov	r2, r0
21f19d80:	e59f3130 	ldr	r3, [pc, #304]	; 21f19eb8 <.text+0x19eb8>
21f19d84:	e5832000 	str	r2, [r3]
		copy_filename (BootFile, argv[2], sizeof(BootFile));
21f19d88:	e51b3030 	ldr	r3, [fp, #-48]
21f19d8c:	e2833008 	add	r3, r3, #8	; 0x8
21f19d90:	e5933000 	ldr	r3, [r3]
21f19d94:	e59f0120 	ldr	r0, [pc, #288]	; 21f19ebc <.text+0x19ebc>
21f19d98:	e1a01003 	mov	r1, r3
21f19d9c:	e3a02080 	mov	r2, #128	; 0x80
21f19da0:	ebffc226 	bl	21f0a640 <copy_filename>

		break;
21f19da4:	ea000007 	b	21f19dc8 <netboot_common+0x15c>

	default: printf ("Usage:\n%s\n", cmdtp->usage);
21f19da8:	e51b3028 	ldr	r3, [fp, #-40]
21f19dac:	e5933010 	ldr	r3, [r3, #16]
21f19db0:	e59f0108 	ldr	r0, [pc, #264]	; 21f19ec0 <.text+0x19ec0>
21f19db4:	e1a01003 	mov	r1, r3
21f19db8:	eb000733 	bl	21f1ba8c <printf>
		return 1;
21f19dbc:	e3a03001 	mov	r3, #1	; 0x1
21f19dc0:	e50b3034 	str	r3, [fp, #-52]
21f19dc4:	ea000036 	b	21f19ea4 <netboot_common+0x238>
	}

	if ((size = NetLoop(proto)) < 0)
21f19dc8:	e51b0024 	ldr	r0, [fp, #-36]
21f19dcc:	ebffbbe4 	bl	21f08d64 <NetLoop>
21f19dd0:	e1a03000 	mov	r3, r0
21f19dd4:	e50b3010 	str	r3, [fp, #-16]
21f19dd8:	e51b3010 	ldr	r3, [fp, #-16]
21f19ddc:	e3530000 	cmp	r3, #0	; 0x0
21f19de0:	aa000002 	bge	21f19df0 <netboot_common+0x184>
		return 1;
21f19de4:	e3a03001 	mov	r3, #1	; 0x1
21f19de8:	e50b3034 	str	r3, [fp, #-52]
21f19dec:	ea00002c 	b	21f19ea4 <netboot_common+0x238>

	/* NetLoop ok, update environment */
	netboot_update_env();
21f19df0:	ebffff2c 	bl	21f19aa8 <netboot_update_env>

	/* done if no file was loaded (no errors though) */
	if (size == 0)
21f19df4:	e51b3010 	ldr	r3, [fp, #-16]
21f19df8:	e3530000 	cmp	r3, #0	; 0x0
21f19dfc:	1a000002 	bne	21f19e0c <netboot_common+0x1a0>
		return 0;
21f19e00:	e3a03000 	mov	r3, #0	; 0x0
21f19e04:	e50b3034 	str	r3, [fp, #-52]
21f19e08:	ea000025 	b	21f19ea4 <netboot_common+0x238>

	/* flush cache */
	flush_cache(load_addr, size);
21f19e0c:	e59f30a4 	ldr	r3, [pc, #164]	; 21f19eb8 <.text+0x19eb8>
21f19e10:	e5933000 	ldr	r3, [r3]
21f19e14:	e51b2010 	ldr	r2, [fp, #-16]
21f19e18:	e1a00003 	mov	r0, r3
21f19e1c:	e1a01002 	mov	r1, r2
21f19e20:	eb0053e2 	bl	21f2edb0 <flush_cache>

	/* Loading ok, check if we should attempt an auto-start */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s,"yes") == 0)) {
21f19e24:	e59f0098 	ldr	r0, [pc, #152]	; 21f19ec4 <.text+0x19ec4>
21f19e28:	eb00037a 	bl	21f1ac18 <getenv>
21f19e2c:	e1a03000 	mov	r3, r0
21f19e30:	e50b3018 	str	r3, [fp, #-24]
21f19e34:	e51b3018 	ldr	r3, [fp, #-24]
21f19e38:	e3530000 	cmp	r3, #0	; 0x0
21f19e3c:	0a000016 	beq	21f19e9c <netboot_common+0x230>
21f19e40:	e51b0018 	ldr	r0, [fp, #-24]
21f19e44:	e59f107c 	ldr	r1, [pc, #124]	; 21f19ec8 <.text+0x19ec8>
21f19e48:	eb0022bf 	bl	21f2294c <strcmp>
21f19e4c:	e1a03000 	mov	r3, r0
21f19e50:	e3530000 	cmp	r3, #0	; 0x0
21f19e54:	1a000010 	bne	21f19e9c <netboot_common+0x230>
		char *local_args[2];
		local_args[0] = argv[0];
21f19e58:	e51b3030 	ldr	r3, [fp, #-48]
21f19e5c:	e5933000 	ldr	r3, [r3]
21f19e60:	e50b3020 	str	r3, [fp, #-32]
		local_args[1] = NULL;
21f19e64:	e3a03000 	mov	r3, #0	; 0x0
21f19e68:	e50b301c 	str	r3, [fp, #-28]

		printf ("Automatic boot of image at addr 0x%08lX ...\n",
21f19e6c:	e59f3044 	ldr	r3, [pc, #68]	; 21f19eb8 <.text+0x19eb8>
21f19e70:	e5933000 	ldr	r3, [r3]
21f19e74:	e59f0050 	ldr	r0, [pc, #80]	; 21f19ecc <.text+0x19ecc>
21f19e78:	e1a01003 	mov	r1, r3
21f19e7c:	eb000702 	bl	21f1ba8c <printf>
			load_addr);
		rcode = do_bootm (cmdtp, 0, 1, local_args);
21f19e80:	e24b3020 	sub	r3, fp, #32	; 0x20
21f19e84:	e51b0028 	ldr	r0, [fp, #-40]
21f19e88:	e3a01000 	mov	r1, #0	; 0x0
21f19e8c:	e3a02001 	mov	r2, #1	; 0x1
21f19e90:	ebffdfbf 	bl	21f11d94 <do_bootm>
21f19e94:	e1a03000 	mov	r3, r0
21f19e98:	e50b3014 	str	r3, [fp, #-20]
	}

#ifdef CONFIG_AUTOSCRIPT
	if (((s = getenv("autoscript")) != NULL) && (strcmp(s,"yes") == 0)) {
		printf("Running autoscript at addr 0x%08lX ...\n", load_addr);
		rcode = autoscript (load_addr);
	}
#endif
	return rcode;
21f19e9c:	e51b3014 	ldr	r3, [fp, #-20]
21f19ea0:	e50b3034 	str	r3, [fp, #-52]
21f19ea4:	e51b3034 	ldr	r3, [fp, #-52]
}
21f19ea8:	e1a00003 	mov	r0, r3
21f19eac:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f19eb0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f19eb4:	21f31d84 	mvncss	r1, r4, lsl #27
21f19eb8:	21f3322c 	mvncss	r3, ip, lsr #4
21f19ebc:	21f64584 	mvncss	r4, r4, lsl #11
21f19ec0:	21f31d90 	ldrcsb	r1, [r3, #208]!
21f19ec4:	21f31d9c 	ldrcsb	r1, [r3, #220]!
21f19ec8:	21f31da8 	mvncss	r1, r8, lsr #27
21f19ecc:	21f31dac 	mvncss	r1, ip, lsr #27

21f19ed0 <do_printenv>:
 * Command interface: print one or all environment variables
 */

int do_printenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f19ed0:	e1a0c00d 	mov	ip, sp
21f19ed4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f19ed8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f19edc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f19ee0:	e50b0028 	str	r0, [fp, #-40]
21f19ee4:	e50b102c 	str	r1, [fp, #-44]
21f19ee8:	e50b2030 	str	r2, [fp, #-48]
21f19eec:	e50b3034 	str	r3, [fp, #-52]
	int i, j, k, nxt;
	int rcode = 0;
21f19ef0:	e3a03000 	mov	r3, #0	; 0x0
21f19ef4:	e50b3014 	str	r3, [fp, #-20]

	if (argc == 1) {		/* Print all env variables	*/
21f19ef8:	e51b3030 	ldr	r3, [fp, #-48]
21f19efc:	e3530001 	cmp	r3, #1	; 0x1
21f19f00:	1a000040 	bne	21f1a008 <do_printenv+0x138>
		for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
21f19f04:	e3a03000 	mov	r3, #0	; 0x0
21f19f08:	e50b3024 	str	r3, [fp, #-36]
21f19f0c:	ea00002d 	b	21f19fc8 <do_printenv+0xf8>
			for (nxt=i; env_get_char(nxt) != '\0'; ++nxt)
21f19f10:	e51b3024 	ldr	r3, [fp, #-36]
21f19f14:	e50b3018 	str	r3, [fp, #-24]
21f19f18:	ea000002 	b	21f19f28 <do_printenv+0x58>
21f19f1c:	e51b3018 	ldr	r3, [fp, #-24]
21f19f20:	e2833001 	add	r3, r3, #1	; 0x1
21f19f24:	e50b3018 	str	r3, [fp, #-24]
21f19f28:	e59f3254 	ldr	r3, [pc, #596]	; 21f1a184 <.text+0x1a184>
21f19f2c:	e5933000 	ldr	r3, [r3]
21f19f30:	e51b0018 	ldr	r0, [fp, #-24]
21f19f34:	e1a0e00f 	mov	lr, pc
21f19f38:	e1a0f003 	mov	pc, r3
21f19f3c:	e1a03000 	mov	r3, r0
21f19f40:	e3530000 	cmp	r3, #0	; 0x0
21f19f44:	1afffff4 	bne	21f19f1c <do_printenv+0x4c>
				;
			for (k=i; k<nxt; ++k)
21f19f48:	e51b3024 	ldr	r3, [fp, #-36]
21f19f4c:	e50b301c 	str	r3, [fp, #-28]
21f19f50:	ea00000a 	b	21f19f80 <do_printenv+0xb0>
				putc(env_get_char(k));
21f19f54:	e59f3228 	ldr	r3, [pc, #552]	; 21f1a184 <.text+0x1a184>
21f19f58:	e5933000 	ldr	r3, [r3]
21f19f5c:	e51b001c 	ldr	r0, [fp, #-28]
21f19f60:	e1a0e00f 	mov	lr, pc
21f19f64:	e1a0f003 	mov	pc, r3
21f19f68:	e1a03000 	mov	r3, r0
21f19f6c:	e1a00003 	mov	r0, r3
21f19f70:	eb00069c 	bl	21f1b9e8 <putc>
21f19f74:	e51b301c 	ldr	r3, [fp, #-28]
21f19f78:	e2833001 	add	r3, r3, #1	; 0x1
21f19f7c:	e50b301c 	str	r3, [fp, #-28]
21f19f80:	e51b201c 	ldr	r2, [fp, #-28]
21f19f84:	e51b3018 	ldr	r3, [fp, #-24]
21f19f88:	e1520003 	cmp	r2, r3
21f19f8c:	bafffff0 	blt	21f19f54 <do_printenv+0x84>
			putc  ('\n');
21f19f90:	e3a0000a 	mov	r0, #10	; 0xa
21f19f94:	eb000693 	bl	21f1b9e8 <putc>

			if (ctrlc()) {
21f19f98:	eb0006e4 	bl	21f1bb30 <ctrlc>
21f19f9c:	e1a03000 	mov	r3, r0
21f19fa0:	e3530000 	cmp	r3, #0	; 0x0
21f19fa4:	0a000004 	beq	21f19fbc <do_printenv+0xec>
				puts ("\n ** Abort\n");
21f19fa8:	e59f01d8 	ldr	r0, [pc, #472]	; 21f1a188 <.text+0x1a188>
21f19fac:	eb0006a3 	bl	21f1ba40 <puts>
				return 1;
21f19fb0:	e3a03001 	mov	r3, #1	; 0x1
21f19fb4:	e50b3038 	str	r3, [fp, #-56]
21f19fb8:	ea00006d 	b	21f1a174 <do_printenv+0x2a4>
21f19fbc:	e51b3018 	ldr	r3, [fp, #-24]
21f19fc0:	e2833001 	add	r3, r3, #1	; 0x1
21f19fc4:	e50b3024 	str	r3, [fp, #-36]
21f19fc8:	e59f31b4 	ldr	r3, [pc, #436]	; 21f1a184 <.text+0x1a184>
21f19fcc:	e5933000 	ldr	r3, [r3]
21f19fd0:	e51b0024 	ldr	r0, [fp, #-36]
21f19fd4:	e1a0e00f 	mov	lr, pc
21f19fd8:	e1a0f003 	mov	pc, r3
21f19fdc:	e1a03000 	mov	r3, r0
21f19fe0:	e3530000 	cmp	r3, #0	; 0x0
21f19fe4:	1affffc9 	bne	21f19f10 <do_printenv+0x40>
			}
		}

		printf("\nEnvironment size: %d/%d bytes\n", i, ENV_SIZE);
21f19fe8:	e59f019c 	ldr	r0, [pc, #412]	; 21f1a18c <.text+0x1a18c>
21f19fec:	e51b1024 	ldr	r1, [fp, #-36]
21f19ff0:	e3a02d7f 	mov	r2, #8128	; 0x1fc0
21f19ff4:	e282203c 	add	r2, r2, #60	; 0x3c
21f19ff8:	eb0006a3 	bl	21f1ba8c <printf>

		return 0;
21f19ffc:	e3a03000 	mov	r3, #0	; 0x0
21f1a000:	e50b3038 	str	r3, [fp, #-56]
21f1a004:	ea00005a 	b	21f1a174 <do_printenv+0x2a4>
	}

	for (i=1; i<argc; ++i) {	/* print single env variables	*/
21f1a008:	e3a03001 	mov	r3, #1	; 0x1
21f1a00c:	e50b3024 	str	r3, [fp, #-36]
21f1a010:	ea000051 	b	21f1a15c <do_printenv+0x28c>
		char *name = argv[i];
21f1a014:	e51b3024 	ldr	r3, [fp, #-36]
21f1a018:	e1a03103 	mov	r3, r3, lsl #2
21f1a01c:	e1a02003 	mov	r2, r3
21f1a020:	e51b3034 	ldr	r3, [fp, #-52]
21f1a024:	e0823003 	add	r3, r2, r3
21f1a028:	e5933000 	ldr	r3, [r3]
21f1a02c:	e50b3010 	str	r3, [fp, #-16]

		k = -1;
21f1a030:	e3e03000 	mvn	r3, #0	; 0x0
21f1a034:	e50b301c 	str	r3, [fp, #-28]

		for (j=0; env_get_char(j) != '\0'; j=nxt+1) {
21f1a038:	e3a03000 	mov	r3, #0	; 0x0
21f1a03c:	e50b3020 	str	r3, [fp, #-32]
21f1a040:	ea000031 	b	21f1a10c <do_printenv+0x23c>

			for (nxt=j; env_get_char(nxt) != '\0'; ++nxt)
21f1a044:	e51b3020 	ldr	r3, [fp, #-32]
21f1a048:	e50b3018 	str	r3, [fp, #-24]
21f1a04c:	ea000002 	b	21f1a05c <do_printenv+0x18c>
21f1a050:	e51b3018 	ldr	r3, [fp, #-24]
21f1a054:	e2833001 	add	r3, r3, #1	; 0x1
21f1a058:	e50b3018 	str	r3, [fp, #-24]
21f1a05c:	e59f3120 	ldr	r3, [pc, #288]	; 21f1a184 <.text+0x1a184>
21f1a060:	e5933000 	ldr	r3, [r3]
21f1a064:	e51b0018 	ldr	r0, [fp, #-24]
21f1a068:	e1a0e00f 	mov	lr, pc
21f1a06c:	e1a0f003 	mov	pc, r3
21f1a070:	e1a03000 	mov	r3, r0
21f1a074:	e3530000 	cmp	r3, #0	; 0x0
21f1a078:	1afffff4 	bne	21f1a050 <do_printenv+0x180>
				;
			k = envmatch((uchar *)name, j);
21f1a07c:	e51b3010 	ldr	r3, [fp, #-16]
21f1a080:	e1a00003 	mov	r0, r3
21f1a084:	e51b1020 	ldr	r1, [fp, #-32]
21f1a088:	eb0003a2 	bl	21f1af18 <envmatch>
21f1a08c:	e1a03000 	mov	r3, r0
21f1a090:	e50b301c 	str	r3, [fp, #-28]
			if (k < 0) {
21f1a094:	e51b301c 	ldr	r3, [fp, #-28]
21f1a098:	e3530000 	cmp	r3, #0	; 0x0
21f1a09c:	ba000017 	blt	21f1a100 <do_printenv+0x230>
				continue;
			}
			puts (name);
21f1a0a0:	e51b0010 	ldr	r0, [fp, #-16]
21f1a0a4:	eb000665 	bl	21f1ba40 <puts>
			putc ('=');
21f1a0a8:	e3a0003d 	mov	r0, #61	; 0x3d
21f1a0ac:	eb00064d 	bl	21f1b9e8 <putc>
			while (k < nxt)
21f1a0b0:	ea00000b 	b	21f1a0e4 <do_printenv+0x214>
				putc(env_get_char(k++));
21f1a0b4:	e59f30c8 	ldr	r3, [pc, #200]	; 21f1a184 <.text+0x1a184>
21f1a0b8:	e5931000 	ldr	r1, [r3]
21f1a0bc:	e51b201c 	ldr	r2, [fp, #-28]
21f1a0c0:	e51b301c 	ldr	r3, [fp, #-28]
21f1a0c4:	e2833001 	add	r3, r3, #1	; 0x1
21f1a0c8:	e50b301c 	str	r3, [fp, #-28]
21f1a0cc:	e1a00002 	mov	r0, r2
21f1a0d0:	e1a0e00f 	mov	lr, pc
21f1a0d4:	e1a0f001 	mov	pc, r1
21f1a0d8:	e1a03000 	mov	r3, r0
21f1a0dc:	e1a00003 	mov	r0, r3
21f1a0e0:	eb000640 	bl	21f1b9e8 <putc>
21f1a0e4:	e51b201c 	ldr	r2, [fp, #-28]
21f1a0e8:	e51b3018 	ldr	r3, [fp, #-24]
21f1a0ec:	e1520003 	cmp	r2, r3
21f1a0f0:	baffffef 	blt	21f1a0b4 <do_printenv+0x1e4>
			putc ('\n');
21f1a0f4:	e3a0000a 	mov	r0, #10	; 0xa
21f1a0f8:	eb00063a 	bl	21f1b9e8 <putc>
			break;
21f1a0fc:	ea00000a 	b	21f1a12c <do_printenv+0x25c>
21f1a100:	e51b3018 	ldr	r3, [fp, #-24]
21f1a104:	e2833001 	add	r3, r3, #1	; 0x1
21f1a108:	e50b3020 	str	r3, [fp, #-32]
21f1a10c:	e59f3070 	ldr	r3, [pc, #112]	; 21f1a184 <.text+0x1a184>
21f1a110:	e5933000 	ldr	r3, [r3]
21f1a114:	e51b0020 	ldr	r0, [fp, #-32]
21f1a118:	e1a0e00f 	mov	lr, pc
21f1a11c:	e1a0f003 	mov	pc, r3
21f1a120:	e1a03000 	mov	r3, r0
21f1a124:	e3530000 	cmp	r3, #0	; 0x0
21f1a128:	1affffc5 	bne	21f1a044 <do_printenv+0x174>
		}
		if (k < 0) {
21f1a12c:	e51b301c 	ldr	r3, [fp, #-28]
21f1a130:	e3530000 	cmp	r3, #0	; 0x0
21f1a134:	aa000005 	bge	21f1a150 <do_printenv+0x280>
			printf ("## Error: \"%s\" not defined\n", name);
21f1a138:	e59f0050 	ldr	r0, [pc, #80]	; 21f1a190 <.text+0x1a190>
21f1a13c:	e51b1010 	ldr	r1, [fp, #-16]
21f1a140:	eb000651 	bl	21f1ba8c <printf>
			rcode ++;
21f1a144:	e51b3014 	ldr	r3, [fp, #-20]
21f1a148:	e2833001 	add	r3, r3, #1	; 0x1
21f1a14c:	e50b3014 	str	r3, [fp, #-20]
21f1a150:	e51b3024 	ldr	r3, [fp, #-36]
21f1a154:	e2833001 	add	r3, r3, #1	; 0x1
21f1a158:	e50b3024 	str	r3, [fp, #-36]
21f1a15c:	e51b2024 	ldr	r2, [fp, #-36]
21f1a160:	e51b3030 	ldr	r3, [fp, #-48]
21f1a164:	e1520003 	cmp	r2, r3
21f1a168:	baffffa9 	blt	21f1a014 <do_printenv+0x144>
		}
	}
	return rcode;
21f1a16c:	e51b3014 	ldr	r3, [fp, #-20]
21f1a170:	e50b3038 	str	r3, [fp, #-56]
21f1a174:	e51b3038 	ldr	r3, [fp, #-56]
}
21f1a178:	e1a00003 	mov	r0, r3
21f1a17c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1a180:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1a184:	21f339a4 	mvncss	r3, r4, lsr #19
21f1a188:	21f31df0 	ldrcssh	r1, [r3, #208]!
21f1a18c:	21f31dfc 	ldrcssh	r1, [r3, #220]!
21f1a190:	21f31e1c 	mvncss	r1, ip, lsl lr

21f1a194 <_do_setenv>:

/************************************************************************
 * Set a new environment variable,
 * or replace or delete an existing one.
 *
 * This function will ONLY work with a in-RAM copy of the environment
 */

int _do_setenv (int flag, int argc, char *argv[])
{
21f1a194:	e1a0c00d 	mov	ip, sp
21f1a198:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1a19c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1a1a0:	e24dd070 	sub	sp, sp, #112	; 0x70
21f1a1a4:	e50b0058 	str	r0, [fp, #-88]
21f1a1a8:	e50b105c 	str	r1, [fp, #-92]
21f1a1ac:	e50b2060 	str	r2, [fp, #-96]
	int   i, len, oldval;
	int   console = -1;
21f1a1b0:	e3e03000 	mvn	r3, #0	; 0x0
21f1a1b4:	e50b3040 	str	r3, [fp, #-64]
	uchar *env, *nxt = NULL;
21f1a1b8:	e3a03000 	mov	r3, #0	; 0x0
21f1a1bc:	e50b3038 	str	r3, [fp, #-56]
	char *name;
	bd_t *bd = gd->bd;
21f1a1c0:	e1a03008 	mov	r3, r8
21f1a1c4:	e5933000 	ldr	r3, [r3]
21f1a1c8:	e50b3030 	str	r3, [fp, #-48]

	uchar *env_data = env_get_addr(0);
21f1a1cc:	e3a00000 	mov	r0, #0	; 0x0
21f1a1d0:	eb0012dd 	bl	21f1ed4c <env_get_addr>
21f1a1d4:	e1a03000 	mov	r3, r0
21f1a1d8:	e50b302c 	str	r3, [fp, #-44]

	if (!env_data)	/* need copy in RAM */
21f1a1dc:	e51b302c 	ldr	r3, [fp, #-44]
21f1a1e0:	e3530000 	cmp	r3, #0	; 0x0
21f1a1e4:	1a000002 	bne	21f1a1f4 <_do_setenv+0x60>
		return 1;
21f1a1e8:	e3a01001 	mov	r1, #1	; 0x1
21f1a1ec:	e50b107c 	str	r1, [fp, #-124]
21f1a1f0:	ea000228 	b	21f1aa98 <_do_setenv+0x904>

	name = argv[1];
21f1a1f4:	e51b3060 	ldr	r3, [fp, #-96]
21f1a1f8:	e2833004 	add	r3, r3, #4	; 0x4
21f1a1fc:	e5933000 	ldr	r3, [r3]
21f1a200:	e50b3034 	str	r3, [fp, #-52]

	if (strchr(name, '=')) {
21f1a204:	e51b0034 	ldr	r0, [fp, #-52]
21f1a208:	e3a0103d 	mov	r1, #61	; 0x3d
21f1a20c:	eb00222c 	bl	21f22ac4 <strchr>
21f1a210:	e1a03000 	mov	r3, r0
21f1a214:	e3530000 	cmp	r3, #0	; 0x0
21f1a218:	0a000005 	beq	21f1a234 <_do_setenv+0xa0>
		printf ("## Error: illegal character '=' in variable name \"%s\"\n", name);
21f1a21c:	e59f0884 	ldr	r0, [pc, #2180]	; 21f1aaa8 <.text+0x1aaa8>
21f1a220:	e51b1034 	ldr	r1, [fp, #-52]
21f1a224:	eb000618 	bl	21f1ba8c <printf>
		return 1;
21f1a228:	e3a03001 	mov	r3, #1	; 0x1
21f1a22c:	e50b307c 	str	r3, [fp, #-124]
21f1a230:	ea000218 	b	21f1aa98 <_do_setenv+0x904>
	}

	/*
	 * search if variable with this name already exists
	 */
	oldval = -1;
21f1a234:	e3e03000 	mvn	r3, #0	; 0x0
21f1a238:	e50b3044 	str	r3, [fp, #-68]
	for (env=env_data; *env; env=nxt+1) {
21f1a23c:	e51b302c 	ldr	r3, [fp, #-44]
21f1a240:	e50b303c 	str	r3, [fp, #-60]
21f1a244:	ea000018 	b	21f1a2ac <_do_setenv+0x118>
		for (nxt=env; *nxt; ++nxt)
21f1a248:	e51b303c 	ldr	r3, [fp, #-60]
21f1a24c:	e50b3038 	str	r3, [fp, #-56]
21f1a250:	ea000002 	b	21f1a260 <_do_setenv+0xcc>
21f1a254:	e51b3038 	ldr	r3, [fp, #-56]
21f1a258:	e2833001 	add	r3, r3, #1	; 0x1
21f1a25c:	e50b3038 	str	r3, [fp, #-56]
21f1a260:	e51b3038 	ldr	r3, [fp, #-56]
21f1a264:	e5d33000 	ldrb	r3, [r3]
21f1a268:	e3530000 	cmp	r3, #0	; 0x0
21f1a26c:	1afffff8 	bne	21f1a254 <_do_setenv+0xc0>
			;
		if ((oldval = envmatch((uchar *)name, env-env_data)) >= 0)
21f1a270:	e51b1034 	ldr	r1, [fp, #-52]
21f1a274:	e51b203c 	ldr	r2, [fp, #-60]
21f1a278:	e51b302c 	ldr	r3, [fp, #-44]
21f1a27c:	e0633002 	rsb	r3, r3, r2
21f1a280:	e1a00001 	mov	r0, r1
21f1a284:	e1a01003 	mov	r1, r3
21f1a288:	eb000322 	bl	21f1af18 <envmatch>
21f1a28c:	e1a03000 	mov	r3, r0
21f1a290:	e50b3044 	str	r3, [fp, #-68]
21f1a294:	e51b3044 	ldr	r3, [fp, #-68]
21f1a298:	e3530000 	cmp	r3, #0	; 0x0
21f1a29c:	aa000006 	bge	21f1a2bc <_do_setenv+0x128>
21f1a2a0:	e51b3038 	ldr	r3, [fp, #-56]
21f1a2a4:	e2833001 	add	r3, r3, #1	; 0x1
21f1a2a8:	e50b303c 	str	r3, [fp, #-60]
21f1a2ac:	e51b303c 	ldr	r3, [fp, #-60]
21f1a2b0:	e5d33000 	ldrb	r3, [r3]
21f1a2b4:	e3530000 	cmp	r3, #0	; 0x0
21f1a2b8:	1affffe2 	bne	21f1a248 <_do_setenv+0xb4>
			break;
	}

	/*
	 * Delete any existing definition
	 */
	if (oldval >= 0) {
21f1a2bc:	e51b3044 	ldr	r3, [fp, #-68]
21f1a2c0:	e3530000 	cmp	r3, #0	; 0x0
21f1a2c4:	ba0000aa 	blt	21f1a574 <_do_setenv+0x3e0>
#ifndef CONFIG_ENV_OVERWRITE

		/*
		 * Ethernet Address and serial# can be set only once,
		 * ver is readonly.
		 */
		if ( (strcmp (name, "serial#") == 0) ||
21f1a2c8:	e51b0034 	ldr	r0, [fp, #-52]
21f1a2cc:	e59f17d8 	ldr	r1, [pc, #2008]	; 21f1aaac <.text+0x1aaac>
21f1a2d0:	eb00219d 	bl	21f2294c <strcmp>
21f1a2d4:	e1a03000 	mov	r3, r0
21f1a2d8:	e3530000 	cmp	r3, #0	; 0x0
21f1a2dc:	0a000005 	beq	21f1a2f8 <_do_setenv+0x164>
21f1a2e0:	e51b0034 	ldr	r0, [fp, #-52]
21f1a2e4:	e59f17c4 	ldr	r1, [pc, #1988]	; 21f1aab0 <.text+0x1aab0>
21f1a2e8:	eb002197 	bl	21f2294c <strcmp>
21f1a2ec:	e1a03000 	mov	r3, r0
21f1a2f0:	e3530000 	cmp	r3, #0	; 0x0
21f1a2f4:	1a000005 	bne	21f1a310 <_do_setenv+0x17c>
		    ((strcmp (name, "ethaddr") == 0)
#if defined(CONFIG_OVERWRITE_ETHADDR_ONCE) && defined(CONFIG_ETHADDR)
		     && (strcmp ((char *)env_get_addr(oldval),MK_STR(CONFIG_ETHADDR)) != 0)
#endif	/* CONFIG_OVERWRITE_ETHADDR_ONCE && CONFIG_ETHADDR */
		    ) ) {
			printf ("Can't overwrite \"%s\"\n", name);
21f1a2f8:	e59f07b4 	ldr	r0, [pc, #1972]	; 21f1aab4 <.text+0x1aab4>
21f1a2fc:	e51b1034 	ldr	r1, [fp, #-52]
21f1a300:	eb0005e1 	bl	21f1ba8c <printf>
			return 1;
21f1a304:	e3a01001 	mov	r1, #1	; 0x1
21f1a308:	e50b107c 	str	r1, [fp, #-124]
21f1a30c:	ea0001e1 	b	21f1aa98 <_do_setenv+0x904>
		}
#endif

		/* Check for console redirection */
		if (strcmp(name,"stdin") == 0) {
21f1a310:	e51b0034 	ldr	r0, [fp, #-52]
21f1a314:	e59f179c 	ldr	r1, [pc, #1948]	; 21f1aab8 <.text+0x1aab8>
21f1a318:	eb00218b 	bl	21f2294c <strcmp>
21f1a31c:	e1a03000 	mov	r3, r0
21f1a320:	e3530000 	cmp	r3, #0	; 0x0
21f1a324:	1a000002 	bne	21f1a334 <_do_setenv+0x1a0>
			console = stdin;
21f1a328:	e3a03000 	mov	r3, #0	; 0x0
21f1a32c:	e50b3040 	str	r3, [fp, #-64]
21f1a330:	ea000010 	b	21f1a378 <_do_setenv+0x1e4>
		} else if (strcmp(name,"stdout") == 0) {
21f1a334:	e51b0034 	ldr	r0, [fp, #-52]
21f1a338:	e59f177c 	ldr	r1, [pc, #1916]	; 21f1aabc <.text+0x1aabc>
21f1a33c:	eb002182 	bl	21f2294c <strcmp>
21f1a340:	e1a03000 	mov	r3, r0
21f1a344:	e3530000 	cmp	r3, #0	; 0x0
21f1a348:	1a000002 	bne	21f1a358 <_do_setenv+0x1c4>
			console = stdout;
21f1a34c:	e3a03001 	mov	r3, #1	; 0x1
21f1a350:	e50b3040 	str	r3, [fp, #-64]
21f1a354:	ea000007 	b	21f1a378 <_do_setenv+0x1e4>
		} else if (strcmp(name,"stderr") == 0) {
21f1a358:	e51b0034 	ldr	r0, [fp, #-52]
21f1a35c:	e59f175c 	ldr	r1, [pc, #1884]	; 21f1aac0 <.text+0x1aac0>
21f1a360:	eb002179 	bl	21f2294c <strcmp>
21f1a364:	e1a03000 	mov	r3, r0
21f1a368:	e3530000 	cmp	r3, #0	; 0x0
21f1a36c:	1a000001 	bne	21f1a378 <_do_setenv+0x1e4>
			console = stderr;
21f1a370:	e3a03002 	mov	r3, #2	; 0x2
21f1a374:	e50b3040 	str	r3, [fp, #-64]
		}

		if (console != -1) {
21f1a378:	e51b3040 	ldr	r3, [fp, #-64]
21f1a37c:	e3730001 	cmn	r3, #1	; 0x1
21f1a380:	0a000014 	beq	21f1a3d8 <_do_setenv+0x244>
			if (argc < 3) {		/* Cannot delete it! */
21f1a384:	e51b305c 	ldr	r3, [fp, #-92]
21f1a388:	e3530002 	cmp	r3, #2	; 0x2
21f1a38c:	ca000005 	bgt	21f1a3a8 <_do_setenv+0x214>
				printf("Can't delete \"%s\"\n", name);
21f1a390:	e59f072c 	ldr	r0, [pc, #1836]	; 21f1aac4 <.text+0x1aac4>
21f1a394:	e51b1034 	ldr	r1, [fp, #-52]
21f1a398:	eb0005bb 	bl	21f1ba8c <printf>
				return 1;
21f1a39c:	e3a03001 	mov	r3, #1	; 0x1
21f1a3a0:	e50b307c 	str	r3, [fp, #-124]
21f1a3a4:	ea0001bb 	b	21f1aa98 <_do_setenv+0x904>
			}

			/* Try assigning specified device */
			if (console_assign (console, argv[2]) < 0)
21f1a3a8:	e51b3060 	ldr	r3, [fp, #-96]
21f1a3ac:	e2833008 	add	r3, r3, #8	; 0x8
21f1a3b0:	e5933000 	ldr	r3, [r3]
21f1a3b4:	e51b0040 	ldr	r0, [fp, #-64]
21f1a3b8:	e1a01003 	mov	r1, r3
21f1a3bc:	eb000623 	bl	21f1bc50 <console_assign>
21f1a3c0:	e1a03000 	mov	r3, r0
21f1a3c4:	e3530000 	cmp	r3, #0	; 0x0
21f1a3c8:	aa000002 	bge	21f1a3d8 <_do_setenv+0x244>
				return 1;
21f1a3cc:	e3a01001 	mov	r1, #1	; 0x1
21f1a3d0:	e50b107c 	str	r1, [fp, #-124]
21f1a3d4:	ea0001af 	b	21f1aa98 <_do_setenv+0x904>

#ifdef CONFIG_SERIAL_MULTI
			if (serial_assign (argv[2]) < 0)
				return 1;
#endif
		}

		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(argv[1],"baudrate") == 0) {
21f1a3d8:	e51b3060 	ldr	r3, [fp, #-96]
21f1a3dc:	e2833004 	add	r3, r3, #4	; 0x4
21f1a3e0:	e5933000 	ldr	r3, [r3]
21f1a3e4:	e1a00003 	mov	r0, r3
21f1a3e8:	e59f16d8 	ldr	r1, [pc, #1752]	; 21f1aac8 <.text+0x1aac8>
21f1a3ec:	eb002156 	bl	21f2294c <strcmp>
21f1a3f0:	e1a03000 	mov	r3, r0
21f1a3f4:	e3530000 	cmp	r3, #0	; 0x0
21f1a3f8:	1a000031 	bne	21f1a4c4 <_do_setenv+0x330>
			int baudrate = simple_strtoul(argv[2], NULL, 10);
21f1a3fc:	e51b3060 	ldr	r3, [fp, #-96]
21f1a400:	e2833008 	add	r3, r3, #8	; 0x8
21f1a404:	e5933000 	ldr	r3, [r3]
21f1a408:	e1a00003 	mov	r0, r3
21f1a40c:	e3a01000 	mov	r1, #0	; 0x0
21f1a410:	e3a0200a 	mov	r2, #10	; 0xa
21f1a414:	eb00246b 	bl	21f235c8 <simple_strtoul>
21f1a418:	e1a03000 	mov	r3, r0
21f1a41c:	e50b3028 	str	r3, [fp, #-40]
			int i;
			for (i=0; i<N_BAUDRATES; ++i) {
21f1a420:	e3a03000 	mov	r3, #0	; 0x0
21f1a424:	e50b3024 	str	r3, [fp, #-36]
21f1a428:	ea000008 	b	21f1a450 <_do_setenv+0x2bc>
				if (baudrate == baudrate_table[i])
21f1a42c:	e51b1028 	ldr	r1, [fp, #-40]
21f1a430:	e51b2024 	ldr	r2, [fp, #-36]
21f1a434:	e59f3690 	ldr	r3, [pc, #1680]	; 21f1aacc <.text+0x1aacc>
21f1a438:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1a43c:	e1510003 	cmp	r1, r3
21f1a440:	0a000005 	beq	21f1a45c <_do_setenv+0x2c8>
21f1a444:	e51b3024 	ldr	r3, [fp, #-36]
21f1a448:	e2833001 	add	r3, r3, #1	; 0x1
21f1a44c:	e50b3024 	str	r3, [fp, #-36]
21f1a450:	e51b3024 	ldr	r3, [fp, #-36]
21f1a454:	e3530004 	cmp	r3, #4	; 0x4
21f1a458:	9afffff3 	bls	21f1a42c <_do_setenv+0x298>
					break;
			}
			if (i == N_BAUDRATES) {
21f1a45c:	e51b3024 	ldr	r3, [fp, #-36]
21f1a460:	e3530005 	cmp	r3, #5	; 0x5
21f1a464:	1a000005 	bne	21f1a480 <_do_setenv+0x2ec>
				printf ("## Baudrate %d bps not supported\n",
21f1a468:	e59f0660 	ldr	r0, [pc, #1632]	; 21f1aad0 <.text+0x1aad0>
21f1a46c:	e51b1028 	ldr	r1, [fp, #-40]
21f1a470:	eb000585 	bl	21f1ba8c <printf>
					baudrate);
				return 1;
21f1a474:	e3a03001 	mov	r3, #1	; 0x1
21f1a478:	e50b307c 	str	r3, [fp, #-124]
21f1a47c:	ea000185 	b	21f1aa98 <_do_setenv+0x904>
			}
			printf ("## Switch baudrate to %d bps and press ENTER ...\n",
21f1a480:	e59f064c 	ldr	r0, [pc, #1612]	; 21f1aad4 <.text+0x1aad4>
21f1a484:	e51b1028 	ldr	r1, [fp, #-40]
21f1a488:	eb00057f 	bl	21f1ba8c <printf>
				baudrate);
			udelay(50000);
21f1a48c:	e3a00cc3 	mov	r0, #49920	; 0xc300
21f1a490:	e2800050 	add	r0, r0, #80	; 0x50
21f1a494:	ebff9983 	bl	21f00aa8 <udelay>
			gd->baudrate = baudrate;
21f1a498:	e1a02008 	mov	r2, r8
21f1a49c:	e51b3028 	ldr	r3, [fp, #-40]
21f1a4a0:	e5823008 	str	r3, [r2, #8]
#ifdef CONFIG_PPC
			gd->bd->bi_baudrate = baudrate;
#endif

			serial_setbrg ();
21f1a4a4:	eb004fa9 	bl	21f2e350 <serial_setbrg>
			udelay(50000);
21f1a4a8:	e3a00cc3 	mov	r0, #49920	; 0xc300
21f1a4ac:	e2800050 	add	r0, r0, #80	; 0x50
21f1a4b0:	ebff997c 	bl	21f00aa8 <udelay>
			for (;;) {
				if (getc() == '\r')
21f1a4b4:	eb00051f 	bl	21f1b938 <getc>
21f1a4b8:	e1a03000 	mov	r3, r0
21f1a4bc:	e353000d 	cmp	r3, #13	; 0xd
21f1a4c0:	1afffffb 	bne	21f1a4b4 <_do_setenv+0x320>
				      break;
			}
		}

		if (*++nxt == '\0') {
21f1a4c4:	e51b3038 	ldr	r3, [fp, #-56]
21f1a4c8:	e2833001 	add	r3, r3, #1	; 0x1
21f1a4cc:	e50b3038 	str	r3, [fp, #-56]
21f1a4d0:	e51b3038 	ldr	r3, [fp, #-56]
21f1a4d4:	e5d33000 	ldrb	r3, [r3]
21f1a4d8:	e3530000 	cmp	r3, #0	; 0x0
21f1a4dc:	1a00000b 	bne	21f1a510 <_do_setenv+0x37c>
			if (env > env_data) {
21f1a4e0:	e51b203c 	ldr	r2, [fp, #-60]
21f1a4e4:	e51b302c 	ldr	r3, [fp, #-44]
21f1a4e8:	e1520003 	cmp	r2, r3
21f1a4ec:	9a000003 	bls	21f1a500 <_do_setenv+0x36c>
				env--;
21f1a4f0:	e51b303c 	ldr	r3, [fp, #-60]
21f1a4f4:	e2433001 	sub	r3, r3, #1	; 0x1
21f1a4f8:	e50b303c 	str	r3, [fp, #-60]
21f1a4fc:	ea000016 	b	21f1a55c <_do_setenv+0x3c8>
			} else {
				*env = '\0';
21f1a500:	e51b303c 	ldr	r3, [fp, #-60]
21f1a504:	e3a02000 	mov	r2, #0	; 0x0
21f1a508:	e5c32000 	strb	r2, [r3]
21f1a50c:	ea000012 	b	21f1a55c <_do_setenv+0x3c8>
			}
		} else {
			for (;;) {
				*env = *nxt++;
21f1a510:	e51b3038 	ldr	r3, [fp, #-56]
21f1a514:	e5d33000 	ldrb	r3, [r3]
21f1a518:	e51b203c 	ldr	r2, [fp, #-60]
21f1a51c:	e5c23000 	strb	r3, [r2]
21f1a520:	e51b3038 	ldr	r3, [fp, #-56]
21f1a524:	e2833001 	add	r3, r3, #1	; 0x1
21f1a528:	e50b3038 	str	r3, [fp, #-56]
				if ((*env == '\0') && (*nxt == '\0'))
21f1a52c:	e51b303c 	ldr	r3, [fp, #-60]
21f1a530:	e5d33000 	ldrb	r3, [r3]
21f1a534:	e3530000 	cmp	r3, #0	; 0x0
21f1a538:	1a000003 	bne	21f1a54c <_do_setenv+0x3b8>
21f1a53c:	e51b3038 	ldr	r3, [fp, #-56]
21f1a540:	e5d33000 	ldrb	r3, [r3]
21f1a544:	e3530000 	cmp	r3, #0	; 0x0
21f1a548:	0a000003 	beq	21f1a55c <_do_setenv+0x3c8>
					break;
				++env;
21f1a54c:	e51b303c 	ldr	r3, [fp, #-60]
21f1a550:	e2833001 	add	r3, r3, #1	; 0x1
21f1a554:	e50b303c 	str	r3, [fp, #-60]
			}
21f1a558:	eaffffec 	b	21f1a510 <_do_setenv+0x37c>
		}
		*++env = '\0';
21f1a55c:	e51b303c 	ldr	r3, [fp, #-60]
21f1a560:	e2833001 	add	r3, r3, #1	; 0x1
21f1a564:	e50b303c 	str	r3, [fp, #-60]
21f1a568:	e51b203c 	ldr	r2, [fp, #-60]
21f1a56c:	e3a03000 	mov	r3, #0	; 0x0
21f1a570:	e5c23000 	strb	r3, [r2]
	}

#ifdef CONFIG_NET_MULTI
	if (strncmp(name, "eth", 3) == 0) {
		char *end;
		int   num = simple_strtoul(name+3, &end, 10);

		if (strcmp(end, "addr") == 0) {
			eth_set_enetaddr(num, argv[2]);
		}
	}
#endif


	/* Delete only ? */
	if ((argc < 3) || argv[2] == NULL) {
21f1a574:	e51b305c 	ldr	r3, [fp, #-92]
21f1a578:	e3530002 	cmp	r3, #2	; 0x2
21f1a57c:	da000004 	ble	21f1a594 <_do_setenv+0x400>
21f1a580:	e51b3060 	ldr	r3, [fp, #-96]
21f1a584:	e2833008 	add	r3, r3, #8	; 0x8
21f1a588:	e5933000 	ldr	r3, [r3]
21f1a58c:	e3530000 	cmp	r3, #0	; 0x0
21f1a590:	1a000003 	bne	21f1a5a4 <_do_setenv+0x410>
		env_crc_update ();
21f1a594:	eb0011ab 	bl	21f1ec48 <env_crc_update>
		return 0;
21f1a598:	e3a01000 	mov	r1, #0	; 0x0
21f1a59c:	e50b107c 	str	r1, [fp, #-124]
21f1a5a0:	ea00013c 	b	21f1aa98 <_do_setenv+0x904>
	}

	/*
	 * Append new definition at the end
	 */
	for (env=env_data; *env || *(env+1); ++env)
21f1a5a4:	e51b302c 	ldr	r3, [fp, #-44]
21f1a5a8:	e50b303c 	str	r3, [fp, #-60]
21f1a5ac:	ea000002 	b	21f1a5bc <_do_setenv+0x428>
21f1a5b0:	e51b303c 	ldr	r3, [fp, #-60]
21f1a5b4:	e2833001 	add	r3, r3, #1	; 0x1
21f1a5b8:	e50b303c 	str	r3, [fp, #-60]
21f1a5bc:	e51b303c 	ldr	r3, [fp, #-60]
21f1a5c0:	e5d33000 	ldrb	r3, [r3]
21f1a5c4:	e3530000 	cmp	r3, #0	; 0x0
21f1a5c8:	1afffff8 	bne	21f1a5b0 <_do_setenv+0x41c>
21f1a5cc:	e51b303c 	ldr	r3, [fp, #-60]
21f1a5d0:	e2833001 	add	r3, r3, #1	; 0x1
21f1a5d4:	e5d33000 	ldrb	r3, [r3]
21f1a5d8:	e3530000 	cmp	r3, #0	; 0x0
21f1a5dc:	1afffff3 	bne	21f1a5b0 <_do_setenv+0x41c>
		;
	if (env > env_data)
21f1a5e0:	e51b203c 	ldr	r2, [fp, #-60]
21f1a5e4:	e51b302c 	ldr	r3, [fp, #-44]
21f1a5e8:	e1520003 	cmp	r2, r3
21f1a5ec:	9a000002 	bls	21f1a5fc <_do_setenv+0x468>
		++env;
21f1a5f0:	e51b303c 	ldr	r3, [fp, #-60]
21f1a5f4:	e2833001 	add	r3, r3, #1	; 0x1
21f1a5f8:	e50b303c 	str	r3, [fp, #-60]
	/*
	 * Overflow when:
	 * "name" + "=" + "val" +"\0\0"  > ENV_SIZE - (env-env_data)
	 */
	len = strlen(name) + 2;
21f1a5fc:	e51b0034 	ldr	r0, [fp, #-52]
21f1a600:	eb00216f 	bl	21f22bc4 <strlen>
21f1a604:	e1a03000 	mov	r3, r0
21f1a608:	e2833002 	add	r3, r3, #2	; 0x2
21f1a60c:	e50b3048 	str	r3, [fp, #-72]
	/* add '=' for first arg, ' ' for all others */
	for (i=2; i<argc; ++i) {
21f1a610:	e3a03002 	mov	r3, #2	; 0x2
21f1a614:	e50b304c 	str	r3, [fp, #-76]
21f1a618:	ea00000f 	b	21f1a65c <_do_setenv+0x4c8>
		len += strlen(argv[i]) + 1;
21f1a61c:	e51b304c 	ldr	r3, [fp, #-76]
21f1a620:	e1a03103 	mov	r3, r3, lsl #2
21f1a624:	e1a02003 	mov	r2, r3
21f1a628:	e51b3060 	ldr	r3, [fp, #-96]
21f1a62c:	e0823003 	add	r3, r2, r3
21f1a630:	e5933000 	ldr	r3, [r3]
21f1a634:	e1a00003 	mov	r0, r3
21f1a638:	eb002161 	bl	21f22bc4 <strlen>
21f1a63c:	e1a02000 	mov	r2, r0
21f1a640:	e51b3048 	ldr	r3, [fp, #-72]
21f1a644:	e0823003 	add	r3, r2, r3
21f1a648:	e2833001 	add	r3, r3, #1	; 0x1
21f1a64c:	e50b3048 	str	r3, [fp, #-72]
21f1a650:	e51b304c 	ldr	r3, [fp, #-76]
21f1a654:	e2833001 	add	r3, r3, #1	; 0x1
21f1a658:	e50b304c 	str	r3, [fp, #-76]
21f1a65c:	e51b204c 	ldr	r2, [fp, #-76]
21f1a660:	e51b305c 	ldr	r3, [fp, #-92]
21f1a664:	e1520003 	cmp	r2, r3
21f1a668:	baffffeb 	blt	21f1a61c <_do_setenv+0x488>
	}
	if (len > (&env_data[ENV_SIZE]-env)) {
21f1a66c:	e51b202c 	ldr	r2, [fp, #-44]
21f1a670:	e51b303c 	ldr	r3, [fp, #-60]
21f1a674:	e0633002 	rsb	r3, r3, r2
21f1a678:	e2833d7f 	add	r3, r3, #8128	; 0x1fc0
21f1a67c:	e283303c 	add	r3, r3, #60	; 0x3c
21f1a680:	e51b2048 	ldr	r2, [fp, #-72]
21f1a684:	e1530002 	cmp	r3, r2
21f1a688:	aa000008 	bge	21f1a6b0 <_do_setenv+0x51c>
		printf ("## Error: environment overflow, \"%s\" deleted\n", name);
21f1a68c:	e59f0444 	ldr	r0, [pc, #1092]	; 21f1aad8 <.text+0x1aad8>
21f1a690:	e51b1034 	ldr	r1, [fp, #-52]
21f1a694:	eb0004fc 	bl	21f1ba8c <printf>
		return 1;
21f1a698:	e3a03001 	mov	r3, #1	; 0x1
21f1a69c:	e50b307c 	str	r3, [fp, #-124]
21f1a6a0:	ea0000fc 	b	21f1aa98 <_do_setenv+0x904>
	}
	while ((*env = *name++) != '\0')
		env++;
21f1a6a4:	e51b303c 	ldr	r3, [fp, #-60]
21f1a6a8:	e2833001 	add	r3, r3, #1	; 0x1
21f1a6ac:	e50b303c 	str	r3, [fp, #-60]
21f1a6b0:	e51b3034 	ldr	r3, [fp, #-52]
21f1a6b4:	e5d33000 	ldrb	r3, [r3]
21f1a6b8:	e51b203c 	ldr	r2, [fp, #-60]
21f1a6bc:	e5c23000 	strb	r3, [r2]
21f1a6c0:	e51b303c 	ldr	r3, [fp, #-60]
21f1a6c4:	e5d33000 	ldrb	r3, [r3]
21f1a6c8:	e3530000 	cmp	r3, #0	; 0x0
21f1a6cc:	03a03000 	moveq	r3, #0	; 0x0
21f1a6d0:	13a03001 	movne	r3, #1	; 0x1
21f1a6d4:	e20320ff 	and	r2, r3, #255	; 0xff
21f1a6d8:	e51b3034 	ldr	r3, [fp, #-52]
21f1a6dc:	e2833001 	add	r3, r3, #1	; 0x1
21f1a6e0:	e50b3034 	str	r3, [fp, #-52]
21f1a6e4:	e3520000 	cmp	r2, #0	; 0x0
21f1a6e8:	1affffed 	bne	21f1a6a4 <_do_setenv+0x510>
	for (i=2; i<argc; ++i) {
21f1a6ec:	e3a03002 	mov	r3, #2	; 0x2
21f1a6f0:	e50b304c 	str	r3, [fp, #-76]
21f1a6f4:	ea000027 	b	21f1a798 <_do_setenv+0x604>
		char *val = argv[i];
21f1a6f8:	e51b304c 	ldr	r3, [fp, #-76]
21f1a6fc:	e1a03103 	mov	r3, r3, lsl #2
21f1a700:	e1a02003 	mov	r2, r3
21f1a704:	e51b3060 	ldr	r3, [fp, #-96]
21f1a708:	e0823003 	add	r3, r2, r3
21f1a70c:	e5933000 	ldr	r3, [r3]
21f1a710:	e50b3020 	str	r3, [fp, #-32]

		*env = (i==2) ? '=' : ' ';
21f1a714:	e51b304c 	ldr	r3, [fp, #-76]
21f1a718:	e3530002 	cmp	r3, #2	; 0x2
21f1a71c:	1a000002 	bne	21f1a72c <_do_setenv+0x598>
21f1a720:	e3a0103d 	mov	r1, #61	; 0x3d
21f1a724:	e50b1078 	str	r1, [fp, #-120]
21f1a728:	ea000001 	b	21f1a734 <_do_setenv+0x5a0>
21f1a72c:	e3a03020 	mov	r3, #32	; 0x20
21f1a730:	e50b3078 	str	r3, [fp, #-120]
21f1a734:	e51b203c 	ldr	r2, [fp, #-60]
21f1a738:	e51b1078 	ldr	r1, [fp, #-120]
21f1a73c:	e1a03001 	mov	r3, r1
21f1a740:	e5c23000 	strb	r3, [r2]
		while ((*++env = *val++) != '\0')
21f1a744:	e51b303c 	ldr	r3, [fp, #-60]
21f1a748:	e2833001 	add	r3, r3, #1	; 0x1
21f1a74c:	e50b303c 	str	r3, [fp, #-60]
21f1a750:	e51b3020 	ldr	r3, [fp, #-32]
21f1a754:	e5d33000 	ldrb	r3, [r3]
21f1a758:	e51b203c 	ldr	r2, [fp, #-60]
21f1a75c:	e5c23000 	strb	r3, [r2]
21f1a760:	e51b303c 	ldr	r3, [fp, #-60]
21f1a764:	e5d33000 	ldrb	r3, [r3]
21f1a768:	e3530000 	cmp	r3, #0	; 0x0
21f1a76c:	03a03000 	moveq	r3, #0	; 0x0
21f1a770:	13a03001 	movne	r3, #1	; 0x1
21f1a774:	e20320ff 	and	r2, r3, #255	; 0xff
21f1a778:	e51b3020 	ldr	r3, [fp, #-32]
21f1a77c:	e2833001 	add	r3, r3, #1	; 0x1
21f1a780:	e50b3020 	str	r3, [fp, #-32]
21f1a784:	e3520000 	cmp	r2, #0	; 0x0
21f1a788:	1affffed 	bne	21f1a744 <_do_setenv+0x5b0>
21f1a78c:	e51b304c 	ldr	r3, [fp, #-76]
21f1a790:	e2833001 	add	r3, r3, #1	; 0x1
21f1a794:	e50b304c 	str	r3, [fp, #-76]
21f1a798:	e51b204c 	ldr	r2, [fp, #-76]
21f1a79c:	e51b305c 	ldr	r3, [fp, #-92]
21f1a7a0:	e1520003 	cmp	r2, r3
21f1a7a4:	baffffd3 	blt	21f1a6f8 <_do_setenv+0x564>
			;
	}

	/* end is marked with double '\0' */
	*++env = '\0';
21f1a7a8:	e51b303c 	ldr	r3, [fp, #-60]
21f1a7ac:	e2833001 	add	r3, r3, #1	; 0x1
21f1a7b0:	e50b303c 	str	r3, [fp, #-60]
21f1a7b4:	e51b203c 	ldr	r2, [fp, #-60]
21f1a7b8:	e3a03000 	mov	r3, #0	; 0x0
21f1a7bc:	e5c23000 	strb	r3, [r2]

	/* Update CRC */
	env_crc_update ();
21f1a7c0:	eb001120 	bl	21f1ec48 <env_crc_update>

	/*
	 * Some variables should be updated when the corresponding
	 * entry in the enviornment is changed
	 */

	if (strcmp(argv[1],"ethaddr") == 0) {
21f1a7c4:	e51b3060 	ldr	r3, [fp, #-96]
21f1a7c8:	e2833004 	add	r3, r3, #4	; 0x4
21f1a7cc:	e5933000 	ldr	r3, [r3]
21f1a7d0:	e1a00003 	mov	r0, r3
21f1a7d4:	e59f12d4 	ldr	r1, [pc, #724]	; 21f1aab0 <.text+0x1aab0>
21f1a7d8:	eb00205b 	bl	21f2294c <strcmp>
21f1a7dc:	e1a03000 	mov	r3, r0
21f1a7e0:	e3530000 	cmp	r3, #0	; 0x0
21f1a7e4:	1a000036 	bne	21f1a8c4 <_do_setenv+0x730>
		char *s = argv[2];	/* always use only one arg */
21f1a7e8:	e51b3060 	ldr	r3, [fp, #-96]
21f1a7ec:	e2833008 	add	r3, r3, #8	; 0x8
21f1a7f0:	e5933000 	ldr	r3, [r3]
21f1a7f4:	e50b301c 	str	r3, [fp, #-28]
		char *e;
		for (i=0; i<6; ++i) {
21f1a7f8:	e3a03000 	mov	r3, #0	; 0x0
21f1a7fc:	e50b304c 	str	r3, [fp, #-76]
21f1a800:	ea000029 	b	21f1a8ac <_do_setenv+0x718>
			bd->bi_enetaddr[i] = s ? simple_strtoul(s, &e, 16) : 0;
21f1a804:	e51b304c 	ldr	r3, [fp, #-76]
21f1a808:	e50b3074 	str	r3, [fp, #-116]
21f1a80c:	e51b301c 	ldr	r3, [fp, #-28]
21f1a810:	e3530000 	cmp	r3, #0	; 0x0
21f1a814:	0a000008 	beq	21f1a83c <_do_setenv+0x6a8>
21f1a818:	e24b3050 	sub	r3, fp, #80	; 0x50
21f1a81c:	e51b001c 	ldr	r0, [fp, #-28]
21f1a820:	e1a01003 	mov	r1, r3
21f1a824:	e3a02010 	mov	r2, #16	; 0x10
21f1a828:	eb002366 	bl	21f235c8 <simple_strtoul>
21f1a82c:	e1a03000 	mov	r3, r0
21f1a830:	e20330ff 	and	r3, r3, #255	; 0xff
21f1a834:	e50b3070 	str	r3, [fp, #-112]
21f1a838:	ea000001 	b	21f1a844 <_do_setenv+0x6b0>
21f1a83c:	e3a01000 	mov	r1, #0	; 0x0
21f1a840:	e50b1070 	str	r1, [fp, #-112]
21f1a844:	e51b3030 	ldr	r3, [fp, #-48]
21f1a848:	e3a02008 	mov	r2, #8	; 0x8
21f1a84c:	e51b1074 	ldr	r1, [fp, #-116]
21f1a850:	e0813003 	add	r3, r1, r3
21f1a854:	e0832002 	add	r2, r3, r2
21f1a858:	e51b1070 	ldr	r1, [fp, #-112]
21f1a85c:	e1a03001 	mov	r3, r1
21f1a860:	e5c23000 	strb	r3, [r2]
			if (s) s = (*e) ? e+1 : e;
21f1a864:	e51b301c 	ldr	r3, [fp, #-28]
21f1a868:	e3530000 	cmp	r3, #0	; 0x0
21f1a86c:	0a00000b 	beq	21f1a8a0 <_do_setenv+0x70c>
21f1a870:	e51b3050 	ldr	r3, [fp, #-80]
21f1a874:	e5d33000 	ldrb	r3, [r3]
21f1a878:	e3530000 	cmp	r3, #0	; 0x0
21f1a87c:	0a000003 	beq	21f1a890 <_do_setenv+0x6fc>
21f1a880:	e51b3050 	ldr	r3, [fp, #-80]
21f1a884:	e2833001 	add	r3, r3, #1	; 0x1
21f1a888:	e50b306c 	str	r3, [fp, #-108]
21f1a88c:	ea000001 	b	21f1a898 <_do_setenv+0x704>
21f1a890:	e51b3050 	ldr	r3, [fp, #-80]
21f1a894:	e50b306c 	str	r3, [fp, #-108]
21f1a898:	e51b106c 	ldr	r1, [fp, #-108]
21f1a89c:	e50b101c 	str	r1, [fp, #-28]
21f1a8a0:	e51b304c 	ldr	r3, [fp, #-76]
21f1a8a4:	e2833001 	add	r3, r3, #1	; 0x1
21f1a8a8:	e50b304c 	str	r3, [fp, #-76]
21f1a8ac:	e51b304c 	ldr	r3, [fp, #-76]
21f1a8b0:	e3530005 	cmp	r3, #5	; 0x5
21f1a8b4:	daffffd2 	ble	21f1a804 <_do_setenv+0x670>
		}
#ifdef CONFIG_NET_MULTI
		eth_set_enetaddr(0, argv[2]);
#endif
		return 0;
21f1a8b8:	e3a03000 	mov	r3, #0	; 0x0
21f1a8bc:	e50b307c 	str	r3, [fp, #-124]
21f1a8c0:	ea000074 	b	21f1aa98 <_do_setenv+0x904>
	}

	if (strcmp(argv[1],"ipaddr") == 0) {
21f1a8c4:	e51b3060 	ldr	r3, [fp, #-96]
21f1a8c8:	e2833004 	add	r3, r3, #4	; 0x4
21f1a8cc:	e5933000 	ldr	r3, [r3]
21f1a8d0:	e1a00003 	mov	r0, r3
21f1a8d4:	e59f1200 	ldr	r1, [pc, #512]	; 21f1aadc <.text+0x1aadc>
21f1a8d8:	eb00201b 	bl	21f2294c <strcmp>
21f1a8dc:	e1a03000 	mov	r3, r0
21f1a8e0:	e3530000 	cmp	r3, #0	; 0x0
21f1a8e4:	1a000040 	bne	21f1a9ec <_do_setenv+0x858>
		char *s = argv[2];	/* always use only one arg */
21f1a8e8:	e51b3060 	ldr	r3, [fp, #-96]
21f1a8ec:	e2833008 	add	r3, r3, #8	; 0x8
21f1a8f0:	e5933000 	ldr	r3, [r3]
21f1a8f4:	e50b3018 	str	r3, [fp, #-24]
		char *e;
		unsigned long addr;
		bd->bi_ip_addr = 0;
21f1a8f8:	e51b2030 	ldr	r2, [fp, #-48]
21f1a8fc:	e3a03000 	mov	r3, #0	; 0x0
21f1a900:	e5823004 	str	r3, [r2, #4]
		for (addr=0, i=0; i<4; ++i) {
21f1a904:	e3a03000 	mov	r3, #0	; 0x0
21f1a908:	e50b3014 	str	r3, [fp, #-20]
21f1a90c:	e3a03000 	mov	r3, #0	; 0x0
21f1a910:	e50b304c 	str	r3, [fp, #-76]
21f1a914:	ea000028 	b	21f1a9bc <_do_setenv+0x828>
			ulong val = s ? simple_strtoul(s, &e, 10) : 0;
21f1a918:	e51b3018 	ldr	r3, [fp, #-24]
21f1a91c:	e3530000 	cmp	r3, #0	; 0x0
21f1a920:	0a000007 	beq	21f1a944 <_do_setenv+0x7b0>
21f1a924:	e24b3054 	sub	r3, fp, #84	; 0x54
21f1a928:	e51b0018 	ldr	r0, [fp, #-24]
21f1a92c:	e1a01003 	mov	r1, r3
21f1a930:	e3a0200a 	mov	r2, #10	; 0xa
21f1a934:	eb002323 	bl	21f235c8 <simple_strtoul>
21f1a938:	e1a03000 	mov	r3, r0
21f1a93c:	e50b3068 	str	r3, [fp, #-104]
21f1a940:	ea000001 	b	21f1a94c <_do_setenv+0x7b8>
21f1a944:	e3a01000 	mov	r1, #0	; 0x0
21f1a948:	e50b1068 	str	r1, [fp, #-104]
21f1a94c:	e51b3068 	ldr	r3, [fp, #-104]
21f1a950:	e50b3010 	str	r3, [fp, #-16]
			addr <<= 8;
21f1a954:	e51b3014 	ldr	r3, [fp, #-20]
21f1a958:	e1a03403 	mov	r3, r3, lsl #8
21f1a95c:	e50b3014 	str	r3, [fp, #-20]
			addr  |= (val & 0xFF);
21f1a960:	e51b3010 	ldr	r3, [fp, #-16]
21f1a964:	e20320ff 	and	r2, r3, #255	; 0xff
21f1a968:	e51b3014 	ldr	r3, [fp, #-20]
21f1a96c:	e1833002 	orr	r3, r3, r2
21f1a970:	e50b3014 	str	r3, [fp, #-20]
			if (s) s = (*e) ? e+1 : e;
21f1a974:	e51b3018 	ldr	r3, [fp, #-24]
21f1a978:	e3530000 	cmp	r3, #0	; 0x0
21f1a97c:	0a00000b 	beq	21f1a9b0 <_do_setenv+0x81c>
21f1a980:	e51b3054 	ldr	r3, [fp, #-84]
21f1a984:	e5d33000 	ldrb	r3, [r3]
21f1a988:	e3530000 	cmp	r3, #0	; 0x0
21f1a98c:	0a000003 	beq	21f1a9a0 <_do_setenv+0x80c>
21f1a990:	e51b3054 	ldr	r3, [fp, #-84]
21f1a994:	e2833001 	add	r3, r3, #1	; 0x1
21f1a998:	e50b3064 	str	r3, [fp, #-100]
21f1a99c:	ea000001 	b	21f1a9a8 <_do_setenv+0x814>
21f1a9a0:	e51b1054 	ldr	r1, [fp, #-84]
21f1a9a4:	e50b1064 	str	r1, [fp, #-100]
21f1a9a8:	e51b3064 	ldr	r3, [fp, #-100]
21f1a9ac:	e50b3018 	str	r3, [fp, #-24]
21f1a9b0:	e51b304c 	ldr	r3, [fp, #-76]
21f1a9b4:	e2833001 	add	r3, r3, #1	; 0x1
21f1a9b8:	e50b304c 	str	r3, [fp, #-76]
21f1a9bc:	e51b304c 	ldr	r3, [fp, #-76]
21f1a9c0:	e3530003 	cmp	r3, #3	; 0x3
21f1a9c4:	daffffd3 	ble	21f1a918 <_do_setenv+0x784>
		}
		bd->bi_ip_addr = htonl(addr);
21f1a9c8:	e51b0014 	ldr	r0, [fp, #-20]
21f1a9cc:	eb000047 	bl	21f1aaf0 <__fswab32>
21f1a9d0:	e1a03000 	mov	r3, r0
21f1a9d4:	e1a02003 	mov	r2, r3
21f1a9d8:	e51b3030 	ldr	r3, [fp, #-48]
21f1a9dc:	e5832004 	str	r2, [r3, #4]
		return 0;
21f1a9e0:	e3a01000 	mov	r1, #0	; 0x0
21f1a9e4:	e50b107c 	str	r1, [fp, #-124]
21f1a9e8:	ea00002a 	b	21f1aa98 <_do_setenv+0x904>
	}
	if (strcmp(argv[1],"loadaddr") == 0) {
21f1a9ec:	e51b3060 	ldr	r3, [fp, #-96]
21f1a9f0:	e2833004 	add	r3, r3, #4	; 0x4
21f1a9f4:	e5933000 	ldr	r3, [r3]
21f1a9f8:	e1a00003 	mov	r0, r3
21f1a9fc:	e59f10dc 	ldr	r1, [pc, #220]	; 21f1aae0 <.text+0x1aae0>
21f1aa00:	eb001fd1 	bl	21f2294c <strcmp>
21f1aa04:	e1a03000 	mov	r3, r0
21f1aa08:	e3530000 	cmp	r3, #0	; 0x0
21f1aa0c:	1a00000c 	bne	21f1aa44 <_do_setenv+0x8b0>
		load_addr = simple_strtoul(argv[2], NULL, 16);
21f1aa10:	e51b3060 	ldr	r3, [fp, #-96]
21f1aa14:	e2833008 	add	r3, r3, #8	; 0x8
21f1aa18:	e5933000 	ldr	r3, [r3]
21f1aa1c:	e1a00003 	mov	r0, r3
21f1aa20:	e3a01000 	mov	r1, #0	; 0x0
21f1aa24:	e3a02010 	mov	r2, #16	; 0x10
21f1aa28:	eb0022e6 	bl	21f235c8 <simple_strtoul>
21f1aa2c:	e1a02000 	mov	r2, r0
21f1aa30:	e59f30ac 	ldr	r3, [pc, #172]	; 21f1aae4 <.text+0x1aae4>
21f1aa34:	e5832000 	str	r2, [r3]
		return 0;
21f1aa38:	e3a03000 	mov	r3, #0	; 0x0
21f1aa3c:	e50b307c 	str	r3, [fp, #-124]
21f1aa40:	ea000014 	b	21f1aa98 <_do_setenv+0x904>
	}
#if (CONFIG_COMMANDS & CFG_CMD_NET)
	if (strcmp(argv[1],"bootfile") == 0) {
21f1aa44:	e51b3060 	ldr	r3, [fp, #-96]
21f1aa48:	e2833004 	add	r3, r3, #4	; 0x4
21f1aa4c:	e5933000 	ldr	r3, [r3]
21f1aa50:	e1a00003 	mov	r0, r3
21f1aa54:	e59f108c 	ldr	r1, [pc, #140]	; 21f1aae8 <.text+0x1aae8>
21f1aa58:	eb001fbb 	bl	21f2294c <strcmp>
21f1aa5c:	e1a03000 	mov	r3, r0
21f1aa60:	e3530000 	cmp	r3, #0	; 0x0
21f1aa64:	1a000009 	bne	21f1aa90 <_do_setenv+0x8fc>
		copy_filename (BootFile, argv[2], sizeof(BootFile));
21f1aa68:	e51b3060 	ldr	r3, [fp, #-96]
21f1aa6c:	e2833008 	add	r3, r3, #8	; 0x8
21f1aa70:	e5933000 	ldr	r3, [r3]
21f1aa74:	e59f0070 	ldr	r0, [pc, #112]	; 21f1aaec <.text+0x1aaec>
21f1aa78:	e1a01003 	mov	r1, r3
21f1aa7c:	e3a02080 	mov	r2, #128	; 0x80
21f1aa80:	ebffbeee 	bl	21f0a640 <copy_filename>
		return 0;
21f1aa84:	e3a01000 	mov	r1, #0	; 0x0
21f1aa88:	e50b107c 	str	r1, [fp, #-124]
21f1aa8c:	ea000001 	b	21f1aa98 <_do_setenv+0x904>
	}
#endif	/* CFG_CMD_NET */

#ifdef CONFIG_AMIGAONEG3SE
	if (strcmp(argv[1], "vga_fg_color") == 0 ||
	    strcmp(argv[1], "vga_bg_color") == 0 ) {
		extern void video_set_color(unsigned char attr);
		extern unsigned char video_get_attr(void);

		video_set_color(video_get_attr());
		return 0;
	}
#endif	/* CONFIG_AMIGAONEG3SE */

	return 0;
21f1aa90:	e3a03000 	mov	r3, #0	; 0x0
21f1aa94:	e50b307c 	str	r3, [fp, #-124]
21f1aa98:	e51b307c 	ldr	r3, [fp, #-124]
}
21f1aa9c:	e1a00003 	mov	r0, r3
21f1aaa0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1aaa4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1aaa8:	21f31e38 	mvncss	r1, r8, lsr lr
21f1aaac:	21f31e70 	mvncss	r1, r0, ror lr
21f1aab0:	21f31e78 	mvncss	r1, r8, ror lr
21f1aab4:	21f31e80 	mvncss	r1, r0, lsl #29
21f1aab8:	21f31e98 	ldrcsb	r1, [r3, #232]!
21f1aabc:	21f31ea0 	mvncss	r1, r0, lsr #29
21f1aac0:	21f31ea8 	mvncss	r1, r8, lsr #29
21f1aac4:	21f31eb0 	ldrcsh	r1, [r3, #224]!
21f1aac8:	21f31ec4 	mvncss	r1, r4, asr #29
21f1aacc:	21f31ddc 	ldrcssb	r1, [r3, #220]!
21f1aad0:	21f31ed0 	ldrcssb	r1, [r3, #224]!
21f1aad4:	21f31ef4 	ldrcssh	r1, [r3, #228]!
21f1aad8:	21f31f28 	mvncss	r1, r8, lsr #30
21f1aadc:	21f31f58 	mvncss	r1, r8, asr pc
21f1aae0:	21f31f60 	mvncss	r1, r0, ror #30
21f1aae4:	21f3322c 	mvncss	r3, ip, lsr #4
21f1aae8:	21f31f6c 	mvncss	r1, ip, ror #30
21f1aaec:	21f64584 	mvncss	r4, r4, lsl #11

21f1aaf0 <__fswab32>:
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
21f1aaf0:	e1a0c00d 	mov	ip, sp
21f1aaf4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1aaf8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1aafc:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1ab00:	e50b0010 	str	r0, [fp, #-16]
	return __arch__swab32(x);
21f1ab04:	e51b3010 	ldr	r3, [fp, #-16]
21f1ab08:	e20330ff 	and	r3, r3, #255	; 0xff
21f1ab0c:	e1a02c03 	mov	r2, r3, lsl #24
21f1ab10:	e51b3010 	ldr	r3, [fp, #-16]
21f1ab14:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f1ab18:	e1a03403 	mov	r3, r3, lsl #8
21f1ab1c:	e1822003 	orr	r2, r2, r3
21f1ab20:	e51b3010 	ldr	r3, [fp, #-16]
21f1ab24:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f1ab28:	e1a03423 	mov	r3, r3, lsr #8
21f1ab2c:	e1822003 	orr	r2, r2, r3
21f1ab30:	e51b3010 	ldr	r3, [fp, #-16]
21f1ab34:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
21f1ab38:	e1a03c23 	mov	r3, r3, lsr #24
21f1ab3c:	e1823003 	orr	r3, r2, r3
}
21f1ab40:	e1a00003 	mov	r0, r3
21f1ab44:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1ab48 <setenv>:

void setenv (char *varname, char *varvalue)
{
21f1ab48:	e1a0c00d 	mov	ip, sp
21f1ab4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ab50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ab54:	e24dd018 	sub	sp, sp, #24	; 0x18
21f1ab58:	e50b0020 	str	r0, [fp, #-32]
21f1ab5c:	e50b1024 	str	r1, [fp, #-36]
	char *argv[4] = { "setenv", varname, varvalue, NULL };
21f1ab60:	e59f3034 	ldr	r3, [pc, #52]	; 21f1ab9c <.text+0x1ab9c>
21f1ab64:	e50b301c 	str	r3, [fp, #-28]
21f1ab68:	e51b3020 	ldr	r3, [fp, #-32]
21f1ab6c:	e50b3018 	str	r3, [fp, #-24]
21f1ab70:	e51b3024 	ldr	r3, [fp, #-36]
21f1ab74:	e50b3014 	str	r3, [fp, #-20]
21f1ab78:	e3a03000 	mov	r3, #0	; 0x0
21f1ab7c:	e50b3010 	str	r3, [fp, #-16]
	_do_setenv (0, 3, argv);
21f1ab80:	e24b301c 	sub	r3, fp, #28	; 0x1c
21f1ab84:	e3a00000 	mov	r0, #0	; 0x0
21f1ab88:	e3a01003 	mov	r1, #3	; 0x3
21f1ab8c:	e1a02003 	mov	r2, r3
21f1ab90:	ebfffd7f 	bl	21f1a194 <_do_setenv>
}
21f1ab94:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1ab98:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1ab9c:	21f31f78 	mvncss	r1, r8, ror pc

21f1aba0 <do_setenv>:

int do_setenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f1aba0:	e1a0c00d 	mov	ip, sp
21f1aba4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1aba8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1abac:	e24dd014 	sub	sp, sp, #20	; 0x14
21f1abb0:	e50b0010 	str	r0, [fp, #-16]
21f1abb4:	e50b1014 	str	r1, [fp, #-20]
21f1abb8:	e50b2018 	str	r2, [fp, #-24]
21f1abbc:	e50b301c 	str	r3, [fp, #-28]
	if (argc < 2) {
21f1abc0:	e51b3018 	ldr	r3, [fp, #-24]
21f1abc4:	e3530001 	cmp	r3, #1	; 0x1
21f1abc8:	ca000007 	bgt	21f1abec <do_setenv+0x4c>
		printf ("Usage:\n%s\n", cmdtp->usage);
21f1abcc:	e51b3010 	ldr	r3, [fp, #-16]
21f1abd0:	e5933010 	ldr	r3, [r3, #16]
21f1abd4:	e59f0038 	ldr	r0, [pc, #56]	; 21f1ac14 <.text+0x1ac14>
21f1abd8:	e1a01003 	mov	r1, r3
21f1abdc:	eb0003aa 	bl	21f1ba8c <printf>
		return 1;
21f1abe0:	e3a03001 	mov	r3, #1	; 0x1
21f1abe4:	e50b3020 	str	r3, [fp, #-32]
21f1abe8:	ea000005 	b	21f1ac04 <do_setenv+0x64>
	}

	return _do_setenv (flag, argc, argv);
21f1abec:	e51b0014 	ldr	r0, [fp, #-20]
21f1abf0:	e51b1018 	ldr	r1, [fp, #-24]
21f1abf4:	e51b201c 	ldr	r2, [fp, #-28]
21f1abf8:	ebfffd65 	bl	21f1a194 <_do_setenv>
21f1abfc:	e1a03000 	mov	r3, r0
21f1ac00:	e50b3020 	str	r3, [fp, #-32]
21f1ac04:	e51b3020 	ldr	r3, [fp, #-32]
}
21f1ac08:	e1a00003 	mov	r0, r3
21f1ac0c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1ac10:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1ac14:	21f31f80 	mvncss	r1, r0, lsl #31

21f1ac18 <getenv>:

/************************************************************************
 * Prompt for environment variable
 */

#if (CONFIG_COMMANDS & CFG_CMD_ASKENV)
int do_askenv ( cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	extern char console_buffer[CFG_CBSIZE];
	char message[CFG_CBSIZE];
	int size = CFG_CBSIZE - 1;
	int len;
	char *local_args[4];

	local_args[0] = argv[0];
	local_args[1] = argv[1];
	local_args[2] = NULL;
	local_args[3] = NULL;

	if (argc < 2) {
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;
	}
	/* Check the syntax */
	switch (argc) {
	case 1:
		printf ("Usage:\n%s\n", cmdtp->usage);
		return 1;

	case 2:		/* askenv envname */
		sprintf (message, "Please enter '%s':", argv[1]);
		break;

	case 3:		/* askenv envname size */
		sprintf (message, "Please enter '%s':", argv[1]);
		size = simple_strtoul (argv[2], NULL, 10);
		break;

	default:	/* askenv envname message1 ... messagen size */
	    {
		int i;
		int pos = 0;

		for (i = 2; i < argc - 1; i++) {
			if (pos) {
				message[pos++] = ' ';
			}
			strcpy (message+pos, argv[i]);
			pos += strlen(argv[i]);
		}
		message[pos] = '\0';
		size = simple_strtoul (argv[argc - 1], NULL, 10);
	    }
		break;
	}

	if (size >= CFG_CBSIZE)
		size = CFG_CBSIZE - 1;

	if (size <= 0)
		return 1;

	/* prompt for input */
	len = readline (message);

	if (size < len)
		console_buffer[size] = '\0';

	len = 2;
	if (console_buffer[0] != '\0') {
		local_args[2] = console_buffer;
		len = 3;
	}

	/* Continue calling setenv code */
	return _do_setenv (flag, len, local_args);
}
#endif	/* CFG_CMD_ASKENV */

/************************************************************************
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */

char *getenv (char *name)
{
21f1ac18:	e1a0c00d 	mov	ip, sp
21f1ac1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ac20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ac24:	e24dd014 	sub	sp, sp, #20	; 0x14
21f1ac28:	e50b001c 	str	r0, [fp, #-28]
	int i, nxt;

	WATCHDOG_RESET();

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
21f1ac2c:	e3a03000 	mov	r3, #0	; 0x0
21f1ac30:	e50b3018 	str	r3, [fp, #-24]
21f1ac34:	ea000026 	b	21f1acd4 <getenv+0xbc>
		int val;

		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
21f1ac38:	e51b3018 	ldr	r3, [fp, #-24]
21f1ac3c:	e50b3014 	str	r3, [fp, #-20]
21f1ac40:	ea00000a 	b	21f1ac70 <getenv+0x58>
			if (nxt >= CFG_ENV_SIZE) {
21f1ac44:	e51b2014 	ldr	r2, [fp, #-20]
21f1ac48:	e3a03d7f 	mov	r3, #8128	; 0x1fc0
21f1ac4c:	e283303f 	add	r3, r3, #63	; 0x3f
21f1ac50:	e1520003 	cmp	r2, r3
21f1ac54:	da000002 	ble	21f1ac64 <getenv+0x4c>
				return (NULL);
21f1ac58:	e3a03000 	mov	r3, #0	; 0x0
21f1ac5c:	e50b3020 	str	r3, [fp, #-32]
21f1ac60:	ea000025 	b	21f1acfc <getenv+0xe4>
21f1ac64:	e51b3014 	ldr	r3, [fp, #-20]
21f1ac68:	e2833001 	add	r3, r3, #1	; 0x1
21f1ac6c:	e50b3014 	str	r3, [fp, #-20]
21f1ac70:	e59f3094 	ldr	r3, [pc, #148]	; 21f1ad0c <.text+0x1ad0c>
21f1ac74:	e5933000 	ldr	r3, [r3]
21f1ac78:	e51b0014 	ldr	r0, [fp, #-20]
21f1ac7c:	e1a0e00f 	mov	lr, pc
21f1ac80:	e1a0f003 	mov	pc, r3
21f1ac84:	e1a03000 	mov	r3, r0
21f1ac88:	e3530000 	cmp	r3, #0	; 0x0
21f1ac8c:	1affffec 	bne	21f1ac44 <getenv+0x2c>
			}
		}
		if ((val=envmatch((uchar *)name, i)) < 0)
21f1ac90:	e51b301c 	ldr	r3, [fp, #-28]
21f1ac94:	e1a00003 	mov	r0, r3
21f1ac98:	e51b1018 	ldr	r1, [fp, #-24]
21f1ac9c:	eb00009d 	bl	21f1af18 <envmatch>
21f1aca0:	e1a03000 	mov	r3, r0
21f1aca4:	e50b3010 	str	r3, [fp, #-16]
21f1aca8:	e51b3010 	ldr	r3, [fp, #-16]
21f1acac:	e3530000 	cmp	r3, #0	; 0x0
21f1acb0:	ba000004 	blt	21f1acc8 <getenv+0xb0>
			continue;
		return ((char *)env_get_addr(val));
21f1acb4:	e51b0010 	ldr	r0, [fp, #-16]
21f1acb8:	eb001023 	bl	21f1ed4c <env_get_addr>
21f1acbc:	e1a03000 	mov	r3, r0
21f1acc0:	e50b3020 	str	r3, [fp, #-32]
21f1acc4:	ea00000c 	b	21f1acfc <getenv+0xe4>
21f1acc8:	e51b3014 	ldr	r3, [fp, #-20]
21f1accc:	e2833001 	add	r3, r3, #1	; 0x1
21f1acd0:	e50b3018 	str	r3, [fp, #-24]
21f1acd4:	e59f3030 	ldr	r3, [pc, #48]	; 21f1ad0c <.text+0x1ad0c>
21f1acd8:	e5933000 	ldr	r3, [r3]
21f1acdc:	e51b0018 	ldr	r0, [fp, #-24]
21f1ace0:	e1a0e00f 	mov	lr, pc
21f1ace4:	e1a0f003 	mov	pc, r3
21f1ace8:	e1a03000 	mov	r3, r0
21f1acec:	e3530000 	cmp	r3, #0	; 0x0
21f1acf0:	1affffd0 	bne	21f1ac38 <getenv+0x20>
	}

	return (NULL);
21f1acf4:	e3a03000 	mov	r3, #0	; 0x0
21f1acf8:	e50b3020 	str	r3, [fp, #-32]
21f1acfc:	e51b3020 	ldr	r3, [fp, #-32]
}
21f1ad00:	e1a00003 	mov	r0, r3
21f1ad04:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1ad08:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1ad0c:	21f339a4 	mvncss	r3, r4, lsr #19

21f1ad10 <getenv_r>:

int getenv_r (char *name, char *buf, unsigned len)
{
21f1ad10:	e1a0c00d 	mov	ip, sp
21f1ad14:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ad18:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ad1c:	e24dd020 	sub	sp, sp, #32	; 0x20
21f1ad20:	e50b0020 	str	r0, [fp, #-32]
21f1ad24:	e50b1024 	str	r1, [fp, #-36]
21f1ad28:	e50b2028 	str	r2, [fp, #-40]
	int i, nxt;

	for (i=0; env_get_char(i) != '\0'; i=nxt+1) {
21f1ad2c:	e3a03000 	mov	r3, #0	; 0x0
21f1ad30:	e50b301c 	str	r3, [fp, #-28]
21f1ad34:	ea000051 	b	21f1ae80 <getenv_r+0x170>
		int val, n;

		for (nxt=i; env_get_char(nxt) != '\0'; ++nxt) {
21f1ad38:	e51b301c 	ldr	r3, [fp, #-28]
21f1ad3c:	e50b3018 	str	r3, [fp, #-24]
21f1ad40:	ea00000a 	b	21f1ad70 <getenv_r+0x60>
			if (nxt >= CFG_ENV_SIZE) {
21f1ad44:	e51b2018 	ldr	r2, [fp, #-24]
21f1ad48:	e3a03d7f 	mov	r3, #8128	; 0x1fc0
21f1ad4c:	e283303f 	add	r3, r3, #63	; 0x3f
21f1ad50:	e1520003 	cmp	r2, r3
21f1ad54:	da000002 	ble	21f1ad64 <getenv_r+0x54>
				return (-1);
21f1ad58:	e3e03000 	mvn	r3, #0	; 0x0
21f1ad5c:	e50b302c 	str	r3, [fp, #-44]
21f1ad60:	ea000050 	b	21f1aea8 <getenv_r+0x198>
21f1ad64:	e51b3018 	ldr	r3, [fp, #-24]
21f1ad68:	e2833001 	add	r3, r3, #1	; 0x1
21f1ad6c:	e50b3018 	str	r3, [fp, #-24]
21f1ad70:	e59f3140 	ldr	r3, [pc, #320]	; 21f1aeb8 <.text+0x1aeb8>
21f1ad74:	e5933000 	ldr	r3, [r3]
21f1ad78:	e51b0018 	ldr	r0, [fp, #-24]
21f1ad7c:	e1a0e00f 	mov	lr, pc
21f1ad80:	e1a0f003 	mov	pc, r3
21f1ad84:	e1a03000 	mov	r3, r0
21f1ad88:	e3530000 	cmp	r3, #0	; 0x0
21f1ad8c:	1affffec 	bne	21f1ad44 <getenv_r+0x34>
			}
		}
		if ((val=envmatch((uchar *)name, i)) < 0)
21f1ad90:	e51b3020 	ldr	r3, [fp, #-32]
21f1ad94:	e1a00003 	mov	r0, r3
21f1ad98:	e51b101c 	ldr	r1, [fp, #-28]
21f1ad9c:	eb00005d 	bl	21f1af18 <envmatch>
21f1ada0:	e1a03000 	mov	r3, r0
21f1ada4:	e50b3014 	str	r3, [fp, #-20]
21f1ada8:	e51b3014 	ldr	r3, [fp, #-20]
21f1adac:	e3530000 	cmp	r3, #0	; 0x0
21f1adb0:	ba00002f 	blt	21f1ae74 <getenv_r+0x164>
			continue;
		/* found; copy out */
		n = 0;
21f1adb4:	e3a03000 	mov	r3, #0	; 0x0
21f1adb8:	e50b3010 	str	r3, [fp, #-16]
		while ((len > n++) && (*buf++ = env_get_char(val++)) != '\0')
21f1adbc:	e51b2010 	ldr	r2, [fp, #-16]
21f1adc0:	e51b3028 	ldr	r3, [fp, #-40]
21f1adc4:	e1520003 	cmp	r2, r3
21f1adc8:	23a03000 	movcs	r3, #0	; 0x0
21f1adcc:	33a03001 	movcc	r3, #1	; 0x1
21f1add0:	e20320ff 	and	r2, r3, #255	; 0xff
21f1add4:	e51b3010 	ldr	r3, [fp, #-16]
21f1add8:	e2833001 	add	r3, r3, #1	; 0x1
21f1addc:	e50b3010 	str	r3, [fp, #-16]
21f1ade0:	e2223001 	eor	r3, r2, #1	; 0x1
21f1ade4:	e20330ff 	and	r3, r3, #255	; 0xff
21f1ade8:	e3530000 	cmp	r3, #0	; 0x0
21f1adec:	1a000016 	bne	21f1ae4c <getenv_r+0x13c>
21f1adf0:	e59f30c0 	ldr	r3, [pc, #192]	; 21f1aeb8 <.text+0x1aeb8>
21f1adf4:	e5931000 	ldr	r1, [r3]
21f1adf8:	e51b2014 	ldr	r2, [fp, #-20]
21f1adfc:	e51b3014 	ldr	r3, [fp, #-20]
21f1ae00:	e2833001 	add	r3, r3, #1	; 0x1
21f1ae04:	e50b3014 	str	r3, [fp, #-20]
21f1ae08:	e1a00002 	mov	r0, r2
21f1ae0c:	e1a0e00f 	mov	lr, pc
21f1ae10:	e1a0f001 	mov	pc, r1
21f1ae14:	e1a03000 	mov	r3, r0
21f1ae18:	e51b2024 	ldr	r2, [fp, #-36]
21f1ae1c:	e5c23000 	strb	r3, [r2]
21f1ae20:	e51b3024 	ldr	r3, [fp, #-36]
21f1ae24:	e5d33000 	ldrb	r3, [r3]
21f1ae28:	e3530000 	cmp	r3, #0	; 0x0
21f1ae2c:	03a03000 	moveq	r3, #0	; 0x0
21f1ae30:	13a03001 	movne	r3, #1	; 0x1
21f1ae34:	e20320ff 	and	r2, r3, #255	; 0xff
21f1ae38:	e51b3024 	ldr	r3, [fp, #-36]
21f1ae3c:	e2833001 	add	r3, r3, #1	; 0x1
21f1ae40:	e50b3024 	str	r3, [fp, #-36]
21f1ae44:	e3520000 	cmp	r2, #0	; 0x0
21f1ae48:	1affffdb 	bne	21f1adbc <getenv_r+0xac>
			;
		if (len == n)
21f1ae4c:	e51b2010 	ldr	r2, [fp, #-16]
21f1ae50:	e51b3028 	ldr	r3, [fp, #-40]
21f1ae54:	e1520003 	cmp	r2, r3
21f1ae58:	1a000002 	bne	21f1ae68 <getenv_r+0x158>
			*buf = '\0';
21f1ae5c:	e51b3024 	ldr	r3, [fp, #-36]
21f1ae60:	e3a02000 	mov	r2, #0	; 0x0
21f1ae64:	e5c32000 	strb	r2, [r3]
		return (n);
21f1ae68:	e51b3010 	ldr	r3, [fp, #-16]
21f1ae6c:	e50b302c 	str	r3, [fp, #-44]
21f1ae70:	ea00000c 	b	21f1aea8 <getenv_r+0x198>
21f1ae74:	e51b3018 	ldr	r3, [fp, #-24]
21f1ae78:	e2833001 	add	r3, r3, #1	; 0x1
21f1ae7c:	e50b301c 	str	r3, [fp, #-28]
21f1ae80:	e59f3030 	ldr	r3, [pc, #48]	; 21f1aeb8 <.text+0x1aeb8>
21f1ae84:	e5933000 	ldr	r3, [r3]
21f1ae88:	e51b001c 	ldr	r0, [fp, #-28]
21f1ae8c:	e1a0e00f 	mov	lr, pc
21f1ae90:	e1a0f003 	mov	pc, r3
21f1ae94:	e1a03000 	mov	r3, r0
21f1ae98:	e3530000 	cmp	r3, #0	; 0x0
21f1ae9c:	1affffa5 	bne	21f1ad38 <getenv_r+0x28>
	}
	return (-1);
21f1aea0:	e3e03000 	mvn	r3, #0	; 0x0
21f1aea4:	e50b302c 	str	r3, [fp, #-44]
21f1aea8:	e51b302c 	ldr	r3, [fp, #-44]
}
21f1aeac:	e1a00003 	mov	r0, r3
21f1aeb0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1aeb4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1aeb8:	21f339a4 	mvncss	r3, r4, lsr #19

21f1aebc <do_saveenv>:

#if defined(CFG_ENV_IS_IN_NVRAM) || defined(CFG_ENV_IS_IN_EEPROM) || \
    ((CONFIG_COMMANDS & (CFG_CMD_ENV|CFG_CMD_FLASH)) == \
      (CFG_CMD_ENV|CFG_CMD_FLASH)) || \
    ((CONFIG_COMMANDS & (CFG_CMD_ENV|CFG_CMD_NAND)) == \
      (CFG_CMD_ENV|CFG_CMD_NAND))
int do_saveenv (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f1aebc:	e1a0c00d 	mov	ip, sp
21f1aec0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1aec4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1aec8:	e24dd010 	sub	sp, sp, #16	; 0x10
21f1aecc:	e50b0010 	str	r0, [fp, #-16]
21f1aed0:	e50b1014 	str	r1, [fp, #-20]
21f1aed4:	e50b2018 	str	r2, [fp, #-24]
21f1aed8:	e50b301c 	str	r3, [fp, #-28]
	extern char * env_name_spec;

	printf ("Saving Environment to %s...\n", env_name_spec);
21f1aedc:	e59f302c 	ldr	r3, [pc, #44]	; 21f1af10 <.text+0x1af10>
21f1aee0:	e5933000 	ldr	r3, [r3]
21f1aee4:	e59f0028 	ldr	r0, [pc, #40]	; 21f1af14 <.text+0x1af14>
21f1aee8:	e1a01003 	mov	r1, r3
21f1aeec:	eb0002e6 	bl	21f1ba8c <printf>

	return (saveenv() ? 1 : 0);
21f1aef0:	eb001014 	bl	21f1ef48 <saveenv>
21f1aef4:	e1a03000 	mov	r3, r0
21f1aef8:	e3530000 	cmp	r3, #0	; 0x0
21f1aefc:	03a03000 	moveq	r3, #0	; 0x0
21f1af00:	13a03001 	movne	r3, #1	; 0x1
}
21f1af04:	e1a00003 	mov	r0, r3
21f1af08:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1af0c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1af10:	21f339c8 	mvncss	r3, r8, asr #19
21f1af14:	21f31f8c 	mvncss	r1, ip, lsl #31

21f1af18 <envmatch>:


#endif


/************************************************************************
 * Match a name / name=value pair
 *
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else NULL.
 */

static int
envmatch (uchar *s1, int i2)
{
21f1af18:	e1a0c00d 	mov	ip, sp
21f1af1c:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f1af20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1af24:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f1af28:	e50b0014 	str	r0, [fp, #-20]
21f1af2c:	e50b1018 	str	r1, [fp, #-24]

	while (*s1 == env_get_char(i2++))
21f1af30:	ea00000d 	b	21f1af6c <envmatch+0x54>
		if (*s1++ == '=')
21f1af34:	e51b3014 	ldr	r3, [fp, #-20]
21f1af38:	e5d33000 	ldrb	r3, [r3]
21f1af3c:	e353003d 	cmp	r3, #61	; 0x3d
21f1af40:	13a03000 	movne	r3, #0	; 0x0
21f1af44:	03a03001 	moveq	r3, #1	; 0x1
21f1af48:	e20320ff 	and	r2, r3, #255	; 0xff
21f1af4c:	e51b3014 	ldr	r3, [fp, #-20]
21f1af50:	e2833001 	add	r3, r3, #1	; 0x1
21f1af54:	e50b3014 	str	r3, [fp, #-20]
21f1af58:	e3520000 	cmp	r2, #0	; 0x0
21f1af5c:	0a000002 	beq	21f1af6c <envmatch+0x54>
			return(i2);
21f1af60:	e51b3018 	ldr	r3, [fp, #-24]
21f1af64:	e50b301c 	str	r3, [fp, #-28]
21f1af68:	ea000020 	b	21f1aff0 <envmatch+0xd8>
21f1af6c:	e51b3014 	ldr	r3, [fp, #-20]
21f1af70:	e5d34000 	ldrb	r4, [r3]
21f1af74:	e59f3084 	ldr	r3, [pc, #132]	; 21f1b000 <.text+0x1b000>
21f1af78:	e5931000 	ldr	r1, [r3]
21f1af7c:	e51b2018 	ldr	r2, [fp, #-24]
21f1af80:	e51b3018 	ldr	r3, [fp, #-24]
21f1af84:	e2833001 	add	r3, r3, #1	; 0x1
21f1af88:	e50b3018 	str	r3, [fp, #-24]
21f1af8c:	e1a00002 	mov	r0, r2
21f1af90:	e1a0e00f 	mov	lr, pc
21f1af94:	e1a0f001 	mov	pc, r1
21f1af98:	e1a03000 	mov	r3, r0
21f1af9c:	e1540003 	cmp	r4, r3
21f1afa0:	0affffe3 	beq	21f1af34 <envmatch+0x1c>
	if (*s1 == '\0' && env_get_char(i2-1) == '=')
21f1afa4:	e51b3014 	ldr	r3, [fp, #-20]
21f1afa8:	e5d33000 	ldrb	r3, [r3]
21f1afac:	e3530000 	cmp	r3, #0	; 0x0
21f1afb0:	1a00000c 	bne	21f1afe8 <envmatch+0xd0>
21f1afb4:	e59f3044 	ldr	r3, [pc, #68]	; 21f1b000 <.text+0x1b000>
21f1afb8:	e5932000 	ldr	r2, [r3]
21f1afbc:	e51b3018 	ldr	r3, [fp, #-24]
21f1afc0:	e2433001 	sub	r3, r3, #1	; 0x1
21f1afc4:	e1a00003 	mov	r0, r3
21f1afc8:	e1a0e00f 	mov	lr, pc
21f1afcc:	e1a0f002 	mov	pc, r2
21f1afd0:	e1a03000 	mov	r3, r0
21f1afd4:	e353003d 	cmp	r3, #61	; 0x3d
21f1afd8:	1a000002 	bne	21f1afe8 <envmatch+0xd0>
		return(i2);
21f1afdc:	e51b3018 	ldr	r3, [fp, #-24]
21f1afe0:	e50b301c 	str	r3, [fp, #-28]
21f1afe4:	ea000001 	b	21f1aff0 <envmatch+0xd8>
	return(-1);
21f1afe8:	e3e03000 	mvn	r3, #0	; 0x0
21f1afec:	e50b301c 	str	r3, [fp, #-28]
21f1aff0:	e51b301c 	ldr	r3, [fp, #-28]
}
21f1aff4:	e1a00003 	mov	r0, r3
21f1aff8:	e24bd010 	sub	sp, fp, #16	; 0x10
21f1affc:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f1b000:	21f339a4 	mvncss	r3, r4, lsr #19

21f1b004 <do_version>:
#include <command.h>

int
do_version (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f1b004:	e1a0c00d 	mov	ip, sp
21f1b008:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b00c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b010:	e24dd010 	sub	sp, sp, #16	; 0x10
21f1b014:	e50b0010 	str	r0, [fp, #-16]
21f1b018:	e50b1014 	str	r1, [fp, #-20]
21f1b01c:	e50b2018 	str	r2, [fp, #-24]
21f1b020:	e50b301c 	str	r3, [fp, #-28]
	extern char version_string[];
	printf ("\n%s\n", version_string);
21f1b024:	e59f0014 	ldr	r0, [pc, #20]	; 21f1b040 <.text+0x1b040>
21f1b028:	e59f1014 	ldr	r1, [pc, #20]	; 21f1b044 <.text+0x1b044>
21f1b02c:	eb000296 	bl	21f1ba8c <printf>
	return 0;
21f1b030:	e3a03000 	mov	r3, #0	; 0x0
}
21f1b034:	e1a00003 	mov	r0, r3
21f1b038:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b03c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1b040:	21f32084 	mvncss	r2, r4, lsl #1
21f1b044:	21f2f244 	mvncss	pc, r4, asr #4

21f1b048 <do_echo>:

U_BOOT_CMD(
	version,	1,		1,	do_version,
 	"version - print monitor version\n",
	NULL
);

#if (CONFIG_COMMANDS & CFG_CMD_ECHO)

int
do_echo (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f1b048:	e1a0c00d 	mov	ip, sp
21f1b04c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b050:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b054:	e24dd020 	sub	sp, sp, #32	; 0x20
21f1b058:	e50b0020 	str	r0, [fp, #-32]
21f1b05c:	e50b1024 	str	r1, [fp, #-36]
21f1b060:	e50b2028 	str	r2, [fp, #-40]
21f1b064:	e50b302c 	str	r3, [fp, #-44]
	int i, putnl = 1;
21f1b068:	e3a03001 	mov	r3, #1	; 0x1
21f1b06c:	e50b3018 	str	r3, [fp, #-24]

	for (i = 1; i < argc; i++) {
21f1b070:	e3a03001 	mov	r3, #1	; 0x1
21f1b074:	e50b301c 	str	r3, [fp, #-28]
21f1b078:	ea00002c 	b	21f1b130 <do_echo+0xe8>
		char *p = argv[i], c;
21f1b07c:	e51b301c 	ldr	r3, [fp, #-28]
21f1b080:	e1a03103 	mov	r3, r3, lsl #2
21f1b084:	e1a02003 	mov	r2, r3
21f1b088:	e51b302c 	ldr	r3, [fp, #-44]
21f1b08c:	e0823003 	add	r3, r2, r3
21f1b090:	e5933000 	ldr	r3, [r3]
21f1b094:	e50b3014 	str	r3, [fp, #-20]

		if (i > 1)
21f1b098:	e51b301c 	ldr	r3, [fp, #-28]
21f1b09c:	e3530001 	cmp	r3, #1	; 0x1
21f1b0a0:	da000012 	ble	21f1b0f0 <do_echo+0xa8>
			putc(' ');
21f1b0a4:	e3a00020 	mov	r0, #32	; 0x20
21f1b0a8:	eb00024e 	bl	21f1b9e8 <putc>
21f1b0ac:	ea00000f 	b	21f1b0f0 <do_echo+0xa8>
		while ((c = *p++) != '\0') {
			if (c == '\\' && *p == 'c') {
21f1b0b0:	e55b300d 	ldrb	r3, [fp, #-13]
21f1b0b4:	e353005c 	cmp	r3, #92	; 0x5c
21f1b0b8:	1a000009 	bne	21f1b0e4 <do_echo+0x9c>
21f1b0bc:	e51b3014 	ldr	r3, [fp, #-20]
21f1b0c0:	e5d33000 	ldrb	r3, [r3]
21f1b0c4:	e3530063 	cmp	r3, #99	; 0x63
21f1b0c8:	1a000005 	bne	21f1b0e4 <do_echo+0x9c>
				putnl = 0;
21f1b0cc:	e3a03000 	mov	r3, #0	; 0x0
21f1b0d0:	e50b3018 	str	r3, [fp, #-24]
				p++;
21f1b0d4:	e51b3014 	ldr	r3, [fp, #-20]
21f1b0d8:	e2833001 	add	r3, r3, #1	; 0x1
21f1b0dc:	e50b3014 	str	r3, [fp, #-20]
21f1b0e0:	ea000002 	b	21f1b0f0 <do_echo+0xa8>
			} else {
				putc(c);
21f1b0e4:	e55b300d 	ldrb	r3, [fp, #-13]
21f1b0e8:	e1a00003 	mov	r0, r3
21f1b0ec:	eb00023d 	bl	21f1b9e8 <putc>
21f1b0f0:	e51b3014 	ldr	r3, [fp, #-20]
21f1b0f4:	e5d33000 	ldrb	r3, [r3]
21f1b0f8:	e54b300d 	strb	r3, [fp, #-13]
21f1b0fc:	e55b300d 	ldrb	r3, [fp, #-13]
21f1b100:	e3530000 	cmp	r3, #0	; 0x0
21f1b104:	03a03000 	moveq	r3, #0	; 0x0
21f1b108:	13a03001 	movne	r3, #1	; 0x1
21f1b10c:	e20320ff 	and	r2, r3, #255	; 0xff
21f1b110:	e51b3014 	ldr	r3, [fp, #-20]
21f1b114:	e2833001 	add	r3, r3, #1	; 0x1
21f1b118:	e50b3014 	str	r3, [fp, #-20]
21f1b11c:	e3520000 	cmp	r2, #0	; 0x0
21f1b120:	1affffe2 	bne	21f1b0b0 <do_echo+0x68>
21f1b124:	e51b301c 	ldr	r3, [fp, #-28]
21f1b128:	e2833001 	add	r3, r3, #1	; 0x1
21f1b12c:	e50b301c 	str	r3, [fp, #-28]
21f1b130:	e51b201c 	ldr	r2, [fp, #-28]
21f1b134:	e51b3028 	ldr	r3, [fp, #-40]
21f1b138:	e1520003 	cmp	r2, r3
21f1b13c:	baffffce 	blt	21f1b07c <do_echo+0x34>
			}
		}
	}

	if (putnl)
21f1b140:	e51b3018 	ldr	r3, [fp, #-24]
21f1b144:	e3530000 	cmp	r3, #0	; 0x0
21f1b148:	0a000001 	beq	21f1b154 <do_echo+0x10c>
		putc('\n');
21f1b14c:	e3a0000a 	mov	r0, #10	; 0xa
21f1b150:	eb000224 	bl	21f1b9e8 <putc>
	return 0;
21f1b154:	e3a03000 	mov	r3, #0	; 0x0
}
21f1b158:	e1a00003 	mov	r0, r3
21f1b15c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b160:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1b164 <do_help>:

U_BOOT_CMD(
	echo,	CFG_MAXARGS,	1,	do_echo,
 	"echo    - echo args to console\n",
 	"[args..]\n"
	"    - echo args to console; \\c suppresses newline\n"
);

#endif	/*  CFG_CMD_ECHO */

#ifdef CFG_HUSH_PARSER

int
do_test (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	char **ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
		return 1;

#if 0
	{
		printf("test:");
		left = 1;
		while (argv[left])
			printf(" %s", argv[left++]);
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
		neg = 1;
		ap++;
		left--;
	} else
		neg = 0;

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
			adv = 2;
		else
			adv = 3;

		if (left < adv) {
			expr = 1;
			break;
		}

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
				last_expr = expr;
				last_cmp = 1;
			} else {
				expr = 1;
				break;
			}
		}

		if (adv == 2) {
			if (strcmp(ap[0], "-z") == 0)
				expr = strlen(ap[1]) == 0 ? 1 : 0;
			else if (strcmp(ap[0], "-n") == 0)
				expr = strlen(ap[1]) == 0 ? 0 : 1;
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
		}

		if (adv == 3) {
			if (strcmp(ap[1], "=") == 0)
				expr = strcmp(ap[0], ap[2]) == 0;
			else if (strcmp(ap[1], "!=") == 0)
				expr = strcmp(ap[0], ap[2]) != 0;
			else if (strcmp(ap[1], ">") == 0)
				expr = strcmp(ap[0], ap[2]) > 0;
			else if (strcmp(ap[1], "<") == 0)
				expr = strcmp(ap[0], ap[2]) < 0;
			else if (strcmp(ap[1], "-eq") == 0)
				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-ne") == 0)
				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-lt") == 0)
				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-le") == 0)
				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-gt") == 0)
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-ge") == 0)
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
		}

		ap += adv; left -= adv;
	}

	if (neg)
		expr = !expr;

	expr = !expr;

#if 0
	printf(": returns %d\n", expr);
#endif

	return expr;
}

U_BOOT_CMD(
	test,	CFG_MAXARGS,	1,	do_test,
 	"test    - minimal test like /bin/sh\n",
 	"[args..]\n"
	"    - test functionality\n"
);

int
do_exit (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
	int r;

	r = 0;
	if (argc > 1)
		r = simple_strtoul(argv[1], NULL, 10);

	return -r - 2;
}

U_BOOT_CMD(
	exit,	2,	1,	do_exit,
 	"exit    - exit script\n",
	"    - exit functionality\n"
);


#endif

/*
 * Use puts() instead of printf() to avoid printf buffer overflow
 * for long help messages
 */
int do_help (cmd_tbl_t * cmdtp, int flag, int argc, char *argv[])
{
21f1b164:	e1a0c00d 	mov	ip, sp
21f1b168:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b16c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b170:	e24dd040 	sub	sp, sp, #64	; 0x40
21f1b174:	e50b0034 	str	r0, [fp, #-52]
21f1b178:	e50b1038 	str	r1, [fp, #-56]
21f1b17c:	e50b203c 	str	r2, [fp, #-60]
21f1b180:	e50b3040 	str	r3, [fp, #-64]
	int i;
	int rcode = 0;
21f1b184:	e3a03000 	mov	r3, #0	; 0x0
21f1b188:	e50b3028 	str	r3, [fp, #-40]

	if (argc == 1) {	/*show list of commands */
21f1b18c:	e51b303c 	ldr	r3, [fp, #-60]
21f1b190:	e3530001 	cmp	r3, #1	; 0x1
21f1b194:	1a00008d 	bne	21f1b3d0 <do_help+0x26c>
21f1b198:	e1a0300d 	mov	r3, sp
21f1b19c:	e50b3044 	str	r3, [fp, #-68]

		int cmd_items = &__u_boot_cmd_end -
				&__u_boot_cmd_start;	/* pointer arith! */
21f1b1a0:	e59f22ec 	ldr	r2, [pc, #748]	; 21f1b494 <.text+0x1b494>
21f1b1a4:	e59f32ec 	ldr	r3, [pc, #748]	; 21f1b498 <.text+0x1b498>
21f1b1a8:	e0633002 	rsb	r3, r3, r2
21f1b1ac:	e1a01143 	mov	r1, r3, asr #2
21f1b1b0:	e1a03001 	mov	r3, r1
21f1b1b4:	e1a03083 	mov	r3, r3, lsl #1
21f1b1b8:	e0833001 	add	r3, r3, r1
21f1b1bc:	e1a02203 	mov	r2, r3, lsl #4
21f1b1c0:	e0833002 	add	r3, r3, r2
21f1b1c4:	e1a02403 	mov	r2, r3, lsl #8
21f1b1c8:	e0833002 	add	r3, r3, r2
21f1b1cc:	e1a02803 	mov	r2, r3, lsl #16
21f1b1d0:	e0833002 	add	r3, r3, r2
21f1b1d4:	e1a03103 	mov	r3, r3, lsl #2
21f1b1d8:	e0833001 	add	r3, r3, r1
21f1b1dc:	e50b3024 	str	r3, [fp, #-36]
		cmd_tbl_t *cmd_array[cmd_items];
21f1b1e0:	e51b3024 	ldr	r3, [fp, #-36]
21f1b1e4:	e1a03103 	mov	r3, r3, lsl #2
21f1b1e8:	e2833003 	add	r3, r3, #3	; 0x3
21f1b1ec:	e2833003 	add	r3, r3, #3	; 0x3
21f1b1f0:	e1a03123 	mov	r3, r3, lsr #2
21f1b1f4:	e1a03103 	mov	r3, r3, lsl #2
21f1b1f8:	e063d00d 	rsb	sp, r3, sp
21f1b1fc:	e50bd04c 	str	sp, [fp, #-76]
21f1b200:	e51b204c 	ldr	r2, [fp, #-76]
21f1b204:	e2823003 	add	r3, r2, #3	; 0x3
21f1b208:	e1a03123 	mov	r3, r3, lsr #2
21f1b20c:	e1a03103 	mov	r3, r3, lsl #2
21f1b210:	e50b304c 	str	r3, [fp, #-76]
21f1b214:	e51b304c 	ldr	r3, [fp, #-76]
21f1b218:	e50b3030 	str	r3, [fp, #-48]
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = &__u_boot_cmd_start;
21f1b21c:	e59f3274 	ldr	r3, [pc, #628]	; 21f1b498 <.text+0x1b498>
21f1b220:	e50b3034 	str	r3, [fp, #-52]
		for (i = 0; i < cmd_items; i++) {
21f1b224:	e3a03000 	mov	r3, #0	; 0x0
21f1b228:	e50b3020 	str	r3, [fp, #-32]
21f1b22c:	ea000009 	b	21f1b258 <do_help+0xf4>
			cmd_array[i] = cmdtp++;
21f1b230:	e51b1020 	ldr	r1, [fp, #-32]
21f1b234:	e51b2030 	ldr	r2, [fp, #-48]
21f1b238:	e51b3034 	ldr	r3, [fp, #-52]
21f1b23c:	e7823101 	str	r3, [r2, r1, lsl #2]
21f1b240:	e51b3034 	ldr	r3, [fp, #-52]
21f1b244:	e2833014 	add	r3, r3, #20	; 0x14
21f1b248:	e50b3034 	str	r3, [fp, #-52]
21f1b24c:	e51b3020 	ldr	r3, [fp, #-32]
21f1b250:	e2833001 	add	r3, r3, #1	; 0x1
21f1b254:	e50b3020 	str	r3, [fp, #-32]
21f1b258:	e51b2020 	ldr	r2, [fp, #-32]
21f1b25c:	e51b3024 	ldr	r3, [fp, #-36]
21f1b260:	e1520003 	cmp	r2, r3
21f1b264:	bafffff1 	blt	21f1b230 <do_help+0xcc>
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
21f1b268:	e51b3024 	ldr	r3, [fp, #-36]
21f1b26c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1b270:	e50b3020 	str	r3, [fp, #-32]
21f1b274:	ea000033 	b	21f1b348 <do_help+0x1e4>
			swaps = 0;
21f1b278:	e3a03000 	mov	r3, #0	; 0x0
21f1b27c:	e50b3018 	str	r3, [fp, #-24]
			for (j = 0; j < i; ++j) {
21f1b280:	e3a03000 	mov	r3, #0	; 0x0
21f1b284:	e50b301c 	str	r3, [fp, #-28]
21f1b288:	ea000024 	b	21f1b320 <do_help+0x1bc>
				if (strcmp (cmd_array[j]->name,
21f1b28c:	e51b201c 	ldr	r2, [fp, #-28]
21f1b290:	e51b3030 	ldr	r3, [fp, #-48]
21f1b294:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b298:	e5931000 	ldr	r1, [r3]
21f1b29c:	e51b301c 	ldr	r3, [fp, #-28]
21f1b2a0:	e2832001 	add	r2, r3, #1	; 0x1
21f1b2a4:	e51b3030 	ldr	r3, [fp, #-48]
21f1b2a8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b2ac:	e5933000 	ldr	r3, [r3]
21f1b2b0:	e1a00001 	mov	r0, r1
21f1b2b4:	e1a01003 	mov	r1, r3
21f1b2b8:	eb001da3 	bl	21f2294c <strcmp>
21f1b2bc:	e1a03000 	mov	r3, r0
21f1b2c0:	e3530000 	cmp	r3, #0	; 0x0
21f1b2c4:	da000012 	ble	21f1b314 <do_help+0x1b0>
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
21f1b2c8:	e51b201c 	ldr	r2, [fp, #-28]
21f1b2cc:	e51b3030 	ldr	r3, [fp, #-48]
21f1b2d0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b2d4:	e50b3014 	str	r3, [fp, #-20]
					cmd_array[j] = cmd_array[j + 1];
21f1b2d8:	e51b101c 	ldr	r1, [fp, #-28]
21f1b2dc:	e51b301c 	ldr	r3, [fp, #-28]
21f1b2e0:	e2832001 	add	r2, r3, #1	; 0x1
21f1b2e4:	e51b3030 	ldr	r3, [fp, #-48]
21f1b2e8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f1b2ec:	e51b3030 	ldr	r3, [fp, #-48]
21f1b2f0:	e7832101 	str	r2, [r3, r1, lsl #2]
					cmd_array[j + 1] = tmp;
21f1b2f4:	e51b301c 	ldr	r3, [fp, #-28]
21f1b2f8:	e2831001 	add	r1, r3, #1	; 0x1
21f1b2fc:	e51b2030 	ldr	r2, [fp, #-48]
21f1b300:	e51b3014 	ldr	r3, [fp, #-20]
21f1b304:	e7823101 	str	r3, [r2, r1, lsl #2]
					++swaps;
21f1b308:	e51b3018 	ldr	r3, [fp, #-24]
21f1b30c:	e2833001 	add	r3, r3, #1	; 0x1
21f1b310:	e50b3018 	str	r3, [fp, #-24]
21f1b314:	e51b301c 	ldr	r3, [fp, #-28]
21f1b318:	e2833001 	add	r3, r3, #1	; 0x1
21f1b31c:	e50b301c 	str	r3, [fp, #-28]
21f1b320:	e51b201c 	ldr	r2, [fp, #-28]
21f1b324:	e51b3020 	ldr	r3, [fp, #-32]
21f1b328:	e1520003 	cmp	r2, r3
21f1b32c:	baffffd6 	blt	21f1b28c <do_help+0x128>
				}
			}
			if (!swaps)
21f1b330:	e51b3018 	ldr	r3, [fp, #-24]
21f1b334:	e3530000 	cmp	r3, #0	; 0x0
21f1b338:	0a000005 	beq	21f1b354 <do_help+0x1f0>
21f1b33c:	e51b3020 	ldr	r3, [fp, #-32]
21f1b340:	e2433001 	sub	r3, r3, #1	; 0x1
21f1b344:	e50b3020 	str	r3, [fp, #-32]
21f1b348:	e51b3020 	ldr	r3, [fp, #-32]
21f1b34c:	e3530000 	cmp	r3, #0	; 0x0
21f1b350:	caffffc8 	bgt	21f1b278 <do_help+0x114>
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
21f1b354:	e3a03000 	mov	r3, #0	; 0x0
21f1b358:	e50b3020 	str	r3, [fp, #-32]
21f1b35c:	ea000013 	b	21f1b3b0 <do_help+0x24c>
			const char *usage = cmd_array[i]->usage;
21f1b360:	e51b2020 	ldr	r2, [fp, #-32]
21f1b364:	e51b3030 	ldr	r3, [fp, #-48]
21f1b368:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b36c:	e5933010 	ldr	r3, [r3, #16]
21f1b370:	e50b3010 	str	r3, [fp, #-16]

			/* allow user abort */
			if (ctrlc ())
21f1b374:	eb0001ed 	bl	21f1bb30 <ctrlc>
21f1b378:	e1a03000 	mov	r3, r0
21f1b37c:	e3530000 	cmp	r3, #0	; 0x0
21f1b380:	0a000002 	beq	21f1b390 <do_help+0x22c>
				return 1;
21f1b384:	e3a02001 	mov	r2, #1	; 0x1
21f1b388:	e50b2048 	str	r2, [fp, #-72]
21f1b38c:	ea00000d 	b	21f1b3c8 <do_help+0x264>
			if (usage == NULL)
21f1b390:	e51b3010 	ldr	r3, [fp, #-16]
21f1b394:	e3530000 	cmp	r3, #0	; 0x0
21f1b398:	0a000001 	beq	21f1b3a4 <do_help+0x240>
				continue;
			puts (usage);
21f1b39c:	e51b0010 	ldr	r0, [fp, #-16]
21f1b3a0:	eb0001a6 	bl	21f1ba40 <puts>
21f1b3a4:	e51b3020 	ldr	r3, [fp, #-32]
21f1b3a8:	e2833001 	add	r3, r3, #1	; 0x1
21f1b3ac:	e50b3020 	str	r3, [fp, #-32]
21f1b3b0:	e51b2020 	ldr	r2, [fp, #-32]
21f1b3b4:	e51b3024 	ldr	r3, [fp, #-36]
21f1b3b8:	e1520003 	cmp	r2, r3
21f1b3bc:	baffffe7 	blt	21f1b360 <do_help+0x1fc>
		}
		return 0;
21f1b3c0:	e3a03000 	mov	r3, #0	; 0x0
21f1b3c4:	e50b3048 	str	r3, [fp, #-72]
21f1b3c8:	e51bd044 	ldr	sp, [fp, #-68]
21f1b3cc:	ea00002c 	b	21f1b484 <do_help+0x320>
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
21f1b3d0:	e3a03001 	mov	r3, #1	; 0x1
21f1b3d4:	e50b302c 	str	r3, [fp, #-44]
21f1b3d8:	ea000023 	b	21f1b46c <do_help+0x308>
		if ((cmdtp = find_cmd (argv[i])) != NULL) {
21f1b3dc:	e51b302c 	ldr	r3, [fp, #-44]
21f1b3e0:	e1a03103 	mov	r3, r3, lsl #2
21f1b3e4:	e1a02003 	mov	r2, r3
21f1b3e8:	e51b3040 	ldr	r3, [fp, #-64]
21f1b3ec:	e0823003 	add	r3, r2, r3
21f1b3f0:	e5933000 	ldr	r3, [r3]
21f1b3f4:	e1a00003 	mov	r0, r3
21f1b3f8:	eb000028 	bl	21f1b4a0 <find_cmd>
21f1b3fc:	e1a03000 	mov	r3, r0
21f1b400:	e50b3034 	str	r3, [fp, #-52]
21f1b404:	e51b3034 	ldr	r3, [fp, #-52]
21f1b408:	e3530000 	cmp	r3, #0	; 0x0
21f1b40c:	0a000008 	beq	21f1b434 <do_help+0x2d0>
#ifdef	CFG_LONGHELP
			/* found - print (long) help info */
			puts (cmdtp->name);
			putc (' ');
			if (cmdtp->help) {
				puts (cmdtp->help);
			} else {
				puts ("- No help available.\n");
				rcode = 1;
			}
			putc ('\n');
#else	/* no long help available */
			if (cmdtp->usage)
21f1b410:	e51b3034 	ldr	r3, [fp, #-52]
21f1b414:	e5933010 	ldr	r3, [r3, #16]
21f1b418:	e3530000 	cmp	r3, #0	; 0x0
21f1b41c:	0a00000f 	beq	21f1b460 <do_help+0x2fc>
				puts (cmdtp->usage);
21f1b420:	e51b3034 	ldr	r3, [fp, #-52]
21f1b424:	e5933010 	ldr	r3, [r3, #16]
21f1b428:	e1a00003 	mov	r0, r3
21f1b42c:	eb000183 	bl	21f1ba40 <puts>
21f1b430:	ea00000a 	b	21f1b460 <do_help+0x2fc>
#endif	/* CFG_LONGHELP */
		} else {
			printf ("Unknown command '%s' - try 'help'"
21f1b434:	e51b302c 	ldr	r3, [fp, #-44]
21f1b438:	e1a03103 	mov	r3, r3, lsl #2
21f1b43c:	e1a02003 	mov	r2, r3
21f1b440:	e51b3040 	ldr	r3, [fp, #-64]
21f1b444:	e0823003 	add	r3, r2, r3
21f1b448:	e5933000 	ldr	r3, [r3]
21f1b44c:	e59f0048 	ldr	r0, [pc, #72]	; 21f1b49c <.text+0x1b49c>
21f1b450:	e1a01003 	mov	r1, r3
21f1b454:	eb00018c 	bl	21f1ba8c <printf>
				" without arguments for list of all"
				" known commands\n\n", argv[i]
					);
			rcode = 1;
21f1b458:	e3a03001 	mov	r3, #1	; 0x1
21f1b45c:	e50b3028 	str	r3, [fp, #-40]
21f1b460:	e51b302c 	ldr	r3, [fp, #-44]
21f1b464:	e2833001 	add	r3, r3, #1	; 0x1
21f1b468:	e50b302c 	str	r3, [fp, #-44]
21f1b46c:	e51b202c 	ldr	r2, [fp, #-44]
21f1b470:	e51b303c 	ldr	r3, [fp, #-60]
21f1b474:	e1520003 	cmp	r2, r3
21f1b478:	baffffd7 	blt	21f1b3dc <do_help+0x278>
		}
	}
	return rcode;
21f1b47c:	e51b2028 	ldr	r2, [fp, #-40]
21f1b480:	e50b2048 	str	r2, [fp, #-72]
21f1b484:	e51b3048 	ldr	r3, [fp, #-72]
}
21f1b488:	e1a00003 	mov	r0, r3
21f1b48c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b490:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1b494:	21f340e4 	mvncss	r4, r4, ror #1
21f1b498:	21f33db0 	ldrcsh	r3, [r3, #208]!
21f1b49c:	21f320e0 	mvncss	r2, r0, ror #1

21f1b4a0 <find_cmd>:


U_BOOT_CMD(
	help,	CFG_MAXARGS,	1,	do_help,
 	"help    - print online help\n",
 	"[command ...]\n"
 	"    - show help information (for 'command')\n"
 	"'help' prints online help for the monitor commands.\n\n"
 	"Without arguments, it prints a short usage message for all commands.\n\n"
 	"To get detailed help information for specific commands you can type\n"
  "'help' with one or more command names as arguments.\n"
);

/* This do not ust the U_BOOT_CMD macro as ? can't be used in symbol names */
#ifdef  CFG_LONGHELP
cmd_tbl_t __u_boot_cmd_question_mark Struct_Section = {
	"?",	CFG_MAXARGS,	1,	do_help,
 	"?       - alias for 'help'\n",
	NULL
};
#else
cmd_tbl_t __u_boot_cmd_question_mark Struct_Section = {
	"?",	CFG_MAXARGS,	1,	do_help,
 	"?       - alias for 'help'\n"
};
#endif /* CFG_LONGHELP */

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd (const char *cmd)
{
21f1b4a0:	e1a0c00d 	mov	ip, sp
21f1b4a4:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f1b4a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b4ac:	e24dd020 	sub	sp, sp, #32	; 0x20
21f1b4b0:	e50b0028 	str	r0, [fp, #-40]
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = &__u_boot_cmd_start;	/*Init value */
21f1b4b4:	e59f3110 	ldr	r3, [pc, #272]	; 21f1b5cc <.text+0x1b5cc>
21f1b4b8:	e50b3020 	str	r3, [fp, #-32]
	const char *p;
	int len;
	int n_found = 0;
21f1b4bc:	e3a03000 	mov	r3, #0	; 0x0
21f1b4c0:	e50b3014 	str	r3, [fp, #-20]

	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
21f1b4c4:	e51b0028 	ldr	r0, [fp, #-40]
21f1b4c8:	e3a0102e 	mov	r1, #46	; 0x2e
21f1b4cc:	eb001d7c 	bl	21f22ac4 <strchr>
21f1b4d0:	e1a03000 	mov	r3, r0
21f1b4d4:	e50b301c 	str	r3, [fp, #-28]
21f1b4d8:	e51b301c 	ldr	r3, [fp, #-28]
21f1b4dc:	e3530000 	cmp	r3, #0	; 0x0
21f1b4e0:	1a000004 	bne	21f1b4f8 <find_cmd+0x58>
21f1b4e4:	e51b0028 	ldr	r0, [fp, #-40]
21f1b4e8:	eb001db5 	bl	21f22bc4 <strlen>
21f1b4ec:	e1a03000 	mov	r3, r0
21f1b4f0:	e50b3030 	str	r3, [fp, #-48]
21f1b4f4:	ea000003 	b	21f1b508 <find_cmd+0x68>
21f1b4f8:	e51b201c 	ldr	r2, [fp, #-28]
21f1b4fc:	e51b3028 	ldr	r3, [fp, #-40]
21f1b500:	e0632002 	rsb	r2, r3, r2
21f1b504:	e50b2030 	str	r2, [fp, #-48]
21f1b508:	e51b3030 	ldr	r3, [fp, #-48]
21f1b50c:	e50b3018 	str	r3, [fp, #-24]

	for (cmdtp = &__u_boot_cmd_start;
21f1b510:	e59f30b4 	ldr	r3, [pc, #180]	; 21f1b5cc <.text+0x1b5cc>
21f1b514:	e50b3024 	str	r3, [fp, #-36]
	     cmdtp != &__u_boot_cmd_end;
21f1b518:	ea00001b 	b	21f1b58c <find_cmd+0xec>
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
21f1b51c:	e51b3024 	ldr	r3, [fp, #-36]
21f1b520:	e5933000 	ldr	r3, [r3]
21f1b524:	e51b2018 	ldr	r2, [fp, #-24]
21f1b528:	e51b0028 	ldr	r0, [fp, #-40]
21f1b52c:	e1a01003 	mov	r1, r3
21f1b530:	eb001d2f 	bl	21f229f4 <strncmp>
21f1b534:	e1a03000 	mov	r3, r0
21f1b538:	e3530000 	cmp	r3, #0	; 0x0
21f1b53c:	1a00000f 	bne	21f1b580 <find_cmd+0xe0>
			if (len == strlen (cmdtp->name))
21f1b540:	e51b4018 	ldr	r4, [fp, #-24]
21f1b544:	e51b3024 	ldr	r3, [fp, #-36]
21f1b548:	e5933000 	ldr	r3, [r3]
21f1b54c:	e1a00003 	mov	r0, r3
21f1b550:	eb001d9b 	bl	21f22bc4 <strlen>
21f1b554:	e1a03000 	mov	r3, r0
21f1b558:	e1540003 	cmp	r4, r3
21f1b55c:	1a000002 	bne	21f1b56c <find_cmd+0xcc>
				return cmdtp;	/* full match */
21f1b560:	e51b3024 	ldr	r3, [fp, #-36]
21f1b564:	e50b302c 	str	r3, [fp, #-44]
21f1b568:	ea000013 	b	21f1b5bc <find_cmd+0x11c>

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
21f1b56c:	e51b3024 	ldr	r3, [fp, #-36]
21f1b570:	e50b3020 	str	r3, [fp, #-32]
			n_found++;
21f1b574:	e51b3014 	ldr	r3, [fp, #-20]
21f1b578:	e2833001 	add	r3, r3, #1	; 0x1
21f1b57c:	e50b3014 	str	r3, [fp, #-20]
21f1b580:	e51b3024 	ldr	r3, [fp, #-36]
21f1b584:	e2833014 	add	r3, r3, #20	; 0x14
21f1b588:	e50b3024 	str	r3, [fp, #-36]
21f1b58c:	e51b2024 	ldr	r2, [fp, #-36]
21f1b590:	e59f3038 	ldr	r3, [pc, #56]	; 21f1b5d0 <.text+0x1b5d0>
21f1b594:	e1520003 	cmp	r2, r3
21f1b598:	1affffdf 	bne	21f1b51c <find_cmd+0x7c>
		}
	}
	if (n_found == 1) {			/* exactly one match */
21f1b59c:	e51b3014 	ldr	r3, [fp, #-20]
21f1b5a0:	e3530001 	cmp	r3, #1	; 0x1
21f1b5a4:	1a000002 	bne	21f1b5b4 <find_cmd+0x114>
		return cmdtp_temp;
21f1b5a8:	e51b3020 	ldr	r3, [fp, #-32]
21f1b5ac:	e50b302c 	str	r3, [fp, #-44]
21f1b5b0:	ea000001 	b	21f1b5bc <find_cmd+0x11c>
	}

	return NULL;	/* not found or ambiguous command */
21f1b5b4:	e3a03000 	mov	r3, #0	; 0x0
21f1b5b8:	e50b302c 	str	r3, [fp, #-44]
21f1b5bc:	e51b302c 	ldr	r3, [fp, #-44]
}
21f1b5c0:	e1a00003 	mov	r0, r3
21f1b5c4:	e24bd010 	sub	sp, fp, #16	; 0x10
21f1b5c8:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f1b5cc:	21f33db0 	ldrcsh	r3, [r3, #208]!
21f1b5d0:	21f340e4 	mvncss	r4, r4, ror #1

21f1b5d4 <console_setfile>:

#endif /* CFG_CONSOLE_IS_IN_ENV */

static int console_setfile (int file, device_t * dev)
{
21f1b5d4:	e1a0c00d 	mov	ip, sp
21f1b5d8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b5dc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b5e0:	e24dd014 	sub	sp, sp, #20	; 0x14
21f1b5e4:	e50b0014 	str	r0, [fp, #-20]
21f1b5e8:	e50b1018 	str	r1, [fp, #-24]
	int error = 0;
21f1b5ec:	e3a03000 	mov	r3, #0	; 0x0
21f1b5f0:	e50b3010 	str	r3, [fp, #-16]

	if (dev == NULL)
21f1b5f4:	e51b3018 	ldr	r3, [fp, #-24]
21f1b5f8:	e3530000 	cmp	r3, #0	; 0x0
21f1b5fc:	1a000002 	bne	21f1b60c <console_setfile+0x38>
		return -1;
21f1b600:	e3e03000 	mvn	r3, #0	; 0x0
21f1b604:	e50b301c 	str	r3, [fp, #-28]
21f1b608:	ea000040 	b	21f1b710 <console_setfile+0x13c>

	switch (file) {
21f1b60c:	e51b3014 	ldr	r3, [fp, #-20]
21f1b610:	e2833000 	add	r3, r3, #0	; 0x0
21f1b614:	e3530002 	cmp	r3, #2	; 0x2
21f1b618:	8a000038 	bhi	21f1b700 <console_setfile+0x12c>
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
21f1b61c:	e51b3018 	ldr	r3, [fp, #-24]
21f1b620:	e5933018 	ldr	r3, [r3, #24]
21f1b624:	e3530000 	cmp	r3, #0	; 0x0
21f1b628:	0a000008 	beq	21f1b650 <console_setfile+0x7c>
			error = dev->start ();
21f1b62c:	e51b3018 	ldr	r3, [fp, #-24]
21f1b630:	e5933018 	ldr	r3, [r3, #24]
21f1b634:	e1a0e00f 	mov	lr, pc
21f1b638:	e1a0f003 	mov	pc, r3
21f1b63c:	e1a03000 	mov	r3, r0
21f1b640:	e50b3010 	str	r3, [fp, #-16]
			/* If it's not started dont use it */
			if (error < 0)
21f1b644:	e51b3010 	ldr	r3, [fp, #-16]
21f1b648:	e3530000 	cmp	r3, #0	; 0x0
21f1b64c:	ba00002d 	blt	21f1b708 <console_setfile+0x134>
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
21f1b650:	e51b1014 	ldr	r1, [fp, #-20]
21f1b654:	e59f20c4 	ldr	r2, [pc, #196]	; 21f1b720 <.text+0x1b720>
21f1b658:	e51b3018 	ldr	r3, [fp, #-24]
21f1b65c:	e7823101 	str	r3, [r2, r1, lsl #2]

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
21f1b660:	e51b3014 	ldr	r3, [fp, #-20]
21f1b664:	e50b3020 	str	r3, [fp, #-32]
21f1b668:	e51b3020 	ldr	r3, [fp, #-32]
21f1b66c:	e3530000 	cmp	r3, #0	; 0x0
21f1b670:	0a000003 	beq	21f1b684 <console_setfile+0xb0>
21f1b674:	e51b3020 	ldr	r3, [fp, #-32]
21f1b678:	e3530001 	cmp	r3, #1	; 0x1
21f1b67c:	0a00000d 	beq	21f1b6b8 <console_setfile+0xe4>
21f1b680:	ea000020 	b	21f1b708 <console_setfile+0x134>
		case stdin:
			gd->jt[XF_getc] = dev->getc;
21f1b684:	e1a03008 	mov	r3, r8
21f1b688:	e5933020 	ldr	r3, [r3, #32]
21f1b68c:	e2832004 	add	r2, r3, #4	; 0x4
21f1b690:	e51b3018 	ldr	r3, [fp, #-24]
21f1b694:	e593302c 	ldr	r3, [r3, #44]
21f1b698:	e5823000 	str	r3, [r2]
			gd->jt[XF_tstc] = dev->tstc;
21f1b69c:	e1a03008 	mov	r3, r8
21f1b6a0:	e5933020 	ldr	r3, [r3, #32]
21f1b6a4:	e2832008 	add	r2, r3, #8	; 0x8
21f1b6a8:	e51b3018 	ldr	r3, [fp, #-24]
21f1b6ac:	e5933028 	ldr	r3, [r3, #40]
21f1b6b0:	e5823000 	str	r3, [r2]
			break;
21f1b6b4:	ea000013 	b	21f1b708 <console_setfile+0x134>
		case stdout:
			gd->jt[XF_putc] = dev->putc;
21f1b6b8:	e1a03008 	mov	r3, r8
21f1b6bc:	e5933020 	ldr	r3, [r3, #32]
21f1b6c0:	e283200c 	add	r2, r3, #12	; 0xc
21f1b6c4:	e51b3018 	ldr	r3, [fp, #-24]
21f1b6c8:	e5933020 	ldr	r3, [r3, #32]
21f1b6cc:	e5823000 	str	r3, [r2]
			gd->jt[XF_puts] = dev->puts;
21f1b6d0:	e1a03008 	mov	r3, r8
21f1b6d4:	e5933020 	ldr	r3, [r3, #32]
21f1b6d8:	e2832010 	add	r2, r3, #16	; 0x10
21f1b6dc:	e51b3018 	ldr	r3, [fp, #-24]
21f1b6e0:	e5933024 	ldr	r3, [r3, #36]
21f1b6e4:	e5823000 	str	r3, [r2]
			gd->jt[XF_printf] = printf;
21f1b6e8:	e1a03008 	mov	r3, r8
21f1b6ec:	e5933020 	ldr	r3, [r3, #32]
21f1b6f0:	e2832014 	add	r2, r3, #20	; 0x14
21f1b6f4:	e59f3028 	ldr	r3, [pc, #40]	; 21f1b724 <.text+0x1b724>
21f1b6f8:	e5823000 	str	r3, [r2]
21f1b6fc:	ea000001 	b	21f1b708 <console_setfile+0x134>
			break;
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
21f1b700:	e3e03000 	mvn	r3, #0	; 0x0
21f1b704:	e50b3010 	str	r3, [fp, #-16]
	}
	return error;
21f1b708:	e51b3010 	ldr	r3, [fp, #-16]
21f1b70c:	e50b301c 	str	r3, [fp, #-28]
21f1b710:	e51b301c 	ldr	r3, [fp, #-28]
}
21f1b714:	e1a00003 	mov	r0, r3
21f1b718:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b71c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1b720:	21f67764 	mvncss	r7, r4, ror #14
21f1b724:	21f1ba8c 	mvncss	fp, ip, lsl #21

21f1b728 <serial_printf>:

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

void serial_printf (const char *fmt, ...)
{
21f1b728:	e1a0c00d 	mov	ip, sp
21f1b72c:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
21f1b730:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b734:	e24cb014 	sub	fp, ip, #20	; 0x14
21f1b738:	e24ddf49 	sub	sp, sp, #292	; 0x124
	va_list args;
	uint i;
	char printbuffer[CFG_PBSIZE];

	va_start (args, fmt);
21f1b73c:	e28b3008 	add	r3, fp, #8	; 0x8
21f1b740:	e50b3014 	str	r3, [fp, #-20]

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
21f1b744:	e51b2014 	ldr	r2, [fp, #-20]
21f1b748:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f1b74c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1b750:	e1a00003 	mov	r0, r3
21f1b754:	e59b1004 	ldr	r1, [fp, #4]
21f1b758:	eb0021a9 	bl	21f23e04 <vsprintf>
21f1b75c:	e1a03000 	mov	r3, r0
21f1b760:	e50b3010 	str	r3, [fp, #-16]
	va_end (args);

	serial_puts (printbuffer);
21f1b764:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f1b768:	e2433001 	sub	r3, r3, #1	; 0x1
21f1b76c:	e1a00003 	mov	r0, r3
21f1b770:	eb004b48 	bl	21f2e498 <serial_puts>
}
21f1b774:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b778:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1b77c <fgetc>:

int fgetc (int file)
{
21f1b77c:	e1a0c00d 	mov	ip, sp
21f1b780:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b784:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b788:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1b78c:	e50b0010 	str	r0, [fp, #-16]
	if (file < MAX_FILES)
21f1b790:	e51b3010 	ldr	r3, [fp, #-16]
21f1b794:	e3530002 	cmp	r3, #2	; 0x2
21f1b798:	ca000008 	bgt	21f1b7c0 <fgetc+0x44>
		return stdio_devices[file]->getc ();
21f1b79c:	e51b2010 	ldr	r2, [fp, #-16]
21f1b7a0:	e59f3030 	ldr	r3, [pc, #48]	; 21f1b7d8 <.text+0x1b7d8>
21f1b7a4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b7a8:	e593302c 	ldr	r3, [r3, #44]
21f1b7ac:	e1a0e00f 	mov	lr, pc
21f1b7b0:	e1a0f003 	mov	pc, r3
21f1b7b4:	e1a03000 	mov	r3, r0
21f1b7b8:	e50b3014 	str	r3, [fp, #-20]
21f1b7bc:	ea000001 	b	21f1b7c8 <fgetc+0x4c>

	return -1;
21f1b7c0:	e3e03000 	mvn	r3, #0	; 0x0
21f1b7c4:	e50b3014 	str	r3, [fp, #-20]
21f1b7c8:	e51b3014 	ldr	r3, [fp, #-20]
}
21f1b7cc:	e1a00003 	mov	r0, r3
21f1b7d0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b7d4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1b7d8:	21f67764 	mvncss	r7, r4, ror #14

21f1b7dc <ftstc>:

int ftstc (int file)
{
21f1b7dc:	e1a0c00d 	mov	ip, sp
21f1b7e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b7e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b7e8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1b7ec:	e50b0010 	str	r0, [fp, #-16]
	if (file < MAX_FILES)
21f1b7f0:	e51b3010 	ldr	r3, [fp, #-16]
21f1b7f4:	e3530002 	cmp	r3, #2	; 0x2
21f1b7f8:	ca000008 	bgt	21f1b820 <ftstc+0x44>
		return stdio_devices[file]->tstc ();
21f1b7fc:	e51b2010 	ldr	r2, [fp, #-16]
21f1b800:	e59f3030 	ldr	r3, [pc, #48]	; 21f1b838 <.text+0x1b838>
21f1b804:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b808:	e5933028 	ldr	r3, [r3, #40]
21f1b80c:	e1a0e00f 	mov	lr, pc
21f1b810:	e1a0f003 	mov	pc, r3
21f1b814:	e1a03000 	mov	r3, r0
21f1b818:	e50b3014 	str	r3, [fp, #-20]
21f1b81c:	ea000001 	b	21f1b828 <ftstc+0x4c>

	return -1;
21f1b820:	e3e03000 	mvn	r3, #0	; 0x0
21f1b824:	e50b3014 	str	r3, [fp, #-20]
21f1b828:	e51b3014 	ldr	r3, [fp, #-20]
}
21f1b82c:	e1a00003 	mov	r0, r3
21f1b830:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b834:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1b838:	21f67764 	mvncss	r7, r4, ror #14

21f1b83c <fputc>:

void fputc (int file, const char c)
{
21f1b83c:	e1a0c00d 	mov	ip, sp
21f1b840:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b844:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b848:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1b84c:	e50b0010 	str	r0, [fp, #-16]
21f1b850:	e1a03001 	mov	r3, r1
21f1b854:	e54b3014 	strb	r3, [fp, #-20]
	if (file < MAX_FILES)
21f1b858:	e51b3010 	ldr	r3, [fp, #-16]
21f1b85c:	e3530002 	cmp	r3, #2	; 0x2
21f1b860:	ca000007 	bgt	21f1b884 <fputc+0x48>
		stdio_devices[file]->putc (c);
21f1b864:	e51b2010 	ldr	r2, [fp, #-16]
21f1b868:	e59f301c 	ldr	r3, [pc, #28]	; 21f1b88c <.text+0x1b88c>
21f1b86c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b870:	e5932020 	ldr	r2, [r3, #32]
21f1b874:	e55b3014 	ldrb	r3, [fp, #-20]
21f1b878:	e1a00003 	mov	r0, r3
21f1b87c:	e1a0e00f 	mov	lr, pc
21f1b880:	e1a0f002 	mov	pc, r2
}
21f1b884:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b888:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1b88c:	21f67764 	mvncss	r7, r4, ror #14

21f1b890 <fputs>:

void fputs (int file, const char *s)
{
21f1b890:	e1a0c00d 	mov	ip, sp
21f1b894:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b898:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b89c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1b8a0:	e50b0010 	str	r0, [fp, #-16]
21f1b8a4:	e50b1014 	str	r1, [fp, #-20]
	if (file < MAX_FILES)
21f1b8a8:	e51b3010 	ldr	r3, [fp, #-16]
21f1b8ac:	e3530002 	cmp	r3, #2	; 0x2
21f1b8b0:	ca000006 	bgt	21f1b8d0 <fputs+0x40>
		stdio_devices[file]->puts (s);
21f1b8b4:	e51b2010 	ldr	r2, [fp, #-16]
21f1b8b8:	e59f3018 	ldr	r3, [pc, #24]	; 21f1b8d8 <.text+0x1b8d8>
21f1b8bc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1b8c0:	e5933024 	ldr	r3, [r3, #36]
21f1b8c4:	e51b0014 	ldr	r0, [fp, #-20]
21f1b8c8:	e1a0e00f 	mov	lr, pc
21f1b8cc:	e1a0f003 	mov	pc, r3
}
21f1b8d0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b8d4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1b8d8:	21f67764 	mvncss	r7, r4, ror #14

21f1b8dc <fprintf>:

void fprintf (int file, const char *fmt, ...)
{
21f1b8dc:	e1a0c00d 	mov	ip, sp
21f1b8e0:	e92d000e 	stmdb	sp!, {r1, r2, r3}
21f1b8e4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b8e8:	e24cb010 	sub	fp, ip, #16	; 0x10
21f1b8ec:	e24ddf4a 	sub	sp, sp, #296	; 0x128
21f1b8f0:	e50b0134 	str	r0, [fp, #-308]
	va_list args;
	uint i;
	char printbuffer[CFG_PBSIZE];

	va_start (args, fmt);
21f1b8f4:	e28b3008 	add	r3, fp, #8	; 0x8
21f1b8f8:	e50b3014 	str	r3, [fp, #-20]

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
21f1b8fc:	e51b2014 	ldr	r2, [fp, #-20]
21f1b900:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f1b904:	e2433001 	sub	r3, r3, #1	; 0x1
21f1b908:	e1a00003 	mov	r0, r3
21f1b90c:	e59b1004 	ldr	r1, [fp, #4]
21f1b910:	eb00213b 	bl	21f23e04 <vsprintf>
21f1b914:	e1a03000 	mov	r3, r0
21f1b918:	e50b3010 	str	r3, [fp, #-16]
	va_end (args);

	/* Send to desired file */
	fputs (file, printbuffer);
21f1b91c:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f1b920:	e2433001 	sub	r3, r3, #1	; 0x1
21f1b924:	e51b0134 	ldr	r0, [fp, #-308]
21f1b928:	e1a01003 	mov	r1, r3
21f1b92c:	ebffffd7 	bl	21f1b890 <fputs>
}
21f1b930:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1b934:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1b938 <getc>:

/** U-Boot INITIAL CONSOLE-COMPATIBLE FUNCTION *****************************/

int getc (void)
{
21f1b938:	e1a0c00d 	mov	ip, sp
21f1b93c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b940:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b944:	e24dd004 	sub	sp, sp, #4	; 0x4
	if (gd->flags & GD_FLG_DEVINIT) {
21f1b948:	e1a03008 	mov	r3, r8
21f1b94c:	e5933004 	ldr	r3, [r3, #4]
21f1b950:	e1a030a3 	mov	r3, r3, lsr #1
21f1b954:	e2033001 	and	r3, r3, #1	; 0x1
21f1b958:	e20330ff 	and	r3, r3, #255	; 0xff
21f1b95c:	e3530000 	cmp	r3, #0	; 0x0
21f1b960:	0a000004 	beq	21f1b978 <getc+0x40>
		/* Get from the standard input */
		return fgetc (stdin);
21f1b964:	e3a00000 	mov	r0, #0	; 0x0
21f1b968:	ebffff83 	bl	21f1b77c <fgetc>
21f1b96c:	e1a03000 	mov	r3, r0
21f1b970:	e50b3010 	str	r3, [fp, #-16]
21f1b974:	ea000002 	b	21f1b984 <getc+0x4c>
	}

	/* Send directly to the handler */
	return serial_getc ();
21f1b978:	eb004ad9 	bl	21f2e4e4 <serial_getc>
21f1b97c:	e1a03000 	mov	r3, r0
21f1b980:	e50b3010 	str	r3, [fp, #-16]
21f1b984:	e51b3010 	ldr	r3, [fp, #-16]
}
21f1b988:	e1a00003 	mov	r0, r3
21f1b98c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1b990 <tstc>:

int tstc (void)
{
21f1b990:	e1a0c00d 	mov	ip, sp
21f1b994:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b998:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b99c:	e24dd004 	sub	sp, sp, #4	; 0x4
	if (gd->flags & GD_FLG_DEVINIT) {
21f1b9a0:	e1a03008 	mov	r3, r8
21f1b9a4:	e5933004 	ldr	r3, [r3, #4]
21f1b9a8:	e1a030a3 	mov	r3, r3, lsr #1
21f1b9ac:	e2033001 	and	r3, r3, #1	; 0x1
21f1b9b0:	e20330ff 	and	r3, r3, #255	; 0xff
21f1b9b4:	e3530000 	cmp	r3, #0	; 0x0
21f1b9b8:	0a000004 	beq	21f1b9d0 <tstc+0x40>
		/* Test the standard input */
		return ftstc (stdin);
21f1b9bc:	e3a00000 	mov	r0, #0	; 0x0
21f1b9c0:	ebffff85 	bl	21f1b7dc <ftstc>
21f1b9c4:	e1a03000 	mov	r3, r0
21f1b9c8:	e50b3010 	str	r3, [fp, #-16]
21f1b9cc:	ea000002 	b	21f1b9dc <tstc+0x4c>
	}

	/* Send directly to the handler */
	return serial_tstc ();
21f1b9d0:	eb004ad4 	bl	21f2e528 <serial_tstc>
21f1b9d4:	e1a03000 	mov	r3, r0
21f1b9d8:	e50b3010 	str	r3, [fp, #-16]
21f1b9dc:	e51b3010 	ldr	r3, [fp, #-16]
}
21f1b9e0:	e1a00003 	mov	r0, r3
21f1b9e4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1b9e8 <putc>:

void putc (const char c)
{
21f1b9e8:	e1a0c00d 	mov	ip, sp
21f1b9ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1b9f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1b9f4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1b9f8:	e1a03000 	mov	r3, r0
21f1b9fc:	e54b3010 	strb	r3, [fp, #-16]
#ifdef CONFIG_SILENT_CONSOLE
	if (gd->flags & GD_FLG_SILENT)
		return;
#endif

	if (gd->flags & GD_FLG_DEVINIT) {
21f1ba00:	e1a03008 	mov	r3, r8
21f1ba04:	e5933004 	ldr	r3, [r3, #4]
21f1ba08:	e1a030a3 	mov	r3, r3, lsr #1
21f1ba0c:	e2033001 	and	r3, r3, #1	; 0x1
21f1ba10:	e20330ff 	and	r3, r3, #255	; 0xff
21f1ba14:	e3530000 	cmp	r3, #0	; 0x0
21f1ba18:	0a000004 	beq	21f1ba30 <putc+0x48>
		/* Send to the standard output */
		fputc (stdout, c);
21f1ba1c:	e55b3010 	ldrb	r3, [fp, #-16]
21f1ba20:	e3a00001 	mov	r0, #1	; 0x1
21f1ba24:	e1a01003 	mov	r1, r3
21f1ba28:	ebffff83 	bl	21f1b83c <fputc>
21f1ba2c:	ea000002 	b	21f1ba3c <putc+0x54>
	} else {
		/* Send directly to the handler */
		serial_putc (c);
21f1ba30:	e55b3010 	ldrb	r3, [fp, #-16]
21f1ba34:	e1a00003 	mov	r0, r3
21f1ba38:	eb004a7c 	bl	21f2e430 <serial_putc>
	}
}
21f1ba3c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1ba40 <puts>:

void puts (const char *s)
{
21f1ba40:	e1a0c00d 	mov	ip, sp
21f1ba44:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ba48:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ba4c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1ba50:	e50b0010 	str	r0, [fp, #-16]
#ifdef CONFIG_SILENT_CONSOLE
	if (gd->flags & GD_FLG_SILENT)
		return;
#endif

	if (gd->flags & GD_FLG_DEVINIT) {
21f1ba54:	e1a03008 	mov	r3, r8
21f1ba58:	e5933004 	ldr	r3, [r3, #4]
21f1ba5c:	e1a030a3 	mov	r3, r3, lsr #1
21f1ba60:	e2033001 	and	r3, r3, #1	; 0x1
21f1ba64:	e20330ff 	and	r3, r3, #255	; 0xff
21f1ba68:	e3530000 	cmp	r3, #0	; 0x0
21f1ba6c:	0a000003 	beq	21f1ba80 <puts+0x40>
		/* Send to the standard output */
		fputs (stdout, s);
21f1ba70:	e3a00001 	mov	r0, #1	; 0x1
21f1ba74:	e51b1010 	ldr	r1, [fp, #-16]
21f1ba78:	ebffff84 	bl	21f1b890 <fputs>
21f1ba7c:	ea000001 	b	21f1ba88 <puts+0x48>
	} else {
		/* Send directly to the handler */
		serial_puts (s);
21f1ba80:	e51b0010 	ldr	r0, [fp, #-16]
21f1ba84:	eb004a83 	bl	21f2e498 <serial_puts>
	}
}
21f1ba88:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1ba8c <printf>:

void printf (const char *fmt, ...)
{
21f1ba8c:	e1a0c00d 	mov	ip, sp
21f1ba90:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
21f1ba94:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ba98:	e24cb014 	sub	fp, ip, #20	; 0x14
21f1ba9c:	e24ddf49 	sub	sp, sp, #292	; 0x124
	va_list args;
	uint i;
	char printbuffer[CFG_PBSIZE];

	va_start (args, fmt);
21f1baa0:	e28b3008 	add	r3, fp, #8	; 0x8
21f1baa4:	e50b3014 	str	r3, [fp, #-20]

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
21f1baa8:	e51b2014 	ldr	r2, [fp, #-20]
21f1baac:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f1bab0:	e2433001 	sub	r3, r3, #1	; 0x1
21f1bab4:	e1a00003 	mov	r0, r3
21f1bab8:	e59b1004 	ldr	r1, [fp, #4]
21f1babc:	eb0020d0 	bl	21f23e04 <vsprintf>
21f1bac0:	e1a03000 	mov	r3, r0
21f1bac4:	e50b3010 	str	r3, [fp, #-16]
	va_end (args);

	/* Print the string */
	puts (printbuffer);
21f1bac8:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
21f1bacc:	e2433001 	sub	r3, r3, #1	; 0x1
21f1bad0:	e1a00003 	mov	r0, r3
21f1bad4:	ebffffd9 	bl	21f1ba40 <puts>
}
21f1bad8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1badc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1bae0 <vprintf>:

void vprintf (const char *fmt, va_list args)
{
21f1bae0:	e1a0c00d 	mov	ip, sp
21f1bae4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bae8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1baec:	e24ddf4a 	sub	sp, sp, #296	; 0x128
21f1baf0:	e50b0130 	str	r0, [fp, #-304]
21f1baf4:	e50b1134 	str	r1, [fp, #-308]
	uint i;
	char printbuffer[CFG_PBSIZE];

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf (printbuffer, fmt, args);
21f1baf8:	e24b3f4a 	sub	r3, fp, #296	; 0x128
21f1bafc:	e2433001 	sub	r3, r3, #1	; 0x1
21f1bb00:	e1a00003 	mov	r0, r3
21f1bb04:	e51b1130 	ldr	r1, [fp, #-304]
21f1bb08:	e51b2134 	ldr	r2, [fp, #-308]
21f1bb0c:	eb0020bc 	bl	21f23e04 <vsprintf>
21f1bb10:	e1a03000 	mov	r3, r0
21f1bb14:	e50b3010 	str	r3, [fp, #-16]

	/* Print the string */
	puts (printbuffer);
21f1bb18:	e24b3f4a 	sub	r3, fp, #296	; 0x128
21f1bb1c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1bb20:	e1a00003 	mov	r0, r3
21f1bb24:	ebffffc5 	bl	21f1ba40 <puts>
}
21f1bb28:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1bb2c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1bb30 <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc (void)
{
21f1bb30:	e1a0c00d 	mov	ip, sp
21f1bb34:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bb38:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1bb3c:	e24dd004 	sub	sp, sp, #4	; 0x4
	if (!ctrlc_disabled && gd->have_console) {
21f1bb40:	e59f3068 	ldr	r3, [pc, #104]	; 21f1bbb0 <.text+0x1bbb0>
21f1bb44:	e5933000 	ldr	r3, [r3]
21f1bb48:	e3530000 	cmp	r3, #0	; 0x0
21f1bb4c:	1a000012 	bne	21f1bb9c <ctrlc+0x6c>
21f1bb50:	e1a03008 	mov	r3, r8
21f1bb54:	e593300c 	ldr	r3, [r3, #12]
21f1bb58:	e3530000 	cmp	r3, #0	; 0x0
21f1bb5c:	0a00000e 	beq	21f1bb9c <ctrlc+0x6c>
		if (tstc ()) {
21f1bb60:	ebffff8a 	bl	21f1b990 <tstc>
21f1bb64:	e1a03000 	mov	r3, r0
21f1bb68:	e3530000 	cmp	r3, #0	; 0x0
21f1bb6c:	0a00000a 	beq	21f1bb9c <ctrlc+0x6c>
			switch (getc ()) {
21f1bb70:	ebffff70 	bl	21f1b938 <getc>
21f1bb74:	e1a03000 	mov	r3, r0
21f1bb78:	e3530003 	cmp	r3, #3	; 0x3
21f1bb7c:	0a000000 	beq	21f1bb84 <ctrlc+0x54>
21f1bb80:	ea000005 	b	21f1bb9c <ctrlc+0x6c>
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
21f1bb84:	e59f2028 	ldr	r2, [pc, #40]	; 21f1bbb4 <.text+0x1bbb4>
21f1bb88:	e3a03001 	mov	r3, #1	; 0x1
21f1bb8c:	e5823000 	str	r3, [r2]
				return 1;
21f1bb90:	e3a03001 	mov	r3, #1	; 0x1
21f1bb94:	e50b3010 	str	r3, [fp, #-16]
21f1bb98:	ea000001 	b	21f1bba4 <ctrlc+0x74>
			default:
				break;
			}
		}
	}
	return 0;
21f1bb9c:	e3a03000 	mov	r3, #0	; 0x0
21f1bba0:	e50b3010 	str	r3, [fp, #-16]
21f1bba4:	e51b3010 	ldr	r3, [fp, #-16]
}
21f1bba8:	e1a00003 	mov	r0, r3
21f1bbac:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f1bbb0:	21f67758 	mvncss	r7, r8, asr r7
21f1bbb4:	21f6775c 	mvncss	r7, ip, asr r7

21f1bbb8 <disable_ctrlc>:

/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc (int disable)
{
21f1bbb8:	e1a0c00d 	mov	ip, sp
21f1bbbc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bbc0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1bbc4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1bbc8:	e50b0014 	str	r0, [fp, #-20]
	int prev = ctrlc_disabled;	/* save previous state */
21f1bbcc:	e59f3020 	ldr	r3, [pc, #32]	; 21f1bbf4 <.text+0x1bbf4>
21f1bbd0:	e5933000 	ldr	r3, [r3]
21f1bbd4:	e50b3010 	str	r3, [fp, #-16]

	ctrlc_disabled = disable;
21f1bbd8:	e59f2014 	ldr	r2, [pc, #20]	; 21f1bbf4 <.text+0x1bbf4>
21f1bbdc:	e51b3014 	ldr	r3, [fp, #-20]
21f1bbe0:	e5823000 	str	r3, [r2]
	return prev;
21f1bbe4:	e51b3010 	ldr	r3, [fp, #-16]
}
21f1bbe8:	e1a00003 	mov	r0, r3
21f1bbec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1bbf0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1bbf4:	21f67758 	mvncss	r7, r8, asr r7

21f1bbf8 <had_ctrlc>:

int had_ctrlc (void)
{
21f1bbf8:	e1a0c00d 	mov	ip, sp
21f1bbfc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bc00:	e24cb004 	sub	fp, ip, #4	; 0x4
	return ctrlc_was_pressed;
21f1bc04:	e59f3008 	ldr	r3, [pc, #8]	; 21f1bc14 <.text+0x1bc14>
21f1bc08:	e5933000 	ldr	r3, [r3]
}
21f1bc0c:	e1a00003 	mov	r0, r3
21f1bc10:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1bc14:	21f6775c 	mvncss	r7, ip, asr r7

21f1bc18 <clear_ctrlc>:

void clear_ctrlc (void)
{
21f1bc18:	e1a0c00d 	mov	ip, sp
21f1bc1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bc20:	e24cb004 	sub	fp, ip, #4	; 0x4
	ctrlc_was_pressed = 0;
21f1bc24:	e59f2008 	ldr	r2, [pc, #8]	; 21f1bc34 <.text+0x1bc34>
21f1bc28:	e3a03000 	mov	r3, #0	; 0x0
21f1bc2c:	e5823000 	str	r3, [r2]
}
21f1bc30:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1bc34:	21f6775c 	mvncss	r7, ip, asr r7

21f1bc38 <dbg>:

#ifdef CONFIG_MODEM_SUPPORT_DEBUG
char	screen[1024];
char *cursor = screen;
int once = 0;
inline void dbg(const char *fmt, ...)
{
	va_list	args;
	uint	i;
	char	printbuffer[CFG_PBSIZE];

	if (!once) {
		memset(screen, 0, sizeof(screen));
		once++;
	}

	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vsprintf(printbuffer, fmt, args);
	va_end(args);

	if ((screen + sizeof(screen) - 1 - cursor) < strlen(printbuffer)+1) {
		memset(screen, 0, sizeof(screen));
		cursor = screen;
	}
	sprintf(cursor, printbuffer);
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
21f1bc38:	e1a0c00d 	mov	ip, sp
21f1bc3c:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
21f1bc40:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bc44:	e24cb014 	sub	fp, ip, #20	; 0x14
}
21f1bc48:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1bc4c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1bc50 <console_assign>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

int console_assign (int file, char *devname)
{
21f1bc50:	e1a0c00d 	mov	ip, sp
21f1bc54:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bc58:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1bc5c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f1bc60:	e50b001c 	str	r0, [fp, #-28]
21f1bc64:	e50b1020 	str	r1, [fp, #-32]
	int flag, i;

	/* Check for valid file */
	switch (file) {
21f1bc68:	e51b301c 	ldr	r3, [fp, #-28]
21f1bc6c:	e50b3028 	str	r3, [fp, #-40]
21f1bc70:	e51b3028 	ldr	r3, [fp, #-40]
21f1bc74:	e3530000 	cmp	r3, #0	; 0x0
21f1bc78:	0a000006 	beq	21f1bc98 <console_assign+0x48>
21f1bc7c:	e51b3028 	ldr	r3, [fp, #-40]
21f1bc80:	e3530000 	cmp	r3, #0	; 0x0
21f1bc84:	ba000009 	blt	21f1bcb0 <console_assign+0x60>
21f1bc88:	e51b3028 	ldr	r3, [fp, #-40]
21f1bc8c:	e3530002 	cmp	r3, #2	; 0x2
21f1bc90:	ca000006 	bgt	21f1bcb0 <console_assign+0x60>
21f1bc94:	ea000002 	b	21f1bca4 <console_assign+0x54>
	case stdin:
		flag = DEV_FLAGS_INPUT;
21f1bc98:	e3a03001 	mov	r3, #1	; 0x1
21f1bc9c:	e50b3018 	str	r3, [fp, #-24]
		break;
21f1bca0:	ea000005 	b	21f1bcbc <console_assign+0x6c>
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
21f1bca4:	e3a03002 	mov	r3, #2	; 0x2
21f1bca8:	e50b3018 	str	r3, [fp, #-24]
		break;
21f1bcac:	ea000002 	b	21f1bcbc <console_assign+0x6c>
	default:
		return -1;
21f1bcb0:	e3e03000 	mvn	r3, #0	; 0x0
21f1bcb4:	e50b3024 	str	r3, [fp, #-36]
21f1bcb8:	ea00002d 	b	21f1bd74 <console_assign+0x124>
	}

	/* Check for valid device name */

	for (i = 1; i <= ListNumItems (devlist); i++) {
21f1bcbc:	e3a03001 	mov	r3, #1	; 0x1
21f1bcc0:	e50b3014 	str	r3, [fp, #-20]
21f1bcc4:	ea000020 	b	21f1bd4c <console_assign+0xfc>
		device_t *dev = ListGetPtrToItem (devlist, i);
21f1bcc8:	e59f30b4 	ldr	r3, [pc, #180]	; 21f1bd84 <.text+0x1bd84>
21f1bccc:	e5933000 	ldr	r3, [r3]
21f1bcd0:	e1a00003 	mov	r0, r3
21f1bcd4:	e51b1014 	ldr	r1, [fp, #-20]
21f1bcd8:	eb00111c 	bl	21f20150 <ListGetPtrToItem>
21f1bcdc:	e1a03000 	mov	r3, r0
21f1bce0:	e50b3010 	str	r3, [fp, #-16]

		if (strcmp (devname, dev->name) == 0) {
21f1bce4:	e51b3010 	ldr	r3, [fp, #-16]
21f1bce8:	e2833008 	add	r3, r3, #8	; 0x8
21f1bcec:	e51b0020 	ldr	r0, [fp, #-32]
21f1bcf0:	e1a01003 	mov	r1, r3
21f1bcf4:	eb001b14 	bl	21f2294c <strcmp>
21f1bcf8:	e1a03000 	mov	r3, r0
21f1bcfc:	e3530000 	cmp	r3, #0	; 0x0
21f1bd00:	1a00000e 	bne	21f1bd40 <console_assign+0xf0>
			if (dev->flags & flag)
21f1bd04:	e51b3010 	ldr	r3, [fp, #-16]
21f1bd08:	e5932000 	ldr	r2, [r3]
21f1bd0c:	e51b3018 	ldr	r3, [fp, #-24]
21f1bd10:	e0023003 	and	r3, r2, r3
21f1bd14:	e3530000 	cmp	r3, #0	; 0x0
21f1bd18:	0a000005 	beq	21f1bd34 <console_assign+0xe4>
				return console_setfile (file, dev);
21f1bd1c:	e51b001c 	ldr	r0, [fp, #-28]
21f1bd20:	e51b1010 	ldr	r1, [fp, #-16]
21f1bd24:	ebfffe2a 	bl	21f1b5d4 <console_setfile>
21f1bd28:	e1a03000 	mov	r3, r0
21f1bd2c:	e50b3024 	str	r3, [fp, #-36]
21f1bd30:	ea00000f 	b	21f1bd74 <console_assign+0x124>

			return -1;
21f1bd34:	e3e03000 	mvn	r3, #0	; 0x0
21f1bd38:	e50b3024 	str	r3, [fp, #-36]
21f1bd3c:	ea00000c 	b	21f1bd74 <console_assign+0x124>
21f1bd40:	e51b3014 	ldr	r3, [fp, #-20]
21f1bd44:	e2833001 	add	r3, r3, #1	; 0x1
21f1bd48:	e50b3014 	str	r3, [fp, #-20]
21f1bd4c:	e59f3030 	ldr	r3, [pc, #48]	; 21f1bd84 <.text+0x1bd84>
21f1bd50:	e5933000 	ldr	r3, [r3]
21f1bd54:	e1a00003 	mov	r0, r3
21f1bd58:	eb001131 	bl	21f20224 <ListNumItems>
21f1bd5c:	e1a02000 	mov	r2, r0
21f1bd60:	e51b3014 	ldr	r3, [fp, #-20]
21f1bd64:	e1520003 	cmp	r2, r3
21f1bd68:	aaffffd6 	bge	21f1bcc8 <console_assign+0x78>
		}
	}

	return -1;
21f1bd6c:	e3e03000 	mvn	r3, #0	; 0x0
21f1bd70:	e50b3024 	str	r3, [fp, #-36]
21f1bd74:	e51b3024 	ldr	r3, [fp, #-36]
}
21f1bd78:	e1a00003 	mov	r0, r3
21f1bd7c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1bd80:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1bd84:	21f67760 	mvncss	r7, r0, ror #14

21f1bd88 <console_init_f>:

/* Called before relocation - use serial functions */
int console_init_f (void)
{
21f1bd88:	e1a0c00d 	mov	ip, sp
21f1bd8c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bd90:	e24cb004 	sub	fp, ip, #4	; 0x4
	gd->have_console = 1;
21f1bd94:	e1a02008 	mov	r2, r8
21f1bd98:	e3a03001 	mov	r3, #1	; 0x1
21f1bd9c:	e582300c 	str	r3, [r2, #12]

#ifdef CONFIG_SILENT_CONSOLE
	if (getenv("silent") != NULL)
		gd->flags |= GD_FLG_SILENT;
#endif

	return (0);
21f1bda0:	e3a03000 	mov	r3, #0	; 0x0
}
21f1bda4:	e1a00003 	mov	r0, r3
21f1bda8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1bdac <console_init_r>:

#if defined(CFG_CONSOLE_IS_IN_ENV) || defined(CONFIG_SPLASH_SCREEN) || defined(CONFIG_SILENT_CONSOLE)
/* search a device */
device_t *search_device (int flags, char *name)
{
	int i, items;
	device_t *dev = NULL;

	items = ListNumItems (devlist);
	if (name == NULL)
		return dev;

	for (i = 1; i <= items; i++) {
		dev = ListGetPtrToItem (devlist, i);
		if ((dev->flags & flags) && (strcmp (name, dev->name) == 0)) {
			break;
		}
	}
	return dev;
}
#endif /* CFG_CONSOLE_IS_IN_ENV || CONFIG_SPLASH_SCREEN */

#ifdef CFG_CONSOLE_IS_IN_ENV
/* Called after the relocation - use desired console functions */
int console_init_r (void)
{
	char *stdinname, *stdoutname, *stderrname;
	device_t *inputdev = NULL, *outputdev = NULL, *errdev = NULL;
#ifdef CFG_CONSOLE_ENV_OVERWRITE
	int i;
#endif /* CFG_CONSOLE_ENV_OVERWRITE */

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
	gd->jt[XF_putc] = serial_putc;
	gd->jt[XF_puts] = serial_puts;
	gd->jt[XF_printf] = serial_printf;

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv ("stdin");
	stdoutname = getenv ("stdout");
	stderrname = getenv ("stderr");

	if (OVERWRITE_CONSOLE == 0) { 	/* if not overwritten by config switch */
		inputdev  = search_device (DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device (DEV_FLAGS_OUTPUT, stdoutname);
		errdev    = search_device (DEV_FLAGS_OUTPUT, stderrname);
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
		inputdev  = search_device (DEV_FLAGS_INPUT,  "serial");
	}
	if (outputdev == NULL) {
		outputdev = search_device (DEV_FLAGS_OUTPUT, "serial");
	}
	if (errdev == NULL) {
		errdev    = search_device (DEV_FLAGS_OUTPUT, "serial");
	}
	/* Initializes output console first */
	if (outputdev != NULL) {
		console_setfile (stdout, outputdev);
	}
	if (errdev != NULL) {
		console_setfile (stderr, errdev);
	}
	if (inputdev != NULL) {
		console_setfile (stdin, inputdev);
	}

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */

#ifndef CFG_CONSOLE_INFO_QUIET
	/* Print information */
	puts ("In:    ");
	if (stdio_devices[stdin] == NULL) {
		puts ("No input devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
	}

	puts ("Out:   ");
	if (stdio_devices[stdout] == NULL) {
		puts ("No output devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
	}

	puts ("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts ("No error devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
	}
#endif /* CFG_CONSOLE_INFO_QUIET */

#ifdef CFG_CONSOLE_ENV_OVERWRITE
	/* set the environment variables (will overwrite previous env settings) */
	for (i = 0; i < 3; i++) {
		setenv (stdio_names[i], stdio_devices[i]->name);
	}
#endif /* CFG_CONSOLE_ENV_OVERWRITE */

#if 0
	/* If nothing usable installed, use only the initial console */
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return (0);
#endif
	return (0);
}

#else /* CFG_CONSOLE_IS_IN_ENV */

/* Called after the relocation - use desired console functions */
int console_init_r (void)
{
21f1bdac:	e1a0c00d 	mov	ip, sp
21f1bdb0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1bdb4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1bdb8:	e24dd014 	sub	sp, sp, #20	; 0x14
	device_t *inputdev = NULL, *outputdev = NULL;
21f1bdbc:	e3a03000 	mov	r3, #0	; 0x0
21f1bdc0:	e50b3020 	str	r3, [fp, #-32]
21f1bdc4:	e3a03000 	mov	r3, #0	; 0x0
21f1bdc8:	e50b301c 	str	r3, [fp, #-28]
	int i, items = ListNumItems (devlist);
21f1bdcc:	e59f3228 	ldr	r3, [pc, #552]	; 21f1bffc <.text+0x1bffc>
21f1bdd0:	e5933000 	ldr	r3, [r3]
21f1bdd4:	e1a00003 	mov	r0, r3
21f1bdd8:	eb001111 	bl	21f20224 <ListNumItems>
21f1bddc:	e1a03000 	mov	r3, r0
21f1bde0:	e50b3014 	str	r3, [fp, #-20]

#ifdef CONFIG_SPLASH_SCREEN
	/* suppress all output if splash screen is enabled and we have
	   a bmp to display                                            */
	if (getenv("splashimage") != NULL)
		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
#endif

#ifdef CONFIG_SILENT_CONSOLE
	/* Suppress all output if "silent" mode requested		*/
	if (gd->flags & GD_FLG_SILENT)
		outputdev = search_device (DEV_FLAGS_OUTPUT, "nulldev");
#endif

	/* Scan devices looking for input and output devices */
	for (i = 1;
21f1bde4:	e3a03001 	mov	r3, #1	; 0x1
21f1bde8:	e50b3018 	str	r3, [fp, #-24]
	     (i <= items) && ((inputdev == NULL) || (outputdev == NULL));
21f1bdec:	ea000020 	b	21f1be74 <console_init_r+0xc8>
	     i++
	    ) {
		device_t *dev = ListGetPtrToItem (devlist, i);
21f1bdf0:	e59f3204 	ldr	r3, [pc, #516]	; 21f1bffc <.text+0x1bffc>
21f1bdf4:	e5933000 	ldr	r3, [r3]
21f1bdf8:	e1a00003 	mov	r0, r3
21f1bdfc:	e51b1018 	ldr	r1, [fp, #-24]
21f1be00:	eb0010d2 	bl	21f20150 <ListGetPtrToItem>
21f1be04:	e1a03000 	mov	r3, r0
21f1be08:	e50b3010 	str	r3, [fp, #-16]

		if ((dev->flags & DEV_FLAGS_INPUT) && (inputdev == NULL)) {
21f1be0c:	e51b3010 	ldr	r3, [fp, #-16]
21f1be10:	e5933000 	ldr	r3, [r3]
21f1be14:	e2033001 	and	r3, r3, #1	; 0x1
21f1be18:	e20330ff 	and	r3, r3, #255	; 0xff
21f1be1c:	e3530000 	cmp	r3, #0	; 0x0
21f1be20:	0a000004 	beq	21f1be38 <console_init_r+0x8c>
21f1be24:	e51b3020 	ldr	r3, [fp, #-32]
21f1be28:	e3530000 	cmp	r3, #0	; 0x0
21f1be2c:	1a000001 	bne	21f1be38 <console_init_r+0x8c>
			inputdev = dev;
21f1be30:	e51b3010 	ldr	r3, [fp, #-16]
21f1be34:	e50b3020 	str	r3, [fp, #-32]
		}
		if ((dev->flags & DEV_FLAGS_OUTPUT) && (outputdev == NULL)) {
21f1be38:	e51b3010 	ldr	r3, [fp, #-16]
21f1be3c:	e5933000 	ldr	r3, [r3]
21f1be40:	e1a030a3 	mov	r3, r3, lsr #1
21f1be44:	e2033001 	and	r3, r3, #1	; 0x1
21f1be48:	e20330ff 	and	r3, r3, #255	; 0xff
21f1be4c:	e3530000 	cmp	r3, #0	; 0x0
21f1be50:	0a000004 	beq	21f1be68 <console_init_r+0xbc>
21f1be54:	e51b301c 	ldr	r3, [fp, #-28]
21f1be58:	e3530000 	cmp	r3, #0	; 0x0
21f1be5c:	1a000001 	bne	21f1be68 <console_init_r+0xbc>
			outputdev = dev;
21f1be60:	e51b3010 	ldr	r3, [fp, #-16]
21f1be64:	e50b301c 	str	r3, [fp, #-28]
21f1be68:	e51b3018 	ldr	r3, [fp, #-24]
21f1be6c:	e2833001 	add	r3, r3, #1	; 0x1
21f1be70:	e50b3018 	str	r3, [fp, #-24]
21f1be74:	e51b2018 	ldr	r2, [fp, #-24]
21f1be78:	e51b3014 	ldr	r3, [fp, #-20]
21f1be7c:	e1520003 	cmp	r2, r3
21f1be80:	ca000005 	bgt	21f1be9c <console_init_r+0xf0>
21f1be84:	e51b3020 	ldr	r3, [fp, #-32]
21f1be88:	e3530000 	cmp	r3, #0	; 0x0
21f1be8c:	0affffd7 	beq	21f1bdf0 <console_init_r+0x44>
21f1be90:	e51b301c 	ldr	r3, [fp, #-28]
21f1be94:	e3530000 	cmp	r3, #0	; 0x0
21f1be98:	0affffd4 	beq	21f1bdf0 <console_init_r+0x44>
		}
	}

	/* Initializes output console first */
	if (outputdev != NULL) {
21f1be9c:	e51b301c 	ldr	r3, [fp, #-28]
21f1bea0:	e3530000 	cmp	r3, #0	; 0x0
21f1bea4:	0a000005 	beq	21f1bec0 <console_init_r+0x114>
		console_setfile (stdout, outputdev);
21f1bea8:	e3a00001 	mov	r0, #1	; 0x1
21f1beac:	e51b101c 	ldr	r1, [fp, #-28]
21f1beb0:	ebfffdc7 	bl	21f1b5d4 <console_setfile>
		console_setfile (stderr, outputdev);
21f1beb4:	e3a00002 	mov	r0, #2	; 0x2
21f1beb8:	e51b101c 	ldr	r1, [fp, #-28]
21f1bebc:	ebfffdc4 	bl	21f1b5d4 <console_setfile>
	}

	/* Initializes input console */
	if (inputdev != NULL) {
21f1bec0:	e51b3020 	ldr	r3, [fp, #-32]
21f1bec4:	e3530000 	cmp	r3, #0	; 0x0
21f1bec8:	0a000002 	beq	21f1bed8 <console_init_r+0x12c>
		console_setfile (stdin, inputdev);
21f1becc:	e3a00000 	mov	r0, #0	; 0x0
21f1bed0:	e51b1020 	ldr	r1, [fp, #-32]
21f1bed4:	ebfffdbe 	bl	21f1b5d4 <console_setfile>
	}

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
21f1bed8:	e1a02008 	mov	r2, r8
21f1bedc:	e1a03008 	mov	r3, r8
21f1bee0:	e5933004 	ldr	r3, [r3, #4]
21f1bee4:	e3833002 	orr	r3, r3, #2	; 0x2
21f1bee8:	e5823004 	str	r3, [r2, #4]

#ifndef CFG_CONSOLE_INFO_QUIET
	/* Print information */
	puts ("In:    ");
21f1beec:	e59f010c 	ldr	r0, [pc, #268]	; 21f1c000 <.text+0x1c000>
21f1bef0:	ebfffed2 	bl	21f1ba40 <puts>
	if (stdio_devices[stdin] == NULL) {
21f1bef4:	e59f3108 	ldr	r3, [pc, #264]	; 21f1c004 <.text+0x1c004>
21f1bef8:	e5933000 	ldr	r3, [r3]
21f1befc:	e3530000 	cmp	r3, #0	; 0x0
21f1bf00:	1a000002 	bne	21f1bf10 <console_init_r+0x164>
		puts ("No input devices available!\n");
21f1bf04:	e59f00fc 	ldr	r0, [pc, #252]	; 21f1c008 <.text+0x1c008>
21f1bf08:	ebfffecc 	bl	21f1ba40 <puts>
21f1bf0c:	ea000005 	b	21f1bf28 <console_init_r+0x17c>
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
21f1bf10:	e59f30ec 	ldr	r3, [pc, #236]	; 21f1c004 <.text+0x1c004>
21f1bf14:	e5933000 	ldr	r3, [r3]
21f1bf18:	e2833008 	add	r3, r3, #8	; 0x8
21f1bf1c:	e59f00e8 	ldr	r0, [pc, #232]	; 21f1c00c <.text+0x1c00c>
21f1bf20:	e1a01003 	mov	r1, r3
21f1bf24:	ebfffed8 	bl	21f1ba8c <printf>
	}

	puts ("Out:   ");
21f1bf28:	e59f00e0 	ldr	r0, [pc, #224]	; 21f1c010 <.text+0x1c010>
21f1bf2c:	ebfffec3 	bl	21f1ba40 <puts>
	if (stdio_devices[stdout] == NULL) {
21f1bf30:	e59f30cc 	ldr	r3, [pc, #204]	; 21f1c004 <.text+0x1c004>
21f1bf34:	e5933004 	ldr	r3, [r3, #4]
21f1bf38:	e3530000 	cmp	r3, #0	; 0x0
21f1bf3c:	1a000002 	bne	21f1bf4c <console_init_r+0x1a0>
		puts ("No output devices available!\n");
21f1bf40:	e59f00cc 	ldr	r0, [pc, #204]	; 21f1c014 <.text+0x1c014>
21f1bf44:	ebfffebd 	bl	21f1ba40 <puts>
21f1bf48:	ea000005 	b	21f1bf64 <console_init_r+0x1b8>
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
21f1bf4c:	e59f30b0 	ldr	r3, [pc, #176]	; 21f1c004 <.text+0x1c004>
21f1bf50:	e5933004 	ldr	r3, [r3, #4]
21f1bf54:	e2833008 	add	r3, r3, #8	; 0x8
21f1bf58:	e59f00ac 	ldr	r0, [pc, #172]	; 21f1c00c <.text+0x1c00c>
21f1bf5c:	e1a01003 	mov	r1, r3
21f1bf60:	ebfffec9 	bl	21f1ba8c <printf>
	}

	puts ("Err:   ");
21f1bf64:	e59f00ac 	ldr	r0, [pc, #172]	; 21f1c018 <.text+0x1c018>
21f1bf68:	ebfffeb4 	bl	21f1ba40 <puts>
	if (stdio_devices[stderr] == NULL) {
21f1bf6c:	e59f3090 	ldr	r3, [pc, #144]	; 21f1c004 <.text+0x1c004>
21f1bf70:	e5933008 	ldr	r3, [r3, #8]
21f1bf74:	e3530000 	cmp	r3, #0	; 0x0
21f1bf78:	1a000002 	bne	21f1bf88 <console_init_r+0x1dc>
		puts ("No error devices available!\n");
21f1bf7c:	e59f0098 	ldr	r0, [pc, #152]	; 21f1c01c <.text+0x1c01c>
21f1bf80:	ebfffeae 	bl	21f1ba40 <puts>
21f1bf84:	ea000005 	b	21f1bfa0 <console_init_r+0x1f4>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
21f1bf88:	e59f3074 	ldr	r3, [pc, #116]	; 21f1c004 <.text+0x1c004>
21f1bf8c:	e5933008 	ldr	r3, [r3, #8]
21f1bf90:	e2833008 	add	r3, r3, #8	; 0x8
21f1bf94:	e59f0070 	ldr	r0, [pc, #112]	; 21f1c00c <.text+0x1c00c>
21f1bf98:	e1a01003 	mov	r1, r3
21f1bf9c:	ebfffeba 	bl	21f1ba8c <printf>
	}
#endif /* CFG_CONSOLE_INFO_QUIET */

	/* Setting environment variables */
	for (i = 0; i < 3; i++) {
21f1bfa0:	e3a03000 	mov	r3, #0	; 0x0
21f1bfa4:	e50b3018 	str	r3, [fp, #-24]
21f1bfa8:	ea00000c 	b	21f1bfe0 <console_init_r+0x234>
		setenv (stdio_names[i], stdio_devices[i]->name);
21f1bfac:	e51b2018 	ldr	r2, [fp, #-24]
21f1bfb0:	e59f3068 	ldr	r3, [pc, #104]	; 21f1c020 <.text+0x1c020>
21f1bfb4:	e7931102 	ldr	r1, [r3, r2, lsl #2]
21f1bfb8:	e51b2018 	ldr	r2, [fp, #-24]
21f1bfbc:	e59f3040 	ldr	r3, [pc, #64]	; 21f1c004 <.text+0x1c004>
21f1bfc0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f1bfc4:	e2833008 	add	r3, r3, #8	; 0x8
21f1bfc8:	e1a00001 	mov	r0, r1
21f1bfcc:	e1a01003 	mov	r1, r3
21f1bfd0:	ebfffadc 	bl	21f1ab48 <setenv>
21f1bfd4:	e51b3018 	ldr	r3, [fp, #-24]
21f1bfd8:	e2833001 	add	r3, r3, #1	; 0x1
21f1bfdc:	e50b3018 	str	r3, [fp, #-24]
21f1bfe0:	e51b3018 	ldr	r3, [fp, #-24]
21f1bfe4:	e3530002 	cmp	r3, #2	; 0x2
21f1bfe8:	daffffef 	ble	21f1bfac <console_init_r+0x200>
	}

#if 0
	/* If nothing usable installed, use only the initial console */
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return (0);
#endif

	return (0);
21f1bfec:	e3a03000 	mov	r3, #0	; 0x0
}
21f1bff0:	e1a00003 	mov	r0, r3
21f1bff4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1bff8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1bffc:	21f67760 	mvncss	r7, r0, ror #14
21f1c000:	21f32180 	mvncss	r2, r0, lsl #3
21f1c004:	21f67764 	mvncss	r7, r4, ror #14
21f1c008:	21f32188 	mvncss	r2, r8, lsl #3
21f1c00c:	21f321a8 	mvncss	r2, r8, lsr #3
21f1c010:	21f321ac 	mvncss	r2, ip, lsr #3
21f1c014:	21f321b4 	ldrcsh	r2, [r3, #20]!
21f1c018:	21f321d4 	ldrcssb	r2, [r3, #20]!
21f1c01c:	21f321dc 	ldrcssb	r2, [r3, #28]!
21f1c020:	21f33584 	mvncss	r3, r4, lsl #11

21f1c024 <drv_system_init>:
 **************************************************************************
 */

static void drv_system_init (void)
{
21f1c024:	e1a0c00d 	mov	ip, sp
21f1c028:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1c02c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1c030:	e24dd034 	sub	sp, sp, #52	; 0x34
	device_t dev;

	memset (&dev, 0, sizeof (dev));
21f1c034:	e24b3040 	sub	r3, fp, #64	; 0x40
21f1c038:	e1a00003 	mov	r0, r3
21f1c03c:	e3a01000 	mov	r1, #0	; 0x0
21f1c040:	e3a02034 	mov	r2, #52	; 0x34
21f1c044:	eb001c27 	bl	21f230e8 <memset>

	strcpy (dev.name, "serial");
21f1c048:	e24b3040 	sub	r3, fp, #64	; 0x40
21f1c04c:	e2833008 	add	r3, r3, #8	; 0x8
21f1c050:	e1a00003 	mov	r0, r3
21f1c054:	e59f103c 	ldr	r1, [pc, #60]	; 21f1c098 <.text+0x1c098>
21f1c058:	eb00199d 	bl	21f226d4 <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
21f1c05c:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
21f1c060:	e50b3040 	str	r3, [fp, #-64]
#ifdef CONFIG_SERIAL_SOFTWARE_FIFO
	dev.putc = serial_buffered_putc;
	dev.puts = serial_buffered_puts;
	dev.getc = serial_buffered_getc;
	dev.tstc = serial_buffered_tstc;
#else
	dev.putc = serial_putc;
21f1c064:	e59f3030 	ldr	r3, [pc, #48]	; 21f1c09c <.text+0x1c09c>
21f1c068:	e50b3020 	str	r3, [fp, #-32]
	dev.puts = serial_puts;
21f1c06c:	e59f302c 	ldr	r3, [pc, #44]	; 21f1c0a0 <.text+0x1c0a0>
21f1c070:	e50b301c 	str	r3, [fp, #-28]
	dev.getc = serial_getc;
21f1c074:	e59f3028 	ldr	r3, [pc, #40]	; 21f1c0a4 <.text+0x1c0a4>
21f1c078:	e50b3014 	str	r3, [fp, #-20]
	dev.tstc = serial_tstc;
21f1c07c:	e59f3024 	ldr	r3, [pc, #36]	; 21f1c0a8 <.text+0x1c0a8>
21f1c080:	e50b3018 	str	r3, [fp, #-24]
#endif

	device_register (&dev);
21f1c084:	e24b3040 	sub	r3, fp, #64	; 0x40
21f1c088:	e1a00003 	mov	r0, r3
21f1c08c:	eb000006 	bl	21f1c0ac <device_register>

#ifdef CFG_DEVICE_NULLDEV
	memset (&dev, 0, sizeof (dev));

	strcpy (dev.name, "nulldev");
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
	dev.putc = nulldev_putc;
	dev.puts = nulldev_puts;
	dev.getc = nulldev_input;
	dev.tstc = nulldev_input;

	device_register (&dev);
#endif
}
21f1c090:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1c094:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1c098:	21f32214 	mvncss	r2, r4, lsl r2
21f1c09c:	21f2e430 	mvncss	lr, r0, lsr r4
21f1c0a0:	21f2e498 	ldrcsb	lr, [r2, #72]!
21f1c0a4:	21f2e4e4 	mvncss	lr, r4, ror #9
21f1c0a8:	21f2e528 	mvncss	lr, r8, lsr #10

21f1c0ac <device_register>:

/**************************************************************************
 * DEVICES
 **************************************************************************
 */

int device_register (device_t * dev)
{
21f1c0ac:	e1a0c00d 	mov	ip, sp
21f1c0b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1c0b4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1c0b8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1c0bc:	e50b0010 	str	r0, [fp, #-16]
	ListInsertItem (devlist, dev, LIST_END);
21f1c0c0:	e59f301c 	ldr	r3, [pc, #28]	; 21f1c0e4 <.text+0x1c0e4>
21f1c0c4:	e5933000 	ldr	r3, [r3]
21f1c0c8:	e1a00003 	mov	r0, r3
21f1c0cc:	e51b1010 	ldr	r1, [fp, #-16]
21f1c0d0:	e3a02000 	mov	r2, #0	; 0x0
21f1c0d4:	eb000f18 	bl	21f1fd3c <ListInsertItem>
	return 0;
21f1c0d8:	e3a03000 	mov	r3, #0	; 0x0
}
21f1c0dc:	e1a00003 	mov	r0, r3
21f1c0e0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f1c0e4:	21f67760 	mvncss	r7, r0, ror #14

21f1c0e8 <devices_init>:

/* deregister the device "devname".
 * returns 0 if success, -1 if device is assigned and 1 if devname not found
 */
#ifdef	CFG_DEVICE_DEREGISTER
int device_deregister(char *devname)
{
	int i,l,dev_index;
	device_t *dev = NULL;
	char temp_names[3][8];

	dev_index=-1;
	for (i=1; i<=ListNumItems(devlist); i++) {
		dev = ListGetPtrToItem (devlist, i);
		if(strcmp(dev->name,devname)==0) {
			dev_index=i;
			break;
		}
	}
	if(dev_index<0) /* device not found */
		return 0;
	/* get stdio devices (ListRemoveItem changes the dev list) */
	for (l=0 ; l< MAX_FILES; l++) {
		if (stdio_devices[l] == dev) {
			/* Device is assigned -> report error */
			return -1;
		}
		memcpy (&temp_names[l][0],
			stdio_devices[l]->name,
			sizeof(stdio_devices[l]->name));
	}
	ListRemoveItem(devlist,NULL,dev_index);
	/* reassign Device list */
	for (i=1; i<=ListNumItems(devlist); i++) {
		dev = ListGetPtrToItem (devlist, i);
		for (l=0 ; l< MAX_FILES; l++) {
			if(strcmp(dev->name,temp_names[l])==0) {
				stdio_devices[l] = dev;
			}
		}
	}
	return 0;
}
#endif	/* CFG_DEVICE_DEREGISTER */

int devices_init (void)
{
21f1c0e8:	e1a0c00d 	mov	ip, sp
21f1c0ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1c0f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1c0f4:	e24dd004 	sub	sp, sp, #4	; 0x4
#ifndef CONFIG_ARM     /* already relocated for current ARM implementation */
	ulong relocation_offset = gd->reloc_off;
	int i;

	/* relocate device name pointers */
	for (i = 0; i < (sizeof (stdio_names) / sizeof (char *)); ++i) {
		stdio_names[i] = (char *) (((ulong) stdio_names[i]) +
						relocation_offset);
	}
#endif

	/* Initialize the list */
	devlist = ListCreate (sizeof (device_t));
21f1c0f8:	e3a00034 	mov	r0, #52	; 0x34
21f1c0fc:	eb000ecb 	bl	21f1fc30 <ListCreate>
21f1c100:	e1a02000 	mov	r2, r0
21f1c104:	e59f3040 	ldr	r3, [pc, #64]	; 21f1c14c <.text+0x1c14c>
21f1c108:	e5832000 	str	r2, [r3]

	if (devlist == NULL) {
21f1c10c:	e59f3038 	ldr	r3, [pc, #56]	; 21f1c14c <.text+0x1c14c>
21f1c110:	e5933000 	ldr	r3, [r3]
21f1c114:	e3530000 	cmp	r3, #0	; 0x0
21f1c118:	1a000005 	bne	21f1c134 <devices_init+0x4c>
		eputs ("Cannot initialize the list of devices!\n");
21f1c11c:	e3a00002 	mov	r0, #2	; 0x2
21f1c120:	e59f1028 	ldr	r1, [pc, #40]	; 21f1c150 <.text+0x1c150>
21f1c124:	ebfffdd9 	bl	21f1b890 <fputs>
		return -1;
21f1c128:	e3e03000 	mvn	r3, #0	; 0x0
21f1c12c:	e50b3010 	str	r3, [fp, #-16]
21f1c130:	ea000002 	b	21f1c140 <devices_init+0x58>
	}
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
	i2c_init (CFG_I2C_SPEED, CFG_I2C_SLAVE);
#endif
#ifdef CONFIG_LCD
	drv_lcd_init ();
#endif
#if defined(CONFIG_VIDEO) || defined(CONFIG_CFB_CONSOLE)
	drv_video_init ();
#endif
#ifdef CONFIG_KEYBOARD
	drv_keyboard_init ();
#endif
#ifdef CONFIG_LOGBUFFER
	drv_logbuff_init ();
#endif
	drv_system_init ();
21f1c134:	ebffffba 	bl	21f1c024 <drv_system_init>
#ifdef CONFIG_SERIAL_MULTI
	serial_devices_init ();
#endif
#ifdef CONFIG_USB_TTY
	drv_usbtty_init ();
#endif
#ifdef CONFIG_NETCONSOLE
	drv_nc_init ();
#endif

	return (0);
21f1c138:	e3a03000 	mov	r3, #0	; 0x0
21f1c13c:	e50b3010 	str	r3, [fp, #-16]
21f1c140:	e51b3010 	ldr	r3, [fp, #-16]
}
21f1c144:	e1a00003 	mov	r0, r3
21f1c148:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f1c14c:	21f67760 	mvncss	r7, r0, ror #14
21f1c150:	21f3221c 	mvncss	r2, ip, lsl r2

21f1c154 <devices_done>:

int devices_done (void)
{
21f1c154:	e1a0c00d 	mov	ip, sp
21f1c158:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1c15c:	e24cb004 	sub	fp, ip, #4	; 0x4
	ListDispose (devlist);
21f1c160:	e59f3014 	ldr	r3, [pc, #20]	; 21f1c17c <.text+0x1c17c>
21f1c164:	e5933000 	ldr	r3, [r3]
21f1c168:	e1a00003 	mov	r0, r3
21f1c16c:	eb000ee9 	bl	21f1fd18 <ListDispose>

	return 0;
21f1c170:	e3a03000 	mov	r3, #0	; 0x0
}
21f1c174:	e1a00003 	mov	r0, r3
21f1c178:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1c17c:	21f67760 	mvncss	r7, r0, ror #14

21f1c180 <malloc_bin_reloc>:
 IAV(120), IAV(121), IAV(122), IAV(123), IAV(124), IAV(125), IAV(126), IAV(127)
};

void malloc_bin_reloc (void)
{
21f1c180:	e1a0c00d 	mov	ip, sp
21f1c184:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1c188:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1c18c:	e24dd008 	sub	sp, sp, #8	; 0x8
	unsigned long *p = (unsigned long *)(&av_[2]);
21f1c190:	e59f3058 	ldr	r3, [pc, #88]	; 21f1c1f0 <.text+0x1c1f0>
21f1c194:	e50b3014 	str	r3, [fp, #-20]
	int i;
	for (i=2; i<(sizeof(av_)/sizeof(mbinptr)); ++i) {
21f1c198:	e3a03002 	mov	r3, #2	; 0x2
21f1c19c:	e50b3010 	str	r3, [fp, #-16]
21f1c1a0:	ea00000b 	b	21f1c1d4 <malloc_bin_reloc+0x54>
		*p++ += gd->reloc_off;
21f1c1a4:	e51b2014 	ldr	r2, [fp, #-20]
21f1c1a8:	e5921000 	ldr	r1, [r2]
21f1c1ac:	e1a03008 	mov	r3, r8
21f1c1b0:	e5933010 	ldr	r3, [r3, #16]
21f1c1b4:	e0813003 	add	r3, r1, r3
21f1c1b8:	e5823000 	str	r3, [r2]
21f1c1bc:	e51b3014 	ldr	r3, [fp, #-20]
21f1c1c0:	e2833004 	add	r3, r3, #4	; 0x4
21f1c1c4:	e50b3014 	str	r3, [fp, #-20]
21f1c1c8:	e51b3010 	ldr	r3, [fp, #-16]
21f1c1cc:	e2833001 	add	r3, r3, #1	; 0x1
21f1c1d0:	e50b3010 	str	r3, [fp, #-16]
21f1c1d4:	e51b2010 	ldr	r2, [fp, #-16]
21f1c1d8:	e3a03c01 	mov	r3, #256	; 0x100
21f1c1dc:	e2833001 	add	r3, r3, #1	; 0x1
21f1c1e0:	e1520003 	cmp	r2, r3
21f1c1e4:	9affffee 	bls	21f1c1a4 <malloc_bin_reloc+0x24>
	}
}
21f1c1e8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1c1ec:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1c1f0:	21f33598 	ldrcsb	r3, [r3, #88]!

21f1c1f4 <malloc_extend_top>:


/* field-extraction macros */

#define first(b) ((b)->fd)
#define last(b)  ((b)->bk)

/*
  Indexing into bins
*/

#define bin_index(sz)                                                          \
(((((unsigned long)(sz)) >> 9) ==    0) ?       (((unsigned long)(sz)) >>  3): \
 ((((unsigned long)(sz)) >> 9) <=    4) ?  56 + (((unsigned long)(sz)) >>  6): \
 ((((unsigned long)(sz)) >> 9) <=   20) ?  91 + (((unsigned long)(sz)) >>  9): \
 ((((unsigned long)(sz)) >> 9) <=   84) ? 110 + (((unsigned long)(sz)) >> 12): \
 ((((unsigned long)(sz)) >> 9) <=  340) ? 119 + (((unsigned long)(sz)) >> 15): \
 ((((unsigned long)(sz)) >> 9) <= 1364) ? 124 + (((unsigned long)(sz)) >> 18): \
					  126)
/*
  bins for chunks < 512 are all spaced 8 bytes apart, and hold
  identically sized chunks. This is exploited in malloc.
*/

#define MAX_SMALLBIN         63
#define MAX_SMALLBIN_SIZE   512
#define SMALLBIN_WIDTH        8

#define smallbin_index(sz)  (((unsigned long)(sz)) >> 3)

/*
   Requests are `small' if both the corresponding and the next bin are small
*/

#define is_small_request(nb) (nb < MAX_SMALLBIN_SIZE - SMALLBIN_WIDTH)



/*
    To help compensate for the large number of bins, a one-level index
    structure is used for bin-by-bin searching.  `binblocks' is a
    one-word bitvector recording whether groups of BINBLOCKWIDTH bins
    have any (possibly) non-empty bins, so they can be skipped over
    all at once during during traversals. The bits are NOT always
    cleared as soon as all bins in a block are empty, but instead only
    when all are noticed to be empty during traversal in malloc.
*/

#define BINBLOCKWIDTH     4   /* bins per block */

#define binblocks      (bin_at(0)->size) /* bitvector of nonempty blocks */

/* bin<->block macros */

#define idx2binblock(ix)    ((unsigned)1 << (ix / BINBLOCKWIDTH))
#define mark_binblock(ii)   (binblocks |= idx2binblock(ii))
#define clear_binblock(ii)  (binblocks &= ~(idx2binblock(ii)))





/*  Other static bookkeeping data */

/* variables holding tunable values */

static unsigned long trim_threshold   = DEFAULT_TRIM_THRESHOLD;
static unsigned long top_pad          = DEFAULT_TOP_PAD;
static unsigned int  n_mmaps_max      = DEFAULT_MMAP_MAX;
static unsigned long mmap_threshold   = DEFAULT_MMAP_THRESHOLD;

/* The first value returned from sbrk */
static char* sbrk_base = (char*)(-1);

/* The maximum memory obtained from system via sbrk */
static unsigned long max_sbrked_mem = 0;

/* The maximum via either sbrk or mmap */
static unsigned long max_total_mem = 0;

/* internal working copy of mallinfo */
static struct mallinfo current_mallinfo = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

/* The total memory obtained from system via sbrk */
#define sbrked_mem  (current_mallinfo.arena)

/* Tracking mmaps */

#if 0
static unsigned int n_mmaps = 0;
#endif	/* 0 */
static unsigned long mmapped_mem = 0;
#if HAVE_MMAP
static unsigned int max_n_mmaps = 0;
static unsigned long max_mmapped_mem = 0;
#endif



/*
  Debugging support
*/

#ifdef DEBUG


/*
  These routines make a number of assertions about the states
  of data structures that should be true at all times. If any
  are not true, it's very likely that a user program has somehow
  trashed memory. (It's also possible that there is a coding error
  in malloc. In which case, please report it!)
*/

#if __STD_C
static void do_check_chunk(mchunkptr p)
#else
static void do_check_chunk(p) mchunkptr p;
#endif
{
#if 0	/* causes warnings because assert() is off */
  INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;
#endif	/* 0 */

  /* No checkable chunk is mmapped */
  assert(!chunk_is_mmapped(p));

  /* Check for legal address ... */
  assert((char*)p >= sbrk_base);
  if (p != top)
    assert((char*)p + sz <= (char*)top);
  else
    assert((char*)p + sz <= sbrk_base + sbrked_mem);

}


#if __STD_C
static void do_check_free_chunk(mchunkptr p)
#else
static void do_check_free_chunk(p) mchunkptr p;
#endif
{
  INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;
#if 0	/* causes warnings because assert() is off */
  mchunkptr next = chunk_at_offset(p, sz);
#endif	/* 0 */

  do_check_chunk(p);

  /* Check whether it claims to be free ... */
  assert(!inuse(p));

  /* Unless a special marker, must have OK fields */
  if ((long)sz >= (long)MINSIZE)
  {
    assert((sz & MALLOC_ALIGN_MASK) == 0);
    assert(aligned_OK(chunk2mem(p)));
    /* ... matching footer field */
    assert(next->prev_size == sz);
    /* ... and is fully consolidated */
    assert(prev_inuse(p));
    assert (next == top || inuse(next));

    /* ... and has minimally sane links */
    assert(p->fd->bk == p);
    assert(p->bk->fd == p);
  }
  else /* markers are always of size SIZE_SZ */
    assert(sz == SIZE_SZ);
}

#if __STD_C
static void do_check_inuse_chunk(mchunkptr p)
#else
static void do_check_inuse_chunk(p) mchunkptr p;
#endif
{
  mchunkptr next = next_chunk(p);
  do_check_chunk(p);

  /* Check whether it claims to be in use ... */
  assert(inuse(p));

  /* ... and is surrounded by OK chunks.
    Since more things can be checked with free chunks than inuse ones,
    if an inuse chunk borders them and debug is on, it's worth doing them.
  */
  if (!prev_inuse(p))
  {
    mchunkptr prv = prev_chunk(p);
    assert(next_chunk(prv) == p);
    do_check_free_chunk(prv);
  }
  if (next == top)
  {
    assert(prev_inuse(next));
    assert(chunksize(next) >= MINSIZE);
  }
  else if (!inuse(next))
    do_check_free_chunk(next);

}

#if __STD_C
static void do_check_malloced_chunk(mchunkptr p, INTERNAL_SIZE_T s)
#else
static void do_check_malloced_chunk(p, s) mchunkptr p; INTERNAL_SIZE_T s;
#endif
{
#if 0	/* causes warnings because assert() is off */
  INTERNAL_SIZE_T sz = p->size & ~PREV_INUSE;
  long room = sz - s;
#endif	/* 0 */

  do_check_inuse_chunk(p);

  /* Legal size ... */
  assert((long)sz >= (long)MINSIZE);
  assert((sz & MALLOC_ALIGN_MASK) == 0);
  assert(room >= 0);
  assert(room < (long)MINSIZE);

  /* ... and alignment */
  assert(aligned_OK(chunk2mem(p)));


  /* ... and was allocated at front of an available chunk */
  assert(prev_inuse(p));

}


#define check_free_chunk(P)  do_check_free_chunk(P)
#define check_inuse_chunk(P) do_check_inuse_chunk(P)
#define check_chunk(P) do_check_chunk(P)
#define check_malloced_chunk(P,N) do_check_malloced_chunk(P,N)
#else
#define check_free_chunk(P)
#define check_inuse_chunk(P)
#define check_chunk(P)
#define check_malloced_chunk(P,N)
#endif



/*
  Macro-based internal utilities
*/


/*
  Linking chunks in bin lists.
  Call these only with variables, not arbitrary expressions, as arguments.
*/

/*
  Place chunk p of size s in its bin, in size order,
  putting it ahead of others of same size.
*/


#define frontlink(P, S, IDX, BK, FD)                                          \
{                                                                             \
  if (S < MAX_SMALLBIN_SIZE)                                                  \
  {                                                                           \
    IDX = smallbin_index(S);                                                  \
    mark_binblock(IDX);                                                       \
    BK = bin_at(IDX);                                                         \
    FD = BK->fd;                                                              \
    P->bk = BK;                                                               \
    P->fd = FD;                                                               \
    FD->bk = BK->fd = P;                                                      \
  }                                                                           \
  else                                                                        \
  {                                                                           \
    IDX = bin_index(S);                                                       \
    BK = bin_at(IDX);                                                         \
    FD = BK->fd;                                                              \
    if (FD == BK) mark_binblock(IDX);                                         \
    else                                                                      \
    {                                                                         \
      while (FD != BK && S < chunksize(FD)) FD = FD->fd;                      \
      BK = FD->bk;                                                            \
    }                                                                         \
    P->bk = BK;                                                               \
    P->fd = FD;                                                               \
    FD->bk = BK->fd = P;                                                      \
  }                                                                           \
}


/* take a chunk off a list */

#define unlink(P, BK, FD)                                                     \
{                                                                             \
  BK = P->bk;                                                                 \
  FD = P->fd;                                                                 \
  FD->bk = BK;                                                                \
  BK->fd = FD;                                                                \
}                                                                             \

/* Place p as the last remainder */

#define link_last_remainder(P)                                                \
{                                                                             \
  last_remainder->fd = last_remainder->bk =  P;                               \
  P->fd = P->bk = last_remainder;                                             \
}

/* Clear the last_remainder bin */

#define clear_last_remainder \
  (last_remainder->fd = last_remainder->bk = last_remainder)





/* Routines dealing with mmap(). */

#if HAVE_MMAP

#if __STD_C
static mchunkptr mmap_chunk(size_t size)
#else
static mchunkptr mmap_chunk(size) size_t size;
#endif
{
  size_t page_mask = malloc_getpagesize - 1;
  mchunkptr p;

#ifndef MAP_ANONYMOUS
  static int fd = -1;
#endif

  if(n_mmaps >= n_mmaps_max) return 0; /* too many regions */

  /* For mmapped chunks, the overhead is one SIZE_SZ unit larger, because
   * there is no following chunk whose prev_size field could be used.
   */
  size = (size + SIZE_SZ + page_mask) & ~page_mask;

#ifdef MAP_ANONYMOUS
  p = (mchunkptr)mmap(0, size, PROT_READ|PROT_WRITE,
		      MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
#else /* !MAP_ANONYMOUS */
  if (fd < 0)
  {
    fd = open("/dev/zero", O_RDWR);
    if(fd < 0) return 0;
  }
  p = (mchunkptr)mmap(0, size, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
#endif

  if(p == (mchunkptr)-1) return 0;

  n_mmaps++;
  if (n_mmaps > max_n_mmaps) max_n_mmaps = n_mmaps;

  /* We demand that eight bytes into a page must be 8-byte aligned. */
  assert(aligned_OK(chunk2mem(p)));

  /* The offset to the start of the mmapped region is stored
   * in the prev_size field of the chunk; normally it is zero,
   * but that can be changed in memalign().
   */
  p->prev_size = 0;
  set_head(p, size|IS_MMAPPED);

  mmapped_mem += size;
  if ((unsigned long)mmapped_mem > (unsigned long)max_mmapped_mem)
    max_mmapped_mem = mmapped_mem;
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
    max_total_mem = mmapped_mem + sbrked_mem;
  return p;
}

#if __STD_C
static void munmap_chunk(mchunkptr p)
#else
static void munmap_chunk(p) mchunkptr p;
#endif
{
  INTERNAL_SIZE_T size = chunksize(p);
  int ret;

  assert (chunk_is_mmapped(p));
  assert(! ((char*)p >= sbrk_base && (char*)p < sbrk_base + sbrked_mem));
  assert((n_mmaps > 0));
  assert(((p->prev_size + size) & (malloc_getpagesize-1)) == 0);

  n_mmaps--;
  mmapped_mem -= (size + p->prev_size);

  ret = munmap((char *)p - p->prev_size, size + p->prev_size);

  /* munmap returns non-zero on failure */
  assert(ret == 0);
}

#if HAVE_MREMAP

#if __STD_C
static mchunkptr mremap_chunk(mchunkptr p, size_t new_size)
#else
static mchunkptr mremap_chunk(p, new_size) mchunkptr p; size_t new_size;
#endif
{
  size_t page_mask = malloc_getpagesize - 1;
  INTERNAL_SIZE_T offset = p->prev_size;
  INTERNAL_SIZE_T size = chunksize(p);
  char *cp;

  assert (chunk_is_mmapped(p));
  assert(! ((char*)p >= sbrk_base && (char*)p < sbrk_base + sbrked_mem));
  assert((n_mmaps > 0));
  assert(((size + offset) & (malloc_getpagesize-1)) == 0);

  /* Note the extra SIZE_SZ overhead as in mmap_chunk(). */
  new_size = (new_size + offset + SIZE_SZ + page_mask) & ~page_mask;

  cp = (char *)mremap((char *)p - offset, size + offset, new_size, 1);

  if (cp == (char *)-1) return 0;

  p = (mchunkptr)(cp + offset);

  assert(aligned_OK(chunk2mem(p)));

  assert((p->prev_size == offset));
  set_head(p, (new_size - offset)|IS_MMAPPED);

  mmapped_mem -= size + offset;
  mmapped_mem += new_size;
  if ((unsigned long)mmapped_mem > (unsigned long)max_mmapped_mem)
    max_mmapped_mem = mmapped_mem;
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
    max_total_mem = mmapped_mem + sbrked_mem;
  return p;
}

#endif /* HAVE_MREMAP */

#endif /* HAVE_MMAP */




/*
  Extend the top-most chunk by obtaining memory from system.
  Main interface to sbrk (but see also malloc_trim).
*/

#if __STD_C
static void malloc_extend_top(INTERNAL_SIZE_T nb)
#else
static void malloc_extend_top(nb) INTERNAL_SIZE_T nb;
#endif
{
21f1c1f4:	e1a0c00d 	mov	ip, sp
21f1c1f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1c1fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1c200:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f1c204:	e50b0038 	str	r0, [fp, #-56]
  char*     brk;                  /* return value from sbrk */
  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of sbrked space */
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
21f1c208:	e59f337c 	ldr	r3, [pc, #892]	; 21f1c58c <.text+0x1c58c>
21f1c20c:	e5933008 	ldr	r3, [r3, #8]
21f1c210:	e50b3020 	str	r3, [fp, #-32]
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
21f1c214:	e51b3020 	ldr	r3, [fp, #-32]
21f1c218:	e5933004 	ldr	r3, [r3, #4]
21f1c21c:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1c220:	e50b301c 	str	r3, [fp, #-28]
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
21f1c224:	e51b2020 	ldr	r2, [fp, #-32]
21f1c228:	e51b301c 	ldr	r3, [fp, #-28]
21f1c22c:	e0823003 	add	r3, r2, r3
21f1c230:	e50b3018 	str	r3, [fp, #-24]

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
21f1c234:	e59f3354 	ldr	r3, [pc, #852]	; 21f1c590 <.text+0x1c590>
21f1c238:	e5932000 	ldr	r2, [r3]
21f1c23c:	e51b3038 	ldr	r3, [fp, #-56]
21f1c240:	e0823003 	add	r3, r2, r3
21f1c244:	e2833010 	add	r3, r3, #16	; 0x10
21f1c248:	e50b3014 	str	r3, [fp, #-20]
  unsigned long pagesz    = malloc_getpagesize;
21f1c24c:	e3a03a01 	mov	r3, #4096	; 0x1000
21f1c250:	e50b3010 	str	r3, [fp, #-16]

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
21f1c254:	e59f3338 	ldr	r3, [pc, #824]	; 21f1c594 <.text+0x1c594>
21f1c258:	e5933000 	ldr	r3, [r3]
21f1c25c:	e3730001 	cmn	r3, #1	; 0x1
21f1c260:	0a000007 	beq	21f1c284 <malloc_extend_top+0x90>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
21f1c264:	e51b2010 	ldr	r2, [fp, #-16]
21f1c268:	e51b3014 	ldr	r3, [fp, #-20]
21f1c26c:	e0823003 	add	r3, r2, r3
21f1c270:	e2432001 	sub	r2, r3, #1	; 0x1
21f1c274:	e51b3010 	ldr	r3, [fp, #-16]
21f1c278:	e2633000 	rsb	r3, r3, #0	; 0x0
21f1c27c:	e0023003 	and	r3, r2, r3
21f1c280:	e50b3014 	str	r3, [fp, #-20]

  brk = (char*)(MORECORE (sbrk_size));
21f1c284:	e51b3014 	ldr	r3, [fp, #-20]
21f1c288:	e1a00003 	mov	r0, r3
21f1c28c:	ebffa67b 	bl	21f05c80 <sbrk>
21f1c290:	e1a03000 	mov	r3, r0
21f1c294:	e50b3034 	str	r3, [fp, #-52]

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
21f1c298:	e51b3034 	ldr	r3, [fp, #-52]
21f1c29c:	e3730001 	cmn	r3, #1	; 0x1
21f1c2a0:	0a0000b7 	beq	21f1c584 <malloc_extend_top+0x390>
21f1c2a4:	e51b2034 	ldr	r2, [fp, #-52]
21f1c2a8:	e51b3018 	ldr	r3, [fp, #-24]
21f1c2ac:	e1520003 	cmp	r2, r3
21f1c2b0:	2a000003 	bcs	21f1c2c4 <malloc_extend_top+0xd0>
21f1c2b4:	e59f22d0 	ldr	r2, [pc, #720]	; 21f1c58c <.text+0x1c58c>
21f1c2b8:	e51b3020 	ldr	r3, [fp, #-32]
21f1c2bc:	e1530002 	cmp	r3, r2
21f1c2c0:	1a0000af 	bne	21f1c584 <malloc_extend_top+0x390>
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
21f1c2c4:	e59f32cc 	ldr	r3, [pc, #716]	; 21f1c598 <.text+0x1c598>
21f1c2c8:	e5933000 	ldr	r3, [r3]
21f1c2cc:	e1a02003 	mov	r2, r3
21f1c2d0:	e51b3014 	ldr	r3, [fp, #-20]
21f1c2d4:	e0823003 	add	r3, r2, r3
21f1c2d8:	e1a02003 	mov	r2, r3
21f1c2dc:	e59f32b4 	ldr	r3, [pc, #692]	; 21f1c598 <.text+0x1c598>
21f1c2e0:	e5832000 	str	r2, [r3]

  if (brk == old_end) /* can just add bytes to current top */
21f1c2e4:	e51b2034 	ldr	r2, [fp, #-52]
21f1c2e8:	e51b3018 	ldr	r3, [fp, #-24]
21f1c2ec:	e1520003 	cmp	r2, r3
21f1c2f0:	1a000009 	bne	21f1c31c <malloc_extend_top+0x128>
  {
    top_size = sbrk_size + old_top_size;
21f1c2f4:	e51b2014 	ldr	r2, [fp, #-20]
21f1c2f8:	e51b301c 	ldr	r3, [fp, #-28]
21f1c2fc:	e0823003 	add	r3, r2, r3
21f1c300:	e50b3024 	str	r3, [fp, #-36]
    set_head(top, top_size | PREV_INUSE);
21f1c304:	e59f3280 	ldr	r3, [pc, #640]	; 21f1c58c <.text+0x1c58c>
21f1c308:	e5932008 	ldr	r2, [r3, #8]
21f1c30c:	e51b3024 	ldr	r3, [fp, #-36]
21f1c310:	e3833001 	orr	r3, r3, #1	; 0x1
21f1c314:	e5823004 	str	r3, [r2, #4]
21f1c318:	ea00007b 	b	21f1c50c <malloc_extend_top+0x318>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
21f1c31c:	e59f3270 	ldr	r3, [pc, #624]	; 21f1c594 <.text+0x1c594>
21f1c320:	e5933000 	ldr	r3, [r3]
21f1c324:	e3730001 	cmn	r3, #1	; 0x1
21f1c328:	1a000003 	bne	21f1c33c <malloc_extend_top+0x148>
      sbrk_base = brk;
21f1c32c:	e59f2260 	ldr	r2, [pc, #608]	; 21f1c594 <.text+0x1c594>
21f1c330:	e51b3034 	ldr	r3, [fp, #-52]
21f1c334:	e5823000 	str	r3, [r2]
21f1c338:	ea000007 	b	21f1c35c <malloc_extend_top+0x168>
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
21f1c33c:	e59f3254 	ldr	r3, [pc, #596]	; 21f1c598 <.text+0x1c598>
21f1c340:	e5931000 	ldr	r1, [r3]
21f1c344:	e51b2034 	ldr	r2, [fp, #-52]
21f1c348:	e51b3018 	ldr	r3, [fp, #-24]
21f1c34c:	e0633002 	rsb	r3, r3, r2
21f1c350:	e0812003 	add	r2, r1, r3
21f1c354:	e59f323c 	ldr	r3, [pc, #572]	; 21f1c598 <.text+0x1c598>
21f1c358:	e5832000 	str	r2, [r3]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK;
21f1c35c:	e51b3034 	ldr	r3, [fp, #-52]
21f1c360:	e2833008 	add	r3, r3, #8	; 0x8
21f1c364:	e2033007 	and	r3, r3, #7	; 0x7
21f1c368:	e50b3030 	str	r3, [fp, #-48]
    if (front_misalign > 0)
21f1c36c:	e51b3030 	ldr	r3, [fp, #-48]
21f1c370:	e3530000 	cmp	r3, #0	; 0x0
21f1c374:	0a000007 	beq	21f1c398 <malloc_extend_top+0x1a4>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
21f1c378:	e51b3030 	ldr	r3, [fp, #-48]
21f1c37c:	e2633008 	rsb	r3, r3, #8	; 0x8
21f1c380:	e50b302c 	str	r3, [fp, #-44]
      brk += correction;
21f1c384:	e51b202c 	ldr	r2, [fp, #-44]
21f1c388:	e51b3034 	ldr	r3, [fp, #-52]
21f1c38c:	e0833002 	add	r3, r3, r2
21f1c390:	e50b3034 	str	r3, [fp, #-52]
21f1c394:	ea000001 	b	21f1c3a0 <malloc_extend_top+0x1ac>
    }
    else
      correction = 0;
21f1c398:	e3a03000 	mov	r3, #0	; 0x0
21f1c39c:	e50b302c 	str	r3, [fp, #-44]

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
21f1c3a0:	e51b2014 	ldr	r2, [fp, #-20]
21f1c3a4:	e51b3034 	ldr	r3, [fp, #-52]
21f1c3a8:	e0823003 	add	r3, r2, r3
21f1c3ac:	e1a02003 	mov	r2, r3
21f1c3b0:	e51b3010 	ldr	r3, [fp, #-16]
21f1c3b4:	e0823003 	add	r3, r2, r3
21f1c3b8:	e2432001 	sub	r2, r3, #1	; 0x1
21f1c3bc:	e51b3010 	ldr	r3, [fp, #-16]
21f1c3c0:	e2633000 	rsb	r3, r3, #0	; 0x0
21f1c3c4:	e0021003 	and	r1, r2, r3
21f1c3c8:	e51b2014 	ldr	r2, [fp, #-20]
21f1c3cc:	e51b3034 	ldr	r3, [fp, #-52]
21f1c3d0:	e0823003 	add	r3, r2, r3
21f1c3d4:	e0632001 	rsb	r2, r3, r1
21f1c3d8:	e51b302c 	ldr	r3, [fp, #-44]
21f1c3dc:	e0833002 	add	r3, r3, r2
21f1c3e0:	e50b302c 	str	r3, [fp, #-44]
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
21f1c3e4:	e51b302c 	ldr	r3, [fp, #-44]
21f1c3e8:	e1a00003 	mov	r0, r3
21f1c3ec:	ebffa623 	bl	21f05c80 <sbrk>
21f1c3f0:	e1a03000 	mov	r3, r0
21f1c3f4:	e50b3028 	str	r3, [fp, #-40]
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
21f1c3f8:	e51b3028 	ldr	r3, [fp, #-40]
21f1c3fc:	e3730001 	cmn	r3, #1	; 0x1
21f1c400:	0a00005f 	beq	21f1c584 <malloc_extend_top+0x390>

    sbrked_mem += correction;
21f1c404:	e59f318c 	ldr	r3, [pc, #396]	; 21f1c598 <.text+0x1c598>
21f1c408:	e5933000 	ldr	r3, [r3]
21f1c40c:	e1a02003 	mov	r2, r3
21f1c410:	e51b302c 	ldr	r3, [fp, #-44]
21f1c414:	e0823003 	add	r3, r2, r3
21f1c418:	e1a02003 	mov	r2, r3
21f1c41c:	e59f3174 	ldr	r3, [pc, #372]	; 21f1c598 <.text+0x1c598>
21f1c420:	e5832000 	str	r2, [r3]

    top = (mchunkptr)brk;
21f1c424:	e59f2160 	ldr	r2, [pc, #352]	; 21f1c58c <.text+0x1c58c>
21f1c428:	e51b3034 	ldr	r3, [fp, #-52]
21f1c42c:	e5823008 	str	r3, [r2, #8]
    top_size = new_brk - brk + correction;
21f1c430:	e51b2028 	ldr	r2, [fp, #-40]
21f1c434:	e51b3034 	ldr	r3, [fp, #-52]
21f1c438:	e0633002 	rsb	r3, r3, r2
21f1c43c:	e1a02003 	mov	r2, r3
21f1c440:	e51b302c 	ldr	r3, [fp, #-44]
21f1c444:	e0823003 	add	r3, r2, r3
21f1c448:	e50b3024 	str	r3, [fp, #-36]
    set_head(top, top_size | PREV_INUSE);
21f1c44c:	e59f3138 	ldr	r3, [pc, #312]	; 21f1c58c <.text+0x1c58c>
21f1c450:	e5932008 	ldr	r2, [r3, #8]
21f1c454:	e51b3024 	ldr	r3, [fp, #-36]
21f1c458:	e3833001 	orr	r3, r3, #1	; 0x1
21f1c45c:	e5823004 	str	r3, [r2, #4]

    if (old_top != initial_top)
21f1c460:	e59f2124 	ldr	r2, [pc, #292]	; 21f1c58c <.text+0x1c58c>
21f1c464:	e51b3020 	ldr	r3, [fp, #-32]
21f1c468:	e1530002 	cmp	r3, r2
21f1c46c:	0a000026 	beq	21f1c50c <malloc_extend_top+0x318>
    {

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
21f1c470:	e51b301c 	ldr	r3, [fp, #-28]
21f1c474:	e353000f 	cmp	r3, #15	; 0xf
21f1c478:	8a000004 	bhi	21f1c490 <malloc_extend_top+0x29c>
      {
	set_head(top, PREV_INUSE); /* will force null return from malloc */
21f1c47c:	e59f3108 	ldr	r3, [pc, #264]	; 21f1c58c <.text+0x1c58c>
21f1c480:	e5932008 	ldr	r2, [r3, #8]
21f1c484:	e3a03001 	mov	r3, #1	; 0x1
21f1c488:	e5823004 	str	r3, [r2, #4]
	return;
21f1c48c:	ea00003c 	b	21f1c584 <malloc_extend_top+0x390>
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
21f1c490:	e51b301c 	ldr	r3, [fp, #-28]
21f1c494:	e243300c 	sub	r3, r3, #12	; 0xc
21f1c498:	e3c33007 	bic	r3, r3, #7	; 0x7
21f1c49c:	e50b301c 	str	r3, [fp, #-28]
      set_head_size(old_top, old_top_size);
21f1c4a0:	e51b3020 	ldr	r3, [fp, #-32]
21f1c4a4:	e5933004 	ldr	r3, [r3, #4]
21f1c4a8:	e2032001 	and	r2, r3, #1	; 0x1
21f1c4ac:	e51b301c 	ldr	r3, [fp, #-28]
21f1c4b0:	e1822003 	orr	r2, r2, r3
21f1c4b4:	e51b3020 	ldr	r3, [fp, #-32]
21f1c4b8:	e5832004 	str	r2, [r3, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
21f1c4bc:	e51b2020 	ldr	r2, [fp, #-32]
21f1c4c0:	e51b301c 	ldr	r3, [fp, #-28]
21f1c4c4:	e0823003 	add	r3, r2, r3
21f1c4c8:	e1a02003 	mov	r2, r3
21f1c4cc:	e3a03005 	mov	r3, #5	; 0x5
21f1c4d0:	e5823004 	str	r3, [r2, #4]
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
21f1c4d4:	e51b2020 	ldr	r2, [fp, #-32]
21f1c4d8:	e51b301c 	ldr	r3, [fp, #-28]
21f1c4dc:	e0823003 	add	r3, r2, r3
21f1c4e0:	e2833004 	add	r3, r3, #4	; 0x4
21f1c4e4:	e1a02003 	mov	r2, r3
21f1c4e8:	e3a03005 	mov	r3, #5	; 0x5
21f1c4ec:	e5823004 	str	r3, [r2, #4]
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
21f1c4f0:	e51b301c 	ldr	r3, [fp, #-28]
21f1c4f4:	e353000f 	cmp	r3, #15	; 0xf
21f1c4f8:	9a000003 	bls	21f1c50c <malloc_extend_top+0x318>
	fREe(chunk2mem(old_top));
21f1c4fc:	e51b3020 	ldr	r3, [fp, #-32]
21f1c500:	e2833008 	add	r3, r3, #8	; 0x8
21f1c504:	e1a00003 	mov	r0, r3
21f1c508:	eb00030f 	bl	21f1d14c <free>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
21f1c50c:	e59f3084 	ldr	r3, [pc, #132]	; 21f1c598 <.text+0x1c598>
21f1c510:	e5933000 	ldr	r3, [r3]
21f1c514:	e1a02003 	mov	r2, r3
21f1c518:	e59f307c 	ldr	r3, [pc, #124]	; 21f1c59c <.text+0x1c59c>
21f1c51c:	e5933000 	ldr	r3, [r3]
21f1c520:	e1520003 	cmp	r2, r3
21f1c524:	9a000004 	bls	21f1c53c <malloc_extend_top+0x348>
    max_sbrked_mem = sbrked_mem;
21f1c528:	e59f3068 	ldr	r3, [pc, #104]	; 21f1c598 <.text+0x1c598>
21f1c52c:	e5933000 	ldr	r3, [r3]
21f1c530:	e1a02003 	mov	r2, r3
21f1c534:	e59f3060 	ldr	r3, [pc, #96]	; 21f1c59c <.text+0x1c59c>
21f1c538:	e5832000 	str	r2, [r3]
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
21f1c53c:	e59f3054 	ldr	r3, [pc, #84]	; 21f1c598 <.text+0x1c598>
21f1c540:	e5933000 	ldr	r3, [r3]
21f1c544:	e1a02003 	mov	r2, r3
21f1c548:	e59f3050 	ldr	r3, [pc, #80]	; 21f1c5a0 <.text+0x1c5a0>
21f1c54c:	e5933000 	ldr	r3, [r3]
21f1c550:	e0822003 	add	r2, r2, r3
21f1c554:	e59f3048 	ldr	r3, [pc, #72]	; 21f1c5a4 <.text+0x1c5a4>
21f1c558:	e5933000 	ldr	r3, [r3]
21f1c55c:	e1520003 	cmp	r2, r3
21f1c560:	9a000007 	bls	21f1c584 <malloc_extend_top+0x390>
    max_total_mem = mmapped_mem + sbrked_mem;
21f1c564:	e59f302c 	ldr	r3, [pc, #44]	; 21f1c598 <.text+0x1c598>
21f1c568:	e5933000 	ldr	r3, [r3]
21f1c56c:	e1a02003 	mov	r2, r3
21f1c570:	e59f3028 	ldr	r3, [pc, #40]	; 21f1c5a0 <.text+0x1c5a0>
21f1c574:	e5933000 	ldr	r3, [r3]
21f1c578:	e0822003 	add	r2, r2, r3
21f1c57c:	e59f3020 	ldr	r3, [pc, #32]	; 21f1c5a4 <.text+0x1c5a4>
21f1c580:	e5832000 	str	r2, [r3]

  /* We always land on a page boundary */
  assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0);
}
21f1c584:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1c588:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1c58c:	21f33590 	ldrcsb	r3, [r3, #80]!
21f1c590:	21f67770 	mvncss	r7, r0, ror r7
21f1c594:	21f339a0 	mvncss	r3, r0, lsr #19
21f1c598:	21f67780 	mvncss	r7, r0, lsl #15
21f1c59c:	21f67778 	mvncss	r7, r8, ror r7
21f1c5a0:	21f677a8 	mvncss	r7, r8, lsr #15
21f1c5a4:	21f6777c 	mvncss	r7, ip, ror r7

21f1c5a8 <malloc>:




/* Main public routines */


/*
  Malloc Algorthim:

    The requested size is first converted into a usable form, `nb'.
    This currently means to add 4 bytes overhead plus possibly more to
    obtain 8-byte alignment and/or to obtain a size of at least
    MINSIZE (currently 16 bytes), the smallest allocatable size.
    (All fits are considered `exact' if they are within MINSIZE bytes.)

    From there, the first successful of the following steps is taken:

      1. The bin corresponding to the request size is scanned, and if
	 a chunk of exactly the right size is found, it is taken.

      2. The most recently remaindered chunk is used if it is big
	 enough.  This is a form of (roving) first fit, used only in
	 the absence of exact fits. Runs of consecutive requests use
	 the remainder of the chunk used for the previous such request
	 whenever possible. This limited use of a first-fit style
	 allocation strategy tends to give contiguous chunks
	 coextensive lifetimes, which improves locality and can reduce
	 fragmentation in the long run.

      3. Other bins are scanned in increasing size order, using a
	 chunk big enough to fulfill the request, and splitting off
	 any remainder.  This search is strictly by best-fit; i.e.,
	 the smallest (with ties going to approximately the least
	 recently used) chunk that fits is selected.

      4. If large enough, the chunk bordering the end of memory
	 (`top') is split off. (This use of `top' is in accord with
	 the best-fit search rule.  In effect, `top' is treated as
	 larger (and thus less well fitting) than any other available
	 chunk since it can be extended to be as large as necessary
	 (up to system limitations).

      5. If the request size meets the mmap threshold and the
	 system supports mmap, and there are few enough currently
	 allocated mmapped regions, and a call to mmap succeeds,
	 the request is allocated via direct memory mapping.

      6. Otherwise, the top of memory is extended by
	 obtaining more space from the system (normally using sbrk,
	 but definable to anything else via the MORECORE macro).
	 Memory is gathered from the system (in system page-sized
	 units) in a way that allows chunks obtained across different
	 sbrk calls to be consolidated, but does not require
	 contiguous memory. Thus, it should be safe to intersperse
	 mallocs with other sbrk calls.


      All allocations are made from the the `lowest' part of any found
      chunk. (The implementation invariant is that prev_inuse is
      always true of any allocated chunk; i.e., that each allocated
      chunk borders either a previously allocated and still in-use chunk,
      or the base of its memory arena.)

*/

#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
21f1c5a8:	e1a0c00d 	mov	ip, sp
21f1c5ac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1c5b0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1c5b4:	e24dd070 	sub	sp, sp, #112	; 0x70
21f1c5b8:	e50b0044 	str	r0, [fp, #-68]
  mchunkptr victim;                  /* inspected/selected chunk */
  INTERNAL_SIZE_T victim_size;       /* its size */
  int       idx;                     /* index for bin traversal */
  mbinptr   bin;                     /* associated bin */
  mchunkptr remainder;               /* remainder from a split */
  long      remainder_size;          /* its size */
  int       remainder_index;         /* its bin index */
  unsigned long block;               /* block traverser bit */
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  if ((long)bytes < 0) return 0;
21f1c5bc:	e51b3044 	ldr	r3, [fp, #-68]
21f1c5c0:	e3530000 	cmp	r3, #0	; 0x0
21f1c5c4:	aa000002 	bge	21f1c5d4 <malloc+0x2c>
21f1c5c8:	e3a03000 	mov	r3, #0	; 0x0
21f1c5cc:	e50b307c 	str	r3, [fp, #-124]
21f1c5d0:	ea0002d8 	b	21f1d138 <malloc+0xb90>

  nb = request2size(bytes);  /* padded request size; */
21f1c5d4:	e51b3044 	ldr	r3, [fp, #-68]
21f1c5d8:	e283300b 	add	r3, r3, #11	; 0xb
21f1c5dc:	e3530016 	cmp	r3, #22	; 0x16
21f1c5e0:	da000004 	ble	21f1c5f8 <malloc+0x50>
21f1c5e4:	e51b3044 	ldr	r3, [fp, #-68]
21f1c5e8:	e283300b 	add	r3, r3, #11	; 0xb
21f1c5ec:	e3c33007 	bic	r3, r3, #7	; 0x7
21f1c5f0:	e50b3078 	str	r3, [fp, #-120]
21f1c5f4:	ea000001 	b	21f1c600 <malloc+0x58>
21f1c5f8:	e3a03010 	mov	r3, #16	; 0x10
21f1c5fc:	e50b3078 	str	r3, [fp, #-120]
21f1c600:	e51b3078 	ldr	r3, [fp, #-120]
21f1c604:	e50b3010 	str	r3, [fp, #-16]

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
21f1c608:	e51b2010 	ldr	r2, [fp, #-16]
21f1c60c:	e3a03f7d 	mov	r3, #500	; 0x1f4
21f1c610:	e2833003 	add	r3, r3, #3	; 0x3
21f1c614:	e1520003 	cmp	r2, r3
21f1c618:	8a00003b 	bhi	21f1c70c <malloc+0x164>
  {
    idx = smallbin_index(nb);
21f1c61c:	e51b3010 	ldr	r3, [fp, #-16]
21f1c620:	e1a031a3 	mov	r3, r3, lsr #3
21f1c624:	e50b3038 	str	r3, [fp, #-56]

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
21f1c628:	e51b3038 	ldr	r3, [fp, #-56]
21f1c62c:	e1a03183 	mov	r3, r3, lsl #3
21f1c630:	e1a02003 	mov	r2, r3
21f1c634:	e59f3b0c 	ldr	r3, [pc, #2828]	; 21f1d148 <.text+0x1d148>
21f1c638:	e0823003 	add	r3, r2, r3
21f1c63c:	e50b3014 	str	r3, [fp, #-20]
    victim = last(q);
21f1c640:	e51b3014 	ldr	r3, [fp, #-20]
21f1c644:	e593300c 	ldr	r3, [r3, #12]
21f1c648:	e50b3040 	str	r3, [fp, #-64]

    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
21f1c64c:	e51b2040 	ldr	r2, [fp, #-64]
21f1c650:	e51b3014 	ldr	r3, [fp, #-20]
21f1c654:	e1520003 	cmp	r2, r3
21f1c658:	1a000005 	bne	21f1c674 <malloc+0xcc>
    {
      q = next_bin(q);
21f1c65c:	e51b3014 	ldr	r3, [fp, #-20]
21f1c660:	e2833008 	add	r3, r3, #8	; 0x8
21f1c664:	e50b3014 	str	r3, [fp, #-20]
      victim = last(q);
21f1c668:	e51b3014 	ldr	r3, [fp, #-20]
21f1c66c:	e593300c 	ldr	r3, [r3, #12]
21f1c670:	e50b3040 	str	r3, [fp, #-64]
    }
    if (victim != q)
21f1c674:	e51b2040 	ldr	r2, [fp, #-64]
21f1c678:	e51b3014 	ldr	r3, [fp, #-20]
21f1c67c:	e1520003 	cmp	r2, r3
21f1c680:	0a00001d 	beq	21f1c6fc <malloc+0x154>
    {
      victim_size = chunksize(victim);
21f1c684:	e51b3040 	ldr	r3, [fp, #-64]
21f1c688:	e5933004 	ldr	r3, [r3, #4]
21f1c68c:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1c690:	e50b303c 	str	r3, [fp, #-60]
      unlink(victim, bck, fwd);
21f1c694:	e51b3040 	ldr	r3, [fp, #-64]
21f1c698:	e593300c 	ldr	r3, [r3, #12]
21f1c69c:	e50b3018 	str	r3, [fp, #-24]
21f1c6a0:	e51b3040 	ldr	r3, [fp, #-64]
21f1c6a4:	e5933008 	ldr	r3, [r3, #8]
21f1c6a8:	e50b301c 	str	r3, [fp, #-28]
21f1c6ac:	e51b201c 	ldr	r2, [fp, #-28]
21f1c6b0:	e51b3018 	ldr	r3, [fp, #-24]
21f1c6b4:	e582300c 	str	r3, [r2, #12]
21f1c6b8:	e51b2018 	ldr	r2, [fp, #-24]
21f1c6bc:	e51b301c 	ldr	r3, [fp, #-28]
21f1c6c0:	e5823008 	str	r3, [r2, #8]
      set_inuse_bit_at_offset(victim, victim_size);
21f1c6c4:	e51b2040 	ldr	r2, [fp, #-64]
21f1c6c8:	e51b303c 	ldr	r3, [fp, #-60]
21f1c6cc:	e0823003 	add	r3, r2, r3
21f1c6d0:	e1a01003 	mov	r1, r3
21f1c6d4:	e51b2040 	ldr	r2, [fp, #-64]
21f1c6d8:	e51b303c 	ldr	r3, [fp, #-60]
21f1c6dc:	e0823003 	add	r3, r2, r3
21f1c6e0:	e5933004 	ldr	r3, [r3, #4]
21f1c6e4:	e3833001 	orr	r3, r3, #1	; 0x1
21f1c6e8:	e5813004 	str	r3, [r1, #4]
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
21f1c6ec:	e51b3040 	ldr	r3, [fp, #-64]
21f1c6f0:	e2833008 	add	r3, r3, #8	; 0x8
21f1c6f4:	e50b307c 	str	r3, [fp, #-124]
21f1c6f8:	ea00028e 	b	21f1d138 <malloc+0xb90>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
21f1c6fc:	e51b3038 	ldr	r3, [fp, #-56]
21f1c700:	e2833002 	add	r3, r3, #2	; 0x2
21f1c704:	e50b3038 	str	r3, [fp, #-56]
21f1c708:	ea000084 	b	21f1c920 <malloc+0x378>

  }
  else
  {
    idx = bin_index(nb);
21f1c70c:	e51b3010 	ldr	r3, [fp, #-16]
21f1c710:	e1a034a3 	mov	r3, r3, lsr #9
21f1c714:	e3530000 	cmp	r3, #0	; 0x0
21f1c718:	1a000003 	bne	21f1c72c <malloc+0x184>
21f1c71c:	e51b3010 	ldr	r3, [fp, #-16]
21f1c720:	e1a031a3 	mov	r3, r3, lsr #3
21f1c724:	e50b3074 	str	r3, [fp, #-116]
21f1c728:	ea00003a 	b	21f1c818 <malloc+0x270>
21f1c72c:	e51b3010 	ldr	r3, [fp, #-16]
21f1c730:	e1a034a3 	mov	r3, r3, lsr #9
21f1c734:	e3530004 	cmp	r3, #4	; 0x4
21f1c738:	8a000004 	bhi	21f1c750 <malloc+0x1a8>
21f1c73c:	e51b3010 	ldr	r3, [fp, #-16]
21f1c740:	e1a03323 	mov	r3, r3, lsr #6
21f1c744:	e2833038 	add	r3, r3, #56	; 0x38
21f1c748:	e50b3070 	str	r3, [fp, #-112]
21f1c74c:	ea00002f 	b	21f1c810 <malloc+0x268>
21f1c750:	e51b3010 	ldr	r3, [fp, #-16]
21f1c754:	e1a034a3 	mov	r3, r3, lsr #9
21f1c758:	e3530014 	cmp	r3, #20	; 0x14
21f1c75c:	8a000004 	bhi	21f1c774 <malloc+0x1cc>
21f1c760:	e51b3010 	ldr	r3, [fp, #-16]
21f1c764:	e1a034a3 	mov	r3, r3, lsr #9
21f1c768:	e283305b 	add	r3, r3, #91	; 0x5b
21f1c76c:	e50b306c 	str	r3, [fp, #-108]
21f1c770:	ea000024 	b	21f1c808 <malloc+0x260>
21f1c774:	e51b3010 	ldr	r3, [fp, #-16]
21f1c778:	e1a034a3 	mov	r3, r3, lsr #9
21f1c77c:	e3530054 	cmp	r3, #84	; 0x54
21f1c780:	8a000004 	bhi	21f1c798 <malloc+0x1f0>
21f1c784:	e51b3010 	ldr	r3, [fp, #-16]
21f1c788:	e1a03623 	mov	r3, r3, lsr #12
21f1c78c:	e283306e 	add	r3, r3, #110	; 0x6e
21f1c790:	e50b3068 	str	r3, [fp, #-104]
21f1c794:	ea000019 	b	21f1c800 <malloc+0x258>
21f1c798:	e51b3010 	ldr	r3, [fp, #-16]
21f1c79c:	e1a034a3 	mov	r3, r3, lsr #9
21f1c7a0:	e3530f55 	cmp	r3, #340	; 0x154
21f1c7a4:	8a000004 	bhi	21f1c7bc <malloc+0x214>
21f1c7a8:	e51b3010 	ldr	r3, [fp, #-16]
21f1c7ac:	e1a037a3 	mov	r3, r3, lsr #15
21f1c7b0:	e2833077 	add	r3, r3, #119	; 0x77
21f1c7b4:	e50b3064 	str	r3, [fp, #-100]
21f1c7b8:	ea00000e 	b	21f1c7f8 <malloc+0x250>
21f1c7bc:	e51b3010 	ldr	r3, [fp, #-16]
21f1c7c0:	e1a024a3 	mov	r2, r3, lsr #9
21f1c7c4:	e3a03e55 	mov	r3, #1360	; 0x550
21f1c7c8:	e2833004 	add	r3, r3, #4	; 0x4
21f1c7cc:	e1520003 	cmp	r2, r3
21f1c7d0:	8a000004 	bhi	21f1c7e8 <malloc+0x240>
21f1c7d4:	e51b3010 	ldr	r3, [fp, #-16]
21f1c7d8:	e1a03923 	mov	r3, r3, lsr #18
21f1c7dc:	e283307c 	add	r3, r3, #124	; 0x7c
21f1c7e0:	e50b3060 	str	r3, [fp, #-96]
21f1c7e4:	ea000001 	b	21f1c7f0 <malloc+0x248>
21f1c7e8:	e3a0307e 	mov	r3, #126	; 0x7e
21f1c7ec:	e50b3060 	str	r3, [fp, #-96]
21f1c7f0:	e51b3060 	ldr	r3, [fp, #-96]
21f1c7f4:	e50b3064 	str	r3, [fp, #-100]
21f1c7f8:	e51b3064 	ldr	r3, [fp, #-100]
21f1c7fc:	e50b3068 	str	r3, [fp, #-104]
21f1c800:	e51b3068 	ldr	r3, [fp, #-104]
21f1c804:	e50b306c 	str	r3, [fp, #-108]
21f1c808:	e51b306c 	ldr	r3, [fp, #-108]
21f1c80c:	e50b3070 	str	r3, [fp, #-112]
21f1c810:	e51b3070 	ldr	r3, [fp, #-112]
21f1c814:	e50b3074 	str	r3, [fp, #-116]
21f1c818:	e51b3074 	ldr	r3, [fp, #-116]
21f1c81c:	e50b3038 	str	r3, [fp, #-56]
    bin = bin_at(idx);
21f1c820:	e51b3038 	ldr	r3, [fp, #-56]
21f1c824:	e1a03183 	mov	r3, r3, lsl #3
21f1c828:	e1a02003 	mov	r2, r3
21f1c82c:	e59f3914 	ldr	r3, [pc, #2324]	; 21f1d148 <.text+0x1d148>
21f1c830:	e0823003 	add	r3, r2, r3
21f1c834:	e50b3034 	str	r3, [fp, #-52]

    for (victim = last(bin); victim != bin; victim = victim->bk)
21f1c838:	e51b3034 	ldr	r3, [fp, #-52]
21f1c83c:	e593300c 	ldr	r3, [r3, #12]
21f1c840:	e50b3040 	str	r3, [fp, #-64]
21f1c844:	ea00002e 	b	21f1c904 <malloc+0x35c>
    {
      victim_size = chunksize(victim);
21f1c848:	e51b3040 	ldr	r3, [fp, #-64]
21f1c84c:	e5933004 	ldr	r3, [r3, #4]
21f1c850:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1c854:	e50b303c 	str	r3, [fp, #-60]
      remainder_size = victim_size - nb;
21f1c858:	e51b203c 	ldr	r2, [fp, #-60]
21f1c85c:	e51b3010 	ldr	r3, [fp, #-16]
21f1c860:	e0633002 	rsb	r3, r3, r2
21f1c864:	e50b302c 	str	r3, [fp, #-44]

      if (remainder_size >= (long)MINSIZE) /* too big */
21f1c868:	e51b302c 	ldr	r3, [fp, #-44]
21f1c86c:	e353000f 	cmp	r3, #15	; 0xf
21f1c870:	da000003 	ble	21f1c884 <malloc+0x2dc>
      {
	--idx; /* adjust to rescan below after checking last remainder */
21f1c874:	e51b3038 	ldr	r3, [fp, #-56]
21f1c878:	e2433001 	sub	r3, r3, #1	; 0x1
21f1c87c:	e50b3038 	str	r3, [fp, #-56]
	break;
21f1c880:	ea000023 	b	21f1c914 <malloc+0x36c>
      }

      else if (remainder_size >= 0) /* exact fit */
21f1c884:	e51b302c 	ldr	r3, [fp, #-44]
21f1c888:	e3530000 	cmp	r3, #0	; 0x0
21f1c88c:	ba000019 	blt	21f1c8f8 <malloc+0x350>
      {
	unlink(victim, bck, fwd);
21f1c890:	e51b3040 	ldr	r3, [fp, #-64]
21f1c894:	e593300c 	ldr	r3, [r3, #12]
21f1c898:	e50b3018 	str	r3, [fp, #-24]
21f1c89c:	e51b3040 	ldr	r3, [fp, #-64]
21f1c8a0:	e5933008 	ldr	r3, [r3, #8]
21f1c8a4:	e50b301c 	str	r3, [fp, #-28]
21f1c8a8:	e51b201c 	ldr	r2, [fp, #-28]
21f1c8ac:	e51b3018 	ldr	r3, [fp, #-24]
21f1c8b0:	e582300c 	str	r3, [r2, #12]
21f1c8b4:	e51b2018 	ldr	r2, [fp, #-24]
21f1c8b8:	e51b301c 	ldr	r3, [fp, #-28]
21f1c8bc:	e5823008 	str	r3, [r2, #8]
	set_inuse_bit_at_offset(victim, victim_size);
21f1c8c0:	e51b2040 	ldr	r2, [fp, #-64]
21f1c8c4:	e51b303c 	ldr	r3, [fp, #-60]
21f1c8c8:	e0823003 	add	r3, r2, r3
21f1c8cc:	e1a01003 	mov	r1, r3
21f1c8d0:	e51b2040 	ldr	r2, [fp, #-64]
21f1c8d4:	e51b303c 	ldr	r3, [fp, #-60]
21f1c8d8:	e0823003 	add	r3, r2, r3
21f1c8dc:	e5933004 	ldr	r3, [r3, #4]
21f1c8e0:	e3833001 	orr	r3, r3, #1	; 0x1
21f1c8e4:	e5813004 	str	r3, [r1, #4]
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
21f1c8e8:	e51b3040 	ldr	r3, [fp, #-64]
21f1c8ec:	e2833008 	add	r3, r3, #8	; 0x8
21f1c8f0:	e50b307c 	str	r3, [fp, #-124]
21f1c8f4:	ea00020f 	b	21f1d138 <malloc+0xb90>
21f1c8f8:	e51b3040 	ldr	r3, [fp, #-64]
21f1c8fc:	e593300c 	ldr	r3, [r3, #12]
21f1c900:	e50b3040 	str	r3, [fp, #-64]
21f1c904:	e51b2040 	ldr	r2, [fp, #-64]
21f1c908:	e51b3034 	ldr	r3, [fp, #-52]
21f1c90c:	e1520003 	cmp	r2, r3
21f1c910:	1affffcc 	bne	21f1c848 <malloc+0x2a0>
      }
    }

    ++idx;
21f1c914:	e51b3038 	ldr	r3, [fp, #-56]
21f1c918:	e2833001 	add	r3, r3, #1	; 0x1
21f1c91c:	e50b3038 	str	r3, [fp, #-56]

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
21f1c920:	e59f3820 	ldr	r3, [pc, #2080]	; 21f1d148 <.text+0x1d148>
21f1c924:	e2833008 	add	r3, r3, #8	; 0x8
21f1c928:	e5933008 	ldr	r3, [r3, #8]
21f1c92c:	e50b3040 	str	r3, [fp, #-64]
21f1c930:	e59f3810 	ldr	r3, [pc, #2064]	; 21f1d148 <.text+0x1d148>
21f1c934:	e2833008 	add	r3, r3, #8	; 0x8
21f1c938:	e1a02003 	mov	r2, r3
21f1c93c:	e51b3040 	ldr	r3, [fp, #-64]
21f1c940:	e1530002 	cmp	r3, r2
21f1c944:	0a0000f9 	beq	21f1cd30 <malloc+0x788>
  {
    victim_size = chunksize(victim);
21f1c948:	e51b3040 	ldr	r3, [fp, #-64]
21f1c94c:	e5933004 	ldr	r3, [r3, #4]
21f1c950:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1c954:	e50b303c 	str	r3, [fp, #-60]
    remainder_size = victim_size - nb;
21f1c958:	e51b203c 	ldr	r2, [fp, #-60]
21f1c95c:	e51b3010 	ldr	r3, [fp, #-16]
21f1c960:	e0633002 	rsb	r3, r3, r2
21f1c964:	e50b302c 	str	r3, [fp, #-44]

    if (remainder_size >= (long)MINSIZE) /* re-split */
21f1c968:	e51b302c 	ldr	r3, [fp, #-44]
21f1c96c:	e353000f 	cmp	r3, #15	; 0xf
21f1c970:	da000029 	ble	21f1ca1c <malloc+0x474>
    {
      remainder = chunk_at_offset(victim, nb);
21f1c974:	e51b2040 	ldr	r2, [fp, #-64]
21f1c978:	e51b3010 	ldr	r3, [fp, #-16]
21f1c97c:	e0823003 	add	r3, r2, r3
21f1c980:	e50b3030 	str	r3, [fp, #-48]
      set_head(victim, nb | PREV_INUSE);
21f1c984:	e51b3010 	ldr	r3, [fp, #-16]
21f1c988:	e3832001 	orr	r2, r3, #1	; 0x1
21f1c98c:	e51b3040 	ldr	r3, [fp, #-64]
21f1c990:	e5832004 	str	r2, [r3, #4]
      link_last_remainder(remainder);
21f1c994:	e59f37ac 	ldr	r3, [pc, #1964]	; 21f1d148 <.text+0x1d148>
21f1c998:	e2833008 	add	r3, r3, #8	; 0x8
21f1c99c:	e1a01003 	mov	r1, r3
21f1c9a0:	e59f37a0 	ldr	r3, [pc, #1952]	; 21f1d148 <.text+0x1d148>
21f1c9a4:	e2833008 	add	r3, r3, #8	; 0x8
21f1c9a8:	e1a02003 	mov	r2, r3
21f1c9ac:	e51b3030 	ldr	r3, [fp, #-48]
21f1c9b0:	e582300c 	str	r3, [r2, #12]
21f1c9b4:	e592300c 	ldr	r3, [r2, #12]
21f1c9b8:	e5813008 	str	r3, [r1, #8]
21f1c9bc:	e59f3784 	ldr	r3, [pc, #1924]	; 21f1d148 <.text+0x1d148>
21f1c9c0:	e2833008 	add	r3, r3, #8	; 0x8
21f1c9c4:	e1a02003 	mov	r2, r3
21f1c9c8:	e51b3030 	ldr	r3, [fp, #-48]
21f1c9cc:	e583200c 	str	r2, [r3, #12]
21f1c9d0:	e51b3030 	ldr	r3, [fp, #-48]
21f1c9d4:	e593200c 	ldr	r2, [r3, #12]
21f1c9d8:	e51b3030 	ldr	r3, [fp, #-48]
21f1c9dc:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
21f1c9e0:	e51b302c 	ldr	r3, [fp, #-44]
21f1c9e4:	e3833001 	orr	r3, r3, #1	; 0x1
21f1c9e8:	e1a02003 	mov	r2, r3
21f1c9ec:	e51b3030 	ldr	r3, [fp, #-48]
21f1c9f0:	e5832004 	str	r2, [r3, #4]
      set_foot(remainder, remainder_size);
21f1c9f4:	e51b2030 	ldr	r2, [fp, #-48]
21f1c9f8:	e51b302c 	ldr	r3, [fp, #-44]
21f1c9fc:	e0823003 	add	r3, r2, r3
21f1ca00:	e1a02003 	mov	r2, r3
21f1ca04:	e51b302c 	ldr	r3, [fp, #-44]
21f1ca08:	e5823000 	str	r3, [r2]
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
21f1ca0c:	e51b3040 	ldr	r3, [fp, #-64]
21f1ca10:	e2833008 	add	r3, r3, #8	; 0x8
21f1ca14:	e50b307c 	str	r3, [fp, #-124]
21f1ca18:	ea0001c6 	b	21f1d138 <malloc+0xb90>
    }

    clear_last_remainder;
21f1ca1c:	e59f3724 	ldr	r3, [pc, #1828]	; 21f1d148 <.text+0x1d148>
21f1ca20:	e2833008 	add	r3, r3, #8	; 0x8
21f1ca24:	e1a01003 	mov	r1, r3
21f1ca28:	e59f3718 	ldr	r3, [pc, #1816]	; 21f1d148 <.text+0x1d148>
21f1ca2c:	e2833008 	add	r3, r3, #8	; 0x8
21f1ca30:	e1a02003 	mov	r2, r3
21f1ca34:	e59f370c 	ldr	r3, [pc, #1804]	; 21f1d148 <.text+0x1d148>
21f1ca38:	e2833008 	add	r3, r3, #8	; 0x8
21f1ca3c:	e582300c 	str	r3, [r2, #12]
21f1ca40:	e592300c 	ldr	r3, [r2, #12]
21f1ca44:	e5813008 	str	r3, [r1, #8]

    if (remainder_size >= 0)  /* exhaust */
21f1ca48:	e51b302c 	ldr	r3, [fp, #-44]
21f1ca4c:	e3530000 	cmp	r3, #0	; 0x0
21f1ca50:	ba00000d 	blt	21f1ca8c <malloc+0x4e4>
    {
      set_inuse_bit_at_offset(victim, victim_size);
21f1ca54:	e51b2040 	ldr	r2, [fp, #-64]
21f1ca58:	e51b303c 	ldr	r3, [fp, #-60]
21f1ca5c:	e0823003 	add	r3, r2, r3
21f1ca60:	e1a01003 	mov	r1, r3
21f1ca64:	e51b2040 	ldr	r2, [fp, #-64]
21f1ca68:	e51b303c 	ldr	r3, [fp, #-60]
21f1ca6c:	e0823003 	add	r3, r2, r3
21f1ca70:	e5933004 	ldr	r3, [r3, #4]
21f1ca74:	e3833001 	orr	r3, r3, #1	; 0x1
21f1ca78:	e5813004 	str	r3, [r1, #4]
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
21f1ca7c:	e51b3040 	ldr	r3, [fp, #-64]
21f1ca80:	e2833008 	add	r3, r3, #8	; 0x8
21f1ca84:	e50b307c 	str	r3, [fp, #-124]
21f1ca88:	ea0001aa 	b	21f1d138 <malloc+0xb90>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
21f1ca8c:	e51b203c 	ldr	r2, [fp, #-60]
21f1ca90:	e3a03f7f 	mov	r3, #508	; 0x1fc
21f1ca94:	e2833003 	add	r3, r3, #3	; 0x3
21f1ca98:	e1520003 	cmp	r2, r3
21f1ca9c:	8a000026 	bhi	21f1cb3c <malloc+0x594>
21f1caa0:	e51b303c 	ldr	r3, [fp, #-60]
21f1caa4:	e1a031a3 	mov	r3, r3, lsr #3
21f1caa8:	e50b3028 	str	r3, [fp, #-40]
21f1caac:	e59f0694 	ldr	r0, [pc, #1684]	; 21f1d148 <.text+0x1d148>
21f1cab0:	e59f3690 	ldr	r3, [pc, #1680]	; 21f1d148 <.text+0x1d148>
21f1cab4:	e5931004 	ldr	r1, [r3, #4]
21f1cab8:	e51b3028 	ldr	r3, [fp, #-40]
21f1cabc:	e2832003 	add	r2, r3, #3	; 0x3
21f1cac0:	e3530000 	cmp	r3, #0	; 0x0
21f1cac4:	b1a03002 	movlt	r3, r2
21f1cac8:	e1a03143 	mov	r3, r3, asr #2
21f1cacc:	e1a02003 	mov	r2, r3
21f1cad0:	e3a03001 	mov	r3, #1	; 0x1
21f1cad4:	e1a03213 	mov	r3, r3, lsl r2
21f1cad8:	e1813003 	orr	r3, r1, r3
21f1cadc:	e5803004 	str	r3, [r0, #4]
21f1cae0:	e51b3028 	ldr	r3, [fp, #-40]
21f1cae4:	e1a03183 	mov	r3, r3, lsl #3
21f1cae8:	e1a02003 	mov	r2, r3
21f1caec:	e59f3654 	ldr	r3, [pc, #1620]	; 21f1d148 <.text+0x1d148>
21f1caf0:	e0823003 	add	r3, r2, r3
21f1caf4:	e50b3018 	str	r3, [fp, #-24]
21f1caf8:	e51b3018 	ldr	r3, [fp, #-24]
21f1cafc:	e5933008 	ldr	r3, [r3, #8]
21f1cb00:	e50b301c 	str	r3, [fp, #-28]
21f1cb04:	e51b2040 	ldr	r2, [fp, #-64]
21f1cb08:	e51b3018 	ldr	r3, [fp, #-24]
21f1cb0c:	e582300c 	str	r3, [r2, #12]
21f1cb10:	e51b2040 	ldr	r2, [fp, #-64]
21f1cb14:	e51b301c 	ldr	r3, [fp, #-28]
21f1cb18:	e5823008 	str	r3, [r2, #8]
21f1cb1c:	e51b2018 	ldr	r2, [fp, #-24]
21f1cb20:	e51b3040 	ldr	r3, [fp, #-64]
21f1cb24:	e5823008 	str	r3, [r2, #8]
21f1cb28:	e51b3018 	ldr	r3, [fp, #-24]
21f1cb2c:	e5932008 	ldr	r2, [r3, #8]
21f1cb30:	e51b301c 	ldr	r3, [fp, #-28]
21f1cb34:	e583200c 	str	r2, [r3, #12]
21f1cb38:	ea00007c 	b	21f1cd30 <malloc+0x788>
21f1cb3c:	e51b303c 	ldr	r3, [fp, #-60]
21f1cb40:	e1a034a3 	mov	r3, r3, lsr #9
21f1cb44:	e3530000 	cmp	r3, #0	; 0x0
21f1cb48:	1a000003 	bne	21f1cb5c <malloc+0x5b4>
21f1cb4c:	e51b303c 	ldr	r3, [fp, #-60]
21f1cb50:	e1a031a3 	mov	r3, r3, lsr #3
21f1cb54:	e50b305c 	str	r3, [fp, #-92]
21f1cb58:	ea00003a 	b	21f1cc48 <malloc+0x6a0>
21f1cb5c:	e51b303c 	ldr	r3, [fp, #-60]
21f1cb60:	e1a034a3 	mov	r3, r3, lsr #9
21f1cb64:	e3530004 	cmp	r3, #4	; 0x4
21f1cb68:	8a000004 	bhi	21f1cb80 <malloc+0x5d8>
21f1cb6c:	e51b303c 	ldr	r3, [fp, #-60]
21f1cb70:	e1a03323 	mov	r3, r3, lsr #6
21f1cb74:	e2833038 	add	r3, r3, #56	; 0x38
21f1cb78:	e50b3058 	str	r3, [fp, #-88]
21f1cb7c:	ea00002f 	b	21f1cc40 <malloc+0x698>
21f1cb80:	e51b303c 	ldr	r3, [fp, #-60]
21f1cb84:	e1a034a3 	mov	r3, r3, lsr #9
21f1cb88:	e3530014 	cmp	r3, #20	; 0x14
21f1cb8c:	8a000004 	bhi	21f1cba4 <malloc+0x5fc>
21f1cb90:	e51b303c 	ldr	r3, [fp, #-60]
21f1cb94:	e1a034a3 	mov	r3, r3, lsr #9
21f1cb98:	e283305b 	add	r3, r3, #91	; 0x5b
21f1cb9c:	e50b3054 	str	r3, [fp, #-84]
21f1cba0:	ea000024 	b	21f1cc38 <malloc+0x690>
21f1cba4:	e51b303c 	ldr	r3, [fp, #-60]
21f1cba8:	e1a034a3 	mov	r3, r3, lsr #9
21f1cbac:	e3530054 	cmp	r3, #84	; 0x54
21f1cbb0:	8a000004 	bhi	21f1cbc8 <malloc+0x620>
21f1cbb4:	e51b303c 	ldr	r3, [fp, #-60]
21f1cbb8:	e1a03623 	mov	r3, r3, lsr #12
21f1cbbc:	e283306e 	add	r3, r3, #110	; 0x6e
21f1cbc0:	e50b3050 	str	r3, [fp, #-80]
21f1cbc4:	ea000019 	b	21f1cc30 <malloc+0x688>
21f1cbc8:	e51b303c 	ldr	r3, [fp, #-60]
21f1cbcc:	e1a034a3 	mov	r3, r3, lsr #9
21f1cbd0:	e3530f55 	cmp	r3, #340	; 0x154
21f1cbd4:	8a000004 	bhi	21f1cbec <malloc+0x644>
21f1cbd8:	e51b303c 	ldr	r3, [fp, #-60]
21f1cbdc:	e1a037a3 	mov	r3, r3, lsr #15
21f1cbe0:	e2833077 	add	r3, r3, #119	; 0x77
21f1cbe4:	e50b304c 	str	r3, [fp, #-76]
21f1cbe8:	ea00000e 	b	21f1cc28 <malloc+0x680>
21f1cbec:	e51b303c 	ldr	r3, [fp, #-60]
21f1cbf0:	e1a024a3 	mov	r2, r3, lsr #9
21f1cbf4:	e3a03e55 	mov	r3, #1360	; 0x550
21f1cbf8:	e2833004 	add	r3, r3, #4	; 0x4
21f1cbfc:	e1520003 	cmp	r2, r3
21f1cc00:	8a000004 	bhi	21f1cc18 <malloc+0x670>
21f1cc04:	e51b303c 	ldr	r3, [fp, #-60]
21f1cc08:	e1a03923 	mov	r3, r3, lsr #18
21f1cc0c:	e283307c 	add	r3, r3, #124	; 0x7c
21f1cc10:	e50b3048 	str	r3, [fp, #-72]
21f1cc14:	ea000001 	b	21f1cc20 <malloc+0x678>
21f1cc18:	e3a0307e 	mov	r3, #126	; 0x7e
21f1cc1c:	e50b3048 	str	r3, [fp, #-72]
21f1cc20:	e51b3048 	ldr	r3, [fp, #-72]
21f1cc24:	e50b304c 	str	r3, [fp, #-76]
21f1cc28:	e51b304c 	ldr	r3, [fp, #-76]
21f1cc2c:	e50b3050 	str	r3, [fp, #-80]
21f1cc30:	e51b3050 	ldr	r3, [fp, #-80]
21f1cc34:	e50b3054 	str	r3, [fp, #-84]
21f1cc38:	e51b3054 	ldr	r3, [fp, #-84]
21f1cc3c:	e50b3058 	str	r3, [fp, #-88]
21f1cc40:	e51b3058 	ldr	r3, [fp, #-88]
21f1cc44:	e50b305c 	str	r3, [fp, #-92]
21f1cc48:	e51b305c 	ldr	r3, [fp, #-92]
21f1cc4c:	e50b3028 	str	r3, [fp, #-40]
21f1cc50:	e51b3028 	ldr	r3, [fp, #-40]
21f1cc54:	e1a03183 	mov	r3, r3, lsl #3
21f1cc58:	e1a02003 	mov	r2, r3
21f1cc5c:	e59f34e4 	ldr	r3, [pc, #1252]	; 21f1d148 <.text+0x1d148>
21f1cc60:	e0823003 	add	r3, r2, r3
21f1cc64:	e50b3018 	str	r3, [fp, #-24]
21f1cc68:	e51b3018 	ldr	r3, [fp, #-24]
21f1cc6c:	e5933008 	ldr	r3, [r3, #8]
21f1cc70:	e50b301c 	str	r3, [fp, #-28]
21f1cc74:	e51b201c 	ldr	r2, [fp, #-28]
21f1cc78:	e51b3018 	ldr	r3, [fp, #-24]
21f1cc7c:	e1520003 	cmp	r2, r3
21f1cc80:	1a000010 	bne	21f1ccc8 <malloc+0x720>
21f1cc84:	e59f04bc 	ldr	r0, [pc, #1212]	; 21f1d148 <.text+0x1d148>
21f1cc88:	e59f34b8 	ldr	r3, [pc, #1208]	; 21f1d148 <.text+0x1d148>
21f1cc8c:	e5931004 	ldr	r1, [r3, #4]
21f1cc90:	e51b3028 	ldr	r3, [fp, #-40]
21f1cc94:	e2832003 	add	r2, r3, #3	; 0x3
21f1cc98:	e3530000 	cmp	r3, #0	; 0x0
21f1cc9c:	b1a03002 	movlt	r3, r2
21f1cca0:	e1a03143 	mov	r3, r3, asr #2
21f1cca4:	e1a02003 	mov	r2, r3
21f1cca8:	e3a03001 	mov	r3, #1	; 0x1
21f1ccac:	e1a03213 	mov	r3, r3, lsl r2
21f1ccb0:	e1813003 	orr	r3, r1, r3
21f1ccb4:	e5803004 	str	r3, [r0, #4]
21f1ccb8:	ea00000f 	b	21f1ccfc <malloc+0x754>
21f1ccbc:	e51b301c 	ldr	r3, [fp, #-28]
21f1ccc0:	e5933008 	ldr	r3, [r3, #8]
21f1ccc4:	e50b301c 	str	r3, [fp, #-28]
21f1ccc8:	e51b201c 	ldr	r2, [fp, #-28]
21f1cccc:	e51b3018 	ldr	r3, [fp, #-24]
21f1ccd0:	e1520003 	cmp	r2, r3
21f1ccd4:	0a000005 	beq	21f1ccf0 <malloc+0x748>
21f1ccd8:	e51b301c 	ldr	r3, [fp, #-28]
21f1ccdc:	e5933004 	ldr	r3, [r3, #4]
21f1cce0:	e3c32003 	bic	r2, r3, #3	; 0x3
21f1cce4:	e51b303c 	ldr	r3, [fp, #-60]
21f1cce8:	e1520003 	cmp	r2, r3
21f1ccec:	8afffff2 	bhi	21f1ccbc <malloc+0x714>
21f1ccf0:	e51b301c 	ldr	r3, [fp, #-28]
21f1ccf4:	e593300c 	ldr	r3, [r3, #12]
21f1ccf8:	e50b3018 	str	r3, [fp, #-24]
21f1ccfc:	e51b2040 	ldr	r2, [fp, #-64]
21f1cd00:	e51b3018 	ldr	r3, [fp, #-24]
21f1cd04:	e582300c 	str	r3, [r2, #12]
21f1cd08:	e51b2040 	ldr	r2, [fp, #-64]
21f1cd0c:	e51b301c 	ldr	r3, [fp, #-28]
21f1cd10:	e5823008 	str	r3, [r2, #8]
21f1cd14:	e51b2018 	ldr	r2, [fp, #-24]
21f1cd18:	e51b3040 	ldr	r3, [fp, #-64]
21f1cd1c:	e5823008 	str	r3, [r2, #8]
21f1cd20:	e51b3018 	ldr	r3, [fp, #-24]
21f1cd24:	e5932008 	ldr	r2, [r3, #8]
21f1cd28:	e51b301c 	ldr	r3, [fp, #-28]
21f1cd2c:	e583200c 	str	r2, [r3, #12]
  }

  /*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)
21f1cd30:	e51b3038 	ldr	r3, [fp, #-56]
21f1cd34:	e2832003 	add	r2, r3, #3	; 0x3
21f1cd38:	e3530000 	cmp	r3, #0	; 0x0
21f1cd3c:	b1a03002 	movlt	r3, r2
21f1cd40:	e1a03143 	mov	r3, r3, asr #2
21f1cd44:	e1a02003 	mov	r2, r3
21f1cd48:	e3a03001 	mov	r3, #1	; 0x1
21f1cd4c:	e1a03213 	mov	r3, r3, lsl r2
21f1cd50:	e50b3024 	str	r3, [fp, #-36]
21f1cd54:	e59f33ec 	ldr	r3, [pc, #1004]	; 21f1d148 <.text+0x1d148>
21f1cd58:	e5932004 	ldr	r2, [r3, #4]
21f1cd5c:	e51b3024 	ldr	r3, [fp, #-36]
21f1cd60:	e1530002 	cmp	r3, r2
21f1cd64:	8a0000c6 	bhi	21f1d084 <malloc+0xadc>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0)
21f1cd68:	e59f33d8 	ldr	r3, [pc, #984]	; 21f1d148 <.text+0x1d148>
21f1cd6c:	e5932004 	ldr	r2, [r3, #4]
21f1cd70:	e51b3024 	ldr	r3, [fp, #-36]
21f1cd74:	e0023003 	and	r3, r2, r3
21f1cd78:	e3530000 	cmp	r3, #0	; 0x0
21f1cd7c:	1a000013 	bne	21f1cdd0 <malloc+0x828>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
21f1cd80:	e51b3038 	ldr	r3, [fp, #-56]
21f1cd84:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1cd88:	e2833004 	add	r3, r3, #4	; 0x4
21f1cd8c:	e50b3038 	str	r3, [fp, #-56]
      block <<= 1;
21f1cd90:	e51b3024 	ldr	r3, [fp, #-36]
21f1cd94:	e1a03083 	mov	r3, r3, lsl #1
21f1cd98:	e50b3024 	str	r3, [fp, #-36]
      while ((block & binblocks) == 0)
21f1cd9c:	ea000005 	b	21f1cdb8 <malloc+0x810>
      {
	idx += BINBLOCKWIDTH;
21f1cda0:	e51b3038 	ldr	r3, [fp, #-56]
21f1cda4:	e2833004 	add	r3, r3, #4	; 0x4
21f1cda8:	e50b3038 	str	r3, [fp, #-56]
	block <<= 1;
21f1cdac:	e51b3024 	ldr	r3, [fp, #-36]
21f1cdb0:	e1a03083 	mov	r3, r3, lsl #1
21f1cdb4:	e50b3024 	str	r3, [fp, #-36]
21f1cdb8:	e59f3388 	ldr	r3, [pc, #904]	; 21f1d148 <.text+0x1d148>
21f1cdbc:	e5932004 	ldr	r2, [r3, #4]
21f1cdc0:	e51b3024 	ldr	r3, [fp, #-36]
21f1cdc4:	e0023003 	and	r3, r2, r3
21f1cdc8:	e3530000 	cmp	r3, #0	; 0x0
21f1cdcc:	0afffff3 	beq	21f1cda0 <malloc+0x7f8>
      }
    }

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
21f1cdd0:	e51b3038 	ldr	r3, [fp, #-56]
21f1cdd4:	e50b3020 	str	r3, [fp, #-32]
      q = bin = bin_at(idx);
21f1cdd8:	e51b3038 	ldr	r3, [fp, #-56]
21f1cddc:	e1a03183 	mov	r3, r3, lsl #3
21f1cde0:	e1a02003 	mov	r2, r3
21f1cde4:	e59f335c 	ldr	r3, [pc, #860]	; 21f1d148 <.text+0x1d148>
21f1cde8:	e0823003 	add	r3, r2, r3
21f1cdec:	e50b3034 	str	r3, [fp, #-52]
21f1cdf0:	e51b3034 	ldr	r3, [fp, #-52]
21f1cdf4:	e50b3014 	str	r3, [fp, #-20]

      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
21f1cdf8:	e51b3034 	ldr	r3, [fp, #-52]
21f1cdfc:	e593300c 	ldr	r3, [r3, #12]
21f1ce00:	e50b3040 	str	r3, [fp, #-64]
21f1ce04:	ea000060 	b	21f1cf8c <malloc+0x9e4>
	{
	  victim_size = chunksize(victim);
21f1ce08:	e51b3040 	ldr	r3, [fp, #-64]
21f1ce0c:	e5933004 	ldr	r3, [r3, #4]
21f1ce10:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1ce14:	e50b303c 	str	r3, [fp, #-60]
	  remainder_size = victim_size - nb;
21f1ce18:	e51b203c 	ldr	r2, [fp, #-60]
21f1ce1c:	e51b3010 	ldr	r3, [fp, #-16]
21f1ce20:	e0633002 	rsb	r3, r3, r2
21f1ce24:	e50b302c 	str	r3, [fp, #-44]

	  if (remainder_size >= (long)MINSIZE) /* split */
21f1ce28:	e51b302c 	ldr	r3, [fp, #-44]
21f1ce2c:	e353000f 	cmp	r3, #15	; 0xf
21f1ce30:	da000035 	ble	21f1cf0c <malloc+0x964>
	  {
	    remainder = chunk_at_offset(victim, nb);
21f1ce34:	e51b2040 	ldr	r2, [fp, #-64]
21f1ce38:	e51b3010 	ldr	r3, [fp, #-16]
21f1ce3c:	e0823003 	add	r3, r2, r3
21f1ce40:	e50b3030 	str	r3, [fp, #-48]
	    set_head(victim, nb | PREV_INUSE);
21f1ce44:	e51b3010 	ldr	r3, [fp, #-16]
21f1ce48:	e3832001 	orr	r2, r3, #1	; 0x1
21f1ce4c:	e51b3040 	ldr	r3, [fp, #-64]
21f1ce50:	e5832004 	str	r2, [r3, #4]
	    unlink(victim, bck, fwd);
21f1ce54:	e51b3040 	ldr	r3, [fp, #-64]
21f1ce58:	e593300c 	ldr	r3, [r3, #12]
21f1ce5c:	e50b3018 	str	r3, [fp, #-24]
21f1ce60:	e51b3040 	ldr	r3, [fp, #-64]
21f1ce64:	e5933008 	ldr	r3, [r3, #8]
21f1ce68:	e50b301c 	str	r3, [fp, #-28]
21f1ce6c:	e51b201c 	ldr	r2, [fp, #-28]
21f1ce70:	e51b3018 	ldr	r3, [fp, #-24]
21f1ce74:	e582300c 	str	r3, [r2, #12]
21f1ce78:	e51b2018 	ldr	r2, [fp, #-24]
21f1ce7c:	e51b301c 	ldr	r3, [fp, #-28]
21f1ce80:	e5823008 	str	r3, [r2, #8]
	    link_last_remainder(remainder);
21f1ce84:	e59f32bc 	ldr	r3, [pc, #700]	; 21f1d148 <.text+0x1d148>
21f1ce88:	e2833008 	add	r3, r3, #8	; 0x8
21f1ce8c:	e1a01003 	mov	r1, r3
21f1ce90:	e59f32b0 	ldr	r3, [pc, #688]	; 21f1d148 <.text+0x1d148>
21f1ce94:	e2833008 	add	r3, r3, #8	; 0x8
21f1ce98:	e1a02003 	mov	r2, r3
21f1ce9c:	e51b3030 	ldr	r3, [fp, #-48]
21f1cea0:	e582300c 	str	r3, [r2, #12]
21f1cea4:	e592300c 	ldr	r3, [r2, #12]
21f1cea8:	e5813008 	str	r3, [r1, #8]
21f1ceac:	e59f3294 	ldr	r3, [pc, #660]	; 21f1d148 <.text+0x1d148>
21f1ceb0:	e2833008 	add	r3, r3, #8	; 0x8
21f1ceb4:	e1a02003 	mov	r2, r3
21f1ceb8:	e51b3030 	ldr	r3, [fp, #-48]
21f1cebc:	e583200c 	str	r2, [r3, #12]
21f1cec0:	e51b3030 	ldr	r3, [fp, #-48]
21f1cec4:	e593200c 	ldr	r2, [r3, #12]
21f1cec8:	e51b3030 	ldr	r3, [fp, #-48]
21f1cecc:	e5832008 	str	r2, [r3, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
21f1ced0:	e51b302c 	ldr	r3, [fp, #-44]
21f1ced4:	e3833001 	orr	r3, r3, #1	; 0x1
21f1ced8:	e1a02003 	mov	r2, r3
21f1cedc:	e51b3030 	ldr	r3, [fp, #-48]
21f1cee0:	e5832004 	str	r2, [r3, #4]
	    set_foot(remainder, remainder_size);
21f1cee4:	e51b2030 	ldr	r2, [fp, #-48]
21f1cee8:	e51b302c 	ldr	r3, [fp, #-44]
21f1ceec:	e0823003 	add	r3, r2, r3
21f1cef0:	e1a02003 	mov	r2, r3
21f1cef4:	e51b302c 	ldr	r3, [fp, #-44]
21f1cef8:	e5823000 	str	r3, [r2]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
21f1cefc:	e51b3040 	ldr	r3, [fp, #-64]
21f1cf00:	e2833008 	add	r3, r3, #8	; 0x8
21f1cf04:	e50b307c 	str	r3, [fp, #-124]
21f1cf08:	ea00008a 	b	21f1d138 <malloc+0xb90>
	  }

	  else if (remainder_size >= 0)  /* take */
21f1cf0c:	e51b302c 	ldr	r3, [fp, #-44]
21f1cf10:	e3530000 	cmp	r3, #0	; 0x0
21f1cf14:	ba000019 	blt	21f1cf80 <malloc+0x9d8>
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
21f1cf18:	e51b2040 	ldr	r2, [fp, #-64]
21f1cf1c:	e51b303c 	ldr	r3, [fp, #-60]
21f1cf20:	e0823003 	add	r3, r2, r3
21f1cf24:	e1a01003 	mov	r1, r3
21f1cf28:	e51b2040 	ldr	r2, [fp, #-64]
21f1cf2c:	e51b303c 	ldr	r3, [fp, #-60]
21f1cf30:	e0823003 	add	r3, r2, r3
21f1cf34:	e5933004 	ldr	r3, [r3, #4]
21f1cf38:	e3833001 	orr	r3, r3, #1	; 0x1
21f1cf3c:	e5813004 	str	r3, [r1, #4]
	    unlink(victim, bck, fwd);
21f1cf40:	e51b3040 	ldr	r3, [fp, #-64]
21f1cf44:	e593300c 	ldr	r3, [r3, #12]
21f1cf48:	e50b3018 	str	r3, [fp, #-24]
21f1cf4c:	e51b3040 	ldr	r3, [fp, #-64]
21f1cf50:	e5933008 	ldr	r3, [r3, #8]
21f1cf54:	e50b301c 	str	r3, [fp, #-28]
21f1cf58:	e51b201c 	ldr	r2, [fp, #-28]
21f1cf5c:	e51b3018 	ldr	r3, [fp, #-24]
21f1cf60:	e582300c 	str	r3, [r2, #12]
21f1cf64:	e51b2018 	ldr	r2, [fp, #-24]
21f1cf68:	e51b301c 	ldr	r3, [fp, #-28]
21f1cf6c:	e5823008 	str	r3, [r2, #8]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
21f1cf70:	e51b3040 	ldr	r3, [fp, #-64]
21f1cf74:	e2833008 	add	r3, r3, #8	; 0x8
21f1cf78:	e50b307c 	str	r3, [fp, #-124]
21f1cf7c:	ea00006d 	b	21f1d138 <malloc+0xb90>
21f1cf80:	e51b3040 	ldr	r3, [fp, #-64]
21f1cf84:	e593300c 	ldr	r3, [r3, #12]
21f1cf88:	e50b3040 	str	r3, [fp, #-64]
21f1cf8c:	e51b2040 	ldr	r2, [fp, #-64]
21f1cf90:	e51b3034 	ldr	r3, [fp, #-52]
21f1cf94:	e1520003 	cmp	r2, r3
21f1cf98:	1affff9a 	bne	21f1ce08 <malloc+0x860>
	  }

	}

       bin = next_bin(bin);
21f1cf9c:	e51b3034 	ldr	r3, [fp, #-52]
21f1cfa0:	e2833008 	add	r3, r3, #8	; 0x8
21f1cfa4:	e50b3034 	str	r3, [fp, #-52]

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
21f1cfa8:	e51b3038 	ldr	r3, [fp, #-56]
21f1cfac:	e2833001 	add	r3, r3, #1	; 0x1
21f1cfb0:	e50b3038 	str	r3, [fp, #-56]
21f1cfb4:	e51b3038 	ldr	r3, [fp, #-56]
21f1cfb8:	e2033003 	and	r3, r3, #3	; 0x3
21f1cfbc:	e3530000 	cmp	r3, #0	; 0x0
21f1cfc0:	1affff8c 	bne	21f1cdf8 <malloc+0x850>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
21f1cfc4:	e51b3020 	ldr	r3, [fp, #-32]
21f1cfc8:	e2033003 	and	r3, r3, #3	; 0x3
21f1cfcc:	e3530000 	cmp	r3, #0	; 0x0
21f1cfd0:	1a000007 	bne	21f1cff4 <malloc+0xa4c>
	{
	  binblocks &= ~block;
21f1cfd4:	e59f116c 	ldr	r1, [pc, #364]	; 21f1d148 <.text+0x1d148>
21f1cfd8:	e59f3168 	ldr	r3, [pc, #360]	; 21f1d148 <.text+0x1d148>
21f1cfdc:	e5932004 	ldr	r2, [r3, #4]
21f1cfe0:	e51b3024 	ldr	r3, [fp, #-36]
21f1cfe4:	e1e03003 	mvn	r3, r3
21f1cfe8:	e0023003 	and	r3, r2, r3
21f1cfec:	e5813004 	str	r3, [r1, #4]
	  break;
21f1cff0:	ea00000a 	b	21f1d020 <malloc+0xa78>
	}
	--startidx;
21f1cff4:	e51b3020 	ldr	r3, [fp, #-32]
21f1cff8:	e2433001 	sub	r3, r3, #1	; 0x1
21f1cffc:	e50b3020 	str	r3, [fp, #-32]
       q = prev_bin(q);
21f1d000:	e51b3014 	ldr	r3, [fp, #-20]
21f1d004:	e2433008 	sub	r3, r3, #8	; 0x8
21f1d008:	e50b3014 	str	r3, [fp, #-20]
      } while (first(q) == q);
21f1d00c:	e51b3014 	ldr	r3, [fp, #-20]
21f1d010:	e5932008 	ldr	r2, [r3, #8]
21f1d014:	e51b3014 	ldr	r3, [fp, #-20]
21f1d018:	e1520003 	cmp	r2, r3
21f1d01c:	0affffe8 	beq	21f1cfc4 <malloc+0xa1c>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) )
21f1d020:	e51b3024 	ldr	r3, [fp, #-36]
21f1d024:	e1a03083 	mov	r3, r3, lsl #1
21f1d028:	e50b3024 	str	r3, [fp, #-36]
21f1d02c:	e59f3114 	ldr	r3, [pc, #276]	; 21f1d148 <.text+0x1d148>
21f1d030:	e5932004 	ldr	r2, [r3, #4]
21f1d034:	e51b3024 	ldr	r3, [fp, #-36]
21f1d038:	e1530002 	cmp	r3, r2
21f1d03c:	8a000010 	bhi	21f1d084 <malloc+0xadc>
21f1d040:	e51b3024 	ldr	r3, [fp, #-36]
21f1d044:	e3530000 	cmp	r3, #0	; 0x0
21f1d048:	0a00000d 	beq	21f1d084 <malloc+0xadc>
21f1d04c:	ea000005 	b	21f1d068 <malloc+0xac0>
      {
	while ((block & binblocks) == 0)
	{
	  idx += BINBLOCKWIDTH;
21f1d050:	e51b3038 	ldr	r3, [fp, #-56]
21f1d054:	e2833004 	add	r3, r3, #4	; 0x4
21f1d058:	e50b3038 	str	r3, [fp, #-56]
	  block <<= 1;
21f1d05c:	e51b3024 	ldr	r3, [fp, #-36]
21f1d060:	e1a03083 	mov	r3, r3, lsl #1
21f1d064:	e50b3024 	str	r3, [fp, #-36]
21f1d068:	e59f30d8 	ldr	r3, [pc, #216]	; 21f1d148 <.text+0x1d148>
21f1d06c:	e5932004 	ldr	r2, [r3, #4]
21f1d070:	e51b3024 	ldr	r3, [fp, #-36]
21f1d074:	e0023003 	and	r3, r2, r3
21f1d078:	e3530000 	cmp	r3, #0	; 0x0
21f1d07c:	0afffff3 	beq	21f1d050 <malloc+0xaa8>
21f1d080:	eaffff52 	b	21f1cdd0 <malloc+0x828>
	}
      }
      else
	break;
    }
  }


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
21f1d084:	e59f30bc 	ldr	r3, [pc, #188]	; 21f1d148 <.text+0x1d148>
21f1d088:	e5933008 	ldr	r3, [r3, #8]
21f1d08c:	e5933004 	ldr	r3, [r3, #4]
21f1d090:	e3c32003 	bic	r2, r3, #3	; 0x3
21f1d094:	e51b3010 	ldr	r3, [fp, #-16]
21f1d098:	e0633002 	rsb	r3, r3, r2
21f1d09c:	e50b302c 	str	r3, [fp, #-44]
21f1d0a0:	e51b302c 	ldr	r3, [fp, #-44]
21f1d0a4:	e353000f 	cmp	r3, #15	; 0xf
21f1d0a8:	ca00000e 	bgt	21f1d0e8 <malloc+0xb40>
  {

#if HAVE_MMAP
    /* If big and would otherwise need to extend, try to use mmap instead */
    if ((unsigned long)nb >= (unsigned long)mmap_threshold &&
	(victim = mmap_chunk(nb)) != 0)
      return chunk2mem(victim);
#endif

    /* Try to extend */
    malloc_extend_top(nb);
21f1d0ac:	e51b0010 	ldr	r0, [fp, #-16]
21f1d0b0:	ebfffc4f 	bl	21f1c1f4 <malloc_extend_top>
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
21f1d0b4:	e59f308c 	ldr	r3, [pc, #140]	; 21f1d148 <.text+0x1d148>
21f1d0b8:	e5933008 	ldr	r3, [r3, #8]
21f1d0bc:	e5933004 	ldr	r3, [r3, #4]
21f1d0c0:	e3c32003 	bic	r2, r3, #3	; 0x3
21f1d0c4:	e51b3010 	ldr	r3, [fp, #-16]
21f1d0c8:	e0633002 	rsb	r3, r3, r2
21f1d0cc:	e50b302c 	str	r3, [fp, #-44]
21f1d0d0:	e51b302c 	ldr	r3, [fp, #-44]
21f1d0d4:	e353000f 	cmp	r3, #15	; 0xf
21f1d0d8:	ca000002 	bgt	21f1d0e8 <malloc+0xb40>
      return 0; /* propagate failure */
21f1d0dc:	e3a03000 	mov	r3, #0	; 0x0
21f1d0e0:	e50b307c 	str	r3, [fp, #-124]
21f1d0e4:	ea000013 	b	21f1d138 <malloc+0xb90>
  }

  victim = top;
21f1d0e8:	e59f3058 	ldr	r3, [pc, #88]	; 21f1d148 <.text+0x1d148>
21f1d0ec:	e5933008 	ldr	r3, [r3, #8]
21f1d0f0:	e50b3040 	str	r3, [fp, #-64]
  set_head(victim, nb | PREV_INUSE);
21f1d0f4:	e51b3010 	ldr	r3, [fp, #-16]
21f1d0f8:	e3832001 	orr	r2, r3, #1	; 0x1
21f1d0fc:	e51b3040 	ldr	r3, [fp, #-64]
21f1d100:	e5832004 	str	r2, [r3, #4]
  top = chunk_at_offset(victim, nb);
21f1d104:	e59f103c 	ldr	r1, [pc, #60]	; 21f1d148 <.text+0x1d148>
21f1d108:	e51b2040 	ldr	r2, [fp, #-64]
21f1d10c:	e51b3010 	ldr	r3, [fp, #-16]
21f1d110:	e0823003 	add	r3, r2, r3
21f1d114:	e5813008 	str	r3, [r1, #8]
  set_head(top, remainder_size | PREV_INUSE);
21f1d118:	e59f3028 	ldr	r3, [pc, #40]	; 21f1d148 <.text+0x1d148>
21f1d11c:	e5932008 	ldr	r2, [r3, #8]
21f1d120:	e51b302c 	ldr	r3, [fp, #-44]
21f1d124:	e3833001 	orr	r3, r3, #1	; 0x1
21f1d128:	e5823004 	str	r3, [r2, #4]
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);
21f1d12c:	e51b3040 	ldr	r3, [fp, #-64]
21f1d130:	e2833008 	add	r3, r3, #8	; 0x8
21f1d134:	e50b307c 	str	r3, [fp, #-124]
21f1d138:	e51b307c 	ldr	r3, [fp, #-124]

}
21f1d13c:	e1a00003 	mov	r0, r3
21f1d140:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1d144:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1d148:	21f33590 	ldrcsb	r3, [r3, #80]!

21f1d14c <free>:




/*

  free() algorithm :

    cases:

       1. free(0) has no effect.

       2. If the chunk was allocated via mmap, it is release via munmap().

       3. If a returned chunk borders the current high end of memory,
	  it is consolidated into the top, and if the total unused
	  topmost memory exceeds the trim threshold, malloc_trim is
	  called.

       4. Other chunks are consolidated as they arrive, and
	  placed in corresponding bins. (This includes the case of
	  consolidating with the current `last_remainder').

*/


#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
21f1d14c:	e1a0c00d 	mov	ip, sp
21f1d150:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1d154:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1d158:	e24dd044 	sub	sp, sp, #68	; 0x44
21f1d15c:	e50b0038 	str	r0, [fp, #-56]
  mchunkptr p;         /* chunk corresponding to mem */
  INTERNAL_SIZE_T hd;  /* its head field */
  INTERNAL_SIZE_T sz;  /* its size */
  int       idx;       /* its bin index */
  mchunkptr next;      /* next contiguous chunk */
  INTERNAL_SIZE_T nextsz; /* its size */
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
21f1d160:	e51b3038 	ldr	r3, [fp, #-56]
21f1d164:	e3530000 	cmp	r3, #0	; 0x0
21f1d168:	0a000160 	beq	21f1d6f0 <free+0x5a4>
    return;

  p = mem2chunk(mem);
21f1d16c:	e51b3038 	ldr	r3, [fp, #-56]
21f1d170:	e2433008 	sub	r3, r3, #8	; 0x8
21f1d174:	e50b3034 	str	r3, [fp, #-52]
  hd = p->size;
21f1d178:	e51b3034 	ldr	r3, [fp, #-52]
21f1d17c:	e5933004 	ldr	r3, [r3, #4]
21f1d180:	e50b3030 	str	r3, [fp, #-48]

#if HAVE_MMAP
  if (hd & IS_MMAPPED)                       /* release mmapped memory. */
  {
    munmap_chunk(p);
    return;
  }
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
21f1d184:	e51b3030 	ldr	r3, [fp, #-48]
21f1d188:	e3c33001 	bic	r3, r3, #1	; 0x1
21f1d18c:	e50b302c 	str	r3, [fp, #-44]
  next = chunk_at_offset(p, sz);
21f1d190:	e51b2034 	ldr	r2, [fp, #-52]
21f1d194:	e51b302c 	ldr	r3, [fp, #-44]
21f1d198:	e0823003 	add	r3, r2, r3
21f1d19c:	e50b3024 	str	r3, [fp, #-36]
  nextsz = chunksize(next);
21f1d1a0:	e51b3024 	ldr	r3, [fp, #-36]
21f1d1a4:	e5933004 	ldr	r3, [r3, #4]
21f1d1a8:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1d1ac:	e50b3020 	str	r3, [fp, #-32]

  if (next == top)                            /* merge with top */
21f1d1b0:	e59f3540 	ldr	r3, [pc, #1344]	; 21f1d6f8 <.text+0x1d6f8>
21f1d1b4:	e5932008 	ldr	r2, [r3, #8]
21f1d1b8:	e51b3024 	ldr	r3, [fp, #-36]
21f1d1bc:	e1520003 	cmp	r2, r3
21f1d1c0:	1a000032 	bne	21f1d290 <free+0x144>
  {
    sz += nextsz;
21f1d1c4:	e51b202c 	ldr	r2, [fp, #-44]
21f1d1c8:	e51b3020 	ldr	r3, [fp, #-32]
21f1d1cc:	e0823003 	add	r3, r2, r3
21f1d1d0:	e50b302c 	str	r3, [fp, #-44]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
21f1d1d4:	e51b3030 	ldr	r3, [fp, #-48]
21f1d1d8:	e2033001 	and	r3, r3, #1	; 0x1
21f1d1dc:	e3530000 	cmp	r3, #0	; 0x0
21f1d1e0:	1a000019 	bne	21f1d24c <free+0x100>
    {
      prevsz = p->prev_size;
21f1d1e4:	e51b3034 	ldr	r3, [fp, #-52]
21f1d1e8:	e5933000 	ldr	r3, [r3]
21f1d1ec:	e50b301c 	str	r3, [fp, #-28]
      p = chunk_at_offset(p, -((long) prevsz));
21f1d1f0:	e51b201c 	ldr	r2, [fp, #-28]
21f1d1f4:	e3a03000 	mov	r3, #0	; 0x0
21f1d1f8:	e0623003 	rsb	r3, r2, r3
21f1d1fc:	e1a02003 	mov	r2, r3
21f1d200:	e51b3034 	ldr	r3, [fp, #-52]
21f1d204:	e0823003 	add	r3, r2, r3
21f1d208:	e50b3034 	str	r3, [fp, #-52]
      sz += prevsz;
21f1d20c:	e51b202c 	ldr	r2, [fp, #-44]
21f1d210:	e51b301c 	ldr	r3, [fp, #-28]
21f1d214:	e0823003 	add	r3, r2, r3
21f1d218:	e50b302c 	str	r3, [fp, #-44]
      unlink(p, bck, fwd);
21f1d21c:	e51b3034 	ldr	r3, [fp, #-52]
21f1d220:	e593300c 	ldr	r3, [r3, #12]
21f1d224:	e50b3018 	str	r3, [fp, #-24]
21f1d228:	e51b3034 	ldr	r3, [fp, #-52]
21f1d22c:	e5933008 	ldr	r3, [r3, #8]
21f1d230:	e50b3014 	str	r3, [fp, #-20]
21f1d234:	e51b2014 	ldr	r2, [fp, #-20]
21f1d238:	e51b3018 	ldr	r3, [fp, #-24]
21f1d23c:	e582300c 	str	r3, [r2, #12]
21f1d240:	e51b2018 	ldr	r2, [fp, #-24]
21f1d244:	e51b3014 	ldr	r3, [fp, #-20]
21f1d248:	e5823008 	str	r3, [r2, #8]
    }

    set_head(p, sz | PREV_INUSE);
21f1d24c:	e51b302c 	ldr	r3, [fp, #-44]
21f1d250:	e3832001 	orr	r2, r3, #1	; 0x1
21f1d254:	e51b3034 	ldr	r3, [fp, #-52]
21f1d258:	e5832004 	str	r2, [r3, #4]
    top = p;
21f1d25c:	e59f2494 	ldr	r2, [pc, #1172]	; 21f1d6f8 <.text+0x1d6f8>
21f1d260:	e51b3034 	ldr	r3, [fp, #-52]
21f1d264:	e5823008 	str	r3, [r2, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
21f1d268:	e59f348c 	ldr	r3, [pc, #1164]	; 21f1d6fc <.text+0x1d6fc>
21f1d26c:	e5932000 	ldr	r2, [r3]
21f1d270:	e51b302c 	ldr	r3, [fp, #-44]
21f1d274:	e1530002 	cmp	r3, r2
21f1d278:	3a00011c 	bcc	21f1d6f0 <free+0x5a4>
      malloc_trim(top_pad);
21f1d27c:	e59f347c 	ldr	r3, [pc, #1148]	; 21f1d700 <.text+0x1d700>
21f1d280:	e5933000 	ldr	r3, [r3]
21f1d284:	e1a00003 	mov	r0, r3
21f1d288:	eb00059e 	bl	21f1e908 <malloc_trim>
21f1d28c:	ea000117 	b	21f1d6f0 <free+0x5a4>
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
21f1d290:	e51b2024 	ldr	r2, [fp, #-36]
21f1d294:	e51b3020 	ldr	r3, [fp, #-32]
21f1d298:	e5823004 	str	r3, [r2, #4]

  islr = 0;
21f1d29c:	e3a03000 	mov	r3, #0	; 0x0
21f1d2a0:	e50b3010 	str	r3, [fp, #-16]

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
21f1d2a4:	e51b3030 	ldr	r3, [fp, #-48]
21f1d2a8:	e2033001 	and	r3, r3, #1	; 0x1
21f1d2ac:	e3530000 	cmp	r3, #0	; 0x0
21f1d2b0:	1a000022 	bne	21f1d340 <free+0x1f4>
  {
    prevsz = p->prev_size;
21f1d2b4:	e51b3034 	ldr	r3, [fp, #-52]
21f1d2b8:	e5933000 	ldr	r3, [r3]
21f1d2bc:	e50b301c 	str	r3, [fp, #-28]
    p = chunk_at_offset(p, -((long) prevsz));
21f1d2c0:	e51b201c 	ldr	r2, [fp, #-28]
21f1d2c4:	e3a03000 	mov	r3, #0	; 0x0
21f1d2c8:	e0623003 	rsb	r3, r2, r3
21f1d2cc:	e1a02003 	mov	r2, r3
21f1d2d0:	e51b3034 	ldr	r3, [fp, #-52]
21f1d2d4:	e0823003 	add	r3, r2, r3
21f1d2d8:	e50b3034 	str	r3, [fp, #-52]
    sz += prevsz;
21f1d2dc:	e51b202c 	ldr	r2, [fp, #-44]
21f1d2e0:	e51b301c 	ldr	r3, [fp, #-28]
21f1d2e4:	e0823003 	add	r3, r2, r3
21f1d2e8:	e50b302c 	str	r3, [fp, #-44]

    if (p->fd == last_remainder)             /* keep as last_remainder */
21f1d2ec:	e51b3034 	ldr	r3, [fp, #-52]
21f1d2f0:	e5932008 	ldr	r2, [r3, #8]
21f1d2f4:	e59f33fc 	ldr	r3, [pc, #1020]	; 21f1d6f8 <.text+0x1d6f8>
21f1d2f8:	e2833008 	add	r3, r3, #8	; 0x8
21f1d2fc:	e1520003 	cmp	r2, r3
21f1d300:	1a000002 	bne	21f1d310 <free+0x1c4>
      islr = 1;
21f1d304:	e3a03001 	mov	r3, #1	; 0x1
21f1d308:	e50b3010 	str	r3, [fp, #-16]
21f1d30c:	ea00000b 	b	21f1d340 <free+0x1f4>
    else
      unlink(p, bck, fwd);
21f1d310:	e51b3034 	ldr	r3, [fp, #-52]
21f1d314:	e593300c 	ldr	r3, [r3, #12]
21f1d318:	e50b3018 	str	r3, [fp, #-24]
21f1d31c:	e51b3034 	ldr	r3, [fp, #-52]
21f1d320:	e5933008 	ldr	r3, [r3, #8]
21f1d324:	e50b3014 	str	r3, [fp, #-20]
21f1d328:	e51b2014 	ldr	r2, [fp, #-20]
21f1d32c:	e51b3018 	ldr	r3, [fp, #-24]
21f1d330:	e582300c 	str	r3, [r2, #12]
21f1d334:	e51b2018 	ldr	r2, [fp, #-24]
21f1d338:	e51b3014 	ldr	r3, [fp, #-20]
21f1d33c:	e5823008 	str	r3, [r2, #8]
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
21f1d340:	e51b2024 	ldr	r2, [fp, #-36]
21f1d344:	e51b3020 	ldr	r3, [fp, #-32]
21f1d348:	e0823003 	add	r3, r2, r3
21f1d34c:	e5933004 	ldr	r3, [r3, #4]
21f1d350:	e2033001 	and	r3, r3, #1	; 0x1
21f1d354:	e3530000 	cmp	r3, #0	; 0x0
21f1d358:	1a00002e 	bne	21f1d418 <free+0x2cc>
  {
    sz += nextsz;
21f1d35c:	e51b202c 	ldr	r2, [fp, #-44]
21f1d360:	e51b3020 	ldr	r3, [fp, #-32]
21f1d364:	e0823003 	add	r3, r2, r3
21f1d368:	e50b302c 	str	r3, [fp, #-44]

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
21f1d36c:	e51b3010 	ldr	r3, [fp, #-16]
21f1d370:	e3530000 	cmp	r3, #0	; 0x0
21f1d374:	1a00001b 	bne	21f1d3e8 <free+0x29c>
21f1d378:	e51b3024 	ldr	r3, [fp, #-36]
21f1d37c:	e5932008 	ldr	r2, [r3, #8]
21f1d380:	e59f3370 	ldr	r3, [pc, #880]	; 21f1d6f8 <.text+0x1d6f8>
21f1d384:	e2833008 	add	r3, r3, #8	; 0x8
21f1d388:	e1520003 	cmp	r2, r3
21f1d38c:	1a000015 	bne	21f1d3e8 <free+0x29c>
    {
      islr = 1;
21f1d390:	e3a03001 	mov	r3, #1	; 0x1
21f1d394:	e50b3010 	str	r3, [fp, #-16]
      link_last_remainder(p);
21f1d398:	e59f3358 	ldr	r3, [pc, #856]	; 21f1d6f8 <.text+0x1d6f8>
21f1d39c:	e2833008 	add	r3, r3, #8	; 0x8
21f1d3a0:	e1a01003 	mov	r1, r3
21f1d3a4:	e59f334c 	ldr	r3, [pc, #844]	; 21f1d6f8 <.text+0x1d6f8>
21f1d3a8:	e2833008 	add	r3, r3, #8	; 0x8
21f1d3ac:	e1a02003 	mov	r2, r3
21f1d3b0:	e51b3034 	ldr	r3, [fp, #-52]
21f1d3b4:	e582300c 	str	r3, [r2, #12]
21f1d3b8:	e592300c 	ldr	r3, [r2, #12]
21f1d3bc:	e5813008 	str	r3, [r1, #8]
21f1d3c0:	e59f3330 	ldr	r3, [pc, #816]	; 21f1d6f8 <.text+0x1d6f8>
21f1d3c4:	e2833008 	add	r3, r3, #8	; 0x8
21f1d3c8:	e1a02003 	mov	r2, r3
21f1d3cc:	e51b3034 	ldr	r3, [fp, #-52]
21f1d3d0:	e583200c 	str	r2, [r3, #12]
21f1d3d4:	e51b3034 	ldr	r3, [fp, #-52]
21f1d3d8:	e593200c 	ldr	r2, [r3, #12]
21f1d3dc:	e51b3034 	ldr	r3, [fp, #-52]
21f1d3e0:	e5832008 	str	r2, [r3, #8]
21f1d3e4:	ea00000b 	b	21f1d418 <free+0x2cc>
    }
    else
      unlink(next, bck, fwd);
21f1d3e8:	e51b3024 	ldr	r3, [fp, #-36]
21f1d3ec:	e593300c 	ldr	r3, [r3, #12]
21f1d3f0:	e50b3018 	str	r3, [fp, #-24]
21f1d3f4:	e51b3024 	ldr	r3, [fp, #-36]
21f1d3f8:	e5933008 	ldr	r3, [r3, #8]
21f1d3fc:	e50b3014 	str	r3, [fp, #-20]
21f1d400:	e51b2014 	ldr	r2, [fp, #-20]
21f1d404:	e51b3018 	ldr	r3, [fp, #-24]
21f1d408:	e582300c 	str	r3, [r2, #12]
21f1d40c:	e51b2018 	ldr	r2, [fp, #-24]
21f1d410:	e51b3014 	ldr	r3, [fp, #-20]
21f1d414:	e5823008 	str	r3, [r2, #8]
  }


  set_head(p, sz | PREV_INUSE);
21f1d418:	e51b302c 	ldr	r3, [fp, #-44]
21f1d41c:	e3832001 	orr	r2, r3, #1	; 0x1
21f1d420:	e51b3034 	ldr	r3, [fp, #-52]
21f1d424:	e5832004 	str	r2, [r3, #4]
  set_foot(p, sz);
21f1d428:	e51b2034 	ldr	r2, [fp, #-52]
21f1d42c:	e51b302c 	ldr	r3, [fp, #-44]
21f1d430:	e0823003 	add	r3, r2, r3
21f1d434:	e1a02003 	mov	r2, r3
21f1d438:	e51b302c 	ldr	r3, [fp, #-44]
21f1d43c:	e5823000 	str	r3, [r2]
  if (!islr)
21f1d440:	e51b3010 	ldr	r3, [fp, #-16]
21f1d444:	e3530000 	cmp	r3, #0	; 0x0
21f1d448:	1a0000a8 	bne	21f1d6f0 <free+0x5a4>
    frontlink(p, sz, idx, bck, fwd);
21f1d44c:	e51b202c 	ldr	r2, [fp, #-44]
21f1d450:	e3a03f7f 	mov	r3, #508	; 0x1fc
21f1d454:	e2833003 	add	r3, r3, #3	; 0x3
21f1d458:	e1520003 	cmp	r2, r3
21f1d45c:	8a000026 	bhi	21f1d4fc <free+0x3b0>
21f1d460:	e51b302c 	ldr	r3, [fp, #-44]
21f1d464:	e1a031a3 	mov	r3, r3, lsr #3
21f1d468:	e50b3028 	str	r3, [fp, #-40]
21f1d46c:	e59f0284 	ldr	r0, [pc, #644]	; 21f1d6f8 <.text+0x1d6f8>
21f1d470:	e59f3280 	ldr	r3, [pc, #640]	; 21f1d6f8 <.text+0x1d6f8>
21f1d474:	e5931004 	ldr	r1, [r3, #4]
21f1d478:	e51b3028 	ldr	r3, [fp, #-40]
21f1d47c:	e2832003 	add	r2, r3, #3	; 0x3
21f1d480:	e3530000 	cmp	r3, #0	; 0x0
21f1d484:	b1a03002 	movlt	r3, r2
21f1d488:	e1a03143 	mov	r3, r3, asr #2
21f1d48c:	e1a02003 	mov	r2, r3
21f1d490:	e3a03001 	mov	r3, #1	; 0x1
21f1d494:	e1a03213 	mov	r3, r3, lsl r2
21f1d498:	e1813003 	orr	r3, r1, r3
21f1d49c:	e5803004 	str	r3, [r0, #4]
21f1d4a0:	e51b3028 	ldr	r3, [fp, #-40]
21f1d4a4:	e1a03183 	mov	r3, r3, lsl #3
21f1d4a8:	e1a02003 	mov	r2, r3
21f1d4ac:	e59f3244 	ldr	r3, [pc, #580]	; 21f1d6f8 <.text+0x1d6f8>
21f1d4b0:	e0823003 	add	r3, r2, r3
21f1d4b4:	e50b3018 	str	r3, [fp, #-24]
21f1d4b8:	e51b3018 	ldr	r3, [fp, #-24]
21f1d4bc:	e5933008 	ldr	r3, [r3, #8]
21f1d4c0:	e50b3014 	str	r3, [fp, #-20]
21f1d4c4:	e51b2034 	ldr	r2, [fp, #-52]
21f1d4c8:	e51b3018 	ldr	r3, [fp, #-24]
21f1d4cc:	e582300c 	str	r3, [r2, #12]
21f1d4d0:	e51b2034 	ldr	r2, [fp, #-52]
21f1d4d4:	e51b3014 	ldr	r3, [fp, #-20]
21f1d4d8:	e5823008 	str	r3, [r2, #8]
21f1d4dc:	e51b2018 	ldr	r2, [fp, #-24]
21f1d4e0:	e51b3034 	ldr	r3, [fp, #-52]
21f1d4e4:	e5823008 	str	r3, [r2, #8]
21f1d4e8:	e51b3018 	ldr	r3, [fp, #-24]
21f1d4ec:	e5932008 	ldr	r2, [r3, #8]
21f1d4f0:	e51b3014 	ldr	r3, [fp, #-20]
21f1d4f4:	e583200c 	str	r2, [r3, #12]
21f1d4f8:	ea00007c 	b	21f1d6f0 <free+0x5a4>
21f1d4fc:	e51b302c 	ldr	r3, [fp, #-44]
21f1d500:	e1a034a3 	mov	r3, r3, lsr #9
21f1d504:	e3530000 	cmp	r3, #0	; 0x0
21f1d508:	1a000003 	bne	21f1d51c <free+0x3d0>
21f1d50c:	e51b302c 	ldr	r3, [fp, #-44]
21f1d510:	e1a031a3 	mov	r3, r3, lsr #3
21f1d514:	e50b3050 	str	r3, [fp, #-80]
21f1d518:	ea00003a 	b	21f1d608 <free+0x4bc>
21f1d51c:	e51b302c 	ldr	r3, [fp, #-44]
21f1d520:	e1a034a3 	mov	r3, r3, lsr #9
21f1d524:	e3530004 	cmp	r3, #4	; 0x4
21f1d528:	8a000004 	bhi	21f1d540 <free+0x3f4>
21f1d52c:	e51b302c 	ldr	r3, [fp, #-44]
21f1d530:	e1a03323 	mov	r3, r3, lsr #6
21f1d534:	e2833038 	add	r3, r3, #56	; 0x38
21f1d538:	e50b304c 	str	r3, [fp, #-76]
21f1d53c:	ea00002f 	b	21f1d600 <free+0x4b4>
21f1d540:	e51b302c 	ldr	r3, [fp, #-44]
21f1d544:	e1a034a3 	mov	r3, r3, lsr #9
21f1d548:	e3530014 	cmp	r3, #20	; 0x14
21f1d54c:	8a000004 	bhi	21f1d564 <free+0x418>
21f1d550:	e51b302c 	ldr	r3, [fp, #-44]
21f1d554:	e1a034a3 	mov	r3, r3, lsr #9
21f1d558:	e283305b 	add	r3, r3, #91	; 0x5b
21f1d55c:	e50b3048 	str	r3, [fp, #-72]
21f1d560:	ea000024 	b	21f1d5f8 <free+0x4ac>
21f1d564:	e51b302c 	ldr	r3, [fp, #-44]
21f1d568:	e1a034a3 	mov	r3, r3, lsr #9
21f1d56c:	e3530054 	cmp	r3, #84	; 0x54
21f1d570:	8a000004 	bhi	21f1d588 <free+0x43c>
21f1d574:	e51b302c 	ldr	r3, [fp, #-44]
21f1d578:	e1a03623 	mov	r3, r3, lsr #12
21f1d57c:	e283306e 	add	r3, r3, #110	; 0x6e
21f1d580:	e50b3044 	str	r3, [fp, #-68]
21f1d584:	ea000019 	b	21f1d5f0 <free+0x4a4>
21f1d588:	e51b302c 	ldr	r3, [fp, #-44]
21f1d58c:	e1a034a3 	mov	r3, r3, lsr #9
21f1d590:	e3530f55 	cmp	r3, #340	; 0x154
21f1d594:	8a000004 	bhi	21f1d5ac <free+0x460>
21f1d598:	e51b302c 	ldr	r3, [fp, #-44]
21f1d59c:	e1a037a3 	mov	r3, r3, lsr #15
21f1d5a0:	e2833077 	add	r3, r3, #119	; 0x77
21f1d5a4:	e50b3040 	str	r3, [fp, #-64]
21f1d5a8:	ea00000e 	b	21f1d5e8 <free+0x49c>
21f1d5ac:	e51b302c 	ldr	r3, [fp, #-44]
21f1d5b0:	e1a024a3 	mov	r2, r3, lsr #9
21f1d5b4:	e3a03e55 	mov	r3, #1360	; 0x550
21f1d5b8:	e2833004 	add	r3, r3, #4	; 0x4
21f1d5bc:	e1520003 	cmp	r2, r3
21f1d5c0:	8a000004 	bhi	21f1d5d8 <free+0x48c>
21f1d5c4:	e51b302c 	ldr	r3, [fp, #-44]
21f1d5c8:	e1a03923 	mov	r3, r3, lsr #18
21f1d5cc:	e283307c 	add	r3, r3, #124	; 0x7c
21f1d5d0:	e50b303c 	str	r3, [fp, #-60]
21f1d5d4:	ea000001 	b	21f1d5e0 <free+0x494>
21f1d5d8:	e3a0307e 	mov	r3, #126	; 0x7e
21f1d5dc:	e50b303c 	str	r3, [fp, #-60]
21f1d5e0:	e51b303c 	ldr	r3, [fp, #-60]
21f1d5e4:	e50b3040 	str	r3, [fp, #-64]
21f1d5e8:	e51b3040 	ldr	r3, [fp, #-64]
21f1d5ec:	e50b3044 	str	r3, [fp, #-68]
21f1d5f0:	e51b3044 	ldr	r3, [fp, #-68]
21f1d5f4:	e50b3048 	str	r3, [fp, #-72]
21f1d5f8:	e51b3048 	ldr	r3, [fp, #-72]
21f1d5fc:	e50b304c 	str	r3, [fp, #-76]
21f1d600:	e51b304c 	ldr	r3, [fp, #-76]
21f1d604:	e50b3050 	str	r3, [fp, #-80]
21f1d608:	e51b3050 	ldr	r3, [fp, #-80]
21f1d60c:	e50b3028 	str	r3, [fp, #-40]
21f1d610:	e51b3028 	ldr	r3, [fp, #-40]
21f1d614:	e1a03183 	mov	r3, r3, lsl #3
21f1d618:	e1a02003 	mov	r2, r3
21f1d61c:	e59f30d4 	ldr	r3, [pc, #212]	; 21f1d6f8 <.text+0x1d6f8>
21f1d620:	e0823003 	add	r3, r2, r3
21f1d624:	e50b3018 	str	r3, [fp, #-24]
21f1d628:	e51b3018 	ldr	r3, [fp, #-24]
21f1d62c:	e5933008 	ldr	r3, [r3, #8]
21f1d630:	e50b3014 	str	r3, [fp, #-20]
21f1d634:	e51b2014 	ldr	r2, [fp, #-20]
21f1d638:	e51b3018 	ldr	r3, [fp, #-24]
21f1d63c:	e1520003 	cmp	r2, r3
21f1d640:	1a000010 	bne	21f1d688 <free+0x53c>
21f1d644:	e59f00ac 	ldr	r0, [pc, #172]	; 21f1d6f8 <.text+0x1d6f8>
21f1d648:	e59f30a8 	ldr	r3, [pc, #168]	; 21f1d6f8 <.text+0x1d6f8>
21f1d64c:	e5931004 	ldr	r1, [r3, #4]
21f1d650:	e51b3028 	ldr	r3, [fp, #-40]
21f1d654:	e2832003 	add	r2, r3, #3	; 0x3
21f1d658:	e3530000 	cmp	r3, #0	; 0x0
21f1d65c:	b1a03002 	movlt	r3, r2
21f1d660:	e1a03143 	mov	r3, r3, asr #2
21f1d664:	e1a02003 	mov	r2, r3
21f1d668:	e3a03001 	mov	r3, #1	; 0x1
21f1d66c:	e1a03213 	mov	r3, r3, lsl r2
21f1d670:	e1813003 	orr	r3, r1, r3
21f1d674:	e5803004 	str	r3, [r0, #4]
21f1d678:	ea00000f 	b	21f1d6bc <free+0x570>
21f1d67c:	e51b3014 	ldr	r3, [fp, #-20]
21f1d680:	e5933008 	ldr	r3, [r3, #8]
21f1d684:	e50b3014 	str	r3, [fp, #-20]
21f1d688:	e51b2014 	ldr	r2, [fp, #-20]
21f1d68c:	e51b3018 	ldr	r3, [fp, #-24]
21f1d690:	e1520003 	cmp	r2, r3
21f1d694:	0a000005 	beq	21f1d6b0 <free+0x564>
21f1d698:	e51b3014 	ldr	r3, [fp, #-20]
21f1d69c:	e5933004 	ldr	r3, [r3, #4]
21f1d6a0:	e3c32003 	bic	r2, r3, #3	; 0x3
21f1d6a4:	e51b302c 	ldr	r3, [fp, #-44]
21f1d6a8:	e1520003 	cmp	r2, r3
21f1d6ac:	8afffff2 	bhi	21f1d67c <free+0x530>
21f1d6b0:	e51b3014 	ldr	r3, [fp, #-20]
21f1d6b4:	e593300c 	ldr	r3, [r3, #12]
21f1d6b8:	e50b3018 	str	r3, [fp, #-24]
21f1d6bc:	e51b2034 	ldr	r2, [fp, #-52]
21f1d6c0:	e51b3018 	ldr	r3, [fp, #-24]
21f1d6c4:	e582300c 	str	r3, [r2, #12]
21f1d6c8:	e51b2034 	ldr	r2, [fp, #-52]
21f1d6cc:	e51b3014 	ldr	r3, [fp, #-20]
21f1d6d0:	e5823008 	str	r3, [r2, #8]
21f1d6d4:	e51b2018 	ldr	r2, [fp, #-24]
21f1d6d8:	e51b3034 	ldr	r3, [fp, #-52]
21f1d6dc:	e5823008 	str	r3, [r2, #8]
21f1d6e0:	e51b3018 	ldr	r3, [fp, #-24]
21f1d6e4:	e5932008 	ldr	r2, [r3, #8]
21f1d6e8:	e51b3014 	ldr	r3, [fp, #-20]
21f1d6ec:	e583200c 	str	r2, [r3, #12]
}
21f1d6f0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1d6f4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1d6f8:	21f33590 	ldrcsb	r3, [r3, #80]!
21f1d6fc:	21f33998 	ldrcsb	r3, [r3, #152]!
21f1d700:	21f67770 	mvncss	r7, r0, ror r7

21f1d704 <realloc>:





/*

  Realloc algorithm:

    Chunks that were obtained via mmap cannot be extended or shrunk
    unless HAVE_MREMAP is defined, in which case mremap is used.
    Otherwise, if their reallocation is for additional space, they are
    copied.  If for less, they are just left alone.

    Otherwise, if the reallocation is for additional space, and the
    chunk can be extended, it is, else a malloc-copy-free sequence is
    taken.  There are several different ways that a chunk could be
    extended. All are tried:

       * Extending forward into following adjacent free chunk.
       * Shifting backwards, joining preceding adjacent space
       * Both shifting backwards and extending forward.
       * Extending into newly sbrked space

    Unless the #define REALLOC_ZERO_BYTES_FREES is set, realloc with a
    size argument of zero (re)allocates a minimum-sized chunk.

    If the reallocation is for less space, and the new request is for
    a `small' (<512 bytes) size, then the newly unused space is lopped
    off and freed.

    The old unix realloc convention of allowing the last-free'd chunk
    to be used as an argument to realloc is no longer supported.
    I don't know of any programs still relying on this feature,
    and allowing it would also allow too many other incorrect
    usages of realloc to be sensible.


*/


#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
21f1d704:	e1a0c00d 	mov	ip, sp
21f1d708:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1d70c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1d710:	e24dd078 	sub	sp, sp, #120	; 0x78
21f1d714:	e50b0078 	str	r0, [fp, #-120]
21f1d718:	e50b107c 	str	r1, [fp, #-124]
  INTERNAL_SIZE_T    nb;      /* padded request size */

  mchunkptr oldp;             /* chunk corresponding to oldmem */
  INTERNAL_SIZE_T    oldsize; /* its size */

  mchunkptr newp;             /* chunk to return */
  INTERNAL_SIZE_T    newsize; /* its size */
  Void_t*   newmem;           /* corresponding user mem */

  mchunkptr next;             /* next contiguous chunk after oldp */
  INTERNAL_SIZE_T  nextsize;  /* its size */

  mchunkptr prev;             /* previous contiguous chunk before oldp */
  INTERNAL_SIZE_T  prevsize;  /* its size */

  mchunkptr remainder;        /* holds split off extra space from newp */
  INTERNAL_SIZE_T  remainder_size;   /* its size */

  mchunkptr bck;              /* misc temp for linking */
  mchunkptr fwd;              /* misc temp for linking */

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
21f1d71c:	e51b307c 	ldr	r3, [fp, #-124]
21f1d720:	e3530000 	cmp	r3, #0	; 0x0
21f1d724:	aa000002 	bge	21f1d734 <realloc+0x30>
21f1d728:	e3a03000 	mov	r3, #0	; 0x0
21f1d72c:	e50b3084 	str	r3, [fp, #-132]
21f1d730:	ea000328 	b	21f1e3d8 <realloc+0xcd4>

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
21f1d734:	e51b3078 	ldr	r3, [fp, #-120]
21f1d738:	e3530000 	cmp	r3, #0	; 0x0
21f1d73c:	1a000004 	bne	21f1d754 <realloc+0x50>
21f1d740:	e51b007c 	ldr	r0, [fp, #-124]
21f1d744:	ebfffb97 	bl	21f1c5a8 <malloc>
21f1d748:	e1a03000 	mov	r3, r0
21f1d74c:	e50b3084 	str	r3, [fp, #-132]
21f1d750:	ea000320 	b	21f1e3d8 <realloc+0xcd4>

  newp    = oldp    = mem2chunk(oldmem);
21f1d754:	e51b3078 	ldr	r3, [fp, #-120]
21f1d758:	e2433008 	sub	r3, r3, #8	; 0x8
21f1d75c:	e50b3070 	str	r3, [fp, #-112]
21f1d760:	e51b3070 	ldr	r3, [fp, #-112]
21f1d764:	e50b3068 	str	r3, [fp, #-104]
  newsize = oldsize = chunksize(oldp);
21f1d768:	e51b3070 	ldr	r3, [fp, #-112]
21f1d76c:	e5933004 	ldr	r3, [r3, #4]
21f1d770:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1d774:	e50b306c 	str	r3, [fp, #-108]
21f1d778:	e51b306c 	ldr	r3, [fp, #-108]
21f1d77c:	e50b3064 	str	r3, [fp, #-100]


  nb = request2size(bytes);
21f1d780:	e51b307c 	ldr	r3, [fp, #-124]
21f1d784:	e283300b 	add	r3, r3, #11	; 0xb
21f1d788:	e3530016 	cmp	r3, #22	; 0x16
21f1d78c:	da000004 	ble	21f1d7a4 <realloc+0xa0>
21f1d790:	e51b307c 	ldr	r3, [fp, #-124]
21f1d794:	e283300b 	add	r3, r3, #11	; 0xb
21f1d798:	e3c33007 	bic	r3, r3, #7	; 0x7
21f1d79c:	e50b3080 	str	r3, [fp, #-128]
21f1d7a0:	ea000001 	b	21f1d7ac <realloc+0xa8>
21f1d7a4:	e3a03010 	mov	r3, #16	; 0x10
21f1d7a8:	e50b3080 	str	r3, [fp, #-128]
21f1d7ac:	e51b3080 	ldr	r3, [fp, #-128]
21f1d7b0:	e50b3074 	str	r3, [fp, #-116]

#if HAVE_MMAP
  if (chunk_is_mmapped(oldp))
  {
#if HAVE_MREMAP
    newp = mremap_chunk(oldp, nb);
    if(newp) return chunk2mem(newp);
#endif
    /* Note the extra SIZE_SZ overhead. */
    if(oldsize - SIZE_SZ >= nb) return oldmem; /* do nothing */
    /* Must alloc, copy, free. */
    newmem = mALLOc(bytes);
    if (newmem == 0) return 0; /* propagate failure */
    MALLOC_COPY(newmem, oldmem, oldsize - 2*SIZE_SZ);
    munmap_chunk(oldp);
    return newmem;
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
21f1d7b4:	e51b206c 	ldr	r2, [fp, #-108]
21f1d7b8:	e51b3074 	ldr	r3, [fp, #-116]
21f1d7bc:	e1520003 	cmp	r2, r3
21f1d7c0:	aa0002c9 	bge	21f1e2ec <realloc+0xbe8>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
21f1d7c4:	e51b2070 	ldr	r2, [fp, #-112]
21f1d7c8:	e51b306c 	ldr	r3, [fp, #-108]
21f1d7cc:	e0823003 	add	r3, r2, r3
21f1d7d0:	e50b305c 	str	r3, [fp, #-92]
    if (next == top || !inuse(next))
21f1d7d4:	e59f3c0c 	ldr	r3, [pc, #3084]	; 21f1e3e8 <.text+0x1e3e8>
21f1d7d8:	e5932008 	ldr	r2, [r3, #8]
21f1d7dc:	e51b305c 	ldr	r3, [fp, #-92]
21f1d7e0:	e1520003 	cmp	r2, r3
21f1d7e4:	0a000009 	beq	21f1d810 <realloc+0x10c>
21f1d7e8:	e51b305c 	ldr	r3, [fp, #-92]
21f1d7ec:	e5933004 	ldr	r3, [r3, #4]
21f1d7f0:	e3c33001 	bic	r3, r3, #1	; 0x1
21f1d7f4:	e1a02003 	mov	r2, r3
21f1d7f8:	e51b305c 	ldr	r3, [fp, #-92]
21f1d7fc:	e0823003 	add	r3, r2, r3
21f1d800:	e5933004 	ldr	r3, [r3, #4]
21f1d804:	e2033001 	and	r3, r3, #1	; 0x1
21f1d808:	e3530000 	cmp	r3, #0	; 0x0
21f1d80c:	1a000043 	bne	21f1d920 <realloc+0x21c>
    {
      nextsize = chunksize(next);
21f1d810:	e51b305c 	ldr	r3, [fp, #-92]
21f1d814:	e5933004 	ldr	r3, [r3, #4]
21f1d818:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1d81c:	e50b3058 	str	r3, [fp, #-88]

      /* Forward into top only if a remainder */
      if (next == top)
21f1d820:	e59f3bc0 	ldr	r3, [pc, #3008]	; 21f1e3e8 <.text+0x1e3e8>
21f1d824:	e5932008 	ldr	r2, [r3, #8]
21f1d828:	e51b305c 	ldr	r3, [fp, #-92]
21f1d82c:	e1520003 	cmp	r2, r3
21f1d830:	1a000022 	bne	21f1d8c0 <realloc+0x1bc>
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
21f1d834:	e51b2058 	ldr	r2, [fp, #-88]
21f1d838:	e51b3064 	ldr	r3, [fp, #-100]
21f1d83c:	e0823003 	add	r3, r2, r3
21f1d840:	e1a02003 	mov	r2, r3
21f1d844:	e51b3074 	ldr	r3, [fp, #-116]
21f1d848:	e2833010 	add	r3, r3, #16	; 0x10
21f1d84c:	e1520003 	cmp	r2, r3
21f1d850:	ba000036 	blt	21f1d930 <realloc+0x22c>
	{
	  newsize += nextsize;
21f1d854:	e51b2064 	ldr	r2, [fp, #-100]
21f1d858:	e51b3058 	ldr	r3, [fp, #-88]
21f1d85c:	e0823003 	add	r3, r2, r3
21f1d860:	e50b3064 	str	r3, [fp, #-100]
	  top = chunk_at_offset(oldp, nb);
21f1d864:	e59f1b7c 	ldr	r1, [pc, #2940]	; 21f1e3e8 <.text+0x1e3e8>
21f1d868:	e51b2070 	ldr	r2, [fp, #-112]
21f1d86c:	e51b3074 	ldr	r3, [fp, #-116]
21f1d870:	e0823003 	add	r3, r2, r3
21f1d874:	e5813008 	str	r3, [r1, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
21f1d878:	e59f3b68 	ldr	r3, [pc, #2920]	; 21f1e3e8 <.text+0x1e3e8>
21f1d87c:	e5931008 	ldr	r1, [r3, #8]
21f1d880:	e51b2064 	ldr	r2, [fp, #-100]
21f1d884:	e51b3074 	ldr	r3, [fp, #-116]
21f1d888:	e0633002 	rsb	r3, r3, r2
21f1d88c:	e3833001 	orr	r3, r3, #1	; 0x1
21f1d890:	e5813004 	str	r3, [r1, #4]
	  set_head_size(oldp, nb);
21f1d894:	e51b3070 	ldr	r3, [fp, #-112]
21f1d898:	e5933004 	ldr	r3, [r3, #4]
21f1d89c:	e2032001 	and	r2, r3, #1	; 0x1
21f1d8a0:	e51b3074 	ldr	r3, [fp, #-116]
21f1d8a4:	e1822003 	orr	r2, r2, r3
21f1d8a8:	e51b3070 	ldr	r3, [fp, #-112]
21f1d8ac:	e5832004 	str	r2, [r3, #4]
	  return chunk2mem(oldp);
21f1d8b0:	e51b3070 	ldr	r3, [fp, #-112]
21f1d8b4:	e2833008 	add	r3, r3, #8	; 0x8
21f1d8b8:	e50b3084 	str	r3, [fp, #-132]
21f1d8bc:	ea0002c5 	b	21f1e3d8 <realloc+0xcd4>
	}
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
21f1d8c0:	e51b2058 	ldr	r2, [fp, #-88]
21f1d8c4:	e51b3064 	ldr	r3, [fp, #-100]
21f1d8c8:	e0823003 	add	r3, r2, r3
21f1d8cc:	e1a02003 	mov	r2, r3
21f1d8d0:	e51b3074 	ldr	r3, [fp, #-116]
21f1d8d4:	e1520003 	cmp	r2, r3
21f1d8d8:	ba000014 	blt	21f1d930 <realloc+0x22c>
      {
	unlink(next, bck, fwd);
21f1d8dc:	e51b305c 	ldr	r3, [fp, #-92]
21f1d8e0:	e593300c 	ldr	r3, [r3, #12]
21f1d8e4:	e50b3044 	str	r3, [fp, #-68]
21f1d8e8:	e51b305c 	ldr	r3, [fp, #-92]
21f1d8ec:	e5933008 	ldr	r3, [r3, #8]
21f1d8f0:	e50b3040 	str	r3, [fp, #-64]
21f1d8f4:	e51b2040 	ldr	r2, [fp, #-64]
21f1d8f8:	e51b3044 	ldr	r3, [fp, #-68]
21f1d8fc:	e582300c 	str	r3, [r2, #12]
21f1d900:	e51b2044 	ldr	r2, [fp, #-68]
21f1d904:	e51b3040 	ldr	r3, [fp, #-64]
21f1d908:	e5823008 	str	r3, [r2, #8]
	newsize  += nextsize;
21f1d90c:	e51b2064 	ldr	r2, [fp, #-100]
21f1d910:	e51b3058 	ldr	r3, [fp, #-88]
21f1d914:	e0823003 	add	r3, r2, r3
21f1d918:	e50b3064 	str	r3, [fp, #-100]
	goto split;
21f1d91c:	ea000272 	b	21f1e2ec <realloc+0xbe8>
      }
    }
    else
    {
      next = 0;
21f1d920:	e3a03000 	mov	r3, #0	; 0x0
21f1d924:	e50b305c 	str	r3, [fp, #-92]
      nextsize = 0;
21f1d928:	e3a03000 	mov	r3, #0	; 0x0
21f1d92c:	e50b3058 	str	r3, [fp, #-88]
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
21f1d930:	e51b3070 	ldr	r3, [fp, #-112]
21f1d934:	e5933004 	ldr	r3, [r3, #4]
21f1d938:	e2033001 	and	r3, r3, #1	; 0x1
21f1d93c:	e3530000 	cmp	r3, #0	; 0x0
21f1d940:	1a0001d8 	bne	21f1e0a8 <realloc+0x9a4>
    {
      prev = prev_chunk(oldp);
21f1d944:	e51b2070 	ldr	r2, [fp, #-112]
21f1d948:	e51b3070 	ldr	r3, [fp, #-112]
21f1d94c:	e5933000 	ldr	r3, [r3]
21f1d950:	e0633002 	rsb	r3, r3, r2
21f1d954:	e50b3054 	str	r3, [fp, #-84]
      prevsize = chunksize(prev);
21f1d958:	e51b3054 	ldr	r3, [fp, #-84]
21f1d95c:	e5933004 	ldr	r3, [r3, #4]
21f1d960:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1d964:	e50b3050 	str	r3, [fp, #-80]

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
21f1d968:	e51b305c 	ldr	r3, [fp, #-92]
21f1d96c:	e3530000 	cmp	r3, #0	; 0x0
21f1d970:	0a000140 	beq	21f1de78 <realloc+0x774>
      {
	/* into top */
	if (next == top)
21f1d974:	e59f3a6c 	ldr	r3, [pc, #2668]	; 21f1e3e8 <.text+0x1e3e8>
21f1d978:	e5932008 	ldr	r2, [r3, #8]
21f1d97c:	e51b305c 	ldr	r3, [fp, #-92]
21f1d980:	e1520003 	cmp	r2, r3
21f1d984:	1a0000a2 	bne	21f1dc14 <realloc+0x510>
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
21f1d988:	e51b2058 	ldr	r2, [fp, #-88]
21f1d98c:	e51b3050 	ldr	r3, [fp, #-80]
21f1d990:	e0822003 	add	r2, r2, r3
21f1d994:	e51b3064 	ldr	r3, [fp, #-100]
21f1d998:	e0823003 	add	r3, r2, r3
21f1d99c:	e1a02003 	mov	r2, r3
21f1d9a0:	e51b3074 	ldr	r3, [fp, #-116]
21f1d9a4:	e2833010 	add	r3, r3, #16	; 0x10
21f1d9a8:	e1520003 	cmp	r2, r3
21f1d9ac:	ba000131 	blt	21f1de78 <realloc+0x774>
	  {
	    unlink(prev, bck, fwd);
21f1d9b0:	e51b3054 	ldr	r3, [fp, #-84]
21f1d9b4:	e593300c 	ldr	r3, [r3, #12]
21f1d9b8:	e50b3044 	str	r3, [fp, #-68]
21f1d9bc:	e51b3054 	ldr	r3, [fp, #-84]
21f1d9c0:	e5933008 	ldr	r3, [r3, #8]
21f1d9c4:	e50b3040 	str	r3, [fp, #-64]
21f1d9c8:	e51b2040 	ldr	r2, [fp, #-64]
21f1d9cc:	e51b3044 	ldr	r3, [fp, #-68]
21f1d9d0:	e582300c 	str	r3, [r2, #12]
21f1d9d4:	e51b2044 	ldr	r2, [fp, #-68]
21f1d9d8:	e51b3040 	ldr	r3, [fp, #-64]
21f1d9dc:	e5823008 	str	r3, [r2, #8]
	    newp = prev;
21f1d9e0:	e51b3054 	ldr	r3, [fp, #-84]
21f1d9e4:	e50b3068 	str	r3, [fp, #-104]
	    newsize += prevsize + nextsize;
21f1d9e8:	e51b2050 	ldr	r2, [fp, #-80]
21f1d9ec:	e51b3058 	ldr	r3, [fp, #-88]
21f1d9f0:	e0822003 	add	r2, r2, r3
21f1d9f4:	e51b3064 	ldr	r3, [fp, #-100]
21f1d9f8:	e0833002 	add	r3, r3, r2
21f1d9fc:	e50b3064 	str	r3, [fp, #-100]
	    newmem = chunk2mem(newp);
21f1da00:	e51b3068 	ldr	r3, [fp, #-104]
21f1da04:	e2833008 	add	r3, r3, #8	; 0x8
21f1da08:	e50b3060 	str	r3, [fp, #-96]
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
21f1da0c:	e51b306c 	ldr	r3, [fp, #-108]
21f1da10:	e2433004 	sub	r3, r3, #4	; 0x4
21f1da14:	e50b303c 	str	r3, [fp, #-60]
21f1da18:	e51b303c 	ldr	r3, [fp, #-60]
21f1da1c:	e3530024 	cmp	r3, #36	; 0x24
21f1da20:	8a000061 	bhi	21f1dbac <realloc+0x4a8>
21f1da24:	e51b3078 	ldr	r3, [fp, #-120]
21f1da28:	e50b3038 	str	r3, [fp, #-56]
21f1da2c:	e51b3060 	ldr	r3, [fp, #-96]
21f1da30:	e50b3034 	str	r3, [fp, #-52]
21f1da34:	e51b303c 	ldr	r3, [fp, #-60]
21f1da38:	e3530013 	cmp	r3, #19	; 0x13
21f1da3c:	9a000041 	bls	21f1db48 <realloc+0x444>
21f1da40:	e51b3038 	ldr	r3, [fp, #-56]
21f1da44:	e5932000 	ldr	r2, [r3]
21f1da48:	e51b3034 	ldr	r3, [fp, #-52]
21f1da4c:	e5832000 	str	r2, [r3]
21f1da50:	e51b3034 	ldr	r3, [fp, #-52]
21f1da54:	e2833004 	add	r3, r3, #4	; 0x4
21f1da58:	e50b3034 	str	r3, [fp, #-52]
21f1da5c:	e51b3038 	ldr	r3, [fp, #-56]
21f1da60:	e2833004 	add	r3, r3, #4	; 0x4
21f1da64:	e50b3038 	str	r3, [fp, #-56]
21f1da68:	e51b3038 	ldr	r3, [fp, #-56]
21f1da6c:	e5932000 	ldr	r2, [r3]
21f1da70:	e51b3034 	ldr	r3, [fp, #-52]
21f1da74:	e5832000 	str	r2, [r3]
21f1da78:	e51b3034 	ldr	r3, [fp, #-52]
21f1da7c:	e2833004 	add	r3, r3, #4	; 0x4
21f1da80:	e50b3034 	str	r3, [fp, #-52]
21f1da84:	e51b3038 	ldr	r3, [fp, #-56]
21f1da88:	e2833004 	add	r3, r3, #4	; 0x4
21f1da8c:	e50b3038 	str	r3, [fp, #-56]
21f1da90:	e51b303c 	ldr	r3, [fp, #-60]
21f1da94:	e353001b 	cmp	r3, #27	; 0x1b
21f1da98:	9a00002a 	bls	21f1db48 <realloc+0x444>
21f1da9c:	e51b3038 	ldr	r3, [fp, #-56]
21f1daa0:	e5932000 	ldr	r2, [r3]
21f1daa4:	e51b3034 	ldr	r3, [fp, #-52]
21f1daa8:	e5832000 	str	r2, [r3]
21f1daac:	e51b3034 	ldr	r3, [fp, #-52]
21f1dab0:	e2833004 	add	r3, r3, #4	; 0x4
21f1dab4:	e50b3034 	str	r3, [fp, #-52]
21f1dab8:	e51b3038 	ldr	r3, [fp, #-56]
21f1dabc:	e2833004 	add	r3, r3, #4	; 0x4
21f1dac0:	e50b3038 	str	r3, [fp, #-56]
21f1dac4:	e51b3038 	ldr	r3, [fp, #-56]
21f1dac8:	e5932000 	ldr	r2, [r3]
21f1dacc:	e51b3034 	ldr	r3, [fp, #-52]
21f1dad0:	e5832000 	str	r2, [r3]
21f1dad4:	e51b3034 	ldr	r3, [fp, #-52]
21f1dad8:	e2833004 	add	r3, r3, #4	; 0x4
21f1dadc:	e50b3034 	str	r3, [fp, #-52]
21f1dae0:	e51b3038 	ldr	r3, [fp, #-56]
21f1dae4:	e2833004 	add	r3, r3, #4	; 0x4
21f1dae8:	e50b3038 	str	r3, [fp, #-56]
21f1daec:	e51b303c 	ldr	r3, [fp, #-60]
21f1daf0:	e3530023 	cmp	r3, #35	; 0x23
21f1daf4:	9a000013 	bls	21f1db48 <realloc+0x444>
21f1daf8:	e51b3038 	ldr	r3, [fp, #-56]
21f1dafc:	e5932000 	ldr	r2, [r3]
21f1db00:	e51b3034 	ldr	r3, [fp, #-52]
21f1db04:	e5832000 	str	r2, [r3]
21f1db08:	e51b3034 	ldr	r3, [fp, #-52]
21f1db0c:	e2833004 	add	r3, r3, #4	; 0x4
21f1db10:	e50b3034 	str	r3, [fp, #-52]
21f1db14:	e51b3038 	ldr	r3, [fp, #-56]
21f1db18:	e2833004 	add	r3, r3, #4	; 0x4
21f1db1c:	e50b3038 	str	r3, [fp, #-56]
21f1db20:	e51b3038 	ldr	r3, [fp, #-56]
21f1db24:	e5932000 	ldr	r2, [r3]
21f1db28:	e51b3034 	ldr	r3, [fp, #-52]
21f1db2c:	e5832000 	str	r2, [r3]
21f1db30:	e51b3034 	ldr	r3, [fp, #-52]
21f1db34:	e2833004 	add	r3, r3, #4	; 0x4
21f1db38:	e50b3034 	str	r3, [fp, #-52]
21f1db3c:	e51b3038 	ldr	r3, [fp, #-56]
21f1db40:	e2833004 	add	r3, r3, #4	; 0x4
21f1db44:	e50b3038 	str	r3, [fp, #-56]
21f1db48:	e51b3038 	ldr	r3, [fp, #-56]
21f1db4c:	e5932000 	ldr	r2, [r3]
21f1db50:	e51b3034 	ldr	r3, [fp, #-52]
21f1db54:	e5832000 	str	r2, [r3]
21f1db58:	e51b3034 	ldr	r3, [fp, #-52]
21f1db5c:	e2833004 	add	r3, r3, #4	; 0x4
21f1db60:	e50b3034 	str	r3, [fp, #-52]
21f1db64:	e51b3038 	ldr	r3, [fp, #-56]
21f1db68:	e2833004 	add	r3, r3, #4	; 0x4
21f1db6c:	e50b3038 	str	r3, [fp, #-56]
21f1db70:	e51b3038 	ldr	r3, [fp, #-56]
21f1db74:	e5932000 	ldr	r2, [r3]
21f1db78:	e51b3034 	ldr	r3, [fp, #-52]
21f1db7c:	e5832000 	str	r2, [r3]
21f1db80:	e51b3034 	ldr	r3, [fp, #-52]
21f1db84:	e2833004 	add	r3, r3, #4	; 0x4
21f1db88:	e50b3034 	str	r3, [fp, #-52]
21f1db8c:	e51b3038 	ldr	r3, [fp, #-56]
21f1db90:	e2833004 	add	r3, r3, #4	; 0x4
21f1db94:	e50b3038 	str	r3, [fp, #-56]
21f1db98:	e51b3038 	ldr	r3, [fp, #-56]
21f1db9c:	e5932000 	ldr	r2, [r3]
21f1dba0:	e51b3034 	ldr	r3, [fp, #-52]
21f1dba4:	e5832000 	str	r2, [r3]
21f1dba8:	ea000003 	b	21f1dbbc <realloc+0x4b8>
21f1dbac:	e51b0060 	ldr	r0, [fp, #-96]
21f1dbb0:	e51b1078 	ldr	r1, [fp, #-120]
21f1dbb4:	e51b203c 	ldr	r2, [fp, #-60]
21f1dbb8:	eb001583 	bl	21f231cc <memcpy>
	    top = chunk_at_offset(newp, nb);
21f1dbbc:	e59f1824 	ldr	r1, [pc, #2084]	; 21f1e3e8 <.text+0x1e3e8>
21f1dbc0:	e51b2068 	ldr	r2, [fp, #-104]
21f1dbc4:	e51b3074 	ldr	r3, [fp, #-116]
21f1dbc8:	e0823003 	add	r3, r2, r3
21f1dbcc:	e5813008 	str	r3, [r1, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
21f1dbd0:	e59f3810 	ldr	r3, [pc, #2064]	; 21f1e3e8 <.text+0x1e3e8>
21f1dbd4:	e5931008 	ldr	r1, [r3, #8]
21f1dbd8:	e51b2064 	ldr	r2, [fp, #-100]
21f1dbdc:	e51b3074 	ldr	r3, [fp, #-116]
21f1dbe0:	e0633002 	rsb	r3, r3, r2
21f1dbe4:	e3833001 	orr	r3, r3, #1	; 0x1
21f1dbe8:	e5813004 	str	r3, [r1, #4]
	    set_head_size(newp, nb);
21f1dbec:	e51b3068 	ldr	r3, [fp, #-104]
21f1dbf0:	e5933004 	ldr	r3, [r3, #4]
21f1dbf4:	e2032001 	and	r2, r3, #1	; 0x1
21f1dbf8:	e51b3074 	ldr	r3, [fp, #-116]
21f1dbfc:	e1822003 	orr	r2, r2, r3
21f1dc00:	e51b3068 	ldr	r3, [fp, #-104]
21f1dc04:	e5832004 	str	r2, [r3, #4]
	    return newmem;
21f1dc08:	e51b3060 	ldr	r3, [fp, #-96]
21f1dc0c:	e50b3084 	str	r3, [fp, #-132]
21f1dc10:	ea0001f0 	b	21f1e3d8 <realloc+0xcd4>
	  }
	}

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
21f1dc14:	e51b2058 	ldr	r2, [fp, #-88]
21f1dc18:	e51b3050 	ldr	r3, [fp, #-80]
21f1dc1c:	e0822003 	add	r2, r2, r3
21f1dc20:	e51b3064 	ldr	r3, [fp, #-100]
21f1dc24:	e0823003 	add	r3, r2, r3
21f1dc28:	e1a02003 	mov	r2, r3
21f1dc2c:	e51b3074 	ldr	r3, [fp, #-116]
21f1dc30:	e1520003 	cmp	r2, r3
21f1dc34:	ba00008f 	blt	21f1de78 <realloc+0x774>
	{
	  unlink(next, bck, fwd);
21f1dc38:	e51b305c 	ldr	r3, [fp, #-92]
21f1dc3c:	e593300c 	ldr	r3, [r3, #12]
21f1dc40:	e50b3044 	str	r3, [fp, #-68]
21f1dc44:	e51b305c 	ldr	r3, [fp, #-92]
21f1dc48:	e5933008 	ldr	r3, [r3, #8]
21f1dc4c:	e50b3040 	str	r3, [fp, #-64]
21f1dc50:	e51b2040 	ldr	r2, [fp, #-64]
21f1dc54:	e51b3044 	ldr	r3, [fp, #-68]
21f1dc58:	e582300c 	str	r3, [r2, #12]
21f1dc5c:	e51b2044 	ldr	r2, [fp, #-68]
21f1dc60:	e51b3040 	ldr	r3, [fp, #-64]
21f1dc64:	e5823008 	str	r3, [r2, #8]
	  unlink(prev, bck, fwd);
21f1dc68:	e51b3054 	ldr	r3, [fp, #-84]
21f1dc6c:	e593300c 	ldr	r3, [r3, #12]
21f1dc70:	e50b3044 	str	r3, [fp, #-68]
21f1dc74:	e51b3054 	ldr	r3, [fp, #-84]
21f1dc78:	e5933008 	ldr	r3, [r3, #8]
21f1dc7c:	e50b3040 	str	r3, [fp, #-64]
21f1dc80:	e51b2040 	ldr	r2, [fp, #-64]
21f1dc84:	e51b3044 	ldr	r3, [fp, #-68]
21f1dc88:	e582300c 	str	r3, [r2, #12]
21f1dc8c:	e51b2044 	ldr	r2, [fp, #-68]
21f1dc90:	e51b3040 	ldr	r3, [fp, #-64]
21f1dc94:	e5823008 	str	r3, [r2, #8]
	  newp = prev;
21f1dc98:	e51b3054 	ldr	r3, [fp, #-84]
21f1dc9c:	e50b3068 	str	r3, [fp, #-104]
	  newsize += nextsize + prevsize;
21f1dca0:	e51b2058 	ldr	r2, [fp, #-88]
21f1dca4:	e51b3050 	ldr	r3, [fp, #-80]
21f1dca8:	e0822003 	add	r2, r2, r3
21f1dcac:	e51b3064 	ldr	r3, [fp, #-100]
21f1dcb0:	e0833002 	add	r3, r3, r2
21f1dcb4:	e50b3064 	str	r3, [fp, #-100]
	  newmem = chunk2mem(newp);
21f1dcb8:	e51b3068 	ldr	r3, [fp, #-104]
21f1dcbc:	e2833008 	add	r3, r3, #8	; 0x8
21f1dcc0:	e50b3060 	str	r3, [fp, #-96]
	  MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
21f1dcc4:	e51b306c 	ldr	r3, [fp, #-108]
21f1dcc8:	e2433004 	sub	r3, r3, #4	; 0x4
21f1dccc:	e50b3030 	str	r3, [fp, #-48]
21f1dcd0:	e51b3030 	ldr	r3, [fp, #-48]
21f1dcd4:	e3530024 	cmp	r3, #36	; 0x24
21f1dcd8:	8a000061 	bhi	21f1de64 <realloc+0x760>
21f1dcdc:	e51b3078 	ldr	r3, [fp, #-120]
21f1dce0:	e50b302c 	str	r3, [fp, #-44]
21f1dce4:	e51b3060 	ldr	r3, [fp, #-96]
21f1dce8:	e50b3028 	str	r3, [fp, #-40]
21f1dcec:	e51b3030 	ldr	r3, [fp, #-48]
21f1dcf0:	e3530013 	cmp	r3, #19	; 0x13
21f1dcf4:	9a000041 	bls	21f1de00 <realloc+0x6fc>
21f1dcf8:	e51b302c 	ldr	r3, [fp, #-44]
21f1dcfc:	e5932000 	ldr	r2, [r3]
21f1dd00:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd04:	e5832000 	str	r2, [r3]
21f1dd08:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd0c:	e2833004 	add	r3, r3, #4	; 0x4
21f1dd10:	e50b3028 	str	r3, [fp, #-40]
21f1dd14:	e51b302c 	ldr	r3, [fp, #-44]
21f1dd18:	e2833004 	add	r3, r3, #4	; 0x4
21f1dd1c:	e50b302c 	str	r3, [fp, #-44]
21f1dd20:	e51b302c 	ldr	r3, [fp, #-44]
21f1dd24:	e5932000 	ldr	r2, [r3]
21f1dd28:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd2c:	e5832000 	str	r2, [r3]
21f1dd30:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd34:	e2833004 	add	r3, r3, #4	; 0x4
21f1dd38:	e50b3028 	str	r3, [fp, #-40]
21f1dd3c:	e51b302c 	ldr	r3, [fp, #-44]
21f1dd40:	e2833004 	add	r3, r3, #4	; 0x4
21f1dd44:	e50b302c 	str	r3, [fp, #-44]
21f1dd48:	e51b3030 	ldr	r3, [fp, #-48]
21f1dd4c:	e353001b 	cmp	r3, #27	; 0x1b
21f1dd50:	9a00002a 	bls	21f1de00 <realloc+0x6fc>
21f1dd54:	e51b302c 	ldr	r3, [fp, #-44]
21f1dd58:	e5932000 	ldr	r2, [r3]
21f1dd5c:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd60:	e5832000 	str	r2, [r3]
21f1dd64:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd68:	e2833004 	add	r3, r3, #4	; 0x4
21f1dd6c:	e50b3028 	str	r3, [fp, #-40]
21f1dd70:	e51b302c 	ldr	r3, [fp, #-44]
21f1dd74:	e2833004 	add	r3, r3, #4	; 0x4
21f1dd78:	e50b302c 	str	r3, [fp, #-44]
21f1dd7c:	e51b302c 	ldr	r3, [fp, #-44]
21f1dd80:	e5932000 	ldr	r2, [r3]
21f1dd84:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd88:	e5832000 	str	r2, [r3]
21f1dd8c:	e51b3028 	ldr	r3, [fp, #-40]
21f1dd90:	e2833004 	add	r3, r3, #4	; 0x4
21f1dd94:	e50b3028 	str	r3, [fp, #-40]
21f1dd98:	e51b302c 	ldr	r3, [fp, #-44]
21f1dd9c:	e2833004 	add	r3, r3, #4	; 0x4
21f1dda0:	e50b302c 	str	r3, [fp, #-44]
21f1dda4:	e51b3030 	ldr	r3, [fp, #-48]
21f1dda8:	e3530023 	cmp	r3, #35	; 0x23
21f1ddac:	9a000013 	bls	21f1de00 <realloc+0x6fc>
21f1ddb0:	e51b302c 	ldr	r3, [fp, #-44]
21f1ddb4:	e5932000 	ldr	r2, [r3]
21f1ddb8:	e51b3028 	ldr	r3, [fp, #-40]
21f1ddbc:	e5832000 	str	r2, [r3]
21f1ddc0:	e51b3028 	ldr	r3, [fp, #-40]
21f1ddc4:	e2833004 	add	r3, r3, #4	; 0x4
21f1ddc8:	e50b3028 	str	r3, [fp, #-40]
21f1ddcc:	e51b302c 	ldr	r3, [fp, #-44]
21f1ddd0:	e2833004 	add	r3, r3, #4	; 0x4
21f1ddd4:	e50b302c 	str	r3, [fp, #-44]
21f1ddd8:	e51b302c 	ldr	r3, [fp, #-44]
21f1dddc:	e5932000 	ldr	r2, [r3]
21f1dde0:	e51b3028 	ldr	r3, [fp, #-40]
21f1dde4:	e5832000 	str	r2, [r3]
21f1dde8:	e51b3028 	ldr	r3, [fp, #-40]
21f1ddec:	e2833004 	add	r3, r3, #4	; 0x4
21f1ddf0:	e50b3028 	str	r3, [fp, #-40]
21f1ddf4:	e51b302c 	ldr	r3, [fp, #-44]
21f1ddf8:	e2833004 	add	r3, r3, #4	; 0x4
21f1ddfc:	e50b302c 	str	r3, [fp, #-44]
21f1de00:	e51b302c 	ldr	r3, [fp, #-44]
21f1de04:	e5932000 	ldr	r2, [r3]
21f1de08:	e51b3028 	ldr	r3, [fp, #-40]
21f1de0c:	e5832000 	str	r2, [r3]
21f1de10:	e51b3028 	ldr	r3, [fp, #-40]
21f1de14:	e2833004 	add	r3, r3, #4	; 0x4
21f1de18:	e50b3028 	str	r3, [fp, #-40]
21f1de1c:	e51b302c 	ldr	r3, [fp, #-44]
21f1de20:	e2833004 	add	r3, r3, #4	; 0x4
21f1de24:	e50b302c 	str	r3, [fp, #-44]
21f1de28:	e51b302c 	ldr	r3, [fp, #-44]
21f1de2c:	e5932000 	ldr	r2, [r3]
21f1de30:	e51b3028 	ldr	r3, [fp, #-40]
21f1de34:	e5832000 	str	r2, [r3]
21f1de38:	e51b3028 	ldr	r3, [fp, #-40]
21f1de3c:	e2833004 	add	r3, r3, #4	; 0x4
21f1de40:	e50b3028 	str	r3, [fp, #-40]
21f1de44:	e51b302c 	ldr	r3, [fp, #-44]
21f1de48:	e2833004 	add	r3, r3, #4	; 0x4
21f1de4c:	e50b302c 	str	r3, [fp, #-44]
21f1de50:	e51b302c 	ldr	r3, [fp, #-44]
21f1de54:	e5932000 	ldr	r2, [r3]
21f1de58:	e51b3028 	ldr	r3, [fp, #-40]
21f1de5c:	e5832000 	str	r2, [r3]
21f1de60:	ea000121 	b	21f1e2ec <realloc+0xbe8>
21f1de64:	e51b0060 	ldr	r0, [fp, #-96]
21f1de68:	e51b1078 	ldr	r1, [fp, #-120]
21f1de6c:	e51b2030 	ldr	r2, [fp, #-48]
21f1de70:	eb0014d5 	bl	21f231cc <memcpy>
21f1de74:	ea00011c 	b	21f1e2ec <realloc+0xbe8>
	  goto split;
	}
      }

      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
21f1de78:	e51b3054 	ldr	r3, [fp, #-84]
21f1de7c:	e3530000 	cmp	r3, #0	; 0x0
21f1de80:	0a000088 	beq	21f1e0a8 <realloc+0x9a4>
21f1de84:	e51b2050 	ldr	r2, [fp, #-80]
21f1de88:	e51b3064 	ldr	r3, [fp, #-100]
21f1de8c:	e0823003 	add	r3, r2, r3
21f1de90:	e1a02003 	mov	r2, r3
21f1de94:	e51b3074 	ldr	r3, [fp, #-116]
21f1de98:	e1520003 	cmp	r2, r3
21f1de9c:	ba000081 	blt	21f1e0a8 <realloc+0x9a4>
      {
	unlink(prev, bck, fwd);
21f1dea0:	e51b3054 	ldr	r3, [fp, #-84]
21f1dea4:	e593300c 	ldr	r3, [r3, #12]
21f1dea8:	e50b3044 	str	r3, [fp, #-68]
21f1deac:	e51b3054 	ldr	r3, [fp, #-84]
21f1deb0:	e5933008 	ldr	r3, [r3, #8]
21f1deb4:	e50b3040 	str	r3, [fp, #-64]
21f1deb8:	e51b2040 	ldr	r2, [fp, #-64]
21f1debc:	e51b3044 	ldr	r3, [fp, #-68]
21f1dec0:	e582300c 	str	r3, [r2, #12]
21f1dec4:	e51b2044 	ldr	r2, [fp, #-68]
21f1dec8:	e51b3040 	ldr	r3, [fp, #-64]
21f1decc:	e5823008 	str	r3, [r2, #8]
	newp = prev;
21f1ded0:	e51b3054 	ldr	r3, [fp, #-84]
21f1ded4:	e50b3068 	str	r3, [fp, #-104]
	newsize += prevsize;
21f1ded8:	e51b2064 	ldr	r2, [fp, #-100]
21f1dedc:	e51b3050 	ldr	r3, [fp, #-80]
21f1dee0:	e0823003 	add	r3, r2, r3
21f1dee4:	e50b3064 	str	r3, [fp, #-100]
	newmem = chunk2mem(newp);
21f1dee8:	e51b3068 	ldr	r3, [fp, #-104]
21f1deec:	e2833008 	add	r3, r3, #8	; 0x8
21f1def0:	e50b3060 	str	r3, [fp, #-96]
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
21f1def4:	e51b306c 	ldr	r3, [fp, #-108]
21f1def8:	e2433004 	sub	r3, r3, #4	; 0x4
21f1defc:	e50b3024 	str	r3, [fp, #-36]
21f1df00:	e51b3024 	ldr	r3, [fp, #-36]
21f1df04:	e3530024 	cmp	r3, #36	; 0x24
21f1df08:	8a000061 	bhi	21f1e094 <realloc+0x990>
21f1df0c:	e51b3078 	ldr	r3, [fp, #-120]
21f1df10:	e50b3020 	str	r3, [fp, #-32]
21f1df14:	e51b3060 	ldr	r3, [fp, #-96]
21f1df18:	e50b301c 	str	r3, [fp, #-28]
21f1df1c:	e51b3024 	ldr	r3, [fp, #-36]
21f1df20:	e3530013 	cmp	r3, #19	; 0x13
21f1df24:	9a000041 	bls	21f1e030 <realloc+0x92c>
21f1df28:	e51b3020 	ldr	r3, [fp, #-32]
21f1df2c:	e5932000 	ldr	r2, [r3]
21f1df30:	e51b301c 	ldr	r3, [fp, #-28]
21f1df34:	e5832000 	str	r2, [r3]
21f1df38:	e51b301c 	ldr	r3, [fp, #-28]
21f1df3c:	e2833004 	add	r3, r3, #4	; 0x4
21f1df40:	e50b301c 	str	r3, [fp, #-28]
21f1df44:	e51b3020 	ldr	r3, [fp, #-32]
21f1df48:	e2833004 	add	r3, r3, #4	; 0x4
21f1df4c:	e50b3020 	str	r3, [fp, #-32]
21f1df50:	e51b3020 	ldr	r3, [fp, #-32]
21f1df54:	e5932000 	ldr	r2, [r3]
21f1df58:	e51b301c 	ldr	r3, [fp, #-28]
21f1df5c:	e5832000 	str	r2, [r3]
21f1df60:	e51b301c 	ldr	r3, [fp, #-28]
21f1df64:	e2833004 	add	r3, r3, #4	; 0x4
21f1df68:	e50b301c 	str	r3, [fp, #-28]
21f1df6c:	e51b3020 	ldr	r3, [fp, #-32]
21f1df70:	e2833004 	add	r3, r3, #4	; 0x4
21f1df74:	e50b3020 	str	r3, [fp, #-32]
21f1df78:	e51b3024 	ldr	r3, [fp, #-36]
21f1df7c:	e353001b 	cmp	r3, #27	; 0x1b
21f1df80:	9a00002a 	bls	21f1e030 <realloc+0x92c>
21f1df84:	e51b3020 	ldr	r3, [fp, #-32]
21f1df88:	e5932000 	ldr	r2, [r3]
21f1df8c:	e51b301c 	ldr	r3, [fp, #-28]
21f1df90:	e5832000 	str	r2, [r3]
21f1df94:	e51b301c 	ldr	r3, [fp, #-28]
21f1df98:	e2833004 	add	r3, r3, #4	; 0x4
21f1df9c:	e50b301c 	str	r3, [fp, #-28]
21f1dfa0:	e51b3020 	ldr	r3, [fp, #-32]
21f1dfa4:	e2833004 	add	r3, r3, #4	; 0x4
21f1dfa8:	e50b3020 	str	r3, [fp, #-32]
21f1dfac:	e51b3020 	ldr	r3, [fp, #-32]
21f1dfb0:	e5932000 	ldr	r2, [r3]
21f1dfb4:	e51b301c 	ldr	r3, [fp, #-28]
21f1dfb8:	e5832000 	str	r2, [r3]
21f1dfbc:	e51b301c 	ldr	r3, [fp, #-28]
21f1dfc0:	e2833004 	add	r3, r3, #4	; 0x4
21f1dfc4:	e50b301c 	str	r3, [fp, #-28]
21f1dfc8:	e51b3020 	ldr	r3, [fp, #-32]
21f1dfcc:	e2833004 	add	r3, r3, #4	; 0x4
21f1dfd0:	e50b3020 	str	r3, [fp, #-32]
21f1dfd4:	e51b3024 	ldr	r3, [fp, #-36]
21f1dfd8:	e3530023 	cmp	r3, #35	; 0x23
21f1dfdc:	9a000013 	bls	21f1e030 <realloc+0x92c>
21f1dfe0:	e51b3020 	ldr	r3, [fp, #-32]
21f1dfe4:	e5932000 	ldr	r2, [r3]
21f1dfe8:	e51b301c 	ldr	r3, [fp, #-28]
21f1dfec:	e5832000 	str	r2, [r3]
21f1dff0:	e51b301c 	ldr	r3, [fp, #-28]
21f1dff4:	e2833004 	add	r3, r3, #4	; 0x4
21f1dff8:	e50b301c 	str	r3, [fp, #-28]
21f1dffc:	e51b3020 	ldr	r3, [fp, #-32]
21f1e000:	e2833004 	add	r3, r3, #4	; 0x4
21f1e004:	e50b3020 	str	r3, [fp, #-32]
21f1e008:	e51b3020 	ldr	r3, [fp, #-32]
21f1e00c:	e5932000 	ldr	r2, [r3]
21f1e010:	e51b301c 	ldr	r3, [fp, #-28]
21f1e014:	e5832000 	str	r2, [r3]
21f1e018:	e51b301c 	ldr	r3, [fp, #-28]
21f1e01c:	e2833004 	add	r3, r3, #4	; 0x4
21f1e020:	e50b301c 	str	r3, [fp, #-28]
21f1e024:	e51b3020 	ldr	r3, [fp, #-32]
21f1e028:	e2833004 	add	r3, r3, #4	; 0x4
21f1e02c:	e50b3020 	str	r3, [fp, #-32]
21f1e030:	e51b3020 	ldr	r3, [fp, #-32]
21f1e034:	e5932000 	ldr	r2, [r3]
21f1e038:	e51b301c 	ldr	r3, [fp, #-28]
21f1e03c:	e5832000 	str	r2, [r3]
21f1e040:	e51b301c 	ldr	r3, [fp, #-28]
21f1e044:	e2833004 	add	r3, r3, #4	; 0x4
21f1e048:	e50b301c 	str	r3, [fp, #-28]
21f1e04c:	e51b3020 	ldr	r3, [fp, #-32]
21f1e050:	e2833004 	add	r3, r3, #4	; 0x4
21f1e054:	e50b3020 	str	r3, [fp, #-32]
21f1e058:	e51b3020 	ldr	r3, [fp, #-32]
21f1e05c:	e5932000 	ldr	r2, [r3]
21f1e060:	e51b301c 	ldr	r3, [fp, #-28]
21f1e064:	e5832000 	str	r2, [r3]
21f1e068:	e51b301c 	ldr	r3, [fp, #-28]
21f1e06c:	e2833004 	add	r3, r3, #4	; 0x4
21f1e070:	e50b301c 	str	r3, [fp, #-28]
21f1e074:	e51b3020 	ldr	r3, [fp, #-32]
21f1e078:	e2833004 	add	r3, r3, #4	; 0x4
21f1e07c:	e50b3020 	str	r3, [fp, #-32]
21f1e080:	e51b3020 	ldr	r3, [fp, #-32]
21f1e084:	e5932000 	ldr	r2, [r3]
21f1e088:	e51b301c 	ldr	r3, [fp, #-28]
21f1e08c:	e5832000 	str	r2, [r3]
21f1e090:	ea000095 	b	21f1e2ec <realloc+0xbe8>
21f1e094:	e51b0060 	ldr	r0, [fp, #-96]
21f1e098:	e51b1078 	ldr	r1, [fp, #-120]
21f1e09c:	e51b2024 	ldr	r2, [fp, #-36]
21f1e0a0:	eb001449 	bl	21f231cc <memcpy>
21f1e0a4:	ea000090 	b	21f1e2ec <realloc+0xbe8>
	goto split;
      }
    }

    /* Must allocate */

    newmem = mALLOc (bytes);
21f1e0a8:	e51b007c 	ldr	r0, [fp, #-124]
21f1e0ac:	ebfff93d 	bl	21f1c5a8 <malloc>
21f1e0b0:	e1a03000 	mov	r3, r0
21f1e0b4:	e50b3060 	str	r3, [fp, #-96]

    if (newmem == 0)  /* propagate failure */
21f1e0b8:	e51b3060 	ldr	r3, [fp, #-96]
21f1e0bc:	e3530000 	cmp	r3, #0	; 0x0
21f1e0c0:	1a000002 	bne	21f1e0d0 <realloc+0x9cc>
      return 0;
21f1e0c4:	e3a03000 	mov	r3, #0	; 0x0
21f1e0c8:	e50b3084 	str	r3, [fp, #-132]
21f1e0cc:	ea0000c1 	b	21f1e3d8 <realloc+0xcd4>

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
21f1e0d0:	e51b3060 	ldr	r3, [fp, #-96]
21f1e0d4:	e2433008 	sub	r3, r3, #8	; 0x8
21f1e0d8:	e50b3068 	str	r3, [fp, #-104]
21f1e0dc:	e51b3070 	ldr	r3, [fp, #-112]
21f1e0e0:	e5933004 	ldr	r3, [r3, #4]
21f1e0e4:	e3c33001 	bic	r3, r3, #1	; 0x1
21f1e0e8:	e1a02003 	mov	r2, r3
21f1e0ec:	e51b3070 	ldr	r3, [fp, #-112]
21f1e0f0:	e0823003 	add	r3, r2, r3
21f1e0f4:	e1a02003 	mov	r2, r3
21f1e0f8:	e51b3068 	ldr	r3, [fp, #-104]
21f1e0fc:	e1530002 	cmp	r3, r2
21f1e100:	1a000008 	bne	21f1e128 <realloc+0xa24>
    {
      newsize += chunksize(newp);
21f1e104:	e51b3068 	ldr	r3, [fp, #-104]
21f1e108:	e5933004 	ldr	r3, [r3, #4]
21f1e10c:	e3c32003 	bic	r2, r3, #3	; 0x3
21f1e110:	e51b3064 	ldr	r3, [fp, #-100]
21f1e114:	e0833002 	add	r3, r3, r2
21f1e118:	e50b3064 	str	r3, [fp, #-100]
      newp = oldp;
21f1e11c:	e51b3070 	ldr	r3, [fp, #-112]
21f1e120:	e50b3068 	str	r3, [fp, #-104]
      goto split;
21f1e124:	ea000070 	b	21f1e2ec <realloc+0xbe8>
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
21f1e128:	e51b306c 	ldr	r3, [fp, #-108]
21f1e12c:	e2433004 	sub	r3, r3, #4	; 0x4
21f1e130:	e50b3018 	str	r3, [fp, #-24]
21f1e134:	e51b3018 	ldr	r3, [fp, #-24]
21f1e138:	e3530024 	cmp	r3, #36	; 0x24
21f1e13c:	8a000061 	bhi	21f1e2c8 <realloc+0xbc4>
21f1e140:	e51b3078 	ldr	r3, [fp, #-120]
21f1e144:	e50b3014 	str	r3, [fp, #-20]
21f1e148:	e51b3060 	ldr	r3, [fp, #-96]
21f1e14c:	e50b3010 	str	r3, [fp, #-16]
21f1e150:	e51b3018 	ldr	r3, [fp, #-24]
21f1e154:	e3530013 	cmp	r3, #19	; 0x13
21f1e158:	9a000041 	bls	21f1e264 <realloc+0xb60>
21f1e15c:	e51b3014 	ldr	r3, [fp, #-20]
21f1e160:	e5932000 	ldr	r2, [r3]
21f1e164:	e51b3010 	ldr	r3, [fp, #-16]
21f1e168:	e5832000 	str	r2, [r3]
21f1e16c:	e51b3010 	ldr	r3, [fp, #-16]
21f1e170:	e2833004 	add	r3, r3, #4	; 0x4
21f1e174:	e50b3010 	str	r3, [fp, #-16]
21f1e178:	e51b3014 	ldr	r3, [fp, #-20]
21f1e17c:	e2833004 	add	r3, r3, #4	; 0x4
21f1e180:	e50b3014 	str	r3, [fp, #-20]
21f1e184:	e51b3014 	ldr	r3, [fp, #-20]
21f1e188:	e5932000 	ldr	r2, [r3]
21f1e18c:	e51b3010 	ldr	r3, [fp, #-16]
21f1e190:	e5832000 	str	r2, [r3]
21f1e194:	e51b3010 	ldr	r3, [fp, #-16]
21f1e198:	e2833004 	add	r3, r3, #4	; 0x4
21f1e19c:	e50b3010 	str	r3, [fp, #-16]
21f1e1a0:	e51b3014 	ldr	r3, [fp, #-20]
21f1e1a4:	e2833004 	add	r3, r3, #4	; 0x4
21f1e1a8:	e50b3014 	str	r3, [fp, #-20]
21f1e1ac:	e51b3018 	ldr	r3, [fp, #-24]
21f1e1b0:	e353001b 	cmp	r3, #27	; 0x1b
21f1e1b4:	9a00002a 	bls	21f1e264 <realloc+0xb60>
21f1e1b8:	e51b3014 	ldr	r3, [fp, #-20]
21f1e1bc:	e5932000 	ldr	r2, [r3]
21f1e1c0:	e51b3010 	ldr	r3, [fp, #-16]
21f1e1c4:	e5832000 	str	r2, [r3]
21f1e1c8:	e51b3010 	ldr	r3, [fp, #-16]
21f1e1cc:	e2833004 	add	r3, r3, #4	; 0x4
21f1e1d0:	e50b3010 	str	r3, [fp, #-16]
21f1e1d4:	e51b3014 	ldr	r3, [fp, #-20]
21f1e1d8:	e2833004 	add	r3, r3, #4	; 0x4
21f1e1dc:	e50b3014 	str	r3, [fp, #-20]
21f1e1e0:	e51b3014 	ldr	r3, [fp, #-20]
21f1e1e4:	e5932000 	ldr	r2, [r3]
21f1e1e8:	e51b3010 	ldr	r3, [fp, #-16]
21f1e1ec:	e5832000 	str	r2, [r3]
21f1e1f0:	e51b3010 	ldr	r3, [fp, #-16]
21f1e1f4:	e2833004 	add	r3, r3, #4	; 0x4
21f1e1f8:	e50b3010 	str	r3, [fp, #-16]
21f1e1fc:	e51b3014 	ldr	r3, [fp, #-20]
21f1e200:	e2833004 	add	r3, r3, #4	; 0x4
21f1e204:	e50b3014 	str	r3, [fp, #-20]
21f1e208:	e51b3018 	ldr	r3, [fp, #-24]
21f1e20c:	e3530023 	cmp	r3, #35	; 0x23
21f1e210:	9a000013 	bls	21f1e264 <realloc+0xb60>
21f1e214:	e51b3014 	ldr	r3, [fp, #-20]
21f1e218:	e5932000 	ldr	r2, [r3]
21f1e21c:	e51b3010 	ldr	r3, [fp, #-16]
21f1e220:	e5832000 	str	r2, [r3]
21f1e224:	e51b3010 	ldr	r3, [fp, #-16]
21f1e228:	e2833004 	add	r3, r3, #4	; 0x4
21f1e22c:	e50b3010 	str	r3, [fp, #-16]
21f1e230:	e51b3014 	ldr	r3, [fp, #-20]
21f1e234:	e2833004 	add	r3, r3, #4	; 0x4
21f1e238:	e50b3014 	str	r3, [fp, #-20]
21f1e23c:	e51b3014 	ldr	r3, [fp, #-20]
21f1e240:	e5932000 	ldr	r2, [r3]
21f1e244:	e51b3010 	ldr	r3, [fp, #-16]
21f1e248:	e5832000 	str	r2, [r3]
21f1e24c:	e51b3010 	ldr	r3, [fp, #-16]
21f1e250:	e2833004 	add	r3, r3, #4	; 0x4
21f1e254:	e50b3010 	str	r3, [fp, #-16]
21f1e258:	e51b3014 	ldr	r3, [fp, #-20]
21f1e25c:	e2833004 	add	r3, r3, #4	; 0x4
21f1e260:	e50b3014 	str	r3, [fp, #-20]
21f1e264:	e51b3014 	ldr	r3, [fp, #-20]
21f1e268:	e5932000 	ldr	r2, [r3]
21f1e26c:	e51b3010 	ldr	r3, [fp, #-16]
21f1e270:	e5832000 	str	r2, [r3]
21f1e274:	e51b3010 	ldr	r3, [fp, #-16]
21f1e278:	e2833004 	add	r3, r3, #4	; 0x4
21f1e27c:	e50b3010 	str	r3, [fp, #-16]
21f1e280:	e51b3014 	ldr	r3, [fp, #-20]
21f1e284:	e2833004 	add	r3, r3, #4	; 0x4
21f1e288:	e50b3014 	str	r3, [fp, #-20]
21f1e28c:	e51b3014 	ldr	r3, [fp, #-20]
21f1e290:	e5932000 	ldr	r2, [r3]
21f1e294:	e51b3010 	ldr	r3, [fp, #-16]
21f1e298:	e5832000 	str	r2, [r3]
21f1e29c:	e51b3010 	ldr	r3, [fp, #-16]
21f1e2a0:	e2833004 	add	r3, r3, #4	; 0x4
21f1e2a4:	e50b3010 	str	r3, [fp, #-16]
21f1e2a8:	e51b3014 	ldr	r3, [fp, #-20]
21f1e2ac:	e2833004 	add	r3, r3, #4	; 0x4
21f1e2b0:	e50b3014 	str	r3, [fp, #-20]
21f1e2b4:	e51b3014 	ldr	r3, [fp, #-20]
21f1e2b8:	e5932000 	ldr	r2, [r3]
21f1e2bc:	e51b3010 	ldr	r3, [fp, #-16]
21f1e2c0:	e5832000 	str	r2, [r3]
21f1e2c4:	ea000003 	b	21f1e2d8 <realloc+0xbd4>
21f1e2c8:	e51b0060 	ldr	r0, [fp, #-96]
21f1e2cc:	e51b1078 	ldr	r1, [fp, #-120]
21f1e2d0:	e51b2018 	ldr	r2, [fp, #-24]
21f1e2d4:	eb0013bc 	bl	21f231cc <memcpy>
    fREe(oldmem);
21f1e2d8:	e51b0078 	ldr	r0, [fp, #-120]
21f1e2dc:	ebfffb9a 	bl	21f1d14c <free>
    return newmem;
21f1e2e0:	e51b3060 	ldr	r3, [fp, #-96]
21f1e2e4:	e50b3084 	str	r3, [fp, #-132]
21f1e2e8:	ea00003a 	b	21f1e3d8 <realloc+0xcd4>
  }


 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
21f1e2ec:	e51b3064 	ldr	r3, [fp, #-100]
21f1e2f0:	e51b2074 	ldr	r2, [fp, #-116]
21f1e2f4:	e0623003 	rsb	r3, r2, r3
21f1e2f8:	e353000f 	cmp	r3, #15	; 0xf
21f1e2fc:	9a000021 	bls	21f1e388 <realloc+0xc84>
  {
    remainder = chunk_at_offset(newp, nb);
21f1e300:	e51b2068 	ldr	r2, [fp, #-104]
21f1e304:	e51b3074 	ldr	r3, [fp, #-116]
21f1e308:	e0823003 	add	r3, r2, r3
21f1e30c:	e50b304c 	str	r3, [fp, #-76]
    remainder_size = newsize - nb;
21f1e310:	e51b2064 	ldr	r2, [fp, #-100]
21f1e314:	e51b3074 	ldr	r3, [fp, #-116]
21f1e318:	e0633002 	rsb	r3, r3, r2
21f1e31c:	e50b3048 	str	r3, [fp, #-72]
    set_head_size(newp, nb);
21f1e320:	e51b3068 	ldr	r3, [fp, #-104]
21f1e324:	e5933004 	ldr	r3, [r3, #4]
21f1e328:	e2032001 	and	r2, r3, #1	; 0x1
21f1e32c:	e51b3074 	ldr	r3, [fp, #-116]
21f1e330:	e1822003 	orr	r2, r2, r3
21f1e334:	e51b3068 	ldr	r3, [fp, #-104]
21f1e338:	e5832004 	str	r2, [r3, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
21f1e33c:	e51b3048 	ldr	r3, [fp, #-72]
21f1e340:	e3832001 	orr	r2, r3, #1	; 0x1
21f1e344:	e51b304c 	ldr	r3, [fp, #-76]
21f1e348:	e5832004 	str	r2, [r3, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
21f1e34c:	e51b204c 	ldr	r2, [fp, #-76]
21f1e350:	e51b3048 	ldr	r3, [fp, #-72]
21f1e354:	e0823003 	add	r3, r2, r3
21f1e358:	e1a01003 	mov	r1, r3
21f1e35c:	e51b204c 	ldr	r2, [fp, #-76]
21f1e360:	e51b3048 	ldr	r3, [fp, #-72]
21f1e364:	e0823003 	add	r3, r2, r3
21f1e368:	e5933004 	ldr	r3, [r3, #4]
21f1e36c:	e3833001 	orr	r3, r3, #1	; 0x1
21f1e370:	e5813004 	str	r3, [r1, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
21f1e374:	e51b304c 	ldr	r3, [fp, #-76]
21f1e378:	e2833008 	add	r3, r3, #8	; 0x8
21f1e37c:	e1a00003 	mov	r0, r3
21f1e380:	ebfffb71 	bl	21f1d14c <free>
21f1e384:	ea000010 	b	21f1e3cc <realloc+0xcc8>
  }
  else
  {
    set_head_size(newp, newsize);
21f1e388:	e51b3068 	ldr	r3, [fp, #-104]
21f1e38c:	e5933004 	ldr	r3, [r3, #4]
21f1e390:	e2032001 	and	r2, r3, #1	; 0x1
21f1e394:	e51b3064 	ldr	r3, [fp, #-100]
21f1e398:	e1822003 	orr	r2, r2, r3
21f1e39c:	e51b3068 	ldr	r3, [fp, #-104]
21f1e3a0:	e5832004 	str	r2, [r3, #4]
    set_inuse_bit_at_offset(newp, newsize);
21f1e3a4:	e51b2068 	ldr	r2, [fp, #-104]
21f1e3a8:	e51b3064 	ldr	r3, [fp, #-100]
21f1e3ac:	e0823003 	add	r3, r2, r3
21f1e3b0:	e1a01003 	mov	r1, r3
21f1e3b4:	e51b2068 	ldr	r2, [fp, #-104]
21f1e3b8:	e51b3064 	ldr	r3, [fp, #-100]
21f1e3bc:	e0823003 	add	r3, r2, r3
21f1e3c0:	e5933004 	ldr	r3, [r3, #4]
21f1e3c4:	e3833001 	orr	r3, r3, #1	; 0x1
21f1e3c8:	e5813004 	str	r3, [r1, #4]
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
21f1e3cc:	e51b3068 	ldr	r3, [fp, #-104]
21f1e3d0:	e2833008 	add	r3, r3, #8	; 0x8
21f1e3d4:	e50b3084 	str	r3, [fp, #-132]
21f1e3d8:	e51b3084 	ldr	r3, [fp, #-132]
}
21f1e3dc:	e1a00003 	mov	r0, r3
21f1e3e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1e3e4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1e3e8:	21f33590 	ldrcsb	r3, [r3, #80]!

21f1e3ec <memalign>:




/*

  memalign algorithm:

    memalign requests more than enough space from malloc, finds a spot
    within that chunk that meets the alignment request, and then
    possibly frees the leading and trailing space.

    The alignment argument must be a power of two. This property is not
    checked by memalign, so misuse may result in random runtime errors.

    8-byte alignment is guaranteed by normal malloc calls, so don't
    bother calling memalign with an argument of 8 or less.

    Overreliance on memalign is a sure way to fragment space.

*/


#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
{
21f1e3ec:	e1a0c00d 	mov	ip, sp
21f1e3f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1e3f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1e3f8:	e24dd034 	sub	sp, sp, #52	; 0x34
21f1e3fc:	e50b0034 	str	r0, [fp, #-52]
21f1e400:	e50b1038 	str	r1, [fp, #-56]
  INTERNAL_SIZE_T    nb;      /* padded  request size */
  char*     m;                /* memory returned by malloc call */
  mchunkptr p;                /* corresponding chunk */
  char*     brk;              /* alignment point within p */
  mchunkptr newp;             /* chunk to return */
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return 0;
21f1e404:	e51b3038 	ldr	r3, [fp, #-56]
21f1e408:	e3530000 	cmp	r3, #0	; 0x0
21f1e40c:	aa000002 	bge	21f1e41c <memalign+0x30>
21f1e410:	e3a03000 	mov	r3, #0	; 0x0
21f1e414:	e50b3040 	str	r3, [fp, #-64]
21f1e418:	ea00008b 	b	21f1e64c <memalign+0x260>

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
21f1e41c:	e51b3034 	ldr	r3, [fp, #-52]
21f1e420:	e3530008 	cmp	r3, #8	; 0x8
21f1e424:	8a000004 	bhi	21f1e43c <memalign+0x50>
21f1e428:	e51b0038 	ldr	r0, [fp, #-56]
21f1e42c:	ebfff85d 	bl	21f1c5a8 <malloc>
21f1e430:	e1a03000 	mov	r3, r0
21f1e434:	e50b3040 	str	r3, [fp, #-64]
21f1e438:	ea000083 	b	21f1e64c <memalign+0x260>

  /* Otherwise, ensure that it is at least a minimum chunk size */

  if (alignment <  MINSIZE) alignment = MINSIZE;
21f1e43c:	e51b3034 	ldr	r3, [fp, #-52]
21f1e440:	e353000f 	cmp	r3, #15	; 0xf
21f1e444:	8a000001 	bhi	21f1e450 <memalign+0x64>
21f1e448:	e3a03010 	mov	r3, #16	; 0x10
21f1e44c:	e50b3034 	str	r3, [fp, #-52]

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
21f1e450:	e51b3038 	ldr	r3, [fp, #-56]
21f1e454:	e283300b 	add	r3, r3, #11	; 0xb
21f1e458:	e3530016 	cmp	r3, #22	; 0x16
21f1e45c:	da000004 	ble	21f1e474 <memalign+0x88>
21f1e460:	e51b3038 	ldr	r3, [fp, #-56]
21f1e464:	e283300b 	add	r3, r3, #11	; 0xb
21f1e468:	e3c33007 	bic	r3, r3, #7	; 0x7
21f1e46c:	e50b303c 	str	r3, [fp, #-60]
21f1e470:	ea000001 	b	21f1e47c <memalign+0x90>
21f1e474:	e3a03010 	mov	r3, #16	; 0x10
21f1e478:	e50b303c 	str	r3, [fp, #-60]
21f1e47c:	e51b303c 	ldr	r3, [fp, #-60]
21f1e480:	e50b3030 	str	r3, [fp, #-48]
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
21f1e484:	e51b2030 	ldr	r2, [fp, #-48]
21f1e488:	e51b3034 	ldr	r3, [fp, #-52]
21f1e48c:	e0823003 	add	r3, r2, r3
21f1e490:	e2833010 	add	r3, r3, #16	; 0x10
21f1e494:	e1a00003 	mov	r0, r3
21f1e498:	ebfff842 	bl	21f1c5a8 <malloc>
21f1e49c:	e1a03000 	mov	r3, r0
21f1e4a0:	e50b302c 	str	r3, [fp, #-44]

  if (m == 0) return 0; /* propagate failure */
21f1e4a4:	e51b302c 	ldr	r3, [fp, #-44]
21f1e4a8:	e3530000 	cmp	r3, #0	; 0x0
21f1e4ac:	1a000002 	bne	21f1e4bc <memalign+0xd0>
21f1e4b0:	e3a03000 	mov	r3, #0	; 0x0
21f1e4b4:	e50b3040 	str	r3, [fp, #-64]
21f1e4b8:	ea000063 	b	21f1e64c <memalign+0x260>

  p = mem2chunk(m);
21f1e4bc:	e51b302c 	ldr	r3, [fp, #-44]
21f1e4c0:	e2433008 	sub	r3, r3, #8	; 0x8
21f1e4c4:	e50b3028 	str	r3, [fp, #-40]

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
21f1e4c8:	e51b302c 	ldr	r3, [fp, #-44]
21f1e4cc:	e1a00003 	mov	r0, r3
21f1e4d0:	e51b1034 	ldr	r1, [fp, #-52]
21f1e4d4:	ebff9d9c 	bl	21f05b4c <__umodsi3>
21f1e4d8:	e1a03000 	mov	r3, r0
21f1e4dc:	e3530000 	cmp	r3, #0	; 0x0
21f1e4e0:	0a000039 	beq	21f1e5cc <memalign+0x1e0>
  {
#if HAVE_MMAP
    if(chunk_is_mmapped(p))
      return chunk2mem(p); /* nothing more to do */
#endif
  }
  else /* misaligned */
  {
    /*
      Find an aligned spot inside chunk.
      Since we need to give back leading space in a chunk of at
      least MINSIZE, if the first calculation places us at
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
21f1e4e4:	e51b2034 	ldr	r2, [fp, #-52]
21f1e4e8:	e51b302c 	ldr	r3, [fp, #-44]
21f1e4ec:	e0823003 	add	r3, r2, r3
21f1e4f0:	e2433001 	sub	r3, r3, #1	; 0x1
21f1e4f4:	e1a02003 	mov	r2, r3
21f1e4f8:	e51b3034 	ldr	r3, [fp, #-52]
21f1e4fc:	e2633000 	rsb	r3, r3, #0	; 0x0
21f1e500:	e0023003 	and	r3, r2, r3
21f1e504:	e2433008 	sub	r3, r3, #8	; 0x8
21f1e508:	e50b3024 	str	r3, [fp, #-36]
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
21f1e50c:	e51b2024 	ldr	r2, [fp, #-36]
21f1e510:	e51b3028 	ldr	r3, [fp, #-40]
21f1e514:	e0633002 	rsb	r3, r3, r2
21f1e518:	e353000f 	cmp	r3, #15	; 0xf
21f1e51c:	8a000003 	bhi	21f1e530 <memalign+0x144>
21f1e520:	e51b3034 	ldr	r3, [fp, #-52]
21f1e524:	e51b2024 	ldr	r2, [fp, #-36]
21f1e528:	e0823003 	add	r3, r2, r3
21f1e52c:	e50b3024 	str	r3, [fp, #-36]

    newp = (mchunkptr)brk;
21f1e530:	e51b3024 	ldr	r3, [fp, #-36]
21f1e534:	e50b3020 	str	r3, [fp, #-32]
    leadsize = brk - (char*)(p);
21f1e538:	e51b2024 	ldr	r2, [fp, #-36]
21f1e53c:	e51b3028 	ldr	r3, [fp, #-40]
21f1e540:	e0633002 	rsb	r3, r3, r2
21f1e544:	e50b3018 	str	r3, [fp, #-24]
    newsize = chunksize(p) - leadsize;
21f1e548:	e51b3028 	ldr	r3, [fp, #-40]
21f1e54c:	e5933004 	ldr	r3, [r3, #4]
21f1e550:	e3c32003 	bic	r2, r3, #3	; 0x3
21f1e554:	e51b3018 	ldr	r3, [fp, #-24]
21f1e558:	e0633002 	rsb	r3, r3, r2
21f1e55c:	e50b301c 	str	r3, [fp, #-28]

#if HAVE_MMAP
    if(chunk_is_mmapped(p))
    {
      newp->prev_size = p->prev_size + leadsize;
      set_head(newp, newsize|IS_MMAPPED);
      return chunk2mem(newp);
    }
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
21f1e560:	e51b301c 	ldr	r3, [fp, #-28]
21f1e564:	e3832001 	orr	r2, r3, #1	; 0x1
21f1e568:	e51b3020 	ldr	r3, [fp, #-32]
21f1e56c:	e5832004 	str	r2, [r3, #4]
    set_inuse_bit_at_offset(newp, newsize);
21f1e570:	e51b2020 	ldr	r2, [fp, #-32]
21f1e574:	e51b301c 	ldr	r3, [fp, #-28]
21f1e578:	e0823003 	add	r3, r2, r3
21f1e57c:	e1a01003 	mov	r1, r3
21f1e580:	e51b2020 	ldr	r2, [fp, #-32]
21f1e584:	e51b301c 	ldr	r3, [fp, #-28]
21f1e588:	e0823003 	add	r3, r2, r3
21f1e58c:	e5933004 	ldr	r3, [r3, #4]
21f1e590:	e3833001 	orr	r3, r3, #1	; 0x1
21f1e594:	e5813004 	str	r3, [r1, #4]
    set_head_size(p, leadsize);
21f1e598:	e51b3028 	ldr	r3, [fp, #-40]
21f1e59c:	e5933004 	ldr	r3, [r3, #4]
21f1e5a0:	e2032001 	and	r2, r3, #1	; 0x1
21f1e5a4:	e51b3018 	ldr	r3, [fp, #-24]
21f1e5a8:	e1822003 	orr	r2, r2, r3
21f1e5ac:	e51b3028 	ldr	r3, [fp, #-40]
21f1e5b0:	e5832004 	str	r2, [r3, #4]
    fREe(chunk2mem(p));
21f1e5b4:	e51b3028 	ldr	r3, [fp, #-40]
21f1e5b8:	e2833008 	add	r3, r3, #8	; 0x8
21f1e5bc:	e1a00003 	mov	r0, r3
21f1e5c0:	ebfffae1 	bl	21f1d14c <free>
    p = newp;
21f1e5c4:	e51b3020 	ldr	r3, [fp, #-32]
21f1e5c8:	e50b3028 	str	r3, [fp, #-40]

    assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */

  remainder_size = chunksize(p) - nb;
21f1e5cc:	e51b3028 	ldr	r3, [fp, #-40]
21f1e5d0:	e5933004 	ldr	r3, [r3, #4]
21f1e5d4:	e3c32003 	bic	r2, r3, #3	; 0x3
21f1e5d8:	e51b3030 	ldr	r3, [fp, #-48]
21f1e5dc:	e0633002 	rsb	r3, r3, r2
21f1e5e0:	e50b3010 	str	r3, [fp, #-16]

  if (remainder_size >= (long)MINSIZE)
21f1e5e4:	e51b3010 	ldr	r3, [fp, #-16]
21f1e5e8:	e353000f 	cmp	r3, #15	; 0xf
21f1e5ec:	da000013 	ble	21f1e640 <memalign+0x254>
  {
    remainder = chunk_at_offset(p, nb);
21f1e5f0:	e51b2028 	ldr	r2, [fp, #-40]
21f1e5f4:	e51b3030 	ldr	r3, [fp, #-48]
21f1e5f8:	e0823003 	add	r3, r2, r3
21f1e5fc:	e50b3014 	str	r3, [fp, #-20]
    set_head(remainder, remainder_size | PREV_INUSE);
21f1e600:	e51b3010 	ldr	r3, [fp, #-16]
21f1e604:	e3833001 	orr	r3, r3, #1	; 0x1
21f1e608:	e1a02003 	mov	r2, r3
21f1e60c:	e51b3014 	ldr	r3, [fp, #-20]
21f1e610:	e5832004 	str	r2, [r3, #4]
    set_head_size(p, nb);
21f1e614:	e51b3028 	ldr	r3, [fp, #-40]
21f1e618:	e5933004 	ldr	r3, [r3, #4]
21f1e61c:	e2032001 	and	r2, r3, #1	; 0x1
21f1e620:	e51b3030 	ldr	r3, [fp, #-48]
21f1e624:	e1822003 	orr	r2, r2, r3
21f1e628:	e51b3028 	ldr	r3, [fp, #-40]
21f1e62c:	e5832004 	str	r2, [r3, #4]
    fREe(chunk2mem(remainder));
21f1e630:	e51b3014 	ldr	r3, [fp, #-20]
21f1e634:	e2833008 	add	r3, r3, #8	; 0x8
21f1e638:	e1a00003 	mov	r0, r3
21f1e63c:	ebfffac2 	bl	21f1d14c <free>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);
21f1e640:	e51b3028 	ldr	r3, [fp, #-40]
21f1e644:	e2833008 	add	r3, r3, #8	; 0x8
21f1e648:	e50b3040 	str	r3, [fp, #-64]
21f1e64c:	e51b3040 	ldr	r3, [fp, #-64]

}
21f1e650:	e1a00003 	mov	r0, r3
21f1e654:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1e658:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1e65c <valloc>:




/*
    valloc just invokes memalign with alignment argument equal
    to the page size of the system (or as near to this as can
    be figured out from all the includes/defines above.)
*/

#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
21f1e65c:	e1a0c00d 	mov	ip, sp
21f1e660:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1e664:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1e668:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1e66c:	e50b0010 	str	r0, [fp, #-16]
  return mEMALIGn (malloc_getpagesize, bytes);
21f1e670:	e3a00a01 	mov	r0, #4096	; 0x1000
21f1e674:	e51b1010 	ldr	r1, [fp, #-16]
21f1e678:	ebffff5b 	bl	21f1e3ec <memalign>
21f1e67c:	e1a03000 	mov	r3, r0
}
21f1e680:	e1a00003 	mov	r0, r3
21f1e684:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1e688 <pvalloc>:

/*
  pvalloc just invokes valloc for the nearest pagesize
  that will accommodate request
*/


#if __STD_C
Void_t* pvALLOc(size_t bytes)
#else
Void_t* pvALLOc(bytes) size_t bytes;
#endif
{
21f1e688:	e1a0c00d 	mov	ip, sp
21f1e68c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1e690:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1e694:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1e698:	e50b0014 	str	r0, [fp, #-20]
  size_t pagesize = malloc_getpagesize;
21f1e69c:	e3a03a01 	mov	r3, #4096	; 0x1000
21f1e6a0:	e50b3010 	str	r3, [fp, #-16]
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
21f1e6a4:	e51b2014 	ldr	r2, [fp, #-20]
21f1e6a8:	e51b3010 	ldr	r3, [fp, #-16]
21f1e6ac:	e0823003 	add	r3, r2, r3
21f1e6b0:	e2432001 	sub	r2, r3, #1	; 0x1
21f1e6b4:	e51b3010 	ldr	r3, [fp, #-16]
21f1e6b8:	e2633000 	rsb	r3, r3, #0	; 0x0
21f1e6bc:	e0023003 	and	r3, r2, r3
21f1e6c0:	e51b0010 	ldr	r0, [fp, #-16]
21f1e6c4:	e1a01003 	mov	r1, r3
21f1e6c8:	ebffff47 	bl	21f1e3ec <memalign>
21f1e6cc:	e1a03000 	mov	r3, r0
}
21f1e6d0:	e1a00003 	mov	r0, r3
21f1e6d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1e6d8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1e6dc <calloc>:

/*

  calloc calls malloc, then zeroes out the allocated chunk.

*/

#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
21f1e6dc:	e1a0c00d 	mov	ip, sp
21f1e6e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1e6e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1e6e8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f1e6ec:	e50b0030 	str	r0, [fp, #-48]
21f1e6f0:	e50b1034 	str	r1, [fp, #-52]
  mchunkptr p;
  INTERNAL_SIZE_T csz;

  INTERNAL_SIZE_T sz = n * elem_size;
21f1e6f4:	e51b2030 	ldr	r2, [fp, #-48]
21f1e6f8:	e51b3034 	ldr	r3, [fp, #-52]
21f1e6fc:	e0030392 	mul	r3, r2, r3
21f1e700:	e50b3024 	str	r3, [fp, #-36]


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
21f1e704:	e59f31d8 	ldr	r3, [pc, #472]	; 21f1e8e4 <.text+0x1e8e4>
21f1e708:	e5933008 	ldr	r3, [r3, #8]
21f1e70c:	e50b3020 	str	r3, [fp, #-32]
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
21f1e710:	e59f31cc 	ldr	r3, [pc, #460]	; 21f1e8e4 <.text+0x1e8e4>
21f1e714:	e5933008 	ldr	r3, [r3, #8]
21f1e718:	e5933004 	ldr	r3, [r3, #4]
21f1e71c:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1e720:	e50b301c 	str	r3, [fp, #-28]
#endif
  Void_t* mem = mALLOc (sz);
21f1e724:	e51b0024 	ldr	r0, [fp, #-36]
21f1e728:	ebfff79e 	bl	21f1c5a8 <malloc>
21f1e72c:	e1a03000 	mov	r3, r0
21f1e730:	e50b3018 	str	r3, [fp, #-24]

  if ((long)n < 0) return 0;
21f1e734:	e51b3030 	ldr	r3, [fp, #-48]
21f1e738:	e3530000 	cmp	r3, #0	; 0x0
21f1e73c:	aa000002 	bge	21f1e74c <calloc+0x70>
21f1e740:	e3a03000 	mov	r3, #0	; 0x0
21f1e744:	e50b3038 	str	r3, [fp, #-56]
21f1e748:	ea000061 	b	21f1e8d4 <calloc+0x1f8>

  if (mem == 0)
21f1e74c:	e51b3018 	ldr	r3, [fp, #-24]
21f1e750:	e3530000 	cmp	r3, #0	; 0x0
21f1e754:	1a000002 	bne	21f1e764 <calloc+0x88>
    return 0;
21f1e758:	e3a03000 	mov	r3, #0	; 0x0
21f1e75c:	e50b3038 	str	r3, [fp, #-56]
21f1e760:	ea00005b 	b	21f1e8d4 <calloc+0x1f8>
  else
  {
    p = mem2chunk(mem);
21f1e764:	e51b3018 	ldr	r3, [fp, #-24]
21f1e768:	e2433008 	sub	r3, r3, #8	; 0x8
21f1e76c:	e50b302c 	str	r3, [fp, #-44]

    /* Two optional cases in which clearing not necessary */


#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
21f1e770:	e51b302c 	ldr	r3, [fp, #-44]
21f1e774:	e5933004 	ldr	r3, [r3, #4]
21f1e778:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1e77c:	e50b3028 	str	r3, [fp, #-40]

#if MORECORE_CLEARS
    if (p == oldtop && csz > oldtopsize)
21f1e780:	e51b202c 	ldr	r2, [fp, #-44]
21f1e784:	e51b3020 	ldr	r3, [fp, #-32]
21f1e788:	e1520003 	cmp	r2, r3
21f1e78c:	1a000005 	bne	21f1e7a8 <calloc+0xcc>
21f1e790:	e51b2028 	ldr	r2, [fp, #-40]
21f1e794:	e51b301c 	ldr	r3, [fp, #-28]
21f1e798:	e1520003 	cmp	r2, r3
21f1e79c:	9a000001 	bls	21f1e7a8 <calloc+0xcc>
    {
      /* clear only the bytes from non-freshly-sbrked memory */
      csz = oldtopsize;
21f1e7a0:	e51b301c 	ldr	r3, [fp, #-28]
21f1e7a4:	e50b3028 	str	r3, [fp, #-40]
    }
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
21f1e7a8:	e51b3028 	ldr	r3, [fp, #-40]
21f1e7ac:	e2433004 	sub	r3, r3, #4	; 0x4
21f1e7b0:	e50b3014 	str	r3, [fp, #-20]
21f1e7b4:	e51b3014 	ldr	r3, [fp, #-20]
21f1e7b8:	e3530024 	cmp	r3, #36	; 0x24
21f1e7bc:	8a00003e 	bhi	21f1e8bc <calloc+0x1e0>
21f1e7c0:	e51b3018 	ldr	r3, [fp, #-24]
21f1e7c4:	e50b3010 	str	r3, [fp, #-16]
21f1e7c8:	e51b3014 	ldr	r3, [fp, #-20]
21f1e7cc:	e3530013 	cmp	r3, #19	; 0x13
21f1e7d0:	9a000029 	bls	21f1e87c <calloc+0x1a0>
21f1e7d4:	e51b2010 	ldr	r2, [fp, #-16]
21f1e7d8:	e3a03000 	mov	r3, #0	; 0x0
21f1e7dc:	e5823000 	str	r3, [r2]
21f1e7e0:	e51b3010 	ldr	r3, [fp, #-16]
21f1e7e4:	e2833004 	add	r3, r3, #4	; 0x4
21f1e7e8:	e50b3010 	str	r3, [fp, #-16]
21f1e7ec:	e51b2010 	ldr	r2, [fp, #-16]
21f1e7f0:	e3a03000 	mov	r3, #0	; 0x0
21f1e7f4:	e5823000 	str	r3, [r2]
21f1e7f8:	e51b3010 	ldr	r3, [fp, #-16]
21f1e7fc:	e2833004 	add	r3, r3, #4	; 0x4
21f1e800:	e50b3010 	str	r3, [fp, #-16]
21f1e804:	e51b3014 	ldr	r3, [fp, #-20]
21f1e808:	e353001b 	cmp	r3, #27	; 0x1b
21f1e80c:	9a00001a 	bls	21f1e87c <calloc+0x1a0>
21f1e810:	e51b2010 	ldr	r2, [fp, #-16]
21f1e814:	e3a03000 	mov	r3, #0	; 0x0
21f1e818:	e5823000 	str	r3, [r2]
21f1e81c:	e51b3010 	ldr	r3, [fp, #-16]
21f1e820:	e2833004 	add	r3, r3, #4	; 0x4
21f1e824:	e50b3010 	str	r3, [fp, #-16]
21f1e828:	e51b2010 	ldr	r2, [fp, #-16]
21f1e82c:	e3a03000 	mov	r3, #0	; 0x0
21f1e830:	e5823000 	str	r3, [r2]
21f1e834:	e51b3010 	ldr	r3, [fp, #-16]
21f1e838:	e2833004 	add	r3, r3, #4	; 0x4
21f1e83c:	e50b3010 	str	r3, [fp, #-16]
21f1e840:	e51b3014 	ldr	r3, [fp, #-20]
21f1e844:	e3530023 	cmp	r3, #35	; 0x23
21f1e848:	9a00000b 	bls	21f1e87c <calloc+0x1a0>
21f1e84c:	e51b2010 	ldr	r2, [fp, #-16]
21f1e850:	e3a03000 	mov	r3, #0	; 0x0
21f1e854:	e5823000 	str	r3, [r2]
21f1e858:	e51b3010 	ldr	r3, [fp, #-16]
21f1e85c:	e2833004 	add	r3, r3, #4	; 0x4
21f1e860:	e50b3010 	str	r3, [fp, #-16]
21f1e864:	e51b2010 	ldr	r2, [fp, #-16]
21f1e868:	e3a03000 	mov	r3, #0	; 0x0
21f1e86c:	e5823000 	str	r3, [r2]
21f1e870:	e51b3010 	ldr	r3, [fp, #-16]
21f1e874:	e2833004 	add	r3, r3, #4	; 0x4
21f1e878:	e50b3010 	str	r3, [fp, #-16]
21f1e87c:	e51b2010 	ldr	r2, [fp, #-16]
21f1e880:	e3a03000 	mov	r3, #0	; 0x0
21f1e884:	e5823000 	str	r3, [r2]
21f1e888:	e51b3010 	ldr	r3, [fp, #-16]
21f1e88c:	e2833004 	add	r3, r3, #4	; 0x4
21f1e890:	e50b3010 	str	r3, [fp, #-16]
21f1e894:	e51b2010 	ldr	r2, [fp, #-16]
21f1e898:	e3a03000 	mov	r3, #0	; 0x0
21f1e89c:	e5823000 	str	r3, [r2]
21f1e8a0:	e51b3010 	ldr	r3, [fp, #-16]
21f1e8a4:	e2833004 	add	r3, r3, #4	; 0x4
21f1e8a8:	e50b3010 	str	r3, [fp, #-16]
21f1e8ac:	e51b2010 	ldr	r2, [fp, #-16]
21f1e8b0:	e3a03000 	mov	r3, #0	; 0x0
21f1e8b4:	e5823000 	str	r3, [r2]
21f1e8b8:	ea000003 	b	21f1e8cc <calloc+0x1f0>
21f1e8bc:	e51b0018 	ldr	r0, [fp, #-24]
21f1e8c0:	e3a01000 	mov	r1, #0	; 0x0
21f1e8c4:	e51b2014 	ldr	r2, [fp, #-20]
21f1e8c8:	eb001206 	bl	21f230e8 <memset>
    return mem;
21f1e8cc:	e51b3018 	ldr	r3, [fp, #-24]
21f1e8d0:	e50b3038 	str	r3, [fp, #-56]
21f1e8d4:	e51b3038 	ldr	r3, [fp, #-56]
  }
}
21f1e8d8:	e1a00003 	mov	r0, r3
21f1e8dc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1e8e0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1e8e4:	21f33590 	ldrcsb	r3, [r3, #80]!

21f1e8e8 <cfree>:

/*

  cfree just calls free. It is needed/defined on some systems
  that pair it with calloc, presumably for odd historical reasons.

*/

#if !defined(INTERNAL_LINUX_C_LIB) || !defined(__ELF__)
#if __STD_C
void cfree(Void_t *mem)
#else
void cfree(mem) Void_t *mem;
#endif
{
21f1e8e8:	e1a0c00d 	mov	ip, sp
21f1e8ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1e8f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1e8f4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1e8f8:	e50b0010 	str	r0, [fp, #-16]
  fREe(mem);
21f1e8fc:	e51b0010 	ldr	r0, [fp, #-16]
21f1e900:	ebfffa11 	bl	21f1d14c <free>
}
21f1e904:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1e908 <malloc_trim>:
#endif



/*

    Malloc_trim gives memory back to the system (via negative
    arguments to sbrk) if there is unused memory at the `high' end of
    the malloc pool. You can call this after freeing large blocks of
    memory to potentially reduce the system-level memory requirements
    of a program. However, it cannot guarantee to reduce memory. Under
    some allocation patterns, some large free blocks of memory will be
    locked between two used chunks, so they cannot be given back to
    the system.

    The `pad' argument to malloc_trim represents the amount of free
    trailing space to leave untrimmed. If this argument is zero,
    only the minimum amount of memory to maintain internal data
    structures will be left (one page or less). Non-zero arguments
    can be supplied to maintain enough trailing space to service
    future expected allocations without having to re-obtain memory
    from the system.

    Malloc_trim returns 1 if it actually released any memory, else 0.

*/

#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
21f1e908:	e1a0c00d 	mov	ip, sp
21f1e90c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1e910:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1e914:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f1e918:	e50b0024 	str	r0, [fp, #-36]
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
21f1e91c:	e3a03a01 	mov	r3, #4096	; 0x1000
21f1e920:	e50b3010 	str	r3, [fp, #-16]

  top_size = chunksize(top);
21f1e924:	e59f3174 	ldr	r3, [pc, #372]	; 21f1eaa0 <.text+0x1eaa0>
21f1e928:	e5933008 	ldr	r3, [r3, #8]
21f1e92c:	e5933004 	ldr	r3, [r3, #4]
21f1e930:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1e934:	e50b3020 	str	r3, [fp, #-32]
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
21f1e938:	e51b2020 	ldr	r2, [fp, #-32]
21f1e93c:	e51b3024 	ldr	r3, [fp, #-36]
21f1e940:	e0632002 	rsb	r2, r3, r2
21f1e944:	e51b3010 	ldr	r3, [fp, #-16]
21f1e948:	e0823003 	add	r3, r2, r3
21f1e94c:	e2433011 	sub	r3, r3, #17	; 0x11
21f1e950:	e1a00003 	mov	r0, r3
21f1e954:	e51b1010 	ldr	r1, [fp, #-16]
21f1e958:	ebff9c55 	bl	21f05ab4 <__udivsi3>
21f1e95c:	e1a03000 	mov	r3, r0
21f1e960:	e2432001 	sub	r2, r3, #1	; 0x1
21f1e964:	e51b3010 	ldr	r3, [fp, #-16]
21f1e968:	e0030392 	mul	r3, r2, r3
21f1e96c:	e50b301c 	str	r3, [fp, #-28]

  if (extra < (long)pagesz)  /* Not enough memory to release */
21f1e970:	e51b2010 	ldr	r2, [fp, #-16]
21f1e974:	e51b301c 	ldr	r3, [fp, #-28]
21f1e978:	e1520003 	cmp	r2, r3
21f1e97c:	da000002 	ble	21f1e98c <malloc_trim+0x84>
    return 0;
21f1e980:	e3a03000 	mov	r3, #0	; 0x0
21f1e984:	e50b3028 	str	r3, [fp, #-40]
21f1e988:	ea000040 	b	21f1ea90 <malloc_trim+0x188>

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
21f1e98c:	e3a00000 	mov	r0, #0	; 0x0
21f1e990:	ebff9cba 	bl	21f05c80 <sbrk>
21f1e994:	e1a03000 	mov	r3, r0
21f1e998:	e50b3018 	str	r3, [fp, #-24]
    if (current_brk != (char*)(top) + top_size)
21f1e99c:	e59f30fc 	ldr	r3, [pc, #252]	; 21f1eaa0 <.text+0x1eaa0>
21f1e9a0:	e5933008 	ldr	r3, [r3, #8]
21f1e9a4:	e1a02003 	mov	r2, r3
21f1e9a8:	e51b3020 	ldr	r3, [fp, #-32]
21f1e9ac:	e0822003 	add	r2, r2, r3
21f1e9b0:	e51b3018 	ldr	r3, [fp, #-24]
21f1e9b4:	e1520003 	cmp	r2, r3
21f1e9b8:	0a000002 	beq	21f1e9c8 <malloc_trim+0xc0>
      return 0;     /* Apparently we don't own memory; must fail */
21f1e9bc:	e3a03000 	mov	r3, #0	; 0x0
21f1e9c0:	e50b3028 	str	r3, [fp, #-40]
21f1e9c4:	ea000031 	b	21f1ea90 <malloc_trim+0x188>

    else
    {
      new_brk = (char*)(MORECORE (-extra));
21f1e9c8:	e51b301c 	ldr	r3, [fp, #-28]
21f1e9cc:	e2633000 	rsb	r3, r3, #0	; 0x0
21f1e9d0:	e1a00003 	mov	r0, r3
21f1e9d4:	ebff9ca9 	bl	21f05c80 <sbrk>
21f1e9d8:	e1a03000 	mov	r3, r0
21f1e9dc:	e50b3014 	str	r3, [fp, #-20]

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
21f1e9e0:	e51b3014 	ldr	r3, [fp, #-20]
21f1e9e4:	e3730001 	cmn	r3, #1	; 0x1
21f1e9e8:	1a000019 	bne	21f1ea54 <malloc_trim+0x14c>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
21f1e9ec:	e3a00000 	mov	r0, #0	; 0x0
21f1e9f0:	ebff9ca2 	bl	21f05c80 <sbrk>
21f1e9f4:	e1a03000 	mov	r3, r0
21f1e9f8:	e50b3018 	str	r3, [fp, #-24]
	top_size = current_brk - (char*)top;
21f1e9fc:	e51b2018 	ldr	r2, [fp, #-24]
21f1ea00:	e59f3098 	ldr	r3, [pc, #152]	; 21f1eaa0 <.text+0x1eaa0>
21f1ea04:	e5933008 	ldr	r3, [r3, #8]
21f1ea08:	e0633002 	rsb	r3, r3, r2
21f1ea0c:	e50b3020 	str	r3, [fp, #-32]
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
21f1ea10:	e51b3020 	ldr	r3, [fp, #-32]
21f1ea14:	e353000f 	cmp	r3, #15	; 0xf
21f1ea18:	da00000a 	ble	21f1ea48 <malloc_trim+0x140>
	{
	  sbrked_mem = current_brk - sbrk_base;
21f1ea1c:	e51b2018 	ldr	r2, [fp, #-24]
21f1ea20:	e59f307c 	ldr	r3, [pc, #124]	; 21f1eaa4 <.text+0x1eaa4>
21f1ea24:	e5933000 	ldr	r3, [r3]
21f1ea28:	e0632002 	rsb	r2, r3, r2
21f1ea2c:	e59f3074 	ldr	r3, [pc, #116]	; 21f1eaa8 <.text+0x1eaa8>
21f1ea30:	e5832000 	str	r2, [r3]
	  set_head(top, top_size | PREV_INUSE);
21f1ea34:	e59f3064 	ldr	r3, [pc, #100]	; 21f1eaa0 <.text+0x1eaa0>
21f1ea38:	e5932008 	ldr	r2, [r3, #8]
21f1ea3c:	e51b3020 	ldr	r3, [fp, #-32]
21f1ea40:	e3833001 	orr	r3, r3, #1	; 0x1
21f1ea44:	e5823004 	str	r3, [r2, #4]
	}
	check_chunk(top);
	return 0;
21f1ea48:	e3a03000 	mov	r3, #0	; 0x0
21f1ea4c:	e50b3028 	str	r3, [fp, #-40]
21f1ea50:	ea00000e 	b	21f1ea90 <malloc_trim+0x188>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
21f1ea54:	e59f3044 	ldr	r3, [pc, #68]	; 21f1eaa0 <.text+0x1eaa0>
21f1ea58:	e5931008 	ldr	r1, [r3, #8]
21f1ea5c:	e51b2020 	ldr	r2, [fp, #-32]
21f1ea60:	e51b301c 	ldr	r3, [fp, #-28]
21f1ea64:	e0633002 	rsb	r3, r3, r2
21f1ea68:	e3833001 	orr	r3, r3, #1	; 0x1
21f1ea6c:	e5813004 	str	r3, [r1, #4]
	sbrked_mem -= extra;
21f1ea70:	e59f3030 	ldr	r3, [pc, #48]	; 21f1eaa8 <.text+0x1eaa8>
21f1ea74:	e5932000 	ldr	r2, [r3]
21f1ea78:	e51b301c 	ldr	r3, [fp, #-28]
21f1ea7c:	e0632002 	rsb	r2, r3, r2
21f1ea80:	e59f3020 	ldr	r3, [pc, #32]	; 21f1eaa8 <.text+0x1eaa8>
21f1ea84:	e5832000 	str	r2, [r3]
	check_chunk(top);
	return 1;
21f1ea88:	e3a03001 	mov	r3, #1	; 0x1
21f1ea8c:	e50b3028 	str	r3, [fp, #-40]
21f1ea90:	e51b3028 	ldr	r3, [fp, #-40]
      }
    }
  }
}
21f1ea94:	e1a00003 	mov	r0, r3
21f1ea98:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1ea9c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1eaa0:	21f33590 	ldrcsb	r3, [r3, #80]!
21f1eaa4:	21f339a0 	mvncss	r3, r0, lsr #19
21f1eaa8:	21f67780 	mvncss	r7, r0, lsl #15

21f1eaac <malloc_usable_size>:



/*
  malloc_usable_size:

    This routine tells you how many bytes you can actually use in an
    allocated chunk, which may be more than you requested (although
    often not). You can use this many bytes without worrying about
    overwriting other allocated objects. Not a particularly great
    programming practice, but still sometimes useful.

*/

#if __STD_C
size_t malloc_usable_size(Void_t* mem)
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
21f1eaac:	e1a0c00d 	mov	ip, sp
21f1eab0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1eab4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1eab8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f1eabc:	e50b0014 	str	r0, [fp, #-20]
  mchunkptr p;
  if (mem == 0)
21f1eac0:	e51b3014 	ldr	r3, [fp, #-20]
21f1eac4:	e3530000 	cmp	r3, #0	; 0x0
21f1eac8:	1a000002 	bne	21f1ead8 <malloc_usable_size+0x2c>
    return 0;
21f1eacc:	e3a03000 	mov	r3, #0	; 0x0
21f1ead0:	e50b3018 	str	r3, [fp, #-24]
21f1ead4:	ea000020 	b	21f1eb5c <malloc_usable_size+0xb0>
  else
  {
    p = mem2chunk(mem);
21f1ead8:	e51b3014 	ldr	r3, [fp, #-20]
21f1eadc:	e2433008 	sub	r3, r3, #8	; 0x8
21f1eae0:	e50b3010 	str	r3, [fp, #-16]
    if(!chunk_is_mmapped(p))
21f1eae4:	e51b3010 	ldr	r3, [fp, #-16]
21f1eae8:	e5933004 	ldr	r3, [r3, #4]
21f1eaec:	e1a030a3 	mov	r3, r3, lsr #1
21f1eaf0:	e2033001 	and	r3, r3, #1	; 0x1
21f1eaf4:	e3530000 	cmp	r3, #0	; 0x0
21f1eaf8:	1a000012 	bne	21f1eb48 <malloc_usable_size+0x9c>
    {
      if (!inuse(p)) return 0;
21f1eafc:	e51b3010 	ldr	r3, [fp, #-16]
21f1eb00:	e5933004 	ldr	r3, [r3, #4]
21f1eb04:	e3c33001 	bic	r3, r3, #1	; 0x1
21f1eb08:	e1a02003 	mov	r2, r3
21f1eb0c:	e51b3010 	ldr	r3, [fp, #-16]
21f1eb10:	e0823003 	add	r3, r2, r3
21f1eb14:	e5933004 	ldr	r3, [r3, #4]
21f1eb18:	e2033001 	and	r3, r3, #1	; 0x1
21f1eb1c:	e3530000 	cmp	r3, #0	; 0x0
21f1eb20:	1a000002 	bne	21f1eb30 <malloc_usable_size+0x84>
21f1eb24:	e3a03000 	mov	r3, #0	; 0x0
21f1eb28:	e50b3018 	str	r3, [fp, #-24]
21f1eb2c:	ea00000a 	b	21f1eb5c <malloc_usable_size+0xb0>
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
21f1eb30:	e51b3010 	ldr	r3, [fp, #-16]
21f1eb34:	e5933004 	ldr	r3, [r3, #4]
21f1eb38:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1eb3c:	e2433004 	sub	r3, r3, #4	; 0x4
21f1eb40:	e50b3018 	str	r3, [fp, #-24]
21f1eb44:	ea000004 	b	21f1eb5c <malloc_usable_size+0xb0>
    }
    return chunksize(p) - 2*SIZE_SZ;
21f1eb48:	e51b3010 	ldr	r3, [fp, #-16]
21f1eb4c:	e5933004 	ldr	r3, [r3, #4]
21f1eb50:	e3c33003 	bic	r3, r3, #3	; 0x3
21f1eb54:	e2433008 	sub	r3, r3, #8	; 0x8
21f1eb58:	e50b3018 	str	r3, [fp, #-24]
21f1eb5c:	e51b3018 	ldr	r3, [fp, #-24]
  }
}
21f1eb60:	e1a00003 	mov	r0, r3
21f1eb64:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1eb68:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1eb6c <mallopt>:




/* Utility to update current_mallinfo for malloc_stats and mallinfo() */

#if 0
static void malloc_update_mallinfo()
{
  int i;
  mbinptr b;
  mchunkptr p;
#ifdef DEBUG
  mchunkptr q;
#endif

  INTERNAL_SIZE_T avail = chunksize(top);
  int   navail = ((long)(avail) >= (long)MINSIZE)? 1 : 0;

  for (i = 1; i < NAV; ++i)
  {
    b = bin_at(i);
    for (p = last(b); p != b; p = p->bk)
    {
#ifdef DEBUG
      check_free_chunk(p);
      for (q = next_chunk(p);
	   q < top && inuse(q) && (long)(chunksize(q)) >= (long)MINSIZE;
	   q = next_chunk(q))
	check_inuse_chunk(q);
#endif
      avail += chunksize(p);
      navail++;
    }
  }

  current_mallinfo.ordblks = navail;
  current_mallinfo.uordblks = sbrked_mem - avail;
  current_mallinfo.fordblks = avail;
  current_mallinfo.hblks = n_mmaps;
  current_mallinfo.hblkhd = mmapped_mem;
  current_mallinfo.keepcost = chunksize(top);

}
#endif	/* 0 */



/*

  malloc_stats:

    Prints on the amount of space obtain from the system (both
    via sbrk and mmap), the maximum amount (which may be more than
    current if malloc_trim and/or munmap got called), the maximum
    number of simultaneous mmap regions used, and the current number
    of bytes allocated via malloc (or realloc, etc) but not yet
    freed. (Note that this is the number of bytes allocated, not the
    number requested. It will be larger than the number requested
    because of alignment and bookkeeping overhead.)

*/

#if 0
void malloc_stats()
{
  malloc_update_mallinfo();
  printf("max system bytes = %10u\n",
	  (unsigned int)(max_total_mem));
  printf("system bytes     = %10u\n",
	  (unsigned int)(sbrked_mem + mmapped_mem));
  printf("in use bytes     = %10u\n",
	  (unsigned int)(current_mallinfo.uordblks + mmapped_mem));
#if HAVE_MMAP
  printf("max mmap regions = %10u\n",
	  (unsigned int)max_n_mmaps);
#endif
}
#endif	/* 0 */

/*
  mallinfo returns a copy of updated current mallinfo.
*/

#if 0
struct mallinfo mALLINFo()
{
  malloc_update_mallinfo();
  return current_mallinfo;
}
#endif	/* 0 */




/*
  mallopt:

    mallopt is the general SVID/XPG interface to tunable parameters.
    The format is to provide a (parameter-number, parameter-value) pair.
    mallopt then sets the corresponding parameter to the argument
    value if it can (i.e., so long as the value is meaningful),
    and returns 1 if successful else 0.

    See descriptions of tunable parameters above.

*/

#if __STD_C
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
21f1eb6c:	e1a0c00d 	mov	ip, sp
21f1eb70:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1eb74:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1eb78:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f1eb7c:	e50b0010 	str	r0, [fp, #-16]
21f1eb80:	e50b1014 	str	r1, [fp, #-20]
  switch(param_number)
21f1eb84:	e51b3010 	ldr	r3, [fp, #-16]
21f1eb88:	e2833004 	add	r3, r3, #4	; 0x4
21f1eb8c:	e3530003 	cmp	r3, #3	; 0x3
21f1eb90:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f1eb94:	ea000021 	b	21f1ec20 <.text+0x1ec20>
21f1eb98:	21f1ebf0 	ldrcssh	lr, [r1, #176]!
21f1eb9c:	21f1ebd8 	ldrcssb	lr, [r1, #184]!
21f1eba0:	21f1ebc0 	mvncss	lr, r0, asr #23
21f1eba4:	21f1eba8 	mvncss	lr, r8, lsr #23
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
21f1eba8:	e51b2014 	ldr	r2, [fp, #-20]
21f1ebac:	e59f3084 	ldr	r3, [pc, #132]	; 21f1ec38 <.text+0x1ec38>
21f1ebb0:	e5832000 	str	r2, [r3]
21f1ebb4:	e3a03001 	mov	r3, #1	; 0x1
21f1ebb8:	e50b3018 	str	r3, [fp, #-24]
21f1ebbc:	ea000019 	b	21f1ec28 <.text+0x1ec28>
    case M_TOP_PAD:
      top_pad = value; return 1;
21f1ebc0:	e51b2014 	ldr	r2, [fp, #-20]
21f1ebc4:	e59f3070 	ldr	r3, [pc, #112]	; 21f1ec3c <.text+0x1ec3c>
21f1ebc8:	e5832000 	str	r2, [r3]
21f1ebcc:	e3a03001 	mov	r3, #1	; 0x1
21f1ebd0:	e50b3018 	str	r3, [fp, #-24]
21f1ebd4:	ea000013 	b	21f1ec28 <.text+0x1ec28>
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
21f1ebd8:	e51b2014 	ldr	r2, [fp, #-20]
21f1ebdc:	e59f305c 	ldr	r3, [pc, #92]	; 21f1ec40 <.text+0x1ec40>
21f1ebe0:	e5832000 	str	r2, [r3]
21f1ebe4:	e3a03001 	mov	r3, #1	; 0x1
21f1ebe8:	e50b3018 	str	r3, [fp, #-24]
21f1ebec:	ea00000d 	b	21f1ec28 <.text+0x1ec28>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
21f1ebf0:	e51b3014 	ldr	r3, [fp, #-20]
21f1ebf4:	e3530000 	cmp	r3, #0	; 0x0
21f1ebf8:	0a000002 	beq	21f1ec08 <.text+0x1ec08>
21f1ebfc:	e3a03000 	mov	r3, #0	; 0x0
21f1ec00:	e50b3018 	str	r3, [fp, #-24]
21f1ec04:	ea000007 	b	21f1ec28 <.text+0x1ec28>
21f1ec08:	e51b2014 	ldr	r2, [fp, #-20]
21f1ec0c:	e59f3030 	ldr	r3, [pc, #48]	; 21f1ec44 <.text+0x1ec44>
21f1ec10:	e5832000 	str	r2, [r3]
21f1ec14:	e3a03001 	mov	r3, #1	; 0x1
21f1ec18:	e50b3018 	str	r3, [fp, #-24]
21f1ec1c:	ea000001 	b	21f1ec28 <.text+0x1ec28>
#endif

    default:
      return 0;
21f1ec20:	e3a03000 	mov	r3, #0	; 0x0
21f1ec24:	e50b3018 	str	r3, [fp, #-24]
21f1ec28:	e51b3018 	ldr	r3, [fp, #-24]
  }
}
21f1ec2c:	e1a00003 	mov	r0, r3
21f1ec30:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1ec34:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1ec38:	21f33998 	ldrcsb	r3, [r3, #152]!
21f1ec3c:	21f67770 	mvncss	r7, r0, ror r7
21f1ec40:	21f3399c 	ldrcsb	r3, [r3, #156]!
21f1ec44:	21f67774 	mvncss	r7, r4, ror r7

21f1ec48 <env_crc_update>:
int default_environment_size = sizeof(default_environment);
#endif

void env_crc_update (void)
{
21f1ec48:	e1a0c00d 	mov	ip, sp
21f1ec4c:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f1ec50:	e24cb004 	sub	fp, ip, #4	; 0x4
	env_ptr->crc = crc32(0, env_ptr->data, ENV_SIZE);
21f1ec54:	e59f302c 	ldr	r3, [pc, #44]	; 21f1ec88 <.text+0x1ec88>
21f1ec58:	e5934000 	ldr	r4, [r3]
21f1ec5c:	e59f3024 	ldr	r3, [pc, #36]	; 21f1ec88 <.text+0x1ec88>
21f1ec60:	e5933000 	ldr	r3, [r3]
21f1ec64:	e2833004 	add	r3, r3, #4	; 0x4
21f1ec68:	e3a00000 	mov	r0, #0	; 0x0
21f1ec6c:	e1a01003 	mov	r1, r3
21f1ec70:	e3a02d7f 	mov	r2, #8128	; 0x1fc0
21f1ec74:	e282203c 	add	r2, r2, #60	; 0x3c
21f1ec78:	eb000d9e 	bl	21f222f8 <crc32>
21f1ec7c:	e1a03000 	mov	r3, r0
21f1ec80:	e5843000 	str	r3, [r4]
}
21f1ec84:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f1ec88:	21f339cc 	mvncss	r3, ip, asr #19

21f1ec8c <env_get_char_init>:

static uchar env_get_char_init (int index)
{
21f1ec8c:	e1a0c00d 	mov	ip, sp
21f1ec90:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ec94:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ec98:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1ec9c:	e50b0014 	str	r0, [fp, #-20]
	uchar c;

	/* if crc was bad, use the default environment */
	if (gd->env_valid)
21f1eca0:	e1a03008 	mov	r3, r8
21f1eca4:	e5933018 	ldr	r3, [r3, #24]
21f1eca8:	e3530000 	cmp	r3, #0	; 0x0
21f1ecac:	0a000004 	beq	21f1ecc4 <env_get_char_init+0x38>
	{
		c = env_get_char_spec(index);
21f1ecb0:	e51b0014 	ldr	r0, [fp, #-20]
21f1ecb4:	eb00006d 	bl	21f1ee70 <env_get_char_spec>
21f1ecb8:	e1a03000 	mov	r3, r0
21f1ecbc:	e54b300d 	strb	r3, [fp, #-13]
21f1ecc0:	ea000003 	b	21f1ecd4 <env_get_char_init+0x48>
	} else {
		c = default_environment[index];
21f1ecc4:	e51b3014 	ldr	r3, [fp, #-20]
21f1ecc8:	e59f2014 	ldr	r2, [pc, #20]	; 21f1ece4 <.text+0x1ece4>
21f1eccc:	e7d23003 	ldrb	r3, [r2, r3]
21f1ecd0:	e54b300d 	strb	r3, [fp, #-13]
	}

	return (c);
21f1ecd4:	e55b300d 	ldrb	r3, [fp, #-13]
}
21f1ecd8:	e1a00003 	mov	r0, r3
21f1ecdc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1ece0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1ece4:	21f339a8 	mvncss	r3, r8, lsr #19

21f1ece8 <env_get_char_memory>:

#ifdef CONFIG_AMIGAONEG3SE
uchar env_get_char_memory (int index)
{
	uchar retval;
	enable_nvram();
	if (gd->env_valid) {
		retval = ( *((uchar *)(gd->env_addr + index)) );
	} else {
		retval = ( default_environment[index] );
	}
	disable_nvram();
	return retval;
}
#else
uchar env_get_char_memory (int index)
{
21f1ece8:	e1a0c00d 	mov	ip, sp
21f1ecec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ecf0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ecf4:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1ecf8:	e50b0010 	str	r0, [fp, #-16]
	if (gd->env_valid) {
21f1ecfc:	e1a03008 	mov	r3, r8
21f1ed00:	e5933018 	ldr	r3, [r3, #24]
21f1ed04:	e3530000 	cmp	r3, #0	; 0x0
21f1ed08:	0a000006 	beq	21f1ed28 <env_get_char_memory+0x40>
		return ( *((uchar *)(gd->env_addr + index)) );
21f1ed0c:	e1a03008 	mov	r3, r8
21f1ed10:	e5932014 	ldr	r2, [r3, #20]
21f1ed14:	e51b3010 	ldr	r3, [fp, #-16]
21f1ed18:	e0823003 	add	r3, r2, r3
21f1ed1c:	e5d33000 	ldrb	r3, [r3]
21f1ed20:	e50b3014 	str	r3, [fp, #-20]
21f1ed24:	ea000003 	b	21f1ed38 <env_get_char_memory+0x50>
	} else {
		return ( default_environment[index] );
21f1ed28:	e51b3010 	ldr	r3, [fp, #-16]
21f1ed2c:	e59f2014 	ldr	r2, [pc, #20]	; 21f1ed48 <.text+0x1ed48>
21f1ed30:	e7d23003 	ldrb	r3, [r2, r3]
21f1ed34:	e50b3014 	str	r3, [fp, #-20]
21f1ed38:	e51b3014 	ldr	r3, [fp, #-20]
	}
}
21f1ed3c:	e1a00003 	mov	r0, r3
21f1ed40:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1ed44:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1ed48:	21f339a8 	mvncss	r3, r8, lsr #19

21f1ed4c <env_get_addr>:
#endif

uchar *env_get_addr (int index)
{
21f1ed4c:	e1a0c00d 	mov	ip, sp
21f1ed50:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ed54:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ed58:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1ed5c:	e50b0010 	str	r0, [fp, #-16]
	if (gd->env_valid) {
21f1ed60:	e1a03008 	mov	r3, r8
21f1ed64:	e5933018 	ldr	r3, [r3, #24]
21f1ed68:	e3530000 	cmp	r3, #0	; 0x0
21f1ed6c:	0a000005 	beq	21f1ed88 <env_get_addr+0x3c>
		return ( ((uchar *)(gd->env_addr + index)) );
21f1ed70:	e1a03008 	mov	r3, r8
21f1ed74:	e5932014 	ldr	r2, [r3, #20]
21f1ed78:	e51b3010 	ldr	r3, [fp, #-16]
21f1ed7c:	e0823003 	add	r3, r2, r3
21f1ed80:	e50b3014 	str	r3, [fp, #-20]
21f1ed84:	ea000004 	b	21f1ed9c <env_get_addr+0x50>
	} else {
		return (&default_environment[index]);
21f1ed88:	e51b3010 	ldr	r3, [fp, #-16]
21f1ed8c:	e1a02003 	mov	r2, r3
21f1ed90:	e59f3014 	ldr	r3, [pc, #20]	; 21f1edac <.text+0x1edac>
21f1ed94:	e0822003 	add	r2, r2, r3
21f1ed98:	e50b2014 	str	r2, [fp, #-20]
21f1ed9c:	e51b3014 	ldr	r3, [fp, #-20]
	}
}
21f1eda0:	e1a00003 	mov	r0, r3
21f1eda4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1eda8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1edac:	21f339a8 	mvncss	r3, r8, lsr #19

21f1edb0 <env_relocate>:

void env_relocate (void)
{
21f1edb0:	e1a0c00d 	mov	ip, sp
21f1edb4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1edb8:	e24cb004 	sub	fp, ip, #4	; 0x4
	DEBUGF ("%s[%d] offset = 0x%lx\n", __FUNCTION__,__LINE__,
		gd->reloc_off);

#ifdef CONFIG_AMIGAONEG3SE
	enable_nvram();
#endif

#ifdef ENV_IS_EMBEDDED
	/*
	 * The environment buffer is embedded with the text segment,
	 * just relocate the environment pointer
	 */
	env_ptr = (env_t *)((ulong)env_ptr + gd->reloc_off);
	DEBUGF ("%s[%d] embedded ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
#else
	/*
	 * We must allocate a buffer for the environment
	 */
	env_ptr = (env_t *)malloc (CFG_ENV_SIZE);
21f1edbc:	e3a00a02 	mov	r0, #8192	; 0x2000
21f1edc0:	ebfff5f8 	bl	21f1c5a8 <malloc>
21f1edc4:	e1a03000 	mov	r3, r0
21f1edc8:	e1a02003 	mov	r2, r3
21f1edcc:	e59f3088 	ldr	r3, [pc, #136]	; 21f1ee5c <.text+0x1ee5c>
21f1edd0:	e5832000 	str	r2, [r3]
	DEBUGF ("%s[%d] malloced ENV at %p\n", __FUNCTION__,__LINE__,env_ptr);
#endif

	/*
	 * After relocation to RAM, we can always use the "memory" functions
	 */
	env_get_char = env_get_char_memory;
21f1edd4:	e59f2084 	ldr	r2, [pc, #132]	; 21f1ee60 <.text+0x1ee60>
21f1edd8:	e59f3084 	ldr	r3, [pc, #132]	; 21f1ee64 <.text+0x1ee64>
21f1eddc:	e5823000 	str	r3, [r2]

	if (gd->env_valid == 0) {
21f1ede0:	e1a03008 	mov	r3, r8
21f1ede4:	e5933018 	ldr	r3, [r3, #24]
21f1ede8:	e3530000 	cmp	r3, #0	; 0x0
21f1edec:	1a000013 	bne	21f1ee40 <env_relocate+0x90>
#if defined(CONFIG_GTH)	|| defined(CFG_ENV_IS_NOWHERE)	/* Environment not changable */
		puts ("Using default environment\n\n");
#else
		puts ("*** Warning - bad CRC, using default environment\n\n");
21f1edf0:	e59f0070 	ldr	r0, [pc, #112]	; 21f1ee68 <.text+0x1ee68>
21f1edf4:	ebfff311 	bl	21f1ba40 <puts>
		SHOW_BOOT_PROGRESS (-1);
#endif

		if (sizeof(default_environment) > ENV_SIZE)
		{
			puts ("*** Error - default environment is too large\n\n");
			return;
		}

		memset (env_ptr, 0, sizeof(env_t));
21f1edf8:	e59f305c 	ldr	r3, [pc, #92]	; 21f1ee5c <.text+0x1ee5c>
21f1edfc:	e5933000 	ldr	r3, [r3]
21f1ee00:	e1a00003 	mov	r0, r3
21f1ee04:	e3a01000 	mov	r1, #0	; 0x0
21f1ee08:	e3a02a02 	mov	r2, #8192	; 0x2000
21f1ee0c:	eb0010b5 	bl	21f230e8 <memset>
		memcpy (env_ptr->data,
21f1ee10:	e59f3044 	ldr	r3, [pc, #68]	; 21f1ee5c <.text+0x1ee5c>
21f1ee14:	e5933000 	ldr	r3, [r3]
21f1ee18:	e2833004 	add	r3, r3, #4	; 0x4
21f1ee1c:	e1a00003 	mov	r0, r3
21f1ee20:	e59f1044 	ldr	r1, [pc, #68]	; 21f1ee6c <.text+0x1ee6c>
21f1ee24:	e3a0201e 	mov	r2, #30	; 0x1e
21f1ee28:	eb0010e7 	bl	21f231cc <memcpy>
			default_environment,
			sizeof(default_environment));
#ifdef CFG_REDUNDAND_ENVIRONMENT
		env_ptr->flags = 0xFF;
#endif
		env_crc_update ();
21f1ee2c:	ebffff85 	bl	21f1ec48 <env_crc_update>
		gd->env_valid = 1;
21f1ee30:	e1a02008 	mov	r2, r8
21f1ee34:	e3a03001 	mov	r3, #1	; 0x1
21f1ee38:	e5823018 	str	r3, [r2, #24]
21f1ee3c:	ea000000 	b	21f1ee44 <env_relocate+0x94>
	}
	else {
		env_relocate_spec ();
21f1ee40:	eb00008a 	bl	21f1f070 <env_relocate_spec>
	}
	gd->env_addr = (ulong)&(env_ptr->data);
21f1ee44:	e1a02008 	mov	r2, r8
21f1ee48:	e59f300c 	ldr	r3, [pc, #12]	; 21f1ee5c <.text+0x1ee5c>
21f1ee4c:	e5933000 	ldr	r3, [r3]
21f1ee50:	e2833004 	add	r3, r3, #4	; 0x4
21f1ee54:	e5823014 	str	r3, [r2, #20]

#ifdef CONFIG_AMIGAONEG3SE
	disable_nvram();
#endif
}
21f1ee58:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1ee5c:	21f339cc 	mvncss	r3, ip, asr #19
21f1ee60:	21f339a4 	mvncss	r3, r4, lsr #19
21f1ee64:	21f1ece8 	mvncss	lr, r8, ror #25
21f1ee68:	21f32244 	mvncss	r2, r4, asr #4
21f1ee6c:	21f339a8 	mvncss	r3, r8, lsr #19

21f1ee70 <env_get_char_spec>:
extern int default_environment_size;


uchar env_get_char_spec (int index)
{
21f1ee70:	e1a0c00d 	mov	ip, sp
21f1ee74:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ee78:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ee7c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1ee80:	e50b0010 	str	r0, [fp, #-16]
	return ( *((uchar *)(gd->env_addr + index)) );
21f1ee84:	e1a03008 	mov	r3, r8
21f1ee88:	e5932014 	ldr	r2, [r3, #20]
21f1ee8c:	e51b3010 	ldr	r3, [fp, #-16]
21f1ee90:	e0823003 	add	r3, r2, r3
21f1ee94:	e5d33000 	ldrb	r3, [r3]
}
21f1ee98:	e1a00003 	mov	r0, r3
21f1ee9c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1eea0 <env_init>:

#ifdef CFG_ENV_ADDR_REDUND

int  env_init(void)
{
	int crc1_ok = 0, crc2_ok = 0;

	uchar flag1 = flash_addr->flags;
	uchar flag2 = flash_addr_new->flags;

	ulong addr_default = (ulong)&default_environment[0];
	ulong addr1 = (ulong)&(flash_addr->data);
	ulong addr2 = (ulong)&(flash_addr_new->data);

#ifdef CONFIG_OMAP2420H4
	int flash_probe(void);

	if(flash_probe() == 0)
		goto bad_flash;
#endif

	crc1_ok = (crc32(0, flash_addr->data, ENV_SIZE) == flash_addr->crc);
	crc2_ok = (crc32(0, flash_addr_new->data, ENV_SIZE) == flash_addr_new->crc);

	if (crc1_ok && ! crc2_ok) {
		gd->env_addr  = addr1;
		gd->env_valid = 1;
	} else if (! crc1_ok && crc2_ok) {
		gd->env_addr  = addr2;
		gd->env_valid = 1;
	} else if (! crc1_ok && ! crc2_ok) {
		gd->env_addr  = addr_default;
		gd->env_valid = 0;
	} else if (flag1 == ACTIVE_FLAG && flag2 == OBSOLETE_FLAG) {
		gd->env_addr  = addr1;
		gd->env_valid = 1;
	} else if (flag1 == OBSOLETE_FLAG && flag2 == ACTIVE_FLAG) {
		gd->env_addr  = addr2;
		gd->env_valid = 1;
	} else if (flag1 == flag2) {
		gd->env_addr  = addr1;
		gd->env_valid = 2;
	} else if (flag1 == 0xFF) {
		gd->env_addr  = addr1;
		gd->env_valid = 2;
	} else if (flag2 == 0xFF) {
		gd->env_addr  = addr2;
		gd->env_valid = 2;
	}

#ifdef CONFIG_OMAP2420H4
bad_flash:
#endif
	return (0);
}

#ifdef CMD_SAVEENV
int saveenv(void)
{
	char *saved_data = NULL;
	int rc = 1;
	char flag = OBSOLETE_FLAG, new_flag = ACTIVE_FLAG;
#if CFG_ENV_SECT_SIZE > CFG_ENV_SIZE
	ulong up_data = 0;
#endif

	debug ("Protect off %08lX ... %08lX\n",
		(ulong)flash_addr, end_addr);

	if (flash_sect_protect (0, (ulong)flash_addr, end_addr)) {
		goto Done;
	}

	debug ("Protect off %08lX ... %08lX\n",
		(ulong)flash_addr_new, end_addr_new);

	if (flash_sect_protect (0, (ulong)flash_addr_new, end_addr_new)) {
		goto Done;
	}

#if CFG_ENV_SECT_SIZE > CFG_ENV_SIZE
	up_data = (end_addr_new + 1 - ((long)flash_addr_new + CFG_ENV_SIZE));
	debug ("Data to save 0x%x\n", up_data);
	if (up_data) {
		if ((saved_data = malloc(up_data)) == NULL) {
			printf("Unable to save the rest of sector (%ld)\n",
				up_data);
			goto Done;
		}
		memcpy(saved_data,
			(void *)((long)flash_addr_new + CFG_ENV_SIZE), up_data);
		debug ("Data (start 0x%x, len 0x%x) saved at 0x%x\n",
			   (long)flash_addr_new + CFG_ENV_SIZE,
				up_data, saved_data);
	}
#endif
	puts ("Erasing Flash...");
	debug (" %08lX ... %08lX ...",
		(ulong)flash_addr_new, end_addr_new);

	if (flash_sect_erase ((ulong)flash_addr_new, end_addr_new)) {
		goto Done;
	}

	puts ("Writing to Flash... ");
	debug (" %08lX ... %08lX ...",
		(ulong)&(flash_addr_new->data),
		sizeof(env_ptr->data)+(ulong)&(flash_addr_new->data));
	if ((rc = flash_write((char *)env_ptr->data,
			(ulong)&(flash_addr_new->data),
			sizeof(env_ptr->data))) ||
	    (rc = flash_write((char *)&(env_ptr->crc),
			(ulong)&(flash_addr_new->crc),
			sizeof(env_ptr->crc))) ||
	    (rc = flash_write(&flag,
			(ulong)&(flash_addr->flags),
			sizeof(flash_addr->flags))) ||
	    (rc = flash_write(&new_flag,
			(ulong)&(flash_addr_new->flags),
			sizeof(flash_addr_new->flags))))
	{
		flash_perror (rc);
		goto Done;
	}
	puts ("done\n");

#if CFG_ENV_SECT_SIZE > CFG_ENV_SIZE
	if (up_data) { /* restore the rest of sector */
		debug ("Restoring the rest of data to 0x%x len 0x%x\n",
			   (long)flash_addr_new + CFG_ENV_SIZE, up_data);
		if (flash_write(saved_data,
				(long)flash_addr_new + CFG_ENV_SIZE,
				up_data)) {
			flash_perror(rc);
			goto Done;
		}
	}
#endif
	{
		env_t * etmp = flash_addr;
		ulong ltmp = end_addr;

		flash_addr = flash_addr_new;
		flash_addr_new = etmp;

		end_addr = end_addr_new;
		end_addr_new = ltmp;
	}

	rc = 0;
Done:

	if (saved_data)
		free (saved_data);
	/* try to re-protect */
	(void) flash_sect_protect (1, (ulong)flash_addr, end_addr);
	(void) flash_sect_protect (1, (ulong)flash_addr_new, end_addr_new);

	return rc;
}
#endif /* CMD_SAVEENV */

#else /* ! CFG_ENV_ADDR_REDUND */

int  env_init(void)
{
21f1eea0:	e1a0c00d 	mov	ip, sp
21f1eea4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1eea8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1eeac:	e24dd004 	sub	sp, sp, #4	; 0x4
#ifdef CONFIG_OMAP2420H4
	int flash_probe(void);

	if(flash_probe() == 0)
		goto bad_flash;
#endif
	if (crc32(0, env_ptr->data, ENV_SIZE) == env_ptr->crc) {
21f1eeb0:	e59f3088 	ldr	r3, [pc, #136]	; 21f1ef40 <.text+0x1ef40>
21f1eeb4:	e5933000 	ldr	r3, [r3]
21f1eeb8:	e2833004 	add	r3, r3, #4	; 0x4
21f1eebc:	e3a00000 	mov	r0, #0	; 0x0
21f1eec0:	e1a01003 	mov	r1, r3
21f1eec4:	e3a02d7f 	mov	r2, #8128	; 0x1fc0
21f1eec8:	e282203c 	add	r2, r2, #60	; 0x3c
21f1eecc:	eb000d09 	bl	21f222f8 <crc32>
21f1eed0:	e1a02000 	mov	r2, r0
21f1eed4:	e59f3064 	ldr	r3, [pc, #100]	; 21f1ef40 <.text+0x1ef40>
21f1eed8:	e5933000 	ldr	r3, [r3]
21f1eedc:	e5933000 	ldr	r3, [r3]
21f1eee0:	e1520003 	cmp	r2, r3
21f1eee4:	1a00000a 	bne	21f1ef14 <env_init+0x74>
		gd->env_addr  = (ulong)&(env_ptr->data);
21f1eee8:	e1a02008 	mov	r2, r8
21f1eeec:	e59f304c 	ldr	r3, [pc, #76]	; 21f1ef40 <.text+0x1ef40>
21f1eef0:	e5933000 	ldr	r3, [r3]
21f1eef4:	e2833004 	add	r3, r3, #4	; 0x4
21f1eef8:	e5823014 	str	r3, [r2, #20]
		gd->env_valid = 1;
21f1eefc:	e1a02008 	mov	r2, r8
21f1ef00:	e3a03001 	mov	r3, #1	; 0x1
21f1ef04:	e5823018 	str	r3, [r2, #24]
		return(0);
21f1ef08:	e3a03000 	mov	r3, #0	; 0x0
21f1ef0c:	e50b3010 	str	r3, [fp, #-16]
21f1ef10:	ea000007 	b	21f1ef34 <env_init+0x94>
	}
#ifdef CONFIG_OMAP2420H4
bad_flash:
#endif
	gd->env_addr  = (ulong)&default_environment[0];
21f1ef14:	e1a02008 	mov	r2, r8
21f1ef18:	e59f3024 	ldr	r3, [pc, #36]	; 21f1ef44 <.text+0x1ef44>
21f1ef1c:	e5823014 	str	r3, [r2, #20]
	gd->env_valid = 0;
21f1ef20:	e1a02008 	mov	r2, r8
21f1ef24:	e3a03000 	mov	r3, #0	; 0x0
21f1ef28:	e5823018 	str	r3, [r2, #24]
	return (0);
21f1ef2c:	e3a03000 	mov	r3, #0	; 0x0
21f1ef30:	e50b3010 	str	r3, [fp, #-16]
21f1ef34:	e51b3010 	ldr	r3, [fp, #-16]
}
21f1ef38:	e1a00003 	mov	r0, r3
21f1ef3c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f1ef40:	21f339cc 	mvncss	r3, ip, asr #19
21f1ef44:	21f339a8 	mvncss	r3, r8, lsr #19

21f1ef48 <saveenv>:

#ifdef CMD_SAVEENV

int saveenv(void)
{
21f1ef48:	e1a0c00d 	mov	ip, sp
21f1ef4c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1ef50:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1ef54:	e24dd01c 	sub	sp, sp, #28	; 0x1c
	int	len, rc;
	ulong	end_addr;
	ulong	flash_sect_addr;
#if defined(CFG_ENV_SECT_SIZE) && (CFG_ENV_SECT_SIZE > CFG_ENV_SIZE)
	ulong	flash_offset;
	uchar	env_buffer[CFG_ENV_SECT_SIZE];
#else
	uchar *env_buffer = (uchar *)env_ptr;
21f1ef58:	e59f30fc 	ldr	r3, [pc, #252]	; 21f1f05c <.text+0x1f05c>
21f1ef5c:	e5933000 	ldr	r3, [r3]
21f1ef60:	e50b3014 	str	r3, [fp, #-20]
#endif	/* CFG_ENV_SECT_SIZE */
	int rcode = 0;
21f1ef64:	e3a03000 	mov	r3, #0	; 0x0
21f1ef68:	e50b3010 	str	r3, [fp, #-16]

#if defined(CFG_ENV_SECT_SIZE) && (CFG_ENV_SECT_SIZE > CFG_ENV_SIZE)

	flash_offset    = ((ulong)flash_addr) & (CFG_ENV_SECT_SIZE-1);
	flash_sect_addr = ((ulong)flash_addr) & ~(CFG_ENV_SECT_SIZE-1);

	debug ( "copy old content: "
		"sect_addr: %08lX  env_addr: %08lX  offset: %08lX\n",
		flash_sect_addr, (ulong)flash_addr, flash_offset);

	/* copy old contents to temporary buffer */
	memcpy (env_buffer, (void *)flash_sect_addr, CFG_ENV_SECT_SIZE);

	/* copy current environment to temporary buffer */
	memcpy ((uchar *)((unsigned long)env_buffer + flash_offset),
		env_ptr,
		CFG_ENV_SIZE);

	len	 = CFG_ENV_SECT_SIZE;
#else
	flash_sect_addr = (ulong)flash_addr;
21f1ef6c:	e59f30ec 	ldr	r3, [pc, #236]	; 21f1f060 <.text+0x1f060>
21f1ef70:	e5933000 	ldr	r3, [r3]
21f1ef74:	e50b3018 	str	r3, [fp, #-24]
	len	 = CFG_ENV_SIZE;
21f1ef78:	e3a03a02 	mov	r3, #8192	; 0x2000
21f1ef7c:	e50b3024 	str	r3, [fp, #-36]
#endif	/* CFG_ENV_SECT_SIZE */

#ifndef CONFIG_INFERNO
	end_addr = flash_sect_addr + len - 1;
21f1ef80:	e51b2024 	ldr	r2, [fp, #-36]
21f1ef84:	e51b3018 	ldr	r3, [fp, #-24]
21f1ef88:	e0823003 	add	r3, r2, r3
21f1ef8c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1ef90:	e50b301c 	str	r3, [fp, #-28]
#else
	/* this is the last sector, and the size is hardcoded here */
	/* otherwise we will get stack problems on loading 128 KB environment */
	end_addr = flash_sect_addr + 0x20000 - 1;
#endif

	debug ("Protect off %08lX ... %08lX\n",
		(ulong)flash_sect_addr, end_addr);

	if (flash_sect_protect (0, flash_sect_addr, end_addr))
21f1ef94:	e3a00000 	mov	r0, #0	; 0x0
21f1ef98:	e51b1018 	ldr	r1, [fp, #-24]
21f1ef9c:	e51b201c 	ldr	r2, [fp, #-28]
21f1efa0:	ebffd8e1 	bl	21f1532c <flash_sect_protect>
21f1efa4:	e1a03000 	mov	r3, r0
21f1efa8:	e3530000 	cmp	r3, #0	; 0x0
21f1efac:	0a000002 	beq	21f1efbc <saveenv+0x74>
		return 1;
21f1efb0:	e3a03001 	mov	r3, #1	; 0x1
21f1efb4:	e50b3028 	str	r3, [fp, #-40]
21f1efb8:	ea000023 	b	21f1f04c <saveenv+0x104>

	puts ("Erasing Flash...");
21f1efbc:	e59f00a0 	ldr	r0, [pc, #160]	; 21f1f064 <.text+0x1f064>
21f1efc0:	ebfff29e 	bl	21f1ba40 <puts>
	if (flash_sect_erase (flash_sect_addr, end_addr))
21f1efc4:	e51b0018 	ldr	r0, [fp, #-24]
21f1efc8:	e51b101c 	ldr	r1, [fp, #-28]
21f1efcc:	ebffd69d 	bl	21f14a48 <flash_sect_erase>
21f1efd0:	e1a03000 	mov	r3, r0
21f1efd4:	e3530000 	cmp	r3, #0	; 0x0
21f1efd8:	0a000002 	beq	21f1efe8 <saveenv+0xa0>
		return 1;
21f1efdc:	e3a03001 	mov	r3, #1	; 0x1
21f1efe0:	e50b3028 	str	r3, [fp, #-40]
21f1efe4:	ea000018 	b	21f1f04c <saveenv+0x104>

	puts ("Writing to Flash... ");
21f1efe8:	e59f0078 	ldr	r0, [pc, #120]	; 21f1f068 <.text+0x1f068>
21f1efec:	ebfff293 	bl	21f1ba40 <puts>
	rc = flash_write((char *)env_buffer, flash_sect_addr, len);
21f1eff0:	e51b3014 	ldr	r3, [fp, #-20]
21f1eff4:	e51b2024 	ldr	r2, [fp, #-36]
21f1eff8:	e1a00003 	mov	r0, r3
21f1effc:	e51b1018 	ldr	r1, [fp, #-24]
21f1f000:	eb000127 	bl	21f1f4a4 <flash_write>
21f1f004:	e1a03000 	mov	r3, r0
21f1f008:	e50b3020 	str	r3, [fp, #-32]
	if (rc != 0) {
21f1f00c:	e51b3020 	ldr	r3, [fp, #-32]
21f1f010:	e3530000 	cmp	r3, #0	; 0x0
21f1f014:	0a000004 	beq	21f1f02c <saveenv+0xe4>
		flash_perror (rc);
21f1f018:	e51b0020 	ldr	r0, [fp, #-32]
21f1f01c:	eb0001cc 	bl	21f1f754 <flash_perror>
		rcode = 1;
21f1f020:	e3a03001 	mov	r3, #1	; 0x1
21f1f024:	e50b3010 	str	r3, [fp, #-16]
21f1f028:	ea000001 	b	21f1f034 <saveenv+0xec>
	} else {
		puts ("done\n");
21f1f02c:	e59f0038 	ldr	r0, [pc, #56]	; 21f1f06c <.text+0x1f06c>
21f1f030:	ebfff282 	bl	21f1ba40 <puts>
	}

	/* try to re-protect */
	(void) flash_sect_protect (1, flash_sect_addr, end_addr);
21f1f034:	e3a00001 	mov	r0, #1	; 0x1
21f1f038:	e51b1018 	ldr	r1, [fp, #-24]
21f1f03c:	e51b201c 	ldr	r2, [fp, #-28]
21f1f040:	ebffd8b9 	bl	21f1532c <flash_sect_protect>
	return rcode;
21f1f044:	e51b3010 	ldr	r3, [fp, #-16]
21f1f048:	e50b3028 	str	r3, [fp, #-40]
21f1f04c:	e51b3028 	ldr	r3, [fp, #-40]
}
21f1f050:	e1a00003 	mov	r0, r3
21f1f054:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1f058:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1f05c:	21f339cc 	mvncss	r3, ip, asr #19
21f1f060:	21f339d0 	ldrcssb	r3, [r3, #144]!
21f1f064:	21f32280 	mvncss	r2, r0, lsl #5
21f1f068:	21f32294 	ldrcsb	r2, [r3, #36]!
21f1f06c:	21f322ac 	mvncss	r2, ip, lsr #5

21f1f070 <env_relocate_spec>:

#endif /* CMD_SAVEENV */

#endif /* CFG_ENV_ADDR_REDUND */

void env_relocate_spec (void)
{
21f1f070:	e1a0c00d 	mov	ip, sp
21f1f074:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f078:	e24cb004 	sub	fp, ip, #4	; 0x4
#if !defined(ENV_IS_EMBEDDED) || defined(CFG_ENV_ADDR_REDUND)
#ifdef CFG_ENV_ADDR_REDUND
	if (gd->env_addr != (ulong)&(flash_addr->data)) {
		env_t * etmp = flash_addr;
		ulong ltmp = end_addr;

		flash_addr = flash_addr_new;
		flash_addr_new = etmp;

		end_addr = end_addr_new;
		end_addr_new = ltmp;
	}

	if (flash_addr_new->flags != OBSOLETE_FLAG &&
	    crc32(0, flash_addr_new->data, ENV_SIZE) ==
	    flash_addr_new->crc) {
		char flag = OBSOLETE_FLAG;

		gd->env_valid = 2;
		flash_sect_protect (0, (ulong)flash_addr_new, end_addr_new);
		flash_write(&flag,
			    (ulong)&(flash_addr_new->flags),
			    sizeof(flash_addr_new->flags));
		flash_sect_protect (1, (ulong)flash_addr_new, end_addr_new);
	}

	if (flash_addr->flags != ACTIVE_FLAG &&
	    (flash_addr->flags & ACTIVE_FLAG) == ACTIVE_FLAG) {
		char flag = ACTIVE_FLAG;

		gd->env_valid = 2;
		flash_sect_protect (0, (ulong)flash_addr, end_addr);
		flash_write(&flag,
			    (ulong)&(flash_addr->flags),
			    sizeof(flash_addr->flags));
		flash_sect_protect (1, (ulong)flash_addr, end_addr);
	}

	if (gd->env_valid == 2)
		puts ("*** Warning - some problems detected "
		      "reading environment; recovered successfully\n\n");
#endif /* CFG_ENV_ADDR_REDUND */
	memcpy (env_ptr, (void*)flash_addr, CFG_ENV_SIZE);
21f1f07c:	e59f301c 	ldr	r3, [pc, #28]	; 21f1f0a0 <.text+0x1f0a0>
21f1f080:	e5932000 	ldr	r2, [r3]
21f1f084:	e59f3018 	ldr	r3, [pc, #24]	; 21f1f0a4 <.text+0x1f0a4>
21f1f088:	e5933000 	ldr	r3, [r3]
21f1f08c:	e1a00002 	mov	r0, r2
21f1f090:	e1a01003 	mov	r1, r3
21f1f094:	e3a02a02 	mov	r2, #8192	; 0x2000
21f1f098:	eb00104b 	bl	21f231cc <memcpy>
#endif /* ! ENV_IS_EMBEDDED || CFG_ENV_ADDR_REDUND */
}
21f1f09c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1f0a0:	21f339cc 	mvncss	r3, ip, asr #19
21f1f0a4:	21f339d0 	ldrcssb	r3, [r3, #144]!

21f1f0a8 <dummy>:

DECLARE_GLOBAL_DATA_PTR;

static void dummy(void)
{
21f1f0a8:	e1a0c00d 	mov	ip, sp
21f1f0ac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f0b0:	e24cb004 	sub	fp, ip, #4	; 0x4
}
21f1f0b4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1f0b8 <get_version>:

unsigned long get_version(void)
{
21f1f0b8:	e1a0c00d 	mov	ip, sp
21f1f0bc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f0c0:	e24cb004 	sub	fp, ip, #4	; 0x4
	return XF_VERSION;
21f1f0c4:	e3a03003 	mov	r3, #3	; 0x3
}
21f1f0c8:	e1a00003 	mov	r0, r3
21f1f0cc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1f0d0 <jumptable_init>:

void jumptable_init (void)
{
21f1f0d0:	e1a0c00d 	mov	ip, sp
21f1f0d4:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f1f0d8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f0dc:	e24dd004 	sub	sp, sp, #4	; 0x4
	int i;

	gd->jt = (void **) malloc (XF_MAX * sizeof (void *));
21f1f0e0:	e1a04008 	mov	r4, r8
21f1f0e4:	e3a00044 	mov	r0, #68	; 0x44
21f1f0e8:	ebfff52e 	bl	21f1c5a8 <malloc>
21f1f0ec:	e1a03000 	mov	r3, r0
21f1f0f0:	e5843020 	str	r3, [r4, #32]
	for (i = 0; i < XF_MAX; i++)
21f1f0f4:	e3a03000 	mov	r3, #0	; 0x0
21f1f0f8:	e50b3014 	str	r3, [fp, #-20]
21f1f0fc:	ea000009 	b	21f1f128 <jumptable_init+0x58>
		gd->jt[i] = (void *) dummy;
21f1f100:	e1a03008 	mov	r3, r8
21f1f104:	e5932020 	ldr	r2, [r3, #32]
21f1f108:	e51b3014 	ldr	r3, [fp, #-20]
21f1f10c:	e1a03103 	mov	r3, r3, lsl #2
21f1f110:	e0822003 	add	r2, r2, r3
21f1f114:	e59f30b8 	ldr	r3, [pc, #184]	; 21f1f1d4 <.text+0x1f1d4>
21f1f118:	e5823000 	str	r3, [r2]
21f1f11c:	e51b3014 	ldr	r3, [fp, #-20]
21f1f120:	e2833001 	add	r3, r3, #1	; 0x1
21f1f124:	e50b3014 	str	r3, [fp, #-20]
21f1f128:	e51b3014 	ldr	r3, [fp, #-20]
21f1f12c:	e3530010 	cmp	r3, #16	; 0x10
21f1f130:	dafffff2 	ble	21f1f100 <jumptable_init+0x30>

	gd->jt[XF_get_version] = (void *) get_version;
21f1f134:	e1a03008 	mov	r3, r8
21f1f138:	e5932020 	ldr	r2, [r3, #32]
21f1f13c:	e59f3094 	ldr	r3, [pc, #148]	; 21f1f1d8 <.text+0x1f1d8>
21f1f140:	e5823000 	str	r3, [r2]
	gd->jt[XF_malloc] = (void *) malloc;
21f1f144:	e1a03008 	mov	r3, r8
21f1f148:	e5933020 	ldr	r3, [r3, #32]
21f1f14c:	e2832020 	add	r2, r3, #32	; 0x20
21f1f150:	e59f3084 	ldr	r3, [pc, #132]	; 21f1f1dc <.text+0x1f1dc>
21f1f154:	e5823000 	str	r3, [r2]
	gd->jt[XF_free] = (void *) free;
21f1f158:	e1a03008 	mov	r3, r8
21f1f15c:	e5933020 	ldr	r3, [r3, #32]
21f1f160:	e2832024 	add	r2, r3, #36	; 0x24
21f1f164:	e59f3074 	ldr	r3, [pc, #116]	; 21f1f1e0 <.text+0x1f1e0>
21f1f168:	e5823000 	str	r3, [r2]
	gd->jt[XF_getenv] = (void *) getenv;
21f1f16c:	e1a03008 	mov	r3, r8
21f1f170:	e5933020 	ldr	r3, [r3, #32]
21f1f174:	e2832038 	add	r2, r3, #56	; 0x38
21f1f178:	e59f3064 	ldr	r3, [pc, #100]	; 21f1f1e4 <.text+0x1f1e4>
21f1f17c:	e5823000 	str	r3, [r2]
	gd->jt[XF_setenv] = (void *) setenv;
21f1f180:	e1a03008 	mov	r3, r8
21f1f184:	e5933020 	ldr	r3, [r3, #32]
21f1f188:	e283203c 	add	r2, r3, #60	; 0x3c
21f1f18c:	e59f3054 	ldr	r3, [pc, #84]	; 21f1f1e8 <.text+0x1f1e8>
21f1f190:	e5823000 	str	r3, [r2]
	gd->jt[XF_get_timer] = (void *) get_timer;
21f1f194:	e1a03008 	mov	r3, r8
21f1f198:	e5933020 	ldr	r3, [r3, #32]
21f1f19c:	e283202c 	add	r2, r3, #44	; 0x2c
21f1f1a0:	e59f3044 	ldr	r3, [pc, #68]	; 21f1f1ec <.text+0x1f1ec>
21f1f1a4:	e5823000 	str	r3, [r2]
	gd->jt[XF_simple_strtoul] = (void *) simple_strtoul;
21f1f1a8:	e1a03008 	mov	r3, r8
21f1f1ac:	e5933020 	ldr	r3, [r3, #32]
21f1f1b0:	e2832040 	add	r2, r3, #64	; 0x40
21f1f1b4:	e59f3034 	ldr	r3, [pc, #52]	; 21f1f1f0 <.text+0x1f1f0>
21f1f1b8:	e5823000 	str	r3, [r2]
	gd->jt[XF_udelay] = (void *) udelay;
21f1f1bc:	e1a03008 	mov	r3, r8
21f1f1c0:	e5933020 	ldr	r3, [r3, #32]
21f1f1c4:	e2832028 	add	r2, r3, #40	; 0x28
21f1f1c8:	e59f3024 	ldr	r3, [pc, #36]	; 21f1f1f4 <.text+0x1f1f4>
21f1f1cc:	e5823000 	str	r3, [r2]
#if defined(CONFIG_I386) || defined(CONFIG_PPC)
	gd->jt[XF_install_hdlr] = (void *) irq_install_handler;
	gd->jt[XF_free_hdlr] = (void *) irq_free_handler;
#endif	/* I386 || PPC */
#if (CONFIG_COMMANDS & CFG_CMD_I2C)
	gd->jt[XF_i2c_write] = (void *) i2c_write;
	gd->jt[XF_i2c_read] = (void *) i2c_read;
#endif	/* CFG_CMD_I2C */
}
21f1f1d0:	e89da818 	ldmia	sp, {r3, r4, fp, sp, pc}
21f1f1d4:	21f1f0a8 	mvncss	pc, r8, lsr #1
21f1f1d8:	21f1f0b8 	ldrcsh	pc, [r1, #8]!
21f1f1dc:	21f1c5a8 	mvncss	ip, r8, lsr #11
21f1f1e0:	21f1d14c 	mvncss	sp, ip, asr #2
21f1f1e4:	21f1ac18 	mvncss	sl, r8, lsl ip
21f1f1e8:	21f1ab48 	mvncss	sl, r8, asr #22
21f1f1ec:	21f00a54 	mvncss	r0, r4, asr sl
21f1f1f0:	21f235c8 	mvncss	r3, r8, asr #11
21f1f1f4:	21f00aa8 	mvncss	r0, r8, lsr #21

21f1f1f8 <flash_protect>:
 * If necessary you have to map the second bank at lower addresses.
 */
void
flash_protect (int flag, ulong from, ulong to, flash_info_t *info)
{
21f1f1f8:	e1a0c00d 	mov	ip, sp
21f1f1fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f200:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f204:	e24dd024 	sub	sp, sp, #36	; 0x24
21f1f208:	e50b0020 	str	r0, [fp, #-32]
21f1f20c:	e50b1024 	str	r1, [fp, #-36]
21f1f210:	e50b2028 	str	r2, [fp, #-40]
21f1f214:	e50b302c 	str	r3, [fp, #-44]
	ulong b_end = info->start[0] + info->size - 1;	/* bank end address */
21f1f218:	e51b302c 	ldr	r3, [fp, #-44]
21f1f21c:	e593200c 	ldr	r2, [r3, #12]
21f1f220:	e51b302c 	ldr	r3, [fp, #-44]
21f1f224:	e5933000 	ldr	r3, [r3]
21f1f228:	e0823003 	add	r3, r2, r3
21f1f22c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1f230:	e50b301c 	str	r3, [fp, #-28]
	short s_end = info->sector_count - 1;	/* index of last sector */
21f1f234:	e51b302c 	ldr	r3, [fp, #-44]
21f1f238:	e1d330b4 	ldrh	r3, [r3, #4]
21f1f23c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1f240:	e14b31b6 	strh	r3, [fp, #-22]
	int i;

	debug ("flash_protect %s: from 0x%08lX to 0x%08lX\n",
		(flag & FLAG_PROTECT_SET) ? "ON" :
			(flag & FLAG_PROTECT_CLEAR) ? "OFF" : "???",
		from, to);

	/* Do nothing if input data is bad. */
	if (info->sector_count == 0 || info->size == 0 || to < from) {
21f1f244:	e51b302c 	ldr	r3, [fp, #-44]
21f1f248:	e1d330b4 	ldrh	r3, [r3, #4]
21f1f24c:	e3530000 	cmp	r3, #0	; 0x0
21f1f250:	0a00005f 	beq	21f1f3d4 <flash_protect+0x1dc>
21f1f254:	e51b302c 	ldr	r3, [fp, #-44]
21f1f258:	e5933000 	ldr	r3, [r3]
21f1f25c:	e3530000 	cmp	r3, #0	; 0x0
21f1f260:	0a00005b 	beq	21f1f3d4 <flash_protect+0x1dc>
21f1f264:	e51b2028 	ldr	r2, [fp, #-40]
21f1f268:	e51b3024 	ldr	r3, [fp, #-36]
21f1f26c:	e1520003 	cmp	r2, r3
21f1f270:	3a000057 	bcc	21f1f3d4 <flash_protect+0x1dc>
		return;
	}

	/* There is nothing to do if we have no data about the flash
	 * or the protect range and flash range don't overlap.
	 */
	if (info->flash_id == FLASH_UNKNOWN ||
21f1f274:	e51b302c 	ldr	r3, [fp, #-44]
21f1f278:	e5932008 	ldr	r2, [r3, #8]
21f1f27c:	e3a03cff 	mov	r3, #65280	; 0xff00
21f1f280:	e28330ff 	add	r3, r3, #255	; 0xff
21f1f284:	e1520003 	cmp	r2, r3
21f1f288:	0a000051 	beq	21f1f3d4 <flash_protect+0x1dc>
21f1f28c:	e51b302c 	ldr	r3, [fp, #-44]
21f1f290:	e593200c 	ldr	r2, [r3, #12]
21f1f294:	e51b3028 	ldr	r3, [fp, #-40]
21f1f298:	e1520003 	cmp	r2, r3
21f1f29c:	8a00004c 	bhi	21f1f3d4 <flash_protect+0x1dc>
21f1f2a0:	e51b2024 	ldr	r2, [fp, #-36]
21f1f2a4:	e51b301c 	ldr	r3, [fp, #-28]
21f1f2a8:	e1520003 	cmp	r2, r3
21f1f2ac:	8a000048 	bhi	21f1f3d4 <flash_protect+0x1dc>
	    to < info->start[0] || from > b_end) {
		return;
	}

	for (i=0; i<info->sector_count; ++i) {
21f1f2b0:	e3a03000 	mov	r3, #0	; 0x0
21f1f2b4:	e50b3014 	str	r3, [fp, #-20]
21f1f2b8:	ea00003f 	b	21f1f3bc <flash_protect+0x1c4>
		ulong end;		/* last address in current sect	*/

		end = (i == s_end) ? b_end : info->start[i + 1] - 1;
21f1f2bc:	e15b21f6 	ldrsh	r2, [fp, #-22]
21f1f2c0:	e51b3014 	ldr	r3, [fp, #-20]
21f1f2c4:	e1520003 	cmp	r2, r3
21f1f2c8:	0a00000a 	beq	21f1f2f8 <flash_protect+0x100>
21f1f2cc:	e51b3014 	ldr	r3, [fp, #-20]
21f1f2d0:	e2833001 	add	r3, r3, #1	; 0x1
21f1f2d4:	e51b202c 	ldr	r2, [fp, #-44]
21f1f2d8:	e3a0100c 	mov	r1, #12	; 0xc
21f1f2dc:	e1a03103 	mov	r3, r3, lsl #2
21f1f2e0:	e0833002 	add	r3, r3, r2
21f1f2e4:	e0833001 	add	r3, r3, r1
21f1f2e8:	e5933000 	ldr	r3, [r3]
21f1f2ec:	e2433001 	sub	r3, r3, #1	; 0x1
21f1f2f0:	e50b3030 	str	r3, [fp, #-48]
21f1f2f4:	ea000001 	b	21f1f300 <flash_protect+0x108>
21f1f2f8:	e51b301c 	ldr	r3, [fp, #-28]
21f1f2fc:	e50b3030 	str	r3, [fp, #-48]
21f1f300:	e51b3030 	ldr	r3, [fp, #-48]
21f1f304:	e50b3010 	str	r3, [fp, #-16]

		/* Update protection if any part of the sector
		 * is in the specified range.
		 */
		if (from <= end && to >= info->start[i]) {
21f1f308:	e51b2024 	ldr	r2, [fp, #-36]
21f1f30c:	e51b3010 	ldr	r3, [fp, #-16]
21f1f310:	e1520003 	cmp	r2, r3
21f1f314:	8a000025 	bhi	21f1f3b0 <flash_protect+0x1b8>
21f1f318:	e51b3014 	ldr	r3, [fp, #-20]
21f1f31c:	e51b202c 	ldr	r2, [fp, #-44]
21f1f320:	e3a0100c 	mov	r1, #12	; 0xc
21f1f324:	e1a03103 	mov	r3, r3, lsl #2
21f1f328:	e0833002 	add	r3, r3, r2
21f1f32c:	e0833001 	add	r3, r3, r1
21f1f330:	e5932000 	ldr	r2, [r3]
21f1f334:	e51b3028 	ldr	r3, [fp, #-40]
21f1f338:	e1520003 	cmp	r2, r3
21f1f33c:	8a00001b 	bhi	21f1f3b0 <flash_protect+0x1b8>
			if (flag & FLAG_PROTECT_CLEAR) {
21f1f340:	e51b3020 	ldr	r3, [fp, #-32]
21f1f344:	e1a030a3 	mov	r3, r3, lsr #1
21f1f348:	e2033001 	and	r3, r3, #1	; 0x1
21f1f34c:	e20330ff 	and	r3, r3, #255	; 0xff
21f1f350:	e3530000 	cmp	r3, #0	; 0x0
21f1f354:	0a000008 	beq	21f1f37c <flash_protect+0x184>
#if defined(CFG_FLASH_PROTECTION)
				flash_real_protect(info, i, 0);
#else
				info->protect[i] = 0;
21f1f358:	e51b1014 	ldr	r1, [fp, #-20]
21f1f35c:	e51b202c 	ldr	r2, [fp, #-44]
21f1f360:	e3a03b01 	mov	r3, #1024	; 0x400
21f1f364:	e283300c 	add	r3, r3, #12	; 0xc
21f1f368:	e0812002 	add	r2, r1, r2
21f1f36c:	e0822003 	add	r2, r2, r3
21f1f370:	e3a03000 	mov	r3, #0	; 0x0
21f1f374:	e5c23000 	strb	r3, [r2]
21f1f378:	ea00000c 	b	21f1f3b0 <flash_protect+0x1b8>
#endif	/* CFG_FLASH_PROTECTION */
				debug ("protect off %d\n", i);
			}
			else if (flag & FLAG_PROTECT_SET) {
21f1f37c:	e51b3020 	ldr	r3, [fp, #-32]
21f1f380:	e2033001 	and	r3, r3, #1	; 0x1
21f1f384:	e20330ff 	and	r3, r3, #255	; 0xff
21f1f388:	e3530000 	cmp	r3, #0	; 0x0
21f1f38c:	0a000007 	beq	21f1f3b0 <flash_protect+0x1b8>
#if defined(CFG_FLASH_PROTECTION)
				flash_real_protect(info, i, 1);
#else
				info->protect[i] = 1;
21f1f390:	e51b1014 	ldr	r1, [fp, #-20]
21f1f394:	e51b202c 	ldr	r2, [fp, #-44]
21f1f398:	e3a03b01 	mov	r3, #1024	; 0x400
21f1f39c:	e283300c 	add	r3, r3, #12	; 0xc
21f1f3a0:	e0812002 	add	r2, r1, r2
21f1f3a4:	e0822003 	add	r2, r2, r3
21f1f3a8:	e3a03001 	mov	r3, #1	; 0x1
21f1f3ac:	e5c23000 	strb	r3, [r2]
21f1f3b0:	e51b3014 	ldr	r3, [fp, #-20]
21f1f3b4:	e2833001 	add	r3, r3, #1	; 0x1
21f1f3b8:	e50b3014 	str	r3, [fp, #-20]
21f1f3bc:	e51b302c 	ldr	r3, [fp, #-44]
21f1f3c0:	e1d330b4 	ldrh	r3, [r3, #4]
21f1f3c4:	e1a02003 	mov	r2, r3
21f1f3c8:	e51b3014 	ldr	r3, [fp, #-20]
21f1f3cc:	e1520003 	cmp	r2, r3
21f1f3d0:	caffffb9 	bgt	21f1f2bc <flash_protect+0xc4>
#endif	/* CFG_FLASH_PROTECTION */
				debug ("protect on %d\n", i);
			}
		}
	}
}
21f1f3d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1f3d8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1f3dc <addr2info>:

/*-----------------------------------------------------------------------
 */

flash_info_t *
addr2info (ulong addr)
{
21f1f3dc:	e1a0c00d 	mov	ip, sp
21f1f3e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f3e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f3e8:	e24dd010 	sub	sp, sp, #16	; 0x10
21f1f3ec:	e50b0018 	str	r0, [fp, #-24]
#ifndef CONFIG_SPD823TS
	flash_info_t *info;
	int i;

	for (i=0, info=&flash_info[0]; i<CFG_MAX_FLASH_BANKS; ++i, ++info) {
21f1f3f0:	e3a03000 	mov	r3, #0	; 0x0
21f1f3f4:	e50b3010 	str	r3, [fp, #-16]
21f1f3f8:	e59f30a0 	ldr	r3, [pc, #160]	; 21f1f4a0 <.text+0x1f4a0>
21f1f3fc:	e50b3014 	str	r3, [fp, #-20]
21f1f400:	ea00001d 	b	21f1f47c <addr2info+0xa0>
		if (info->flash_id != FLASH_UNKNOWN &&
21f1f404:	e51b3014 	ldr	r3, [fp, #-20]
21f1f408:	e5932008 	ldr	r2, [r3, #8]
21f1f40c:	e3a03cff 	mov	r3, #65280	; 0xff00
21f1f410:	e28330ff 	add	r3, r3, #255	; 0xff
21f1f414:	e1520003 	cmp	r2, r3
21f1f418:	0a000010 	beq	21f1f460 <addr2info+0x84>
21f1f41c:	e51b3014 	ldr	r3, [fp, #-20]
21f1f420:	e593200c 	ldr	r2, [r3, #12]
21f1f424:	e51b3018 	ldr	r3, [fp, #-24]
21f1f428:	e1520003 	cmp	r2, r3
21f1f42c:	8a00000b 	bhi	21f1f460 <addr2info+0x84>
21f1f430:	e51b3014 	ldr	r3, [fp, #-20]
21f1f434:	e593200c 	ldr	r2, [r3, #12]
21f1f438:	e51b3014 	ldr	r3, [fp, #-20]
21f1f43c:	e5933000 	ldr	r3, [r3]
21f1f440:	e0823003 	add	r3, r2, r3
21f1f444:	e2432001 	sub	r2, r3, #1	; 0x1
21f1f448:	e51b3018 	ldr	r3, [fp, #-24]
21f1f44c:	e1520003 	cmp	r2, r3
21f1f450:	3a000002 	bcc	21f1f460 <addr2info+0x84>
		    addr >= info->start[0] &&
		    /* WARNING - The '- 1' is needed if the flash
		     * is at the end of the address space, since
		     * info->start[0] + info->size wraps back to 0.
		     * Please don't change this unless you understand this.
		     */
		    addr <= info->start[0] + info->size - 1) {
			return (info);
21f1f454:	e51b3014 	ldr	r3, [fp, #-20]
21f1f458:	e50b301c 	str	r3, [fp, #-28]
21f1f45c:	ea00000b 	b	21f1f490 <addr2info+0xb4>
21f1f460:	e51b3010 	ldr	r3, [fp, #-16]
21f1f464:	e2833001 	add	r3, r3, #1	; 0x1
21f1f468:	e50b3010 	str	r3, [fp, #-16]
21f1f46c:	e51b3014 	ldr	r3, [fp, #-20]
21f1f470:	e2833c05 	add	r3, r3, #1280	; 0x500
21f1f474:	e283300c 	add	r3, r3, #12	; 0xc
21f1f478:	e50b3014 	str	r3, [fp, #-20]
21f1f47c:	e51b3010 	ldr	r3, [fp, #-16]
21f1f480:	e3530000 	cmp	r3, #0	; 0x0
21f1f484:	daffffde 	ble	21f1f404 <addr2info+0x28>
		}
	}
#endif /* CONFIG_SPD823TS */

	return (NULL);
21f1f488:	e3a03000 	mov	r3, #0	; 0x0
21f1f48c:	e50b301c 	str	r3, [fp, #-28]
21f1f490:	e51b301c 	ldr	r3, [fp, #-28]
}
21f1f494:	e1a00003 	mov	r0, r3
21f1f498:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1f49c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1f4a0:	21f68ca0 	mvncss	r8, r0, lsr #25

21f1f4a4 <flash_write>:

/*-----------------------------------------------------------------------
 * Copy memory to flash.
 * Make sure all target addresses are within Flash bounds,
 * and no protected sectors are hit.
 * Returns:
 * ERR_OK          0 - OK
 * ERR_TIMOUT      1 - write timeout
 * ERR_NOT_ERASED  2 - Flash not erased
 * ERR_PROTECTED   4 - target range includes protected sectors
 * ERR_INVAL       8 - target address not in Flash memory
 * ERR_ALIGN       16 - target address not aligned on boundary
 *			(only some targets require alignment)
 */
int
flash_write (char *src, ulong addr, ulong cnt)
{
21f1f4a4:	e1a0c00d 	mov	ip, sp
21f1f4a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f4ac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f4b0:	e24dd038 	sub	sp, sp, #56	; 0x38
21f1f4b4:	e50b0034 	str	r0, [fp, #-52]
21f1f4b8:	e50b1038 	str	r1, [fp, #-56]
21f1f4bc:	e50b203c 	str	r2, [fp, #-60]
#ifdef CONFIG_SPD823TS
	return (ERR_TIMOUT);	/* any other error codes are possible as well */
#else
	int i;
	ulong         end        = addr + cnt - 1;
21f1f4c0:	e51b2038 	ldr	r2, [fp, #-56]
21f1f4c4:	e51b303c 	ldr	r3, [fp, #-60]
21f1f4c8:	e0823003 	add	r3, r2, r3
21f1f4cc:	e2433001 	sub	r3, r3, #1	; 0x1
21f1f4d0:	e50b302c 	str	r3, [fp, #-44]
	flash_info_t *info_first = addr2info (addr);
21f1f4d4:	e51b0038 	ldr	r0, [fp, #-56]
21f1f4d8:	ebffffbf 	bl	21f1f3dc <addr2info>
21f1f4dc:	e1a03000 	mov	r3, r0
21f1f4e0:	e50b3028 	str	r3, [fp, #-40]
	flash_info_t *info_last  = addr2info (end );
21f1f4e4:	e51b002c 	ldr	r0, [fp, #-44]
21f1f4e8:	ebffffbb 	bl	21f1f3dc <addr2info>
21f1f4ec:	e1a03000 	mov	r3, r0
21f1f4f0:	e50b3024 	str	r3, [fp, #-36]
	flash_info_t *info;

	if (cnt == 0) {
21f1f4f4:	e51b303c 	ldr	r3, [fp, #-60]
21f1f4f8:	e3530000 	cmp	r3, #0	; 0x0
21f1f4fc:	1a000002 	bne	21f1f50c <flash_write+0x68>
		return (ERR_OK);
21f1f500:	e3a03000 	mov	r3, #0	; 0x0
21f1f504:	e50b3044 	str	r3, [fp, #-68]
21f1f508:	ea00008d 	b	21f1f744 <flash_write+0x2a0>
	}

	if (!info_first || !info_last) {
21f1f50c:	e51b3028 	ldr	r3, [fp, #-40]
21f1f510:	e3530000 	cmp	r3, #0	; 0x0
21f1f514:	0a000002 	beq	21f1f524 <flash_write+0x80>
21f1f518:	e51b3024 	ldr	r3, [fp, #-36]
21f1f51c:	e3530000 	cmp	r3, #0	; 0x0
21f1f520:	1a000002 	bne	21f1f530 <flash_write+0x8c>
		return (ERR_INVAL);
21f1f524:	e3a03008 	mov	r3, #8	; 0x8
21f1f528:	e50b3044 	str	r3, [fp, #-68]
21f1f52c:	ea000084 	b	21f1f744 <flash_write+0x2a0>
	}

	for (info = info_first; info <= info_last; ++info) {
21f1f530:	e51b3028 	ldr	r3, [fp, #-40]
21f1f534:	e50b3020 	str	r3, [fp, #-32]
21f1f538:	ea000045 	b	21f1f654 <flash_write+0x1b0>
		ulong b_end = info->start[0] + info->size;	/* bank end addr */
21f1f53c:	e51b3020 	ldr	r3, [fp, #-32]
21f1f540:	e593200c 	ldr	r2, [r3, #12]
21f1f544:	e51b3020 	ldr	r3, [fp, #-32]
21f1f548:	e5933000 	ldr	r3, [r3]
21f1f54c:	e0823003 	add	r3, r2, r3
21f1f550:	e50b301c 	str	r3, [fp, #-28]
		short s_end = info->sector_count - 1;
21f1f554:	e51b3020 	ldr	r3, [fp, #-32]
21f1f558:	e1d330b4 	ldrh	r3, [r3, #4]
21f1f55c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1f560:	e14b31b6 	strh	r3, [fp, #-22]
		for (i=0; i<info->sector_count; ++i) {
21f1f564:	e3a03000 	mov	r3, #0	; 0x0
21f1f568:	e50b3030 	str	r3, [fp, #-48]
21f1f56c:	ea00002e 	b	21f1f62c <flash_write+0x188>
			ulong e_addr = (i == s_end) ? b_end : info->start[i + 1];
21f1f570:	e15b21f6 	ldrsh	r2, [fp, #-22]
21f1f574:	e51b3030 	ldr	r3, [fp, #-48]
21f1f578:	e1520003 	cmp	r2, r3
21f1f57c:	0a000009 	beq	21f1f5a8 <flash_write+0x104>
21f1f580:	e51b3030 	ldr	r3, [fp, #-48]
21f1f584:	e2833001 	add	r3, r3, #1	; 0x1
21f1f588:	e51b2020 	ldr	r2, [fp, #-32]
21f1f58c:	e3a0100c 	mov	r1, #12	; 0xc
21f1f590:	e1a03103 	mov	r3, r3, lsl #2
21f1f594:	e0833002 	add	r3, r3, r2
21f1f598:	e0833001 	add	r3, r3, r1
21f1f59c:	e5933000 	ldr	r3, [r3]
21f1f5a0:	e50b3040 	str	r3, [fp, #-64]
21f1f5a4:	ea000001 	b	21f1f5b0 <flash_write+0x10c>
21f1f5a8:	e51b301c 	ldr	r3, [fp, #-28]
21f1f5ac:	e50b3040 	str	r3, [fp, #-64]
21f1f5b0:	e51b3040 	ldr	r3, [fp, #-64]
21f1f5b4:	e50b3014 	str	r3, [fp, #-20]

			if ((end >= info->start[i]) && (addr < e_addr) &&
21f1f5b8:	e51b3030 	ldr	r3, [fp, #-48]
21f1f5bc:	e51b2020 	ldr	r2, [fp, #-32]
21f1f5c0:	e3a0100c 	mov	r1, #12	; 0xc
21f1f5c4:	e1a03103 	mov	r3, r3, lsl #2
21f1f5c8:	e0833002 	add	r3, r3, r2
21f1f5cc:	e0833001 	add	r3, r3, r1
21f1f5d0:	e5932000 	ldr	r2, [r3]
21f1f5d4:	e51b302c 	ldr	r3, [fp, #-44]
21f1f5d8:	e1520003 	cmp	r2, r3
21f1f5dc:	8a00000f 	bhi	21f1f620 <flash_write+0x17c>
21f1f5e0:	e51b2038 	ldr	r2, [fp, #-56]
21f1f5e4:	e51b3014 	ldr	r3, [fp, #-20]
21f1f5e8:	e1520003 	cmp	r2, r3
21f1f5ec:	2a00000b 	bcs	21f1f620 <flash_write+0x17c>
21f1f5f0:	e51b1030 	ldr	r1, [fp, #-48]
21f1f5f4:	e51b2020 	ldr	r2, [fp, #-32]
21f1f5f8:	e3a03b01 	mov	r3, #1024	; 0x400
21f1f5fc:	e283300c 	add	r3, r3, #12	; 0xc
21f1f600:	e0812002 	add	r2, r1, r2
21f1f604:	e0823003 	add	r3, r2, r3
21f1f608:	e5d33000 	ldrb	r3, [r3]
21f1f60c:	e3530000 	cmp	r3, #0	; 0x0
21f1f610:	0a000002 	beq	21f1f620 <flash_write+0x17c>
			    (info->protect[i] != 0) ) {
				return (ERR_PROTECTED);
21f1f614:	e3a03004 	mov	r3, #4	; 0x4
21f1f618:	e50b3044 	str	r3, [fp, #-68]
21f1f61c:	ea000048 	b	21f1f744 <flash_write+0x2a0>
21f1f620:	e51b3030 	ldr	r3, [fp, #-48]
21f1f624:	e2833001 	add	r3, r3, #1	; 0x1
21f1f628:	e50b3030 	str	r3, [fp, #-48]
21f1f62c:	e51b3020 	ldr	r3, [fp, #-32]
21f1f630:	e1d330b4 	ldrh	r3, [r3, #4]
21f1f634:	e1a02003 	mov	r2, r3
21f1f638:	e51b3030 	ldr	r3, [fp, #-48]
21f1f63c:	e1520003 	cmp	r2, r3
21f1f640:	caffffca 	bgt	21f1f570 <flash_write+0xcc>
21f1f644:	e51b3020 	ldr	r3, [fp, #-32]
21f1f648:	e2833c05 	add	r3, r3, #1280	; 0x500
21f1f64c:	e283300c 	add	r3, r3, #12	; 0xc
21f1f650:	e50b3020 	str	r3, [fp, #-32]
21f1f654:	e51b2020 	ldr	r2, [fp, #-32]
21f1f658:	e51b3024 	ldr	r3, [fp, #-36]
21f1f65c:	e1520003 	cmp	r2, r3
21f1f660:	9affffb5 	bls	21f1f53c <flash_write+0x98>
			}
		}
	}

	/* finally write data to flash */
	for (info = info_first; info <= info_last && cnt>0; ++info) {
21f1f664:	e51b3028 	ldr	r3, [fp, #-40]
21f1f668:	e50b3020 	str	r3, [fp, #-32]
21f1f66c:	ea00002b 	b	21f1f720 <flash_write+0x27c>
		ulong len;

		len = info->start[0] + info->size - addr;
21f1f670:	e51b3020 	ldr	r3, [fp, #-32]
21f1f674:	e593200c 	ldr	r2, [r3, #12]
21f1f678:	e51b3020 	ldr	r3, [fp, #-32]
21f1f67c:	e5933000 	ldr	r3, [r3]
21f1f680:	e0822003 	add	r2, r2, r3
21f1f684:	e51b3038 	ldr	r3, [fp, #-56]
21f1f688:	e0633002 	rsb	r3, r3, r2
21f1f68c:	e50b3010 	str	r3, [fp, #-16]
		if (len > cnt)
21f1f690:	e51b2010 	ldr	r2, [fp, #-16]
21f1f694:	e51b303c 	ldr	r3, [fp, #-60]
21f1f698:	e1520003 	cmp	r2, r3
21f1f69c:	9a000001 	bls	21f1f6a8 <flash_write+0x204>
			len = cnt;
21f1f6a0:	e51b303c 	ldr	r3, [fp, #-60]
21f1f6a4:	e50b3010 	str	r3, [fp, #-16]
		if ((i = write_buff(info, (uchar *)src, addr, len)) != 0) {
21f1f6a8:	e51b3034 	ldr	r3, [fp, #-52]
21f1f6ac:	e51b0020 	ldr	r0, [fp, #-32]
21f1f6b0:	e1a01003 	mov	r1, r3
21f1f6b4:	e51b2038 	ldr	r2, [fp, #-56]
21f1f6b8:	e51b3010 	ldr	r3, [fp, #-16]
21f1f6bc:	eb0036da 	bl	21f2d22c <write_buff>
21f1f6c0:	e1a03000 	mov	r3, r0
21f1f6c4:	e50b3030 	str	r3, [fp, #-48]
21f1f6c8:	e51b3030 	ldr	r3, [fp, #-48]
21f1f6cc:	e3530000 	cmp	r3, #0	; 0x0
21f1f6d0:	0a000002 	beq	21f1f6e0 <flash_write+0x23c>
			return (i);
21f1f6d4:	e51b3030 	ldr	r3, [fp, #-48]
21f1f6d8:	e50b3044 	str	r3, [fp, #-68]
21f1f6dc:	ea000018 	b	21f1f744 <flash_write+0x2a0>
		}
		cnt  -= len;
21f1f6e0:	e51b203c 	ldr	r2, [fp, #-60]
21f1f6e4:	e51b3010 	ldr	r3, [fp, #-16]
21f1f6e8:	e0633002 	rsb	r3, r3, r2
21f1f6ec:	e50b303c 	str	r3, [fp, #-60]
		addr += len;
21f1f6f0:	e51b2038 	ldr	r2, [fp, #-56]
21f1f6f4:	e51b3010 	ldr	r3, [fp, #-16]
21f1f6f8:	e0823003 	add	r3, r2, r3
21f1f6fc:	e50b3038 	str	r3, [fp, #-56]
		src  += len;
21f1f700:	e51b2010 	ldr	r2, [fp, #-16]
21f1f704:	e51b3034 	ldr	r3, [fp, #-52]
21f1f708:	e0833002 	add	r3, r3, r2
21f1f70c:	e50b3034 	str	r3, [fp, #-52]
21f1f710:	e51b3020 	ldr	r3, [fp, #-32]
21f1f714:	e2833c05 	add	r3, r3, #1280	; 0x500
21f1f718:	e283300c 	add	r3, r3, #12	; 0xc
21f1f71c:	e50b3020 	str	r3, [fp, #-32]
21f1f720:	e51b2020 	ldr	r2, [fp, #-32]
21f1f724:	e51b3024 	ldr	r3, [fp, #-36]
21f1f728:	e1520003 	cmp	r2, r3
21f1f72c:	8a000002 	bhi	21f1f73c <flash_write+0x298>
21f1f730:	e51b303c 	ldr	r3, [fp, #-60]
21f1f734:	e3530000 	cmp	r3, #0	; 0x0
21f1f738:	1affffcc 	bne	21f1f670 <flash_write+0x1cc>
	}
	return (ERR_OK);
21f1f73c:	e3a03000 	mov	r3, #0	; 0x0
21f1f740:	e50b3044 	str	r3, [fp, #-68]
21f1f744:	e51b3044 	ldr	r3, [fp, #-68]
#endif /* CONFIG_SPD823TS */
}
21f1f748:	e1a00003 	mov	r0, r3
21f1f74c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1f750:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1f754 <flash_perror>:

/*-----------------------------------------------------------------------
 */

void flash_perror (int err)
{
21f1f754:	e1a0c00d 	mov	ip, sp
21f1f758:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f75c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f760:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1f764:	e50b0010 	str	r0, [fp, #-16]
	switch (err) {
21f1f768:	e51b3010 	ldr	r3, [fp, #-16]
21f1f76c:	e50b3014 	str	r3, [fp, #-20]
21f1f770:	e51b3014 	ldr	r3, [fp, #-20]
21f1f774:	e3530008 	cmp	r3, #8	; 0x8
21f1f778:	0a00002d 	beq	21f1f834 <flash_perror+0xe0>
21f1f77c:	e51b3014 	ldr	r3, [fp, #-20]
21f1f780:	e3530008 	cmp	r3, #8	; 0x8
21f1f784:	ca000010 	bgt	21f1f7cc <flash_perror+0x78>
21f1f788:	e51b3014 	ldr	r3, [fp, #-20]
21f1f78c:	e3530001 	cmp	r3, #1	; 0x1
21f1f790:	0a00001e 	beq	21f1f810 <flash_perror+0xbc>
21f1f794:	e51b3014 	ldr	r3, [fp, #-20]
21f1f798:	e3530001 	cmp	r3, #1	; 0x1
21f1f79c:	ca000003 	bgt	21f1f7b0 <flash_perror+0x5c>
21f1f7a0:	e51b3014 	ldr	r3, [fp, #-20]
21f1f7a4:	e3530000 	cmp	r3, #0	; 0x0
21f1f7a8:	0a000035 	beq	21f1f884 <flash_perror+0x130>
21f1f7ac:	ea00002f 	b	21f1f870 <flash_perror+0x11c>
21f1f7b0:	e51b3014 	ldr	r3, [fp, #-20]
21f1f7b4:	e3530002 	cmp	r3, #2	; 0x2
21f1f7b8:	0a000017 	beq	21f1f81c <flash_perror+0xc8>
21f1f7bc:	e51b3014 	ldr	r3, [fp, #-20]
21f1f7c0:	e3530004 	cmp	r3, #4	; 0x4
21f1f7c4:	0a000017 	beq	21f1f828 <flash_perror+0xd4>
21f1f7c8:	ea000028 	b	21f1f870 <flash_perror+0x11c>
21f1f7cc:	e51b3014 	ldr	r3, [fp, #-20]
21f1f7d0:	e3530020 	cmp	r3, #32	; 0x20
21f1f7d4:	0a00001c 	beq	21f1f84c <flash_perror+0xf8>
21f1f7d8:	e51b3014 	ldr	r3, [fp, #-20]
21f1f7dc:	e3530020 	cmp	r3, #32	; 0x20
21f1f7e0:	ca000003 	bgt	21f1f7f4 <flash_perror+0xa0>
21f1f7e4:	e51b3014 	ldr	r3, [fp, #-20]
21f1f7e8:	e3530010 	cmp	r3, #16	; 0x10
21f1f7ec:	0a000013 	beq	21f1f840 <flash_perror+0xec>
21f1f7f0:	ea00001e 	b	21f1f870 <flash_perror+0x11c>
21f1f7f4:	e51b3014 	ldr	r3, [fp, #-20]
21f1f7f8:	e3530040 	cmp	r3, #64	; 0x40
21f1f7fc:	0a000015 	beq	21f1f858 <flash_perror+0x104>
21f1f800:	e51b3014 	ldr	r3, [fp, #-20]
21f1f804:	e3530080 	cmp	r3, #128	; 0x80
21f1f808:	0a000015 	beq	21f1f864 <flash_perror+0x110>
21f1f80c:	ea000017 	b	21f1f870 <flash_perror+0x11c>
	case ERR_OK:
		break;
	case ERR_TIMOUT:
		puts ("Timeout writing to Flash\n");
21f1f810:	e59f0074 	ldr	r0, [pc, #116]	; 21f1f88c <.text+0x1f88c>
21f1f814:	ebfff089 	bl	21f1ba40 <puts>
		break;
21f1f818:	ea000019 	b	21f1f884 <flash_perror+0x130>
	case ERR_NOT_ERASED:
		puts ("Flash not Erased\n");
21f1f81c:	e59f006c 	ldr	r0, [pc, #108]	; 21f1f890 <.text+0x1f890>
21f1f820:	ebfff086 	bl	21f1ba40 <puts>
		break;
21f1f824:	ea000016 	b	21f1f884 <flash_perror+0x130>
	case ERR_PROTECTED:
		puts ("Can't write to protected Flash sectors\n");
21f1f828:	e59f0064 	ldr	r0, [pc, #100]	; 21f1f894 <.text+0x1f894>
21f1f82c:	ebfff083 	bl	21f1ba40 <puts>
		break;
21f1f830:	ea000013 	b	21f1f884 <flash_perror+0x130>
	case ERR_INVAL:
		puts ("Outside available Flash\n");
21f1f834:	e59f005c 	ldr	r0, [pc, #92]	; 21f1f898 <.text+0x1f898>
21f1f838:	ebfff080 	bl	21f1ba40 <puts>
		break;
21f1f83c:	ea000010 	b	21f1f884 <flash_perror+0x130>
	case ERR_ALIGN:
		puts ("Start and/or end address not on sector boundary\n");
21f1f840:	e59f0054 	ldr	r0, [pc, #84]	; 21f1f89c <.text+0x1f89c>
21f1f844:	ebfff07d 	bl	21f1ba40 <puts>
		break;
21f1f848:	ea00000d 	b	21f1f884 <flash_perror+0x130>
	case ERR_UNKNOWN_FLASH_VENDOR:
		puts ("Unknown Vendor of Flash\n");
21f1f84c:	e59f004c 	ldr	r0, [pc, #76]	; 21f1f8a0 <.text+0x1f8a0>
21f1f850:	ebfff07a 	bl	21f1ba40 <puts>
		break;
21f1f854:	ea00000a 	b	21f1f884 <flash_perror+0x130>
	case ERR_UNKNOWN_FLASH_TYPE:
		puts ("Unknown Type of Flash\n");
21f1f858:	e59f0044 	ldr	r0, [pc, #68]	; 21f1f8a4 <.text+0x1f8a4>
21f1f85c:	ebfff077 	bl	21f1ba40 <puts>
		break;
21f1f860:	ea000007 	b	21f1f884 <flash_perror+0x130>
	case ERR_PROG_ERROR:
		puts ("General Flash Programming Error\n");
21f1f864:	e59f003c 	ldr	r0, [pc, #60]	; 21f1f8a8 <.text+0x1f8a8>
21f1f868:	ebfff074 	bl	21f1ba40 <puts>
		break;
21f1f86c:	ea000004 	b	21f1f884 <flash_perror+0x130>
	default:
		printf ("%s[%d] FIXME: rc=%d\n", __FILE__, __LINE__, err);
21f1f870:	e59f0034 	ldr	r0, [pc, #52]	; 21f1f8ac <.text+0x1f8ac>
21f1f874:	e59f1034 	ldr	r1, [pc, #52]	; 21f1f8b0 <.text+0x1f8b0>
21f1f878:	e3a020dd 	mov	r2, #221	; 0xdd
21f1f87c:	e51b3010 	ldr	r3, [fp, #-16]
21f1f880:	ebfff081 	bl	21f1ba8c <printf>
		break;
	}
}
21f1f884:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1f888:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1f88c:	21f322b4 	ldrcsh	r2, [r3, #36]!
21f1f890:	21f322d0 	ldrcssb	r2, [r3, #32]!
21f1f894:	21f322e4 	mvncss	r2, r4, ror #5
21f1f898:	21f3230c 	mvncss	r2, ip, lsl #6
21f1f89c:	21f32328 	mvncss	r2, r8, lsr #6
21f1f8a0:	21f3235c 	mvncss	r2, ip, asr r3
21f1f8a4:	21f32378 	mvncss	r2, r8, ror r3
21f1f8a8:	21f32390 	ldrcsb	r2, [r3, #48]!
21f1f8ac:	21f323b4 	ldrcsh	r2, [r3, #52]!
21f1f8b0:	21f323cc 	mvncss	r2, ip, asr #7

21f1f8b4 <NewHandle>:

/********************************************************************/

Handle NewHandle (unsigned int numBytes)
{
21f1f8b4:	e1a0c00d 	mov	ip, sp
21f1f8b8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f8bc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f8c0:	e24dd010 	sub	sp, sp, #16	; 0x10
21f1f8c4:	e50b0018 	str	r0, [fp, #-24]
	void *memPtr;
	HandleRecord *hanPtr;

	memPtr = calloc (numBytes, 1);
21f1f8c8:	e51b0018 	ldr	r0, [fp, #-24]
21f1f8cc:	ebfff335 	bl	21f1c5a8 <malloc>
21f1f8d0:	e1a03000 	mov	r3, r0
21f1f8d4:	e50b3014 	str	r3, [fp, #-20]
	hanPtr = (HandleRecord *) calloc (sizeof (HandleRecord), 1);
21f1f8d8:	e3a00008 	mov	r0, #8	; 0x8
21f1f8dc:	ebfff331 	bl	21f1c5a8 <malloc>
21f1f8e0:	e1a03000 	mov	r3, r0
21f1f8e4:	e50b3010 	str	r3, [fp, #-16]
	if (hanPtr && (memPtr || numBytes == 0)) {
21f1f8e8:	e51b3010 	ldr	r3, [fp, #-16]
21f1f8ec:	e3530000 	cmp	r3, #0	; 0x0
21f1f8f0:	0a00000e 	beq	21f1f930 <NewHandle+0x7c>
21f1f8f4:	e51b3014 	ldr	r3, [fp, #-20]
21f1f8f8:	e3530000 	cmp	r3, #0	; 0x0
21f1f8fc:	1a000002 	bne	21f1f90c <NewHandle+0x58>
21f1f900:	e51b3018 	ldr	r3, [fp, #-24]
21f1f904:	e3530000 	cmp	r3, #0	; 0x0
21f1f908:	1a000008 	bne	21f1f930 <NewHandle+0x7c>
		hanPtr->ptr = memPtr;
21f1f90c:	e51b2010 	ldr	r2, [fp, #-16]
21f1f910:	e51b3014 	ldr	r3, [fp, #-20]
21f1f914:	e5823000 	str	r3, [r2]
		hanPtr->size = numBytes;
21f1f918:	e51b2010 	ldr	r2, [fp, #-16]
21f1f91c:	e51b3018 	ldr	r3, [fp, #-24]
21f1f920:	e5823004 	str	r3, [r2, #4]
		return (Handle) hanPtr;
21f1f924:	e51b3010 	ldr	r3, [fp, #-16]
21f1f928:	e50b301c 	str	r3, [fp, #-28]
21f1f92c:	ea000005 	b	21f1f948 <NewHandle+0x94>
	} else {
		free (memPtr);
21f1f930:	e51b0014 	ldr	r0, [fp, #-20]
21f1f934:	ebfff604 	bl	21f1d14c <free>
		free (hanPtr);
21f1f938:	e51b0010 	ldr	r0, [fp, #-16]
21f1f93c:	ebfff602 	bl	21f1d14c <free>
		return NULL;
21f1f940:	e3a03000 	mov	r3, #0	; 0x0
21f1f944:	e50b301c 	str	r3, [fp, #-28]
21f1f948:	e51b301c 	ldr	r3, [fp, #-28]
	}
}
21f1f94c:	e1a00003 	mov	r0, r3
21f1f950:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1f954:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1f958 <DisposeHandle>:
/********************************************************************/

void DisposeHandle (Handle handle)
{
21f1f958:	e1a0c00d 	mov	ip, sp
21f1f95c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f960:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f964:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1f968:	e50b0010 	str	r0, [fp, #-16]
	if (handle) {
21f1f96c:	e51b3010 	ldr	r3, [fp, #-16]
21f1f970:	e3530000 	cmp	r3, #0	; 0x0
21f1f974:	0a000005 	beq	21f1f990 <DisposeHandle+0x38>
		free (*handle);
21f1f978:	e51b3010 	ldr	r3, [fp, #-16]
21f1f97c:	e5933000 	ldr	r3, [r3]
21f1f980:	e1a00003 	mov	r0, r3
21f1f984:	ebfff5f0 	bl	21f1d14c <free>
		free ((void *) handle);
21f1f988:	e51b0010 	ldr	r0, [fp, #-16]
21f1f98c:	ebfff5ee 	bl	21f1d14c <free>
	}
}
21f1f990:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1f994 <GetHandleSize>:
/********************************************************************/

unsigned int GetHandleSize (Handle handle)
{
21f1f994:	e1a0c00d 	mov	ip, sp
21f1f998:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f99c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f9a0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1f9a4:	e50b0010 	str	r0, [fp, #-16]
	return ((HandleRecord *) handle)->size;
21f1f9a8:	e51b3010 	ldr	r3, [fp, #-16]
21f1f9ac:	e5933004 	ldr	r3, [r3, #4]
}
21f1f9b0:	e1a00003 	mov	r0, r3
21f1f9b4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1f9b8 <SetHandleSize>:
/********************************************************************/

int SetHandleSize (Handle handle, unsigned int newSize)
{
21f1f9b8:	e1a0c00d 	mov	ip, sp
21f1f9bc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1f9c0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1f9c4:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f1f9c8:	e50b0020 	str	r0, [fp, #-32]
21f1f9cc:	e50b1024 	str	r1, [fp, #-36]
	HandleRecord *hanRecPtr = (HandleRecord *) handle;
21f1f9d0:	e51b3020 	ldr	r3, [fp, #-32]
21f1f9d4:	e50b301c 	str	r3, [fp, #-28]
	void *newPtr, *oldPtr;
	unsigned int oldSize;


	oldPtr = hanRecPtr->ptr;
21f1f9d8:	e51b301c 	ldr	r3, [fp, #-28]
21f1f9dc:	e5933000 	ldr	r3, [r3]
21f1f9e0:	e50b3014 	str	r3, [fp, #-20]
	oldSize = hanRecPtr->size;
21f1f9e4:	e51b301c 	ldr	r3, [fp, #-28]
21f1f9e8:	e5933004 	ldr	r3, [r3, #4]
21f1f9ec:	e50b3010 	str	r3, [fp, #-16]

	if (oldSize == newSize)
21f1f9f0:	e51b2010 	ldr	r2, [fp, #-16]
21f1f9f4:	e51b3024 	ldr	r3, [fp, #-36]
21f1f9f8:	e1520003 	cmp	r2, r3
21f1f9fc:	1a000002 	bne	21f1fa0c <SetHandleSize+0x54>
		return 1;
21f1fa00:	e3a03001 	mov	r3, #1	; 0x1
21f1fa04:	e50b3028 	str	r3, [fp, #-40]
21f1fa08:	ea00002b 	b	21f1fabc <SetHandleSize+0x104>

	if (oldPtr == NULL) {
21f1fa0c:	e51b3014 	ldr	r3, [fp, #-20]
21f1fa10:	e3530000 	cmp	r3, #0	; 0x0
21f1fa14:	1a000004 	bne	21f1fa2c <SetHandleSize+0x74>
		newPtr = malloc (newSize);
21f1fa18:	e51b0024 	ldr	r0, [fp, #-36]
21f1fa1c:	ebfff2e1 	bl	21f1c5a8 <malloc>
21f1fa20:	e1a03000 	mov	r3, r0
21f1fa24:	e50b3018 	str	r3, [fp, #-24]
21f1fa28:	ea000004 	b	21f1fa40 <SetHandleSize+0x88>
	} else {
		newPtr = realloc (oldPtr, newSize);
21f1fa2c:	e51b0014 	ldr	r0, [fp, #-20]
21f1fa30:	e51b1024 	ldr	r1, [fp, #-36]
21f1fa34:	ebfff732 	bl	21f1d704 <realloc>
21f1fa38:	e1a03000 	mov	r3, r0
21f1fa3c:	e50b3018 	str	r3, [fp, #-24]
	}
	if (newPtr || (newSize == 0)) {
21f1fa40:	e51b3018 	ldr	r3, [fp, #-24]
21f1fa44:	e3530000 	cmp	r3, #0	; 0x0
21f1fa48:	1a000002 	bne	21f1fa58 <SetHandleSize+0xa0>
21f1fa4c:	e51b3024 	ldr	r3, [fp, #-36]
21f1fa50:	e3530000 	cmp	r3, #0	; 0x0
21f1fa54:	1a000016 	bne	21f1fab4 <SetHandleSize+0xfc>
		hanRecPtr->ptr = newPtr;
21f1fa58:	e51b201c 	ldr	r2, [fp, #-28]
21f1fa5c:	e51b3018 	ldr	r3, [fp, #-24]
21f1fa60:	e5823000 	str	r3, [r2]
		hanRecPtr->size = newSize;
21f1fa64:	e51b201c 	ldr	r2, [fp, #-28]
21f1fa68:	e51b3024 	ldr	r3, [fp, #-36]
21f1fa6c:	e5823004 	str	r3, [r2, #4]
		if (newSize > oldSize)
21f1fa70:	e51b2024 	ldr	r2, [fp, #-36]
21f1fa74:	e51b3010 	ldr	r3, [fp, #-16]
21f1fa78:	e1520003 	cmp	r2, r3
21f1fa7c:	9a000009 	bls	21f1faa8 <SetHandleSize+0xf0>
			memset ((char *) newPtr + oldSize, 0, newSize - oldSize);
21f1fa80:	e51b2018 	ldr	r2, [fp, #-24]
21f1fa84:	e51b3010 	ldr	r3, [fp, #-16]
21f1fa88:	e0821003 	add	r1, r2, r3
21f1fa8c:	e51b2024 	ldr	r2, [fp, #-36]
21f1fa90:	e51b3010 	ldr	r3, [fp, #-16]
21f1fa94:	e0633002 	rsb	r3, r3, r2
21f1fa98:	e1a00001 	mov	r0, r1
21f1fa9c:	e3a01000 	mov	r1, #0	; 0x0
21f1faa0:	e1a02003 	mov	r2, r3
21f1faa4:	eb000d8f 	bl	21f230e8 <memset>
		return 1;
21f1faa8:	e3a03001 	mov	r3, #1	; 0x1
21f1faac:	e50b3028 	str	r3, [fp, #-40]
21f1fab0:	ea000001 	b	21f1fabc <SetHandleSize+0x104>
	} else
		return 0;
21f1fab4:	e3a03000 	mov	r3, #0	; 0x0
21f1fab8:	e50b3028 	str	r3, [fp, #-40]
21f1fabc:	e51b3028 	ldr	r3, [fp, #-40]
}
21f1fac0:	e1a00003 	mov	r0, r3
21f1fac4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1fac8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1facc <ExpandListSpace>:

#ifdef	CFG_ALL_LIST_FUNCTIONS

/*  Used to compare list elements by their raw data contents */
static int ListMemBlockCmp (void *a, void *b, int size)
{
	return memcmp (a, b, size);
}

/***************************************************************************/

/*
 * Binary search numElements of size elementSize in array for a match
 * to the. item. Return the index of the element that matches
 * (0 - numElements - 1). If no match is found return the -i-1 where
 * i is the index (0 - numElements) where the item should be placed.
 * (*theCmp)(a,b) should return <0 if a<b, 0 if a==b, >0 if a>b.
 *
 * This function is like the C-Library function bsearch() except that
 * this function returns the index where the item should be placed if
 * it is not found.
 */
int BinSearch ( void *array, int numElements, int elementSize,
		void *itemPtr, CompareFunction compareFunction)
{
	int low, high, mid, cmp;
	void *arrayItemPtr;

	for (low = 0, high = numElements - 1, mid = 0, cmp = -1; low <= high;) {
		mid = (low + high) >> 1;

		arrayItemPtr = (void *) (((char *) array) + (mid * elementSize));
		cmp = compareFunction
			? compareFunction (itemPtr, arrayItemPtr)
			: ListMemBlockCmp (itemPtr, arrayItemPtr, elementSize);
		if (cmp == 0) {
			return mid;
		} else if (cmp < 0) {
			high = mid - 1;
		} else {
			low = mid + 1;
		}
	}
	if (cmp > 0)
		mid++;

	return -mid - 1;
}

#endif	/* CFG_ALL_LIST_FUNCTIONS */

/*******************************************************************************/

/*
 * If numNewItems == 0 then expand the list by the number of items
 * indicated by its allocation policy.
 * If numNewItems > 0 then expand the list by exactly the number of
 * items indicated.
 * If numNewItems < 0 then expand the list by the absolute value of
 * numNewItems plus the number of items indicated by its allocation
 * policy.
 * Returns 1 for success, 0 if out of memory
*/
static int ExpandListSpace (list_t list, int numNewItems)
{
21f1facc:	e1a0c00d 	mov	ip, sp
21f1fad0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1fad4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1fad8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f1fadc:	e50b0010 	str	r0, [fp, #-16]
21f1fae0:	e50b1014 	str	r1, [fp, #-20]
	if (numNewItems == 0) {
21f1fae4:	e51b3014 	ldr	r3, [fp, #-20]
21f1fae8:	e3530000 	cmp	r3, #0	; 0x0
21f1faec:	1a000013 	bne	21f1fb40 <ExpandListSpace+0x74>
		numNewItems = NUMITEMSPERALLOC (list);
21f1faf0:	e51b3010 	ldr	r3, [fp, #-16]
21f1faf4:	e5933000 	ldr	r3, [r3]
21f1faf8:	e5930008 	ldr	r0, [r3, #8]
21f1fafc:	e51b3010 	ldr	r3, [fp, #-16]
21f1fb00:	e5933000 	ldr	r3, [r3]
21f1fb04:	e593200c 	ldr	r2, [r3, #12]
21f1fb08:	e51b3010 	ldr	r3, [fp, #-16]
21f1fb0c:	e5933000 	ldr	r3, [r3]
21f1fb10:	e5933004 	ldr	r3, [r3, #4]
21f1fb14:	e2833064 	add	r3, r3, #100	; 0x64
21f1fb18:	e0010293 	mul	r1, r3, r2
21f1fb1c:	e59f3108 	ldr	r3, [pc, #264]	; 21f1fc2c <.text+0x1fc2c>
21f1fb20:	e0c32391 	smull	r2, r3, r1, r3
21f1fb24:	e1a022c3 	mov	r2, r3, asr #5
21f1fb28:	e1a03fc1 	mov	r3, r1, asr #31
21f1fb2c:	e0633002 	rsb	r3, r3, r2
21f1fb30:	e1500003 	cmp	r0, r3
21f1fb34:	a1a03000 	movge	r3, r0
21f1fb38:	e50b3014 	str	r3, [fp, #-20]
21f1fb3c:	ea000018 	b	21f1fba4 <ExpandListSpace+0xd8>
	} else if (numNewItems < 0) {
21f1fb40:	e51b3014 	ldr	r3, [fp, #-20]
21f1fb44:	e3530000 	cmp	r3, #0	; 0x0
21f1fb48:	aa000015 	bge	21f1fba4 <ExpandListSpace+0xd8>
		numNewItems = (-numNewItems) + NUMITEMSPERALLOC (list);
21f1fb4c:	e51b3010 	ldr	r3, [fp, #-16]
21f1fb50:	e5933000 	ldr	r3, [r3]
21f1fb54:	e5930008 	ldr	r0, [r3, #8]
21f1fb58:	e51b3010 	ldr	r3, [fp, #-16]
21f1fb5c:	e5933000 	ldr	r3, [r3]
21f1fb60:	e593200c 	ldr	r2, [r3, #12]
21f1fb64:	e51b3010 	ldr	r3, [fp, #-16]
21f1fb68:	e5933000 	ldr	r3, [r3]
21f1fb6c:	e5933004 	ldr	r3, [r3, #4]
21f1fb70:	e2833064 	add	r3, r3, #100	; 0x64
21f1fb74:	e0010293 	mul	r1, r3, r2
21f1fb78:	e59f30ac 	ldr	r3, [pc, #172]	; 21f1fc2c <.text+0x1fc2c>
21f1fb7c:	e0c32391 	smull	r2, r3, r1, r3
21f1fb80:	e1a022c3 	mov	r2, r3, asr #5
21f1fb84:	e1a03fc1 	mov	r3, r1, asr #31
21f1fb88:	e0633002 	rsb	r3, r3, r2
21f1fb8c:	e1500003 	cmp	r0, r3
21f1fb90:	a1a02000 	movge	r2, r0
21f1fb94:	b1a02003 	movlt	r2, r3
21f1fb98:	e51b3014 	ldr	r3, [fp, #-20]
21f1fb9c:	e0633002 	rsb	r3, r3, r2
21f1fba0:	e50b3014 	str	r3, [fp, #-20]
	}

	if (SetHandleSize ((Handle) list,
21f1fba4:	e51b1010 	ldr	r1, [fp, #-16]
21f1fba8:	e51b3010 	ldr	r3, [fp, #-16]
21f1fbac:	e5933000 	ldr	r3, [r3]
21f1fbb0:	e593200c 	ldr	r2, [r3, #12]
21f1fbb4:	e51b3014 	ldr	r3, [fp, #-20]
21f1fbb8:	e0822003 	add	r2, r2, r3
21f1fbbc:	e51b3010 	ldr	r3, [fp, #-16]
21f1fbc0:	e5933000 	ldr	r3, [r3]
21f1fbc4:	e5933010 	ldr	r3, [r3, #16]
21f1fbc8:	e0030392 	mul	r3, r2, r3
21f1fbcc:	e283301c 	add	r3, r3, #28	; 0x1c
21f1fbd0:	e1a00001 	mov	r0, r1
21f1fbd4:	e1a01003 	mov	r1, r3
21f1fbd8:	ebffff76 	bl	21f1f9b8 <SetHandleSize>
21f1fbdc:	e1a03000 	mov	r3, r0
21f1fbe0:	e3530000 	cmp	r3, #0	; 0x0
21f1fbe4:	0a00000a 	beq	21f1fc14 <ExpandListSpace+0x148>
			   sizeof (ListStruct) +
			   ((*list)->listSize +
			   numNewItems) * (*list)->itemSize)) {
		(*list)->listSize += numNewItems;
21f1fbe8:	e51b3010 	ldr	r3, [fp, #-16]
21f1fbec:	e5931000 	ldr	r1, [r3]
21f1fbf0:	e51b3010 	ldr	r3, [fp, #-16]
21f1fbf4:	e5933000 	ldr	r3, [r3]
21f1fbf8:	e593200c 	ldr	r2, [r3, #12]
21f1fbfc:	e51b3014 	ldr	r3, [fp, #-20]
21f1fc00:	e0823003 	add	r3, r2, r3
21f1fc04:	e581300c 	str	r3, [r1, #12]
		return 1;
21f1fc08:	e3a03001 	mov	r3, #1	; 0x1
21f1fc0c:	e50b3018 	str	r3, [fp, #-24]
21f1fc10:	ea000001 	b	21f1fc1c <ExpandListSpace+0x150>
	} else {
		return 0;
21f1fc14:	e3a02000 	mov	r2, #0	; 0x0
21f1fc18:	e50b2018 	str	r2, [fp, #-24]
21f1fc1c:	e51b3018 	ldr	r3, [fp, #-24]
	}
}
21f1fc20:	e1a00003 	mov	r0, r3
21f1fc24:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1fc28:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1fc2c:	51eb851f 	mvnpl	r8, pc, lsl r5

21f1fc30 <ListCreate>:

/*******************************/

#ifdef	CFG_ALL_LIST_FUNCTIONS

/*
 * This function reallocate the list, minus any currently unused
 * portion of its allotted memory.
 */
void ListCompact (list_t list)
{

	if (!SetHandleSize ((Handle) list,
			    sizeof (ListStruct) +
			    (*list)->numItems * (*list)->itemSize)) {
		return;
	}

	(*list)->listSize = (*list)->numItems;
}

#endif	/* CFG_ALL_LIST_FUNCTIONS */

/*******************************/

list_t ListCreate (int elementSize)
{
21f1fc30:	e1a0c00d 	mov	ip, sp
21f1fc34:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1fc38:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1fc3c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f1fc40:	e50b0014 	str	r0, [fp, #-20]
	list_t list;

	list = (list_t) (NewHandle (sizeof (ListStruct)));  /* create empty list */
21f1fc44:	e3a0001c 	mov	r0, #28	; 0x1c
21f1fc48:	ebffff19 	bl	21f1f8b4 <NewHandle>
21f1fc4c:	e1a03000 	mov	r3, r0
21f1fc50:	e50b3010 	str	r3, [fp, #-16]
	if (list) {
21f1fc54:	e51b3010 	ldr	r3, [fp, #-16]
21f1fc58:	e3530000 	cmp	r3, #0	; 0x0
21f1fc5c:	0a000017 	beq	21f1fcc0 <ListCreate+0x90>
		(*list)->signature = LIST_SIGNATURE;
21f1fc60:	e51b3010 	ldr	r3, [fp, #-16]
21f1fc64:	e5932000 	ldr	r2, [r3]
21f1fc68:	e59f3060 	ldr	r3, [pc, #96]	; 21f1fcd0 <.text+0x1fcd0>
21f1fc6c:	e5823000 	str	r3, [r2]
		(*list)->numItems = 0;
21f1fc70:	e51b3010 	ldr	r3, [fp, #-16]
21f1fc74:	e5932000 	ldr	r2, [r3]
21f1fc78:	e3a03000 	mov	r3, #0	; 0x0
21f1fc7c:	e5823014 	str	r3, [r2, #20]
		(*list)->listSize = 0;
21f1fc80:	e51b3010 	ldr	r3, [fp, #-16]
21f1fc84:	e5932000 	ldr	r2, [r3]
21f1fc88:	e3a03000 	mov	r3, #0	; 0x0
21f1fc8c:	e582300c 	str	r3, [r2, #12]
		(*list)->itemSize = elementSize;
21f1fc90:	e51b3010 	ldr	r3, [fp, #-16]
21f1fc94:	e5932000 	ldr	r2, [r3]
21f1fc98:	e51b3014 	ldr	r3, [fp, #-20]
21f1fc9c:	e5823010 	str	r3, [r2, #16]
		(*list)->percentIncrease = kDefaultAllocationPercentIncrease;
21f1fca0:	e51b3010 	ldr	r3, [fp, #-16]
21f1fca4:	e5932000 	ldr	r2, [r3]
21f1fca8:	e3a0300a 	mov	r3, #10	; 0xa
21f1fcac:	e5823004 	str	r3, [r2, #4]
		(*list)->minNumItemsIncrease =
21f1fcb0:	e51b3010 	ldr	r3, [fp, #-16]
21f1fcb4:	e5932000 	ldr	r2, [r3]
21f1fcb8:	e3a03004 	mov	r3, #4	; 0x4
21f1fcbc:	e5823008 	str	r3, [r2, #8]
				kDefaultAllocationminNumItemsIncrease;
	}

	return list;
21f1fcc0:	e51b3010 	ldr	r3, [fp, #-16]
}
21f1fcc4:	e1a00003 	mov	r0, r3
21f1fcc8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1fccc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f1fcd0:	4c495354 	mcrrmi	3, 5, r5, r9, cr4

21f1fcd4 <ListSetAllocationPolicy>:

/*******************************/

void ListSetAllocationPolicy (list_t list, int minItemsPerAlloc,
			      int percentIncreasePerAlloc)
{
21f1fcd4:	e1a0c00d 	mov	ip, sp
21f1fcd8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1fcdc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1fce0:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f1fce4:	e50b0010 	str	r0, [fp, #-16]
21f1fce8:	e50b1014 	str	r1, [fp, #-20]
21f1fcec:	e50b2018 	str	r2, [fp, #-24]
	(*list)->percentIncrease = percentIncreasePerAlloc;
21f1fcf0:	e51b3010 	ldr	r3, [fp, #-16]
21f1fcf4:	e5932000 	ldr	r2, [r3]
21f1fcf8:	e51b3018 	ldr	r3, [fp, #-24]
21f1fcfc:	e5823004 	str	r3, [r2, #4]
	(*list)->minNumItemsIncrease = minItemsPerAlloc;
21f1fd00:	e51b3010 	ldr	r3, [fp, #-16]
21f1fd04:	e5932000 	ldr	r2, [r3]
21f1fd08:	e51b3014 	ldr	r3, [fp, #-20]
21f1fd0c:	e5823008 	str	r3, [r2, #8]
}
21f1fd10:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1fd14:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1fd18 <ListDispose>:

/*******************************/

void ListDispose (list_t list)
{
21f1fd18:	e1a0c00d 	mov	ip, sp
21f1fd1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1fd20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1fd24:	e24dd004 	sub	sp, sp, #4	; 0x4
21f1fd28:	e50b0010 	str	r0, [fp, #-16]
	DisposeHandle ((Handle) list);
21f1fd2c:	e51b3010 	ldr	r3, [fp, #-16]
21f1fd30:	e1a00003 	mov	r0, r3
21f1fd34:	ebffff07 	bl	21f1f958 <DisposeHandle>
}
21f1fd38:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f1fd3c <ListInsertItem>:
/*******************************/

#ifdef	CFG_ALL_LIST_FUNCTIONS

void ListDisposePtrList (list_t list)
{
	int index;
	int numItems;

	if (list) {
		numItems = ListNumItems (list);

		for (index = 1; index <= numItems; index++)
			free (*(void **) ListGetPtrToItem (list, index));

		ListDispose (list);
	}
}

/*******************************/

/*
 * keeps memory, resets the number of items to 0
 */
void ListClear (list_t list)
{
	if (!list)
		return;
	(*list)->numItems = 0;
}

/*******************************/

/*
 * copy is only as large as necessary
 */
list_t ListCopy (list_t originalList)
{
	list_t tempList = NULL;
	int numItems;

	if (!originalList)
		return NULL;

	tempList = ListCreate ((*originalList)->itemSize);
	if (tempList) {
		numItems = ListNumItems (originalList);

		if (!SetHandleSize ((Handle) tempList,
				    sizeof (ListStruct) +
				    numItems * (*tempList)->itemSize)) {
			ListDispose (tempList);
			return NULL;
		}

		(*tempList)->numItems = (*originalList)->numItems;
		(*tempList)->listSize = (*originalList)->numItems;
		(*tempList)->itemSize = (*originalList)->itemSize;
		(*tempList)->percentIncrease = (*originalList)->percentIncrease;
		(*tempList)->minNumItemsIncrease =
				(*originalList)->minNumItemsIncrease;

		memcpy (ITEMPTR (tempList, 0), ITEMPTR (originalList, 0),
				numItems * (*tempList)->itemSize);
	}

	return tempList;
}

/********************************/

/*
 * list1 = list1 + list2
 */
int ListAppend (list_t list1, list_t list2)
{
	int numItemsL1, numItemsL2;

	if (!list2)
		return 1;

	if (!list1)
		return 0;
	if ((*list1)->itemSize != (*list2)->itemSize)
		return 0;

	numItemsL1 = ListNumItems (list1);
	numItemsL2 = ListNumItems (list2);

	if (numItemsL2 == 0)
		return 1;

	if (!SetHandleSize ((Handle) list1,
			    sizeof (ListStruct) + (numItemsL1 + numItemsL2) *
					(*list1)->itemSize)) {
		return 0;
	}

	(*list1)->numItems = numItemsL1 + numItemsL2;
	(*list1)->listSize = numItemsL1 + numItemsL2;

	memmove (ITEMPTR (list1, numItemsL1),
		 ITEMPTR (list2, 0),
		 numItemsL2 * (*list2)->itemSize);

	return 1;
}

#endif	/* CFG_ALL_LIST_FUNCTIONS */

/*******************************/

/*
 * returns 1 if the item is inserted, returns 0 if out of memory or
 * bad arguments were passed.
 */
int ListInsertItem (list_t list, void *ptrToItem, int itemPosition)
{
21f1fd3c:	e1a0c00d 	mov	ip, sp
21f1fd40:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1fd44:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1fd48:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f1fd4c:	e50b0010 	str	r0, [fp, #-16]
21f1fd50:	e50b1014 	str	r1, [fp, #-20]
21f1fd54:	e50b2018 	str	r2, [fp, #-24]
	return ListInsertItems (list, ptrToItem, itemPosition, 1);
21f1fd58:	e51b0010 	ldr	r0, [fp, #-16]
21f1fd5c:	e51b1014 	ldr	r1, [fp, #-20]
21f1fd60:	e51b2018 	ldr	r2, [fp, #-24]
21f1fd64:	e3a03001 	mov	r3, #1	; 0x1
21f1fd68:	eb000003 	bl	21f1fd7c <ListInsertItems>
21f1fd6c:	e1a03000 	mov	r3, r0
}
21f1fd70:	e1a00003 	mov	r0, r3
21f1fd74:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f1fd78:	e89da800 	ldmia	sp, {fp, sp, pc}

21f1fd7c <ListInsertItems>:

/*******************************/

int ListInsertItems (list_t list, void *ptrToItems, int firstItemPosition,
		     int numItemsToInsert)
{
21f1fd7c:	e1a0c00d 	mov	ip, sp
21f1fd80:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f1fd84:	e24cb004 	sub	fp, ip, #4	; 0x4
21f1fd88:	e24dd018 	sub	sp, sp, #24	; 0x18
21f1fd8c:	e50b0014 	str	r0, [fp, #-20]
21f1fd90:	e50b1018 	str	r1, [fp, #-24]
21f1fd94:	e50b201c 	str	r2, [fp, #-28]
21f1fd98:	e50b3020 	str	r3, [fp, #-32]
	int numItems = (*list)->numItems;
21f1fd9c:	e51b3014 	ldr	r3, [fp, #-20]
21f1fda0:	e5933000 	ldr	r3, [r3]
21f1fda4:	e5933014 	ldr	r3, [r3, #20]
21f1fda8:	e50b3010 	str	r3, [fp, #-16]

	if (firstItemPosition == numItems + 1)
21f1fdac:	e51b3010 	ldr	r3, [fp, #-16]
21f1fdb0:	e2832001 	add	r2, r3, #1	; 0x1
21f1fdb4:	e51b301c 	ldr	r3, [fp, #-28]
21f1fdb8:	e1520003 	cmp	r2, r3
21f1fdbc:	1a000002 	bne	21f1fdcc <ListInsertItems+0x50>
		firstItemPosition = LIST_END;
21f1fdc0:	e3a03000 	mov	r3, #0	; 0x0
21f1fdc4:	e50b301c 	str	r3, [fp, #-28]
21f1fdc8:	ea000006 	b	21f1fde8 <ListInsertItems+0x6c>
	else if (firstItemPosition > numItems)
21f1fdcc:	e51b201c 	ldr	r2, [fp, #-28]
21f1fdd0:	e51b3010 	ldr	r3, [fp, #-16]
21f1fdd4:	e1520003 	cmp	r2, r3
21f1fdd8:	da000002 	ble	21f1fde8 <ListInsertItems+0x6c>
		return 0;
21f1fddc:	e3a03000 	mov	r3, #0	; 0x0
21f1fde0:	e50b3024 	str	r3, [fp, #-36]
21f1fde4:	ea0000ab 	b	21f20098 <ListInsertItems+0x31c>

	if ((*list)->numItems >= (*list)->listSize) {
21f1fde8:	e51b3014 	ldr	r3, [fp, #-20]
21f1fdec:	e5933000 	ldr	r3, [r3]
21f1fdf0:	e5932014 	ldr	r2, [r3, #20]
21f1fdf4:	e51b3014 	ldr	r3, [fp, #-20]
21f1fdf8:	e5933000 	ldr	r3, [r3]
21f1fdfc:	e593300c 	ldr	r3, [r3, #12]
21f1fe00:	e1520003 	cmp	r2, r3
21f1fe04:	ba00000a 	blt	21f1fe34 <ListInsertItems+0xb8>
		if (!ExpandListSpace (list, -numItemsToInsert))
21f1fe08:	e51b3020 	ldr	r3, [fp, #-32]
21f1fe0c:	e2633000 	rsb	r3, r3, #0	; 0x0
21f1fe10:	e51b0014 	ldr	r0, [fp, #-20]
21f1fe14:	e1a01003 	mov	r1, r3
21f1fe18:	ebffff2b 	bl	21f1facc <ExpandListSpace>
21f1fe1c:	e1a03000 	mov	r3, r0
21f1fe20:	e3530000 	cmp	r3, #0	; 0x0
21f1fe24:	1a000002 	bne	21f1fe34 <ListInsertItems+0xb8>
			return 0;
21f1fe28:	e3a03000 	mov	r3, #0	; 0x0
21f1fe2c:	e50b3024 	str	r3, [fp, #-36]
21f1fe30:	ea000098 	b	21f20098 <ListInsertItems+0x31c>
	}

	if (firstItemPosition == LIST_START) {
21f1fe34:	e51b301c 	ldr	r3, [fp, #-28]
21f1fe38:	e3730001 	cmn	r3, #1	; 0x1
21f1fe3c:	1a000007 	bne	21f1fe60 <ListInsertItems+0xe4>
		if (numItems == 0) {
21f1fe40:	e51b3010 	ldr	r3, [fp, #-16]
21f1fe44:	e3530000 	cmp	r3, #0	; 0x0
21f1fe48:	1a000002 	bne	21f1fe58 <ListInsertItems+0xdc>
			/* special case for empty list */
			firstItemPosition = LIST_END;
21f1fe4c:	e3a03000 	mov	r3, #0	; 0x0
21f1fe50:	e50b301c 	str	r3, [fp, #-28]
21f1fe54:	ea000001 	b	21f1fe60 <ListInsertItems+0xe4>
		} else {
			firstItemPosition = 1;
21f1fe58:	e3a03001 	mov	r3, #1	; 0x1
21f1fe5c:	e50b301c 	str	r3, [fp, #-28]
		}
	}

	if (firstItemPosition == LIST_END) {	/* add at the end of the list */
21f1fe60:	e51b301c 	ldr	r3, [fp, #-28]
21f1fe64:	e3530000 	cmp	r3, #0	; 0x0
21f1fe68:	1a000032 	bne	21f1ff38 <ListInsertItems+0x1bc>
		if (ptrToItems)
21f1fe6c:	e51b3018 	ldr	r3, [fp, #-24]
21f1fe70:	e3530000 	cmp	r3, #0	; 0x0
21f1fe74:	0a000013 	beq	21f1fec8 <ListInsertItems+0x14c>
			memcpy (ITEMPTR (list, numItems), ptrToItems,
21f1fe78:	e51b3014 	ldr	r3, [fp, #-20]
21f1fe7c:	e5933000 	ldr	r3, [r3]
21f1fe80:	e2833018 	add	r3, r3, #24	; 0x18
21f1fe84:	e1a01003 	mov	r1, r3
21f1fe88:	e51b3014 	ldr	r3, [fp, #-20]
21f1fe8c:	e5933000 	ldr	r3, [r3]
21f1fe90:	e5932010 	ldr	r2, [r3, #16]
21f1fe94:	e51b3010 	ldr	r3, [fp, #-16]
21f1fe98:	e0030392 	mul	r3, r2, r3
21f1fe9c:	e0811003 	add	r1, r1, r3
21f1fea0:	e51b3014 	ldr	r3, [fp, #-20]
21f1fea4:	e5933000 	ldr	r3, [r3]
21f1fea8:	e5932010 	ldr	r2, [r3, #16]
21f1feac:	e51b3020 	ldr	r3, [fp, #-32]
21f1feb0:	e0030392 	mul	r3, r2, r3
21f1feb4:	e1a00001 	mov	r0, r1
21f1feb8:	e51b1018 	ldr	r1, [fp, #-24]
21f1febc:	e1a02003 	mov	r2, r3
21f1fec0:	eb000cc1 	bl	21f231cc <memcpy>
21f1fec4:	ea000012 	b	21f1ff14 <ListInsertItems+0x198>
					(*list)->itemSize * numItemsToInsert);
		else
			memset (ITEMPTR (list, numItems), 0,
21f1fec8:	e51b3014 	ldr	r3, [fp, #-20]
21f1fecc:	e5933000 	ldr	r3, [r3]
21f1fed0:	e2833018 	add	r3, r3, #24	; 0x18
21f1fed4:	e1a01003 	mov	r1, r3
21f1fed8:	e51b3014 	ldr	r3, [fp, #-20]
21f1fedc:	e5933000 	ldr	r3, [r3]
21f1fee0:	e5932010 	ldr	r2, [r3, #16]
21f1fee4:	e51b3010 	ldr	r3, [fp, #-16]
21f1fee8:	e0030392 	mul	r3, r2, r3
21f1feec:	e0811003 	add	r1, r1, r3
21f1fef0:	e51b3014 	ldr	r3, [fp, #-20]
21f1fef4:	e5933000 	ldr	r3, [r3]
21f1fef8:	e5932010 	ldr	r2, [r3, #16]
21f1fefc:	e51b3020 	ldr	r3, [fp, #-32]
21f1ff00:	e0030392 	mul	r3, r2, r3
21f1ff04:	e1a00001 	mov	r0, r1
21f1ff08:	e3a01000 	mov	r1, #0	; 0x0
21f1ff0c:	e1a02003 	mov	r2, r3
21f1ff10:	eb000c74 	bl	21f230e8 <memset>
					(*list)->itemSize * numItemsToInsert);

		(*list)->numItems += numItemsToInsert;
21f1ff14:	e51b3014 	ldr	r3, [fp, #-20]
21f1ff18:	e5931000 	ldr	r1, [r3]
21f1ff1c:	e51b3014 	ldr	r3, [fp, #-20]
21f1ff20:	e5933000 	ldr	r3, [r3]
21f1ff24:	e5932014 	ldr	r2, [r3, #20]
21f1ff28:	e51b3020 	ldr	r3, [fp, #-32]
21f1ff2c:	e0823003 	add	r3, r2, r3
21f1ff30:	e5813014 	str	r3, [r1, #20]
21f1ff34:	ea000055 	b	21f20090 <ListInsertItems+0x314>
	} else {					/* move part of list up to make room for new item */
		memmove (ITEMPTR (list, firstItemPosition - 1 + numItemsToInsert),
21f1ff38:	e51b3014 	ldr	r3, [fp, #-20]
21f1ff3c:	e5933000 	ldr	r3, [r3]
21f1ff40:	e2833018 	add	r3, r3, #24	; 0x18
21f1ff44:	e1a00003 	mov	r0, r3
21f1ff48:	e51b3014 	ldr	r3, [fp, #-20]
21f1ff4c:	e5933000 	ldr	r3, [r3]
21f1ff50:	e5931010 	ldr	r1, [r3, #16]
21f1ff54:	e51b201c 	ldr	r2, [fp, #-28]
21f1ff58:	e51b3020 	ldr	r3, [fp, #-32]
21f1ff5c:	e0823003 	add	r3, r2, r3
21f1ff60:	e2433001 	sub	r3, r3, #1	; 0x1
21f1ff64:	e0030391 	mul	r3, r1, r3
21f1ff68:	e0800003 	add	r0, r0, r3
21f1ff6c:	e51b3014 	ldr	r3, [fp, #-20]
21f1ff70:	e5933000 	ldr	r3, [r3]
21f1ff74:	e2833018 	add	r3, r3, #24	; 0x18
21f1ff78:	e1a01003 	mov	r1, r3
21f1ff7c:	e51b3014 	ldr	r3, [fp, #-20]
21f1ff80:	e5933000 	ldr	r3, [r3]
21f1ff84:	e5932010 	ldr	r2, [r3, #16]
21f1ff88:	e51b301c 	ldr	r3, [fp, #-28]
21f1ff8c:	e2433001 	sub	r3, r3, #1	; 0x1
21f1ff90:	e0030392 	mul	r3, r2, r3
21f1ff94:	e0811003 	add	r1, r1, r3
21f1ff98:	e51b2010 	ldr	r2, [fp, #-16]
21f1ff9c:	e51b301c 	ldr	r3, [fp, #-28]
21f1ffa0:	e0633002 	rsb	r3, r3, r2
21f1ffa4:	e2832001 	add	r2, r3, #1	; 0x1
21f1ffa8:	e51b3014 	ldr	r3, [fp, #-20]
21f1ffac:	e5933000 	ldr	r3, [r3]
21f1ffb0:	e5933010 	ldr	r3, [r3, #16]
21f1ffb4:	e0030392 	mul	r3, r2, r3
21f1ffb8:	e1a02003 	mov	r2, r3
21f1ffbc:	eb000ca2 	bl	21f2324c <memmove>
			 ITEMPTR (list, firstItemPosition - 1),
			 (numItems + 1 - firstItemPosition) * (*list)->itemSize);

		if (ptrToItems)
21f1ffc0:	e51b3018 	ldr	r3, [fp, #-24]
21f1ffc4:	e3530000 	cmp	r3, #0	; 0x0
21f1ffc8:	0a000014 	beq	21f20020 <ListInsertItems+0x2a4>
			memmove (ITEMPTR (list, firstItemPosition - 1), ptrToItems,
21f1ffcc:	e51b3014 	ldr	r3, [fp, #-20]
21f1ffd0:	e5933000 	ldr	r3, [r3]
21f1ffd4:	e2833018 	add	r3, r3, #24	; 0x18
21f1ffd8:	e1a01003 	mov	r1, r3
21f1ffdc:	e51b3014 	ldr	r3, [fp, #-20]
21f1ffe0:	e5933000 	ldr	r3, [r3]
21f1ffe4:	e5932010 	ldr	r2, [r3, #16]
21f1ffe8:	e51b301c 	ldr	r3, [fp, #-28]
21f1ffec:	e2433001 	sub	r3, r3, #1	; 0x1
21f1fff0:	e0030392 	mul	r3, r2, r3
21f1fff4:	e0811003 	add	r1, r1, r3
21f1fff8:	e51b3014 	ldr	r3, [fp, #-20]
21f1fffc:	e5933000 	ldr	r3, [r3]
21f20000:	e5932010 	ldr	r2, [r3, #16]
21f20004:	e51b3020 	ldr	r3, [fp, #-32]
21f20008:	e0030392 	mul	r3, r2, r3
21f2000c:	e1a00001 	mov	r0, r1
21f20010:	e51b1018 	ldr	r1, [fp, #-24]
21f20014:	e1a02003 	mov	r2, r3
21f20018:	eb000c8b 	bl	21f2324c <memmove>
21f2001c:	ea000013 	b	21f20070 <ListInsertItems+0x2f4>
					 (*list)->itemSize * numItemsToInsert);
		else
			memset (ITEMPTR (list, firstItemPosition - 1), 0,
21f20020:	e51b3014 	ldr	r3, [fp, #-20]
21f20024:	e5933000 	ldr	r3, [r3]
21f20028:	e2833018 	add	r3, r3, #24	; 0x18
21f2002c:	e1a01003 	mov	r1, r3
21f20030:	e51b3014 	ldr	r3, [fp, #-20]
21f20034:	e5933000 	ldr	r3, [r3]
21f20038:	e5932010 	ldr	r2, [r3, #16]
21f2003c:	e51b301c 	ldr	r3, [fp, #-28]
21f20040:	e2433001 	sub	r3, r3, #1	; 0x1
21f20044:	e0030392 	mul	r3, r2, r3
21f20048:	e0811003 	add	r1, r1, r3
21f2004c:	e51b3014 	ldr	r3, [fp, #-20]
21f20050:	e5933000 	ldr	r3, [r3]
21f20054:	e5932010 	ldr	r2, [r3, #16]
21f20058:	e51b3020 	ldr	r3, [fp, #-32]
21f2005c:	e0030392 	mul	r3, r2, r3
21f20060:	e1a00001 	mov	r0, r1
21f20064:	e3a01000 	mov	r1, #0	; 0x0
21f20068:	e1a02003 	mov	r2, r3
21f2006c:	eb000c1d 	bl	21f230e8 <memset>
					(*list)->itemSize * numItemsToInsert);

		(*list)->numItems += numItemsToInsert;
21f20070:	e51b3014 	ldr	r3, [fp, #-20]
21f20074:	e5931000 	ldr	r1, [r3]
21f20078:	e51b3014 	ldr	r3, [fp, #-20]
21f2007c:	e5933000 	ldr	r3, [r3]
21f20080:	e5932014 	ldr	r2, [r3, #20]
21f20084:	e51b3020 	ldr	r3, [fp, #-32]
21f20088:	e0823003 	add	r3, r2, r3
21f2008c:	e5813014 	str	r3, [r1, #20]
	}

	return 1;
21f20090:	e3a03001 	mov	r3, #1	; 0x1
21f20094:	e50b3024 	str	r3, [fp, #-36]
21f20098:	e51b3024 	ldr	r3, [fp, #-36]
}
21f2009c:	e1a00003 	mov	r0, r3
21f200a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f200a4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f200a8 <ListGetItems>:

#ifdef CFG_ALL_LIST_FUNCTIONS

/*******************************/

int ListEqual (list_t list1, list_t list2)
{
	if (list1 == list2)
		return 1;

	if (list1 == NULL || list2 == NULL)
		return 0;

	if ((*list1)->itemSize == (*list1)->itemSize) {
	    if ((*list1)->numItems == (*list2)->numItems) {
		return (memcmp (ITEMPTR (list1, 0), ITEMPTR (list2, 0),
				(*list1)->itemSize * (*list1)->numItems) == 0);
	    }
	}

	return 0;
}

/*******************************/

/*
 * The item pointed to by ptrToItem is copied over the current item
 * at itemPosition
 */
void ListReplaceItem (list_t list, void *ptrToItem, int itemPosition)
{
	ListReplaceItems (list, ptrToItem, itemPosition, 1);
}

/*******************************/

/*
 * The item pointed to by ptrToItems is copied over the current item
 * at itemPosition
 */
void ListReplaceItems ( list_t list, void *ptrToItems,
			int firstItemPosition, int numItemsToReplace)
{

	if (firstItemPosition == LIST_END)
		firstItemPosition = (*list)->numItems;
	else if (firstItemPosition == LIST_START)
		firstItemPosition = 1;

	memmove (ITEMPTR (list, firstItemPosition - 1), ptrToItems,
			 (*list)->itemSize * numItemsToReplace);
}

/*******************************/

void ListGetItem (list_t list, void *itemDestination, int itemPosition)
{
	ListGetItems (list, itemDestination, itemPosition, 1);
}

#endif	/* CFG_ALL_LIST_FUNCTIONS */

/*******************************/

#if defined(CFG_ALL_LIST_FUNCTIONS) || defined(CFG_DEVICE_DEREGISTER)

void ListRemoveItem (list_t list, void *itemDestination, int itemPosition)
{
	ListRemoveItems (list, itemDestination, itemPosition, 1);
}

/*******************************/

void ListRemoveItems (list_t list, void *itemsDestination,
		      int firstItemPosition, int numItemsToRemove)
{
	int firstItemAfterChunk, numToMove;

	if (firstItemPosition == LIST_START)
		firstItemPosition = 1;
	else if (firstItemPosition == LIST_END)
		firstItemPosition = (*list)->numItems;

	if (itemsDestination != NULL)
		memcpy (itemsDestination, ITEMPTR (list, firstItemPosition - 1),
				(*list)->itemSize * numItemsToRemove);

	firstItemAfterChunk = firstItemPosition + numItemsToRemove;
	numToMove = (*list)->numItems - (firstItemAfterChunk - 1);

	if (numToMove > 0) {
		/*
		 * move part of list down to cover hole left by removed item
		 */
		memmove (ITEMPTR (list, firstItemPosition - 1),
				 ITEMPTR (list, firstItemAfterChunk - 1),
				 (*list)->itemSize * numToMove);
	}

	(*list)->numItems -= numItemsToRemove;
}
#endif	/* CFG_ALL_LIST_FUNCTIONS || CFG_DEVICE_DEREGISTER */

/*******************************/

void ListGetItems (list_t list, void *itemsDestination,
		   int firstItemPosition, int numItemsToGet)
{
21f200a8:	e1a0c00d 	mov	ip, sp
21f200ac:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f200b0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f200b4:	e24dd010 	sub	sp, sp, #16	; 0x10
21f200b8:	e50b0010 	str	r0, [fp, #-16]
21f200bc:	e50b1014 	str	r1, [fp, #-20]
21f200c0:	e50b2018 	str	r2, [fp, #-24]
21f200c4:	e50b301c 	str	r3, [fp, #-28]

	if (firstItemPosition == LIST_START)
21f200c8:	e51b3018 	ldr	r3, [fp, #-24]
21f200cc:	e3730001 	cmn	r3, #1	; 0x1
21f200d0:	1a000002 	bne	21f200e0 <ListGetItems+0x38>
		firstItemPosition = 1;
21f200d4:	e3a03001 	mov	r3, #1	; 0x1
21f200d8:	e50b3018 	str	r3, [fp, #-24]
21f200dc:	ea000006 	b	21f200fc <ListGetItems+0x54>
	else if (firstItemPosition == LIST_END)
21f200e0:	e51b3018 	ldr	r3, [fp, #-24]
21f200e4:	e3530000 	cmp	r3, #0	; 0x0
21f200e8:	1a000003 	bne	21f200fc <ListGetItems+0x54>
		firstItemPosition = (*list)->numItems;
21f200ec:	e51b3010 	ldr	r3, [fp, #-16]
21f200f0:	e5933000 	ldr	r3, [r3]
21f200f4:	e5933014 	ldr	r3, [r3, #20]
21f200f8:	e50b3018 	str	r3, [fp, #-24]

	memcpy (itemsDestination,
21f200fc:	e51b3010 	ldr	r3, [fp, #-16]
21f20100:	e5933000 	ldr	r3, [r3]
21f20104:	e2833018 	add	r3, r3, #24	; 0x18
21f20108:	e1a01003 	mov	r1, r3
21f2010c:	e51b3010 	ldr	r3, [fp, #-16]
21f20110:	e5933000 	ldr	r3, [r3]
21f20114:	e5932010 	ldr	r2, [r3, #16]
21f20118:	e51b3018 	ldr	r3, [fp, #-24]
21f2011c:	e2433001 	sub	r3, r3, #1	; 0x1
21f20120:	e0030392 	mul	r3, r2, r3
21f20124:	e0811003 	add	r1, r1, r3
21f20128:	e51b3010 	ldr	r3, [fp, #-16]
21f2012c:	e5933000 	ldr	r3, [r3]
21f20130:	e5932010 	ldr	r2, [r3, #16]
21f20134:	e51b301c 	ldr	r3, [fp, #-28]
21f20138:	e0030392 	mul	r3, r2, r3
21f2013c:	e51b0014 	ldr	r0, [fp, #-20]
21f20140:	e1a02003 	mov	r2, r3
21f20144:	eb000c20 	bl	21f231cc <memcpy>
		ITEMPTR (list, firstItemPosition - 1),
		(*list)->itemSize * numItemsToGet);
}
21f20148:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2014c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f20150 <ListGetPtrToItem>:

/*******************************/

/*
 * Returns a pointer to the item at itemPosition. returns null if an
 * errors occurred.
 */
void *ListGetPtrToItem (list_t list, int itemPosition)
{
21f20150:	e1a0c00d 	mov	ip, sp
21f20154:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20158:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2015c:	e24dd008 	sub	sp, sp, #8	; 0x8
21f20160:	e50b0010 	str	r0, [fp, #-16]
21f20164:	e50b1014 	str	r1, [fp, #-20]
	if (itemPosition == LIST_START)
21f20168:	e51b3014 	ldr	r3, [fp, #-20]
21f2016c:	e3730001 	cmn	r3, #1	; 0x1
21f20170:	1a000002 	bne	21f20180 <ListGetPtrToItem+0x30>
		itemPosition = 1;
21f20174:	e3a03001 	mov	r3, #1	; 0x1
21f20178:	e50b3014 	str	r3, [fp, #-20]
21f2017c:	ea000006 	b	21f2019c <ListGetPtrToItem+0x4c>
	else if (itemPosition == LIST_END)
21f20180:	e51b3014 	ldr	r3, [fp, #-20]
21f20184:	e3530000 	cmp	r3, #0	; 0x0
21f20188:	1a000003 	bne	21f2019c <ListGetPtrToItem+0x4c>
		itemPosition = (*list)->numItems;
21f2018c:	e51b3010 	ldr	r3, [fp, #-16]
21f20190:	e5933000 	ldr	r3, [r3]
21f20194:	e5933014 	ldr	r3, [r3, #20]
21f20198:	e50b3014 	str	r3, [fp, #-20]

	return ITEMPTR (list, itemPosition - 1);
21f2019c:	e51b3010 	ldr	r3, [fp, #-16]
21f201a0:	e5933000 	ldr	r3, [r3]
21f201a4:	e2833018 	add	r3, r3, #24	; 0x18
21f201a8:	e1a01003 	mov	r1, r3
21f201ac:	e51b3010 	ldr	r3, [fp, #-16]
21f201b0:	e5933000 	ldr	r3, [r3]
21f201b4:	e5932010 	ldr	r2, [r3, #16]
21f201b8:	e51b3014 	ldr	r3, [fp, #-20]
21f201bc:	e2433001 	sub	r3, r3, #1	; 0x1
21f201c0:	e0030392 	mul	r3, r2, r3
21f201c4:	e0813003 	add	r3, r1, r3
}
21f201c8:	e1a00003 	mov	r0, r3
21f201cc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f201d0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f201d4 <ListGetDataPtr>:

/*******************************/

/*
 * returns a pointer the lists data (abstraction violation for
 * optimization)
 */
void *ListGetDataPtr (list_t list)
{
21f201d4:	e1a0c00d 	mov	ip, sp
21f201d8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f201dc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f201e0:	e24dd004 	sub	sp, sp, #4	; 0x4
21f201e4:	e50b0010 	str	r0, [fp, #-16]
	return &((*list)->itemList[0]);
21f201e8:	e51b3010 	ldr	r3, [fp, #-16]
21f201ec:	e5933000 	ldr	r3, [r3]
21f201f0:	e2833018 	add	r3, r3, #24	; 0x18
}
21f201f4:	e1a00003 	mov	r0, r3
21f201f8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f201fc <ListGetItemSize>:

/********************************/

#ifdef	CFG_ALL_LIST_FUNCTIONS

int ListApplyToEach (list_t list, int ascending,
		     ListApplicationFunc funcToApply,
		     void *callbackData)
{
	int result = 0, index;

	if (!list || !funcToApply)
		goto Error;

	if (ascending) {
		for (index = 1; index <= ListNumItems (list); index++) {
			result = funcToApply (index,
					      ListGetPtrToItem (list, index),
					      callbackData);
			if (result < 0)
				goto Error;
		}
	} else {
		for (index = ListNumItems (list);
		     index > 0 && index <= ListNumItems (list);
		     index--) {
			result = funcToApply (index,
					      ListGetPtrToItem (list, index),
					      callbackData);
			if (result < 0)
				goto Error;
		}
	}

Error:
	return result;
}

#endif /* CFG_ALL_LIST_FUNCTIONS */

/********************************/

int ListGetItemSize (list_t list)
{
21f201fc:	e1a0c00d 	mov	ip, sp
21f20200:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20204:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20208:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2020c:	e50b0010 	str	r0, [fp, #-16]
	return (*list)->itemSize;
21f20210:	e51b3010 	ldr	r3, [fp, #-16]
21f20214:	e5933000 	ldr	r3, [r3]
21f20218:	e5933010 	ldr	r3, [r3, #16]
}
21f2021c:	e1a00003 	mov	r0, r3
21f20220:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f20224 <ListNumItems>:

/********************************/

int ListNumItems (list_t list)
{
21f20224:	e1a0c00d 	mov	ip, sp
21f20228:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2022c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20230:	e24dd004 	sub	sp, sp, #4	; 0x4
21f20234:	e50b0010 	str	r0, [fp, #-16]
	return (*list)->numItems;
21f20238:	e51b3010 	ldr	r3, [fp, #-16]
21f2023c:	e5933000 	ldr	r3, [r3]
21f20240:	e5933014 	ldr	r3, [r3, #20]
}
21f20244:	e1a00003 	mov	r0, r3
21f20248:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2024c <miiphy_init>:
 *
 * Initialize global data. Need to be called before any other miiphy routine.
 */
void miiphy_init()
{
21f2024c:	e1a0c00d 	mov	ip, sp
21f20250:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20254:	e24cb004 	sub	fp, ip, #4	; 0x4
		INIT_LIST_HEAD(&mii_devs);
21f20258:	e59f2020 	ldr	r2, [pc, #32]	; 21f20280 <.text+0x20280>
21f2025c:	e59f301c 	ldr	r3, [pc, #28]	; 21f20280 <.text+0x20280>
21f20260:	e5823000 	str	r3, [r2]
21f20264:	e59f2014 	ldr	r2, [pc, #20]	; 21f20280 <.text+0x20280>
21f20268:	e59f3010 	ldr	r3, [pc, #16]	; 21f20280 <.text+0x20280>
21f2026c:	e5823004 	str	r3, [r2, #4]
		current_mii = NULL;
21f20270:	e59f200c 	ldr	r2, [pc, #12]	; 21f20284 <.text+0x20284>
21f20274:	e3a03000 	mov	r3, #0	; 0x0
21f20278:	e5823000 	str	r3, [r2]
}
21f2027c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f20280:	21f677ac 	mvncss	r7, ip, lsr #15
21f20284:	21f677b4 	ldrcsh	r7, [r6, #116]!

21f20288 <miiphy_register>:

/*****************************************************************************
 *
 * Register read and write MII access routines for the device <name>.
 */
void miiphy_register(char *name,
		int (* read)(char *devname, unsigned char addr,
			unsigned char reg, unsigned short *value),
		int (* write)(char *devname, unsigned char addr,
			unsigned char reg, unsigned short value))
{
21f20288:	e1a0c00d 	mov	ip, sp
21f2028c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20290:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20294:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f20298:	e50b0020 	str	r0, [fp, #-32]
21f2029c:	e50b1024 	str	r1, [fp, #-36]
21f202a0:	e50b2028 	str	r2, [fp, #-40]
	struct list_head *entry;
	struct mii_dev *new_dev;
	struct mii_dev *miidev;
	unsigned int name_len;

	/* check if we have unique name */
	list_for_each(entry, &mii_devs) {
21f202a4:	e59f3180 	ldr	r3, [pc, #384]	; 21f2042c <.text+0x2042c>
21f202a8:	e5933000 	ldr	r3, [r3]
21f202ac:	e50b301c 	str	r3, [fp, #-28]
21f202b0:	e51b301c 	ldr	r3, [fp, #-28]
21f202b4:	e5933000 	ldr	r3, [r3]
21f202b8:	e1a00003 	mov	r0, r3
21f202bc:	eb000081 	bl	21f204c8 <prefetch>
21f202c0:	ea000014 	b	21f20318 <miiphy_register+0x90>
		miidev = list_entry(entry, struct mii_dev, link);
21f202c4:	e51b301c 	ldr	r3, [fp, #-28]
21f202c8:	e50b3014 	str	r3, [fp, #-20]
		if (strcmp(miidev->name, name) == 0) {
21f202cc:	e51b3014 	ldr	r3, [fp, #-20]
21f202d0:	e5933008 	ldr	r3, [r3, #8]
21f202d4:	e1a00003 	mov	r0, r3
21f202d8:	e51b1020 	ldr	r1, [fp, #-32]
21f202dc:	eb00099a 	bl	21f2294c <strcmp>
21f202e0:	e1a03000 	mov	r3, r0
21f202e4:	e3530000 	cmp	r3, #0	; 0x0
21f202e8:	1a000003 	bne	21f202fc <miiphy_register+0x74>
			printf("miiphy_register: non unique device name '%s'\n",
21f202ec:	e59f013c 	ldr	r0, [pc, #316]	; 21f20430 <.text+0x20430>
21f202f0:	e51b1020 	ldr	r1, [fp, #-32]
21f202f4:	ebffede4 	bl	21f1ba8c <printf>
					name);
			return;
21f202f8:	ea000049 	b	21f20424 <miiphy_register+0x19c>
21f202fc:	e51b301c 	ldr	r3, [fp, #-28]
21f20300:	e5933000 	ldr	r3, [r3]
21f20304:	e50b301c 	str	r3, [fp, #-28]
21f20308:	e51b301c 	ldr	r3, [fp, #-28]
21f2030c:	e5933000 	ldr	r3, [r3]
21f20310:	e1a00003 	mov	r0, r3
21f20314:	eb00006b 	bl	21f204c8 <prefetch>
21f20318:	e51b201c 	ldr	r2, [fp, #-28]
21f2031c:	e59f3108 	ldr	r3, [pc, #264]	; 21f2042c <.text+0x2042c>
21f20320:	e1520003 	cmp	r2, r3
21f20324:	1affffe6 	bne	21f202c4 <miiphy_register+0x3c>
		}
	}

	/* allocate memory */
	name_len = strlen(name);
21f20328:	e51b0020 	ldr	r0, [fp, #-32]
21f2032c:	eb000a24 	bl	21f22bc4 <strlen>
21f20330:	e1a03000 	mov	r3, r0
21f20334:	e50b3010 	str	r3, [fp, #-16]
	new_dev = (struct mii_dev *)malloc(sizeof(struct mii_dev) + name_len + 1);
21f20338:	e51b3010 	ldr	r3, [fp, #-16]
21f2033c:	e2833015 	add	r3, r3, #21	; 0x15
21f20340:	e1a00003 	mov	r0, r3
21f20344:	ebfff097 	bl	21f1c5a8 <malloc>
21f20348:	e1a03000 	mov	r3, r0
21f2034c:	e50b3018 	str	r3, [fp, #-24]

	if(new_dev == NULL) {
21f20350:	e51b3018 	ldr	r3, [fp, #-24]
21f20354:	e3530000 	cmp	r3, #0	; 0x0
21f20358:	1a000003 	bne	21f2036c <miiphy_register+0xe4>
		printf("miiphy_register: cannot allocate memory for '%s'\n",
21f2035c:	e59f00d0 	ldr	r0, [pc, #208]	; 21f20434 <.text+0x20434>
21f20360:	e51b1020 	ldr	r1, [fp, #-32]
21f20364:	ebffedc8 	bl	21f1ba8c <printf>
				name);
		return;
21f20368:	ea00002d 	b	21f20424 <miiphy_register+0x19c>
	}
	memset(new_dev, 0, sizeof(struct mii_dev) + name_len);
21f2036c:	e51b3010 	ldr	r3, [fp, #-16]
21f20370:	e2833014 	add	r3, r3, #20	; 0x14
21f20374:	e51b0018 	ldr	r0, [fp, #-24]
21f20378:	e3a01000 	mov	r1, #0	; 0x0
21f2037c:	e1a02003 	mov	r2, r3
21f20380:	eb000b58 	bl	21f230e8 <memset>

	/* initalize mii_dev struct fields */
	INIT_LIST_HEAD(&new_dev->link);
21f20384:	e51b2018 	ldr	r2, [fp, #-24]
21f20388:	e51b3018 	ldr	r3, [fp, #-24]
21f2038c:	e5832000 	str	r2, [r3]
21f20390:	e51b2018 	ldr	r2, [fp, #-24]
21f20394:	e51b3018 	ldr	r3, [fp, #-24]
21f20398:	e5832004 	str	r2, [r3, #4]
	new_dev->read = read;
21f2039c:	e51b2018 	ldr	r2, [fp, #-24]
21f203a0:	e51b3024 	ldr	r3, [fp, #-36]
21f203a4:	e582300c 	str	r3, [r2, #12]
	new_dev->write = write;
21f203a8:	e51b2018 	ldr	r2, [fp, #-24]
21f203ac:	e51b3028 	ldr	r3, [fp, #-40]
21f203b0:	e5823010 	str	r3, [r2, #16]
	new_dev->name = (char *)(new_dev + 1);
21f203b4:	e51b3018 	ldr	r3, [fp, #-24]
21f203b8:	e2833014 	add	r3, r3, #20	; 0x14
21f203bc:	e1a02003 	mov	r2, r3
21f203c0:	e51b3018 	ldr	r3, [fp, #-24]
21f203c4:	e5832008 	str	r2, [r3, #8]
	strncpy(new_dev->name, name, name_len);
21f203c8:	e51b3018 	ldr	r3, [fp, #-24]
21f203cc:	e5933008 	ldr	r3, [r3, #8]
21f203d0:	e1a00003 	mov	r0, r3
21f203d4:	e51b1020 	ldr	r1, [fp, #-32]
21f203d8:	e51b2010 	ldr	r2, [fp, #-16]
21f203dc:	eb0008da 	bl	21f2274c <strncpy>
	new_dev->name[name_len] = '\0';
21f203e0:	e51b3018 	ldr	r3, [fp, #-24]
21f203e4:	e5932008 	ldr	r2, [r3, #8]
21f203e8:	e51b3010 	ldr	r3, [fp, #-16]
21f203ec:	e0822003 	add	r2, r2, r3
21f203f0:	e3a03000 	mov	r3, #0	; 0x0
21f203f4:	e5c23000 	strb	r3, [r2]

	debug("miiphy_register: added '%s', read=0x%08lx, write=0x%08lx\n",
			new_dev->name, new_dev->read, new_dev->write);

	/* add it to the list */
	list_add_tail(&new_dev->link, &mii_devs);
21f203f8:	e51b3018 	ldr	r3, [fp, #-24]
21f203fc:	e1a00003 	mov	r0, r3
21f20400:	e59f1024 	ldr	r1, [pc, #36]	; 21f2042c <.text+0x2042c>
21f20404:	eb00000c 	bl	21f2043c <list_add_tail>

	if (!current_mii)
21f20408:	e59f3028 	ldr	r3, [pc, #40]	; 21f20438 <.text+0x20438>
21f2040c:	e5933000 	ldr	r3, [r3]
21f20410:	e3530000 	cmp	r3, #0	; 0x0
21f20414:	1a000002 	bne	21f20424 <miiphy_register+0x19c>
		current_mii = new_dev;
21f20418:	e59f2018 	ldr	r2, [pc, #24]	; 21f20438 <.text+0x20438>
21f2041c:	e51b3018 	ldr	r3, [fp, #-24]
21f20420:	e5823000 	str	r3, [r2]
}
21f20424:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20428:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2042c:	21f677ac 	mvncss	r7, ip, lsr #15
21f20430:	21f323d4 	ldrcssb	r2, [r3, #52]!
21f20434:	21f32404 	mvncss	r2, r4, lsl #8
21f20438:	21f677b4 	ldrcsh	r7, [r6, #116]!

21f2043c <list_add_tail>:
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
21f2043c:	e1a0c00d 	mov	ip, sp
21f20440:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20444:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20448:	e24dd008 	sub	sp, sp, #8	; 0x8
21f2044c:	e50b0010 	str	r0, [fp, #-16]
21f20450:	e50b1014 	str	r1, [fp, #-20]
	__list_add(new, head->prev, head);
21f20454:	e51b3014 	ldr	r3, [fp, #-20]
21f20458:	e5933004 	ldr	r3, [r3, #4]
21f2045c:	e51b0010 	ldr	r0, [fp, #-16]
21f20460:	e1a01003 	mov	r1, r3
21f20464:	e51b2014 	ldr	r2, [fp, #-20]
21f20468:	eb000001 	bl	21f20474 <__list_add>
}
21f2046c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20470:	e89da800 	ldmia	sp, {fp, sp, pc}

21f20474 <__list_add>:
21f20474:	e1a0c00d 	mov	ip, sp
21f20478:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2047c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20480:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f20484:	e50b0010 	str	r0, [fp, #-16]
21f20488:	e50b1014 	str	r1, [fp, #-20]
21f2048c:	e50b2018 	str	r2, [fp, #-24]
21f20490:	e51b2018 	ldr	r2, [fp, #-24]
21f20494:	e51b3010 	ldr	r3, [fp, #-16]
21f20498:	e5823004 	str	r3, [r2, #4]
21f2049c:	e51b2010 	ldr	r2, [fp, #-16]
21f204a0:	e51b3018 	ldr	r3, [fp, #-24]
21f204a4:	e5823000 	str	r3, [r2]
21f204a8:	e51b2010 	ldr	r2, [fp, #-16]
21f204ac:	e51b3014 	ldr	r3, [fp, #-20]
21f204b0:	e5823004 	str	r3, [r2, #4]
21f204b4:	e51b2014 	ldr	r2, [fp, #-20]
21f204b8:	e51b3010 	ldr	r3, [fp, #-16]
21f204bc:	e5823000 	str	r3, [r2]
21f204c0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f204c4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f204c8 <prefetch>:
21f204c8:	e1a0c00d 	mov	ip, sp
21f204cc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f204d0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f204d4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f204d8:	e50b0010 	str	r0, [fp, #-16]
21f204dc:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f204e0 <miiphy_set_current_dev>:

int miiphy_set_current_dev(char *devname)
{
21f204e0:	e1a0c00d 	mov	ip, sp
21f204e4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f204e8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f204ec:	e24dd010 	sub	sp, sp, #16	; 0x10
21f204f0:	e50b0018 	str	r0, [fp, #-24]
	struct list_head *entry;
	struct mii_dev *dev;

	list_for_each(entry, &mii_devs) {
21f204f4:	e59f30a8 	ldr	r3, [pc, #168]	; 21f205a4 <.text+0x205a4>
21f204f8:	e5933000 	ldr	r3, [r3]
21f204fc:	e50b3014 	str	r3, [fp, #-20]
21f20500:	e51b3014 	ldr	r3, [fp, #-20]
21f20504:	e5933000 	ldr	r3, [r3]
21f20508:	e1a00003 	mov	r0, r3
21f2050c:	ebffffed 	bl	21f204c8 <prefetch>
21f20510:	ea000016 	b	21f20570 <miiphy_set_current_dev+0x90>
		dev = list_entry(entry, struct mii_dev, link);
21f20514:	e51b3014 	ldr	r3, [fp, #-20]
21f20518:	e50b3010 	str	r3, [fp, #-16]

		if (strcmp(devname, dev->name) == 0) {
21f2051c:	e51b3010 	ldr	r3, [fp, #-16]
21f20520:	e5933008 	ldr	r3, [r3, #8]
21f20524:	e51b0018 	ldr	r0, [fp, #-24]
21f20528:	e1a01003 	mov	r1, r3
21f2052c:	eb000906 	bl	21f2294c <strcmp>
21f20530:	e1a03000 	mov	r3, r0
21f20534:	e3530000 	cmp	r3, #0	; 0x0
21f20538:	1a000005 	bne	21f20554 <miiphy_set_current_dev+0x74>
			current_mii = dev;
21f2053c:	e59f2064 	ldr	r2, [pc, #100]	; 21f205a8 <.text+0x205a8>
21f20540:	e51b3010 	ldr	r3, [fp, #-16]
21f20544:	e5823000 	str	r3, [r2]
			return 0;
21f20548:	e3a03000 	mov	r3, #0	; 0x0
21f2054c:	e50b301c 	str	r3, [fp, #-28]
21f20550:	ea00000f 	b	21f20594 <miiphy_set_current_dev+0xb4>
21f20554:	e51b3014 	ldr	r3, [fp, #-20]
21f20558:	e5933000 	ldr	r3, [r3]
21f2055c:	e50b3014 	str	r3, [fp, #-20]
21f20560:	e51b3014 	ldr	r3, [fp, #-20]
21f20564:	e5933000 	ldr	r3, [r3]
21f20568:	e1a00003 	mov	r0, r3
21f2056c:	ebffffd5 	bl	21f204c8 <prefetch>
21f20570:	e51b2014 	ldr	r2, [fp, #-20]
21f20574:	e59f3028 	ldr	r3, [pc, #40]	; 21f205a4 <.text+0x205a4>
21f20578:	e1520003 	cmp	r2, r3
21f2057c:	1affffe4 	bne	21f20514 <miiphy_set_current_dev+0x34>
		}
	}

	printf("No such device: %s\n", devname);
21f20580:	e59f0024 	ldr	r0, [pc, #36]	; 21f205ac <.text+0x205ac>
21f20584:	e51b1018 	ldr	r1, [fp, #-24]
21f20588:	ebffed3f 	bl	21f1ba8c <printf>
	return 1;
21f2058c:	e3a03001 	mov	r3, #1	; 0x1
21f20590:	e50b301c 	str	r3, [fp, #-28]
21f20594:	e51b301c 	ldr	r3, [fp, #-28]
}
21f20598:	e1a00003 	mov	r0, r3
21f2059c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f205a0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f205a4:	21f677ac 	mvncss	r7, ip, lsr #15
21f205a8:	21f677b4 	ldrcsh	r7, [r6, #116]!
21f205ac:	21f32438 	mvncss	r2, r8, lsr r4

21f205b0 <miiphy_get_current_dev>:

char *miiphy_get_current_dev()
{
21f205b0:	e1a0c00d 	mov	ip, sp
21f205b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f205b8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f205bc:	e24dd004 	sub	sp, sp, #4	; 0x4
	if (current_mii)
21f205c0:	e59f3030 	ldr	r3, [pc, #48]	; 21f205f8 <.text+0x205f8>
21f205c4:	e5933000 	ldr	r3, [r3]
21f205c8:	e3530000 	cmp	r3, #0	; 0x0
21f205cc:	0a000004 	beq	21f205e4 <miiphy_get_current_dev+0x34>
		return current_mii->name;
21f205d0:	e59f3020 	ldr	r3, [pc, #32]	; 21f205f8 <.text+0x205f8>
21f205d4:	e5933000 	ldr	r3, [r3]
21f205d8:	e5933008 	ldr	r3, [r3, #8]
21f205dc:	e50b3010 	str	r3, [fp, #-16]
21f205e0:	ea000001 	b	21f205ec <miiphy_get_current_dev+0x3c>

	return NULL;
21f205e4:	e3a03000 	mov	r3, #0	; 0x0
21f205e8:	e50b3010 	str	r3, [fp, #-16]
21f205ec:	e51b3010 	ldr	r3, [fp, #-16]
}
21f205f0:	e1a00003 	mov	r0, r3
21f205f4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f205f8:	21f677b4 	ldrcsh	r7, [r6, #116]!

21f205fc <miiphy_read>:

/*****************************************************************************
 *
 * Read to variable <value> from the PHY attached to device <devname>,
 * use PHY address <addr> and register <reg>.
 *
 * Returns:
 *   0 on success
 */
int miiphy_read(char *devname, unsigned char addr, unsigned char reg,
		unsigned short *value)
{
21f205fc:	e1a0c00d 	mov	ip, sp
21f20600:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20604:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20608:	e24dd028 	sub	sp, sp, #40	; 0x28
21f2060c:	e50b0020 	str	r0, [fp, #-32]
21f20610:	e50b302c 	str	r3, [fp, #-44]
21f20614:	e1a03001 	mov	r3, r1
21f20618:	e54b3024 	strb	r3, [fp, #-36]
21f2061c:	e1a03002 	mov	r3, r2
21f20620:	e54b3028 	strb	r3, [fp, #-40]
	struct list_head *entry;
	struct mii_dev *dev;
	int found_dev = 0;
21f20624:	e3a03000 	mov	r3, #0	; 0x0
21f20628:	e50b3014 	str	r3, [fp, #-20]
	int read_ret = 0;
21f2062c:	e3a03000 	mov	r3, #0	; 0x0
21f20630:	e50b3010 	str	r3, [fp, #-16]

	if (!devname) {
21f20634:	e51b3020 	ldr	r3, [fp, #-32]
21f20638:	e3530000 	cmp	r3, #0	; 0x0
21f2063c:	1a000004 	bne	21f20654 <miiphy_read+0x58>
		printf("NULL device name!\n");
21f20640:	e59f0108 	ldr	r0, [pc, #264]	; 21f20750 <.text+0x20750>
21f20644:	ebffed10 	bl	21f1ba8c <printf>
		return 1;
21f20648:	e3a03001 	mov	r3, #1	; 0x1
21f2064c:	e50b3034 	str	r3, [fp, #-52]
21f20650:	ea00003a 	b	21f20740 <miiphy_read+0x144>
	}

	list_for_each(entry, &mii_devs) {
21f20654:	e59f30f8 	ldr	r3, [pc, #248]	; 21f20754 <.text+0x20754>
21f20658:	e5933000 	ldr	r3, [r3]
21f2065c:	e50b301c 	str	r3, [fp, #-28]
21f20660:	e51b301c 	ldr	r3, [fp, #-28]
21f20664:	e5933000 	ldr	r3, [r3]
21f20668:	e1a00003 	mov	r0, r3
21f2066c:	ebffff95 	bl	21f204c8 <prefetch>
21f20670:	ea00001e 	b	21f206f0 <miiphy_read+0xf4>
		dev = list_entry(entry, struct mii_dev, link);
21f20674:	e51b301c 	ldr	r3, [fp, #-28]
21f20678:	e50b3018 	str	r3, [fp, #-24]

		if (strcmp(devname, dev->name) == 0) {
21f2067c:	e51b3018 	ldr	r3, [fp, #-24]
21f20680:	e5933008 	ldr	r3, [r3, #8]
21f20684:	e51b0020 	ldr	r0, [fp, #-32]
21f20688:	e1a01003 	mov	r1, r3
21f2068c:	eb0008ae 	bl	21f2294c <strcmp>
21f20690:	e1a03000 	mov	r3, r0
21f20694:	e3530000 	cmp	r3, #0	; 0x0
21f20698:	1a00000d 	bne	21f206d4 <miiphy_read+0xd8>
			found_dev = 1;
21f2069c:	e3a03001 	mov	r3, #1	; 0x1
21f206a0:	e50b3014 	str	r3, [fp, #-20]
			read_ret = dev->read(devname, addr, reg, value);
21f206a4:	e51b3018 	ldr	r3, [fp, #-24]
21f206a8:	e593c00c 	ldr	ip, [r3, #12]
21f206ac:	e55b3024 	ldrb	r3, [fp, #-36]
21f206b0:	e55b2028 	ldrb	r2, [fp, #-40]
21f206b4:	e51b0020 	ldr	r0, [fp, #-32]
21f206b8:	e1a01003 	mov	r1, r3
21f206bc:	e51b302c 	ldr	r3, [fp, #-44]
21f206c0:	e1a0e00f 	mov	lr, pc
21f206c4:	e1a0f00c 	mov	pc, ip
21f206c8:	e1a03000 	mov	r3, r0
21f206cc:	e50b3010 	str	r3, [fp, #-16]
			break;
21f206d0:	ea00000a 	b	21f20700 <miiphy_read+0x104>
21f206d4:	e51b301c 	ldr	r3, [fp, #-28]
21f206d8:	e5933000 	ldr	r3, [r3]
21f206dc:	e50b301c 	str	r3, [fp, #-28]
21f206e0:	e51b301c 	ldr	r3, [fp, #-28]
21f206e4:	e5933000 	ldr	r3, [r3]
21f206e8:	e1a00003 	mov	r0, r3
21f206ec:	ebffff75 	bl	21f204c8 <prefetch>
21f206f0:	e51b201c 	ldr	r2, [fp, #-28]
21f206f4:	e59f3058 	ldr	r3, [pc, #88]	; 21f20754 <.text+0x20754>
21f206f8:	e1520003 	cmp	r2, r3
21f206fc:	1affffdc 	bne	21f20674 <miiphy_read+0x78>
		}
	}

	if (found_dev == 0)
21f20700:	e51b3014 	ldr	r3, [fp, #-20]
21f20704:	e3530000 	cmp	r3, #0	; 0x0
21f20708:	1a000002 	bne	21f20718 <miiphy_read+0x11c>
		printf("No such device: %s\n", devname);
21f2070c:	e59f0044 	ldr	r0, [pc, #68]	; 21f20758 <.text+0x20758>
21f20710:	e51b1020 	ldr	r1, [fp, #-32]
21f20714:	ebffecdc 	bl	21f1ba8c <printf>

	return ((found_dev) ? read_ret : 1);
21f20718:	e51b3014 	ldr	r3, [fp, #-20]
21f2071c:	e3530000 	cmp	r3, #0	; 0x0
21f20720:	0a000002 	beq	21f20730 <miiphy_read+0x134>
21f20724:	e51b3010 	ldr	r3, [fp, #-16]
21f20728:	e50b3030 	str	r3, [fp, #-48]
21f2072c:	ea000001 	b	21f20738 <miiphy_read+0x13c>
21f20730:	e3a03001 	mov	r3, #1	; 0x1
21f20734:	e50b3030 	str	r3, [fp, #-48]
21f20738:	e51b3030 	ldr	r3, [fp, #-48]
21f2073c:	e50b3034 	str	r3, [fp, #-52]
21f20740:	e51b3034 	ldr	r3, [fp, #-52]
}
21f20744:	e1a00003 	mov	r0, r3
21f20748:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2074c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f20750:	21f3244c 	mvncss	r2, ip, asr #8
21f20754:	21f677ac 	mvncss	r7, ip, lsr #15
21f20758:	21f32438 	mvncss	r2, r8, lsr r4

21f2075c <miiphy_write>:

/*****************************************************************************
 *
 * Write <value> to the PHY attached to device <devname>,
 * use PHY address <addr> and register <reg>.
 *
 * Returns:
 *   0 on success
 */
int miiphy_write(char *devname, unsigned char addr, unsigned char reg,
		unsigned short value)
{
21f2075c:	e1a0c00d 	mov	ip, sp
21f20760:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f20764:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20768:	e24dd028 	sub	sp, sp, #40	; 0x28
21f2076c:	e50b0024 	str	r0, [fp, #-36]
21f20770:	e1a00003 	mov	r0, r3
21f20774:	e1a03001 	mov	r3, r1
21f20778:	e54b3028 	strb	r3, [fp, #-40]
21f2077c:	e1a03002 	mov	r3, r2
21f20780:	e54b302c 	strb	r3, [fp, #-44]
21f20784:	e14b03b0 	strh	r0, [fp, #-48]
	struct list_head *entry;
	struct mii_dev *dev;
	int found_dev = 0;
21f20788:	e3a03000 	mov	r3, #0	; 0x0
21f2078c:	e50b3018 	str	r3, [fp, #-24]
	int write_ret = 0;
21f20790:	e3a03000 	mov	r3, #0	; 0x0
21f20794:	e50b3014 	str	r3, [fp, #-20]

	if (!devname) {
21f20798:	e51b3024 	ldr	r3, [fp, #-36]
21f2079c:	e3530000 	cmp	r3, #0	; 0x0
21f207a0:	1a000004 	bne	21f207b8 <miiphy_write+0x5c>
		printf("NULL device name!\n");
21f207a4:	e59f010c 	ldr	r0, [pc, #268]	; 21f208b8 <.text+0x208b8>
21f207a8:	ebffecb7 	bl	21f1ba8c <printf>
		return 1;
21f207ac:	e3a03001 	mov	r3, #1	; 0x1
21f207b0:	e50b3038 	str	r3, [fp, #-56]
21f207b4:	ea00003b 	b	21f208a8 <miiphy_write+0x14c>
	}

	list_for_each(entry, &mii_devs) {
21f207b8:	e59f30fc 	ldr	r3, [pc, #252]	; 21f208bc <.text+0x208bc>
21f207bc:	e5933000 	ldr	r3, [r3]
21f207c0:	e50b3020 	str	r3, [fp, #-32]
21f207c4:	e51b3020 	ldr	r3, [fp, #-32]
21f207c8:	e5933000 	ldr	r3, [r3]
21f207cc:	e1a00003 	mov	r0, r3
21f207d0:	ebffff3c 	bl	21f204c8 <prefetch>
21f207d4:	ea00001f 	b	21f20858 <miiphy_write+0xfc>
		dev = list_entry(entry, struct mii_dev, link);
21f207d8:	e51b3020 	ldr	r3, [fp, #-32]
21f207dc:	e50b301c 	str	r3, [fp, #-28]

		if (strcmp(devname, dev->name) == 0) {
21f207e0:	e51b301c 	ldr	r3, [fp, #-28]
21f207e4:	e5933008 	ldr	r3, [r3, #8]
21f207e8:	e51b0024 	ldr	r0, [fp, #-36]
21f207ec:	e1a01003 	mov	r1, r3
21f207f0:	eb000855 	bl	21f2294c <strcmp>
21f207f4:	e1a03000 	mov	r3, r0
21f207f8:	e3530000 	cmp	r3, #0	; 0x0
21f207fc:	1a00000e 	bne	21f2083c <miiphy_write+0xe0>
			found_dev = 1;
21f20800:	e3a03001 	mov	r3, #1	; 0x1
21f20804:	e50b3018 	str	r3, [fp, #-24]
			write_ret = dev->write(devname, addr, reg, value);
21f20808:	e51b301c 	ldr	r3, [fp, #-28]
21f2080c:	e5934010 	ldr	r4, [r3, #16]
21f20810:	e55b3028 	ldrb	r3, [fp, #-40]
21f20814:	e55b202c 	ldrb	r2, [fp, #-44]
21f20818:	e15bc3b0 	ldrh	ip, [fp, #-48]
21f2081c:	e51b0024 	ldr	r0, [fp, #-36]
21f20820:	e1a01003 	mov	r1, r3
21f20824:	e1a0300c 	mov	r3, ip
21f20828:	e1a0e00f 	mov	lr, pc
21f2082c:	e1a0f004 	mov	pc, r4
21f20830:	e1a03000 	mov	r3, r0
21f20834:	e50b3014 	str	r3, [fp, #-20]
			break;
21f20838:	ea00000a 	b	21f20868 <miiphy_write+0x10c>
21f2083c:	e51b3020 	ldr	r3, [fp, #-32]
21f20840:	e5933000 	ldr	r3, [r3]
21f20844:	e50b3020 	str	r3, [fp, #-32]
21f20848:	e51b3020 	ldr	r3, [fp, #-32]
21f2084c:	e5933000 	ldr	r3, [r3]
21f20850:	e1a00003 	mov	r0, r3
21f20854:	ebffff1b 	bl	21f204c8 <prefetch>
21f20858:	e51b2020 	ldr	r2, [fp, #-32]
21f2085c:	e59f3058 	ldr	r3, [pc, #88]	; 21f208bc <.text+0x208bc>
21f20860:	e1520003 	cmp	r2, r3
21f20864:	1affffdb 	bne	21f207d8 <miiphy_write+0x7c>
		}
	}

	if (found_dev == 0)
21f20868:	e51b3018 	ldr	r3, [fp, #-24]
21f2086c:	e3530000 	cmp	r3, #0	; 0x0
21f20870:	1a000002 	bne	21f20880 <miiphy_write+0x124>
		printf("No such device: %s\n", devname);
21f20874:	e59f0044 	ldr	r0, [pc, #68]	; 21f208c0 <.text+0x208c0>
21f20878:	e51b1024 	ldr	r1, [fp, #-36]
21f2087c:	ebffec82 	bl	21f1ba8c <printf>

	return ((found_dev) ? write_ret : 1);
21f20880:	e51b3018 	ldr	r3, [fp, #-24]
21f20884:	e3530000 	cmp	r3, #0	; 0x0
21f20888:	0a000002 	beq	21f20898 <miiphy_write+0x13c>
21f2088c:	e51b3014 	ldr	r3, [fp, #-20]
21f20890:	e50b3034 	str	r3, [fp, #-52]
21f20894:	ea000001 	b	21f208a0 <miiphy_write+0x144>
21f20898:	e3a03001 	mov	r3, #1	; 0x1
21f2089c:	e50b3034 	str	r3, [fp, #-52]
21f208a0:	e51b3034 	ldr	r3, [fp, #-52]
21f208a4:	e50b3038 	str	r3, [fp, #-56]
21f208a8:	e51b3038 	ldr	r3, [fp, #-56]
}
21f208ac:	e1a00003 	mov	r0, r3
21f208b0:	e24bd010 	sub	sp, fp, #16	; 0x10
21f208b4:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f208b8:	21f3244c 	mvncss	r2, ip, asr #8
21f208bc:	21f677ac 	mvncss	r7, ip, lsr #15
21f208c0:	21f32438 	mvncss	r2, r8, lsr r4

21f208c4 <miiphy_listdev>:

/*****************************************************************************
 *
 * Print out list of registered MII capable devices.
 */
void miiphy_listdev(void)
{
21f208c4:	e1a0c00d 	mov	ip, sp
21f208c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f208cc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f208d0:	e24dd008 	sub	sp, sp, #8	; 0x8
	struct list_head *entry;
	struct mii_dev *dev;

	puts("MII devices: ");
21f208d4:	e59f00a0 	ldr	r0, [pc, #160]	; 21f2097c <.text+0x2097c>
21f208d8:	ebffec58 	bl	21f1ba40 <puts>
	list_for_each(entry, &mii_devs) {
21f208dc:	e59f309c 	ldr	r3, [pc, #156]	; 21f20980 <.text+0x20980>
21f208e0:	e5933000 	ldr	r3, [r3]
21f208e4:	e50b3014 	str	r3, [fp, #-20]
21f208e8:	e51b3014 	ldr	r3, [fp, #-20]
21f208ec:	e5933000 	ldr	r3, [r3]
21f208f0:	e1a00003 	mov	r0, r3
21f208f4:	ebfffef3 	bl	21f204c8 <prefetch>
21f208f8:	ea00000d 	b	21f20934 <miiphy_listdev+0x70>
		dev = list_entry(entry, struct mii_dev, link);
21f208fc:	e51b3014 	ldr	r3, [fp, #-20]
21f20900:	e50b3010 	str	r3, [fp, #-16]
		printf("'%s' ", dev->name);
21f20904:	e51b3010 	ldr	r3, [fp, #-16]
21f20908:	e5933008 	ldr	r3, [r3, #8]
21f2090c:	e59f0070 	ldr	r0, [pc, #112]	; 21f20984 <.text+0x20984>
21f20910:	e1a01003 	mov	r1, r3
21f20914:	ebffec5c 	bl	21f1ba8c <printf>
21f20918:	e51b3014 	ldr	r3, [fp, #-20]
21f2091c:	e5933000 	ldr	r3, [r3]
21f20920:	e50b3014 	str	r3, [fp, #-20]
21f20924:	e51b3014 	ldr	r3, [fp, #-20]
21f20928:	e5933000 	ldr	r3, [r3]
21f2092c:	e1a00003 	mov	r0, r3
21f20930:	ebfffee4 	bl	21f204c8 <prefetch>
21f20934:	e51b2014 	ldr	r2, [fp, #-20]
21f20938:	e59f3040 	ldr	r3, [pc, #64]	; 21f20980 <.text+0x20980>
21f2093c:	e1520003 	cmp	r2, r3
21f20940:	1affffed 	bne	21f208fc <miiphy_listdev+0x38>
	}
	puts("\n");
21f20944:	e59f003c 	ldr	r0, [pc, #60]	; 21f20988 <.text+0x20988>
21f20948:	ebffec3c 	bl	21f1ba40 <puts>

	if (current_mii)
21f2094c:	e59f3038 	ldr	r3, [pc, #56]	; 21f2098c <.text+0x2098c>
21f20950:	e5933000 	ldr	r3, [r3]
21f20954:	e3530000 	cmp	r3, #0	; 0x0
21f20958:	0a000005 	beq	21f20974 <miiphy_listdev+0xb0>
		printf("Current device: '%s'\n", current_mii->name);
21f2095c:	e59f3028 	ldr	r3, [pc, #40]	; 21f2098c <.text+0x2098c>
21f20960:	e5933000 	ldr	r3, [r3]
21f20964:	e5933008 	ldr	r3, [r3, #8]
21f20968:	e59f0020 	ldr	r0, [pc, #32]	; 21f20990 <.text+0x20990>
21f2096c:	e1a01003 	mov	r1, r3
21f20970:	ebffec45 	bl	21f1ba8c <printf>
}
21f20974:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20978:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2097c:	21f32460 	mvncss	r2, r0, ror #8
21f20980:	21f677ac 	mvncss	r7, ip, lsr #15
21f20984:	21f32470 	mvncss	r2, r0, ror r4
21f20988:	21f32478 	mvncss	r2, r8, ror r4
21f2098c:	21f677b4 	ldrcsh	r7, [r6, #116]!
21f20990:	21f3247c 	mvncss	r2, ip, ror r4

21f20994 <miiphy_info>:


/*****************************************************************************
 *
 * Read the OUI, manufacture's model number, and revision number.
 *
 * OUI:     22 bits (unsigned int)
 * Model:    6 bits (unsigned char)
 * Revision: 4 bits (unsigned char)
 *
 * Returns:
 *   0 on success
 */
int miiphy_info (char *devname,
		 unsigned char addr,
		 unsigned int *oui,
		 unsigned char *model, unsigned char *rev)
{
21f20994:	e1a0c00d 	mov	ip, sp
21f20998:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2099c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f209a0:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f209a4:	e50b0018 	str	r0, [fp, #-24]
21f209a8:	e50b2020 	str	r2, [fp, #-32]
21f209ac:	e50b3024 	str	r3, [fp, #-36]
21f209b0:	e1a03001 	mov	r3, r1
21f209b4:	e54b301c 	strb	r3, [fp, #-28]
	unsigned int reg = 0;
21f209b8:	e3a03000 	mov	r3, #0	; 0x0
21f209bc:	e50b3010 	str	r3, [fp, #-16]
	unsigned short tmp;

	if (miiphy_read (devname, addr, PHY_PHYIDR2, &tmp) != 0) {
21f209c0:	e55b301c 	ldrb	r3, [fp, #-28]
21f209c4:	e24bc012 	sub	ip, fp, #18	; 0x12
21f209c8:	e51b0018 	ldr	r0, [fp, #-24]
21f209cc:	e1a01003 	mov	r1, r3
21f209d0:	e3a02003 	mov	r2, #3	; 0x3
21f209d4:	e1a0300c 	mov	r3, ip
21f209d8:	ebffff07 	bl	21f205fc <miiphy_read>
21f209dc:	e1a03000 	mov	r3, r0
21f209e0:	e3530000 	cmp	r3, #0	; 0x0
21f209e4:	0a000002 	beq	21f209f4 <miiphy_info+0x60>
#ifdef DEBUG
		puts ("PHY ID register 2 read failed\n");
#endif
		return (-1);
21f209e8:	e3e03000 	mvn	r3, #0	; 0x0
21f209ec:	e50b3028 	str	r3, [fp, #-40]
21f209f0:	ea00002d 	b	21f20aac <miiphy_info+0x118>
	}
	reg = tmp;
21f209f4:	e15b31b2 	ldrh	r3, [fp, #-18]
21f209f8:	e50b3010 	str	r3, [fp, #-16]

#ifdef DEBUG
	printf ("PHY_PHYIDR2 @ 0x%x = 0x%04x\n", addr, reg);
#endif
	if (reg == 0xFFFF) {
21f209fc:	e51b2010 	ldr	r2, [fp, #-16]
21f20a00:	e3a03cff 	mov	r3, #65280	; 0xff00
21f20a04:	e28330ff 	add	r3, r3, #255	; 0xff
21f20a08:	e1520003 	cmp	r2, r3
21f20a0c:	1a000002 	bne	21f20a1c <miiphy_info+0x88>
		/* No physical device present at this address */
		return (-1);
21f20a10:	e3e03000 	mvn	r3, #0	; 0x0
21f20a14:	e50b3028 	str	r3, [fp, #-40]
21f20a18:	ea000023 	b	21f20aac <miiphy_info+0x118>
	}

	if (miiphy_read (devname, addr, PHY_PHYIDR1, &tmp) != 0) {
21f20a1c:	e55b301c 	ldrb	r3, [fp, #-28]
21f20a20:	e24bc012 	sub	ip, fp, #18	; 0x12
21f20a24:	e51b0018 	ldr	r0, [fp, #-24]
21f20a28:	e1a01003 	mov	r1, r3
21f20a2c:	e3a02002 	mov	r2, #2	; 0x2
21f20a30:	e1a0300c 	mov	r3, ip
21f20a34:	ebfffef0 	bl	21f205fc <miiphy_read>
21f20a38:	e1a03000 	mov	r3, r0
21f20a3c:	e3530000 	cmp	r3, #0	; 0x0
21f20a40:	0a000002 	beq	21f20a50 <miiphy_info+0xbc>
#ifdef DEBUG
		puts ("PHY ID register 1 read failed\n");
#endif
		return (-1);
21f20a44:	e3e03000 	mvn	r3, #0	; 0x0
21f20a48:	e50b3028 	str	r3, [fp, #-40]
21f20a4c:	ea000016 	b	21f20aac <miiphy_info+0x118>
	}
	reg |= tmp << 16;
21f20a50:	e15b31b2 	ldrh	r3, [fp, #-18]
21f20a54:	e1a03803 	mov	r3, r3, lsl #16
21f20a58:	e1a02003 	mov	r2, r3
21f20a5c:	e51b3010 	ldr	r3, [fp, #-16]
21f20a60:	e1833002 	orr	r3, r3, r2
21f20a64:	e50b3010 	str	r3, [fp, #-16]
#ifdef DEBUG
	printf ("PHY_PHYIDR[1,2] @ 0x%x = 0x%08x\n", addr, reg);
#endif
	*oui   =                 ( reg >> 10);
21f20a68:	e51b3010 	ldr	r3, [fp, #-16]
21f20a6c:	e1a02523 	mov	r2, r3, lsr #10
21f20a70:	e51b3020 	ldr	r3, [fp, #-32]
21f20a74:	e5832000 	str	r2, [r3]
	*model = (unsigned char) ((reg >>  4) & 0x0000003F);
21f20a78:	e51b3010 	ldr	r3, [fp, #-16]
21f20a7c:	e1a03223 	mov	r3, r3, lsr #4
21f20a80:	e20330ff 	and	r3, r3, #255	; 0xff
21f20a84:	e203303f 	and	r3, r3, #63	; 0x3f
21f20a88:	e51b2024 	ldr	r2, [fp, #-36]
21f20a8c:	e5c23000 	strb	r3, [r2]
	*rev   = (unsigned char) ( reg        & 0x0000000F);
21f20a90:	e51b3010 	ldr	r3, [fp, #-16]
21f20a94:	e20330ff 	and	r3, r3, #255	; 0xff
21f20a98:	e203300f 	and	r3, r3, #15	; 0xf
21f20a9c:	e59b2004 	ldr	r2, [fp, #4]
21f20aa0:	e5c23000 	strb	r3, [r2]
	return (0);
21f20aa4:	e3a03000 	mov	r3, #0	; 0x0
21f20aa8:	e50b3028 	str	r3, [fp, #-40]
21f20aac:	e51b3028 	ldr	r3, [fp, #-40]
}
21f20ab0:	e1a00003 	mov	r0, r3
21f20ab4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20ab8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f20abc <miiphy_reset>:


/*****************************************************************************
 *
 * Reset the PHY.
 * Returns:
 *   0 on success
 */
int miiphy_reset (char *devname, unsigned char addr)
{
21f20abc:	e1a0c00d 	mov	ip, sp
21f20ac0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20ac4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20ac8:	e24dd014 	sub	sp, sp, #20	; 0x14
21f20acc:	e50b0018 	str	r0, [fp, #-24]
21f20ad0:	e1a03001 	mov	r3, r1
21f20ad4:	e54b301c 	strb	r3, [fp, #-28]
	unsigned short reg;
	int loop_cnt;

	if (miiphy_read (devname, addr, PHY_BMCR, &reg) != 0) {
21f20ad8:	e55b301c 	ldrb	r3, [fp, #-28]
21f20adc:	e24bc012 	sub	ip, fp, #18	; 0x12
21f20ae0:	e51b0018 	ldr	r0, [fp, #-24]
21f20ae4:	e1a01003 	mov	r1, r3
21f20ae8:	e3a02000 	mov	r2, #0	; 0x0
21f20aec:	e1a0300c 	mov	r3, ip
21f20af0:	ebfffec1 	bl	21f205fc <miiphy_read>
21f20af4:	e1a03000 	mov	r3, r0
21f20af8:	e3530000 	cmp	r3, #0	; 0x0
21f20afc:	0a000002 	beq	21f20b0c <miiphy_reset+0x50>
#ifdef DEBUG
		printf ("PHY status read failed\n");
#endif
		return (-1);
21f20b00:	e3e03000 	mvn	r3, #0	; 0x0
21f20b04:	e50b3020 	str	r3, [fp, #-32]
21f20b08:	ea00003f 	b	21f20c0c <miiphy_reset+0x150>
	}
	if (miiphy_write (devname, addr, PHY_BMCR, reg | 0x8000) != 0) {
21f20b0c:	e55b201c 	ldrb	r2, [fp, #-28]
21f20b10:	e15b31b2 	ldrh	r3, [fp, #-18]
21f20b14:	e1e03883 	mvn	r3, r3, lsl #17
21f20b18:	e1e038a3 	mvn	r3, r3, lsr #17
21f20b1c:	e1a03803 	mov	r3, r3, lsl #16
21f20b20:	e1a03823 	mov	r3, r3, lsr #16
21f20b24:	e51b0018 	ldr	r0, [fp, #-24]
21f20b28:	e1a01002 	mov	r1, r2
21f20b2c:	e3a02000 	mov	r2, #0	; 0x0
21f20b30:	ebffff09 	bl	21f2075c <miiphy_write>
21f20b34:	e1a03000 	mov	r3, r0
21f20b38:	e3530000 	cmp	r3, #0	; 0x0
21f20b3c:	0a000002 	beq	21f20b4c <miiphy_reset+0x90>
#ifdef DEBUG
		puts ("PHY reset failed\n");
#endif
		return (-1);
21f20b40:	e3e03000 	mvn	r3, #0	; 0x0
21f20b44:	e50b3020 	str	r3, [fp, #-32]
21f20b48:	ea00002f 	b	21f20c0c <miiphy_reset+0x150>
	}
#ifdef CONFIG_PHY_RESET_DELAY
	udelay (CONFIG_PHY_RESET_DELAY);	/* Intel LXT971A needs this */
#endif
	/*
	 * Poll the control register for the reset bit to go to 0 (it is
	 * auto-clearing).  This should happen within 0.5 seconds per the
	 * IEEE spec.
	 */
	loop_cnt = 0;
21f20b4c:	e3a03000 	mov	r3, #0	; 0x0
21f20b50:	e50b3010 	str	r3, [fp, #-16]
	reg = 0x8000;
21f20b54:	e3a03902 	mov	r3, #32768	; 0x8000
21f20b58:	e14b31b2 	strh	r3, [fp, #-18]
	while (((reg & 0x8000) != 0) && (loop_cnt++ < 1000000)) {
21f20b5c:	ea00000c 	b	21f20b94 <miiphy_reset+0xd8>
		if (miiphy_read (devname, addr, PHY_BMCR, &reg) != 0) {
21f20b60:	e55b301c 	ldrb	r3, [fp, #-28]
21f20b64:	e24bc012 	sub	ip, fp, #18	; 0x12
21f20b68:	e51b0018 	ldr	r0, [fp, #-24]
21f20b6c:	e1a01003 	mov	r1, r3
21f20b70:	e3a02000 	mov	r2, #0	; 0x0
21f20b74:	e1a0300c 	mov	r3, ip
21f20b78:	ebfffe9f 	bl	21f205fc <miiphy_read>
21f20b7c:	e1a03000 	mov	r3, r0
21f20b80:	e3530000 	cmp	r3, #0	; 0x0
21f20b84:	0a000002 	beq	21f20b94 <miiphy_reset+0xd8>
#     ifdef DEBUG
			puts ("PHY status read failed\n");
#     endif
			return (-1);
21f20b88:	e3e03000 	mvn	r3, #0	; 0x0
21f20b8c:	e50b3020 	str	r3, [fp, #-32]
21f20b90:	ea00001d 	b	21f20c0c <miiphy_reset+0x150>
21f20b94:	e15b31b2 	ldrh	r3, [fp, #-18]
21f20b98:	e1a03803 	mov	r3, r3, lsl #16
21f20b9c:	e1a03843 	mov	r3, r3, asr #16
21f20ba0:	e3530000 	cmp	r3, #0	; 0x0
21f20ba4:	aa00000c 	bge	21f20bdc <miiphy_reset+0x120>
21f20ba8:	e51b2010 	ldr	r2, [fp, #-16]
21f20bac:	e3a0393d 	mov	r3, #999424	; 0xf4000
21f20bb0:	e2833f8f 	add	r3, r3, #572	; 0x23c
21f20bb4:	e2833003 	add	r3, r3, #3	; 0x3
21f20bb8:	e1520003 	cmp	r2, r3
21f20bbc:	c3a03000 	movgt	r3, #0	; 0x0
21f20bc0:	d3a03001 	movle	r3, #1	; 0x1
21f20bc4:	e20320ff 	and	r2, r3, #255	; 0xff
21f20bc8:	e51b3010 	ldr	r3, [fp, #-16]
21f20bcc:	e2833001 	add	r3, r3, #1	; 0x1
21f20bd0:	e50b3010 	str	r3, [fp, #-16]
21f20bd4:	e3520000 	cmp	r2, #0	; 0x0
21f20bd8:	1affffe0 	bne	21f20b60 <miiphy_reset+0xa4>
		}
	}
	if ((reg & 0x8000) == 0) {
21f20bdc:	e15b31b2 	ldrh	r3, [fp, #-18]
21f20be0:	e1a03803 	mov	r3, r3, lsl #16
21f20be4:	e1a03843 	mov	r3, r3, asr #16
21f20be8:	e3530000 	cmp	r3, #0	; 0x0
21f20bec:	ba000002 	blt	21f20bfc <miiphy_reset+0x140>
		return (0);
21f20bf0:	e3a03000 	mov	r3, #0	; 0x0
21f20bf4:	e50b3020 	str	r3, [fp, #-32]
21f20bf8:	ea000003 	b	21f20c0c <miiphy_reset+0x150>
	} else {
		puts ("PHY reset timed out\n");
21f20bfc:	e59f0018 	ldr	r0, [pc, #24]	; 21f20c1c <.text+0x20c1c>
21f20c00:	ebffeb8e 	bl	21f1ba40 <puts>
		return (-1);
21f20c04:	e3e03000 	mvn	r3, #0	; 0x0
21f20c08:	e50b3020 	str	r3, [fp, #-32]
21f20c0c:	e51b3020 	ldr	r3, [fp, #-32]
	}
	return (0);
}
21f20c10:	e1a00003 	mov	r0, r3
21f20c14:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20c18:	e89da800 	ldmia	sp, {fp, sp, pc}
21f20c1c:	21f32494 	ldrcsb	r2, [r3, #68]!

21f20c20 <miiphy_speed>:


/*****************************************************************************
 *
 * Determine the ethernet speed (10/100).
 */
int miiphy_speed (char *devname, unsigned char addr)
{
21f20c20:	e1a0c00d 	mov	ip, sp
21f20c24:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20c28:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20c2c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f20c30:	e50b0014 	str	r0, [fp, #-20]
21f20c34:	e1a03001 	mov	r3, r1
21f20c38:	e54b3018 	strb	r3, [fp, #-24]
	unsigned short reg;

#if defined(CONFIG_PHY_GIGE)
	if (miiphy_read (devname, addr, PHY_1000BTSR, &reg)) {
		printf ("PHY 1000BT Status read failed\n");
	} else {
		if (reg != 0xFFFF) {
			if ((reg & (PHY_1000BTSR_1000FD | PHY_1000BTSR_1000HD)) !=0) {
				return (_1000BASET);
			}
		}
	}
#endif /* CONFIG_PHY_GIGE */

	/* Check Basic Management Control Register first. */
	if (miiphy_read (devname, addr, PHY_BMCR, &reg)) {
21f20c3c:	e55b3018 	ldrb	r3, [fp, #-24]
21f20c40:	e24bc00e 	sub	ip, fp, #14	; 0xe
21f20c44:	e51b0014 	ldr	r0, [fp, #-20]
21f20c48:	e1a01003 	mov	r1, r3
21f20c4c:	e3a02000 	mov	r2, #0	; 0x0
21f20c50:	e1a0300c 	mov	r3, ip
21f20c54:	ebfffe68 	bl	21f205fc <miiphy_read>
21f20c58:	e1a03000 	mov	r3, r0
21f20c5c:	e3530000 	cmp	r3, #0	; 0x0
21f20c60:	0a000004 	beq	21f20c78 <miiphy_speed+0x58>
		puts ("PHY speed read failed, assuming 10bT\n");
21f20c64:	e59f00c4 	ldr	r0, [pc, #196]	; 21f20d30 <.text+0x20d30>
21f20c68:	ebffeb74 	bl	21f1ba40 <puts>
		return (_10BASET);
21f20c6c:	e3a0300a 	mov	r3, #10	; 0xa
21f20c70:	e50b301c 	str	r3, [fp, #-28]
21f20c74:	ea000029 	b	21f20d20 <miiphy_speed+0x100>
	}
	/* Check if auto-negotiation is on. */
	if ((reg & PHY_BMCR_AUTON) != 0) {
21f20c78:	e15b30be 	ldrh	r3, [fp, #-14]
21f20c7c:	e1a03623 	mov	r3, r3, lsr #12
21f20c80:	e2033001 	and	r3, r3, #1	; 0x1
21f20c84:	e20330ff 	and	r3, r3, #255	; 0xff
21f20c88:	e3530000 	cmp	r3, #0	; 0x0
21f20c8c:	0a000018 	beq	21f20cf4 <miiphy_speed+0xd4>
		/* Get auto-negotiation results. */
		if (miiphy_read (devname, addr, PHY_ANLPAR, &reg)) {
21f20c90:	e55b3018 	ldrb	r3, [fp, #-24]
21f20c94:	e24bc00e 	sub	ip, fp, #14	; 0xe
21f20c98:	e51b0014 	ldr	r0, [fp, #-20]
21f20c9c:	e1a01003 	mov	r1, r3
21f20ca0:	e3a02005 	mov	r2, #5	; 0x5
21f20ca4:	e1a0300c 	mov	r3, ip
21f20ca8:	ebfffe53 	bl	21f205fc <miiphy_read>
21f20cac:	e1a03000 	mov	r3, r0
21f20cb0:	e3530000 	cmp	r3, #0	; 0x0
21f20cb4:	0a000004 	beq	21f20ccc <miiphy_speed+0xac>
			puts ("PHY AN speed read failed, assuming 10bT\n");
21f20cb8:	e59f0074 	ldr	r0, [pc, #116]	; 21f20d34 <.text+0x20d34>
21f20cbc:	ebffeb5f 	bl	21f1ba40 <puts>
			return (_10BASET);
21f20cc0:	e3a0300a 	mov	r3, #10	; 0xa
21f20cc4:	e50b301c 	str	r3, [fp, #-28]
21f20cc8:	ea000014 	b	21f20d20 <miiphy_speed+0x100>
		}
		if ((reg & PHY_ANLPAR_100) != 0) {
21f20ccc:	e15b30be 	ldrh	r3, [fp, #-14]
21f20cd0:	e2033d0e 	and	r3, r3, #896	; 0x380
21f20cd4:	e3530000 	cmp	r3, #0	; 0x0
21f20cd8:	0a000002 	beq	21f20ce8 <miiphy_speed+0xc8>
			return (_100BASET);
21f20cdc:	e3a03064 	mov	r3, #100	; 0x64
21f20ce0:	e50b301c 	str	r3, [fp, #-28]
21f20ce4:	ea00000d 	b	21f20d20 <miiphy_speed+0x100>
		} else {
			return (_10BASET);
21f20ce8:	e3a0300a 	mov	r3, #10	; 0xa
21f20cec:	e50b301c 	str	r3, [fp, #-28]
21f20cf0:	ea00000a 	b	21f20d20 <miiphy_speed+0x100>
		}
	}
	/* Get speed from basic control settings. */
	else if (reg & PHY_BMCR_100MB) {
21f20cf4:	e15b30be 	ldrh	r3, [fp, #-14]
21f20cf8:	e1a036a3 	mov	r3, r3, lsr #13
21f20cfc:	e2033001 	and	r3, r3, #1	; 0x1
21f20d00:	e20330ff 	and	r3, r3, #255	; 0xff
21f20d04:	e3530000 	cmp	r3, #0	; 0x0
21f20d08:	0a000002 	beq	21f20d18 <miiphy_speed+0xf8>
		return (_100BASET);
21f20d0c:	e3a03064 	mov	r3, #100	; 0x64
21f20d10:	e50b301c 	str	r3, [fp, #-28]
21f20d14:	ea000001 	b	21f20d20 <miiphy_speed+0x100>
	} else {
		return (_10BASET);
21f20d18:	e3a0300a 	mov	r3, #10	; 0xa
21f20d1c:	e50b301c 	str	r3, [fp, #-28]
21f20d20:	e51b301c 	ldr	r3, [fp, #-28]
	}

}
21f20d24:	e1a00003 	mov	r0, r3
21f20d28:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20d2c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f20d30:	21f324ac 	mvncss	r2, ip, lsr #9
21f20d34:	21f324d4 	ldrcssb	r2, [r3, #68]!

21f20d38 <miiphy_duplex>:


/*****************************************************************************
 *
 * Determine full/half duplex.
 */
int miiphy_duplex (char *devname, unsigned char addr)
{
21f20d38:	e1a0c00d 	mov	ip, sp
21f20d3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20d40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20d44:	e24dd010 	sub	sp, sp, #16	; 0x10
21f20d48:	e50b0014 	str	r0, [fp, #-20]
21f20d4c:	e1a03001 	mov	r3, r1
21f20d50:	e54b3018 	strb	r3, [fp, #-24]
	unsigned short reg;

#if defined(CONFIG_PHY_GIGE)
	if (miiphy_read (devname, addr, PHY_1000BTSR, &reg)) {
		printf ("PHY 1000BT Status read failed\n");
	} else {
		if ( (reg != 0xFFFF) &&
		     (reg & (PHY_1000BTSR_1000FD | PHY_1000BTSR_1000HD)) ) {
			if ((reg & PHY_1000BTSR_1000FD) !=0) {
				return (FULL);
			} else {
				return (HALF);
			}
		}
	}
#endif /* CONFIG_PHY_GIGE */

	/* Check Basic Management Control Register first. */
	if (miiphy_read (devname, addr, PHY_BMCR, &reg)) {
21f20d54:	e55b3018 	ldrb	r3, [fp, #-24]
21f20d58:	e24bc00e 	sub	ip, fp, #14	; 0xe
21f20d5c:	e51b0014 	ldr	r0, [fp, #-20]
21f20d60:	e1a01003 	mov	r1, r3
21f20d64:	e3a02000 	mov	r2, #0	; 0x0
21f20d68:	e1a0300c 	mov	r3, ip
21f20d6c:	ebfffe22 	bl	21f205fc <miiphy_read>
21f20d70:	e1a03000 	mov	r3, r0
21f20d74:	e3530000 	cmp	r3, #0	; 0x0
21f20d78:	0a000004 	beq	21f20d90 <miiphy_duplex+0x58>
		puts ("PHY duplex read failed, assuming half duplex\n");
21f20d7c:	e59f00c4 	ldr	r0, [pc, #196]	; 21f20e48 <.text+0x20e48>
21f20d80:	ebffeb2e 	bl	21f1ba40 <puts>
		return (HALF);
21f20d84:	e3a03016 	mov	r3, #22	; 0x16
21f20d88:	e50b301c 	str	r3, [fp, #-28]
21f20d8c:	ea000029 	b	21f20e38 <miiphy_duplex+0x100>
	}
	/* Check if auto-negotiation is on. */
	if ((reg & PHY_BMCR_AUTON) != 0) {
21f20d90:	e15b30be 	ldrh	r3, [fp, #-14]
21f20d94:	e1a03623 	mov	r3, r3, lsr #12
21f20d98:	e2033001 	and	r3, r3, #1	; 0x1
21f20d9c:	e20330ff 	and	r3, r3, #255	; 0xff
21f20da0:	e3530000 	cmp	r3, #0	; 0x0
21f20da4:	0a000018 	beq	21f20e0c <miiphy_duplex+0xd4>
		/* Get auto-negotiation results. */
		if (miiphy_read (devname, addr, PHY_ANLPAR, &reg)) {
21f20da8:	e55b3018 	ldrb	r3, [fp, #-24]
21f20dac:	e24bc00e 	sub	ip, fp, #14	; 0xe
21f20db0:	e51b0014 	ldr	r0, [fp, #-20]
21f20db4:	e1a01003 	mov	r1, r3
21f20db8:	e3a02005 	mov	r2, #5	; 0x5
21f20dbc:	e1a0300c 	mov	r3, ip
21f20dc0:	ebfffe0d 	bl	21f205fc <miiphy_read>
21f20dc4:	e1a03000 	mov	r3, r0
21f20dc8:	e3530000 	cmp	r3, #0	; 0x0
21f20dcc:	0a000004 	beq	21f20de4 <miiphy_duplex+0xac>
			puts ("PHY AN duplex read failed, assuming half duplex\n");
21f20dd0:	e59f0074 	ldr	r0, [pc, #116]	; 21f20e4c <.text+0x20e4c>
21f20dd4:	ebffeb19 	bl	21f1ba40 <puts>
			return (HALF);
21f20dd8:	e3a03016 	mov	r3, #22	; 0x16
21f20ddc:	e50b301c 	str	r3, [fp, #-28]
21f20de0:	ea000014 	b	21f20e38 <miiphy_duplex+0x100>
		}

		if ((reg & (PHY_ANLPAR_10FD | PHY_ANLPAR_TXFD)) != 0) {
21f20de4:	e15b30be 	ldrh	r3, [fp, #-14]
21f20de8:	e2033d05 	and	r3, r3, #320	; 0x140
21f20dec:	e3530000 	cmp	r3, #0	; 0x0
21f20df0:	0a000002 	beq	21f20e00 <miiphy_duplex+0xc8>
			return (FULL);
21f20df4:	e3a0302c 	mov	r3, #44	; 0x2c
21f20df8:	e50b301c 	str	r3, [fp, #-28]
21f20dfc:	ea00000d 	b	21f20e38 <miiphy_duplex+0x100>
		} else {
			return (HALF);
21f20e00:	e3a03016 	mov	r3, #22	; 0x16
21f20e04:	e50b301c 	str	r3, [fp, #-28]
21f20e08:	ea00000a 	b	21f20e38 <miiphy_duplex+0x100>
		}
	}
	/* Get speed from basic control settings. */
	else if (reg & PHY_BMCR_DPLX) {
21f20e0c:	e15b30be 	ldrh	r3, [fp, #-14]
21f20e10:	e1a03423 	mov	r3, r3, lsr #8
21f20e14:	e2033001 	and	r3, r3, #1	; 0x1
21f20e18:	e20330ff 	and	r3, r3, #255	; 0xff
21f20e1c:	e3530000 	cmp	r3, #0	; 0x0
21f20e20:	0a000002 	beq	21f20e30 <miiphy_duplex+0xf8>
		return (FULL);
21f20e24:	e3a0302c 	mov	r3, #44	; 0x2c
21f20e28:	e50b301c 	str	r3, [fp, #-28]
21f20e2c:	ea000001 	b	21f20e38 <miiphy_duplex+0x100>
	} else {
		return (HALF);
21f20e30:	e3a03016 	mov	r3, #22	; 0x16
21f20e34:	e50b301c 	str	r3, [fp, #-28]
21f20e38:	e51b301c 	ldr	r3, [fp, #-28]
	}

}
21f20e3c:	e1a00003 	mov	r0, r3
21f20e40:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20e44:	e89da800 	ldmia	sp, {fp, sp, pc}
21f20e48:	21f32500 	mvncss	r2, r0, lsl #10
21f20e4c:	21f32530 	mvncss	r2, r0, lsr r5

21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>:
#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
21f20e50:	e1a0c00d 	mov	ip, sp
21f20e54:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20e58:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20e5c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f20e60:	e1a03000 	mov	r3, r0
21f20e64:	e50b1018 	str	r1, [fp, #-24]
21f20e68:	e54b3014 	strb	r3, [fp, #-20]
#define DELAY 20
  unsigned long counter = 0;
21f20e6c:	e3a03000 	mov	r3, #0	; 0x0
21f20e70:	e50b3010 	str	r3, [fp, #-16]
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
21f20e74:	ea000004 	b	21f20e8c <CYGACC_COMM_IF_GETC_TIMEOUT+0x3c>
    {
      udelay (DELAY);
21f20e78:	e3a00014 	mov	r0, #20	; 0x14
21f20e7c:	ebff7f09 	bl	21f00aa8 <udelay>
      counter++;
21f20e80:	e51b3010 	ldr	r3, [fp, #-16]
21f20e84:	e2833001 	add	r3, r3, #1	; 0x1
21f20e88:	e50b3010 	str	r3, [fp, #-16]
21f20e8c:	ebffeabf 	bl	21f1b990 <tstc>
21f20e90:	e1a03000 	mov	r3, r0
21f20e94:	e3530000 	cmp	r3, #0	; 0x0
21f20e98:	1a000005 	bne	21f20eb4 <CYGACC_COMM_IF_GETC_TIMEOUT+0x64>
21f20e9c:	e51b2010 	ldr	r2, [fp, #-16]
21f20ea0:	e3a03b61 	mov	r3, #99328	; 0x18400
21f20ea4:	e2833fa7 	add	r3, r3, #668	; 0x29c
21f20ea8:	e2833003 	add	r3, r3, #3	; 0x3
21f20eac:	e1520003 	cmp	r2, r3
21f20eb0:	9afffff0 	bls	21f20e78 <CYGACC_COMM_IF_GETC_TIMEOUT+0x28>
    }
  if (tstc ())
21f20eb4:	ebffeab5 	bl	21f1b990 <tstc>
21f20eb8:	e1a03000 	mov	r3, r0
21f20ebc:	e3530000 	cmp	r3, #0	; 0x0
21f20ec0:	0a000007 	beq	21f20ee4 <CYGACC_COMM_IF_GETC_TIMEOUT+0x94>
    {
      *c = getc ();
21f20ec4:	ebffea9b 	bl	21f1b938 <getc>
21f20ec8:	e1a03000 	mov	r3, r0
21f20ecc:	e20330ff 	and	r3, r3, #255	; 0xff
21f20ed0:	e51b2018 	ldr	r2, [fp, #-24]
21f20ed4:	e5c23000 	strb	r3, [r2]
      return 1;
21f20ed8:	e3a03001 	mov	r3, #1	; 0x1
21f20edc:	e50b301c 	str	r3, [fp, #-28]
21f20ee0:	ea000001 	b	21f20eec <CYGACC_COMM_IF_GETC_TIMEOUT+0x9c>
    }
  return 0;
21f20ee4:	e3a03000 	mov	r3, #0	; 0x0
21f20ee8:	e50b301c 	str	r3, [fp, #-28]
21f20eec:	e51b301c 	ldr	r3, [fp, #-28]
}
21f20ef0:	e1a00003 	mov	r0, r3
21f20ef4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20ef8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f20efc <CYGACC_COMM_IF_PUTC>:

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
21f20efc:	e1a0c00d 	mov	ip, sp
21f20f00:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20f04:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20f08:	e24dd008 	sub	sp, sp, #8	; 0x8
21f20f0c:	e1a03000 	mov	r3, r0
21f20f10:	e1a02001 	mov	r2, r1
21f20f14:	e54b3010 	strb	r3, [fp, #-16]
21f20f18:	e1a03002 	mov	r3, r2
21f20f1c:	e54b3014 	strb	r3, [fp, #-20]
  putc (y);
21f20f20:	e55b3014 	ldrb	r3, [fp, #-20]
21f20f24:	e1a00003 	mov	r0, r3
21f20f28:	ebffeaae 	bl	21f1b9e8 <putc>
}
21f20f2c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f20f30:	e89da800 	ldmia	sp, {fp, sp, pc}

21f20f34 <parse_num>:

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
}

/* Convert a single hex nibble */
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
    {
      ret = (c - 'a' + 0x0a);
    }
  else if ((c >= 'A') && (c <= 'F'))
    {
      ret = (c - 'A' + 0x0A);
    }
  return ret;
}

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
  if ((c >= 'A') && (c <= 'Z'))
    {
      c = (c - 'A') + 'a';
    }
  return c;
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
21f20f34:	e1a0c00d 	mov	ip, sp
21f20f38:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f20f3c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f20f40:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f20f44:	e50b0028 	str	r0, [fp, #-40]
21f20f48:	e50b102c 	str	r1, [fp, #-44]
21f20f4c:	e50b2030 	str	r2, [fp, #-48]
21f20f50:	e50b3034 	str	r3, [fp, #-52]
  bool first = true;
21f20f54:	e3a03001 	mov	r3, #1	; 0x1
21f20f58:	e50b3024 	str	r3, [fp, #-36]
  int radix = 10;
21f20f5c:	e3a0300a 	mov	r3, #10	; 0xa
21f20f60:	e50b3020 	str	r3, [fp, #-32]
  char c;
  unsigned long result = 0;
21f20f64:	e3a03000 	mov	r3, #0	; 0x0
21f20f68:	e50b3018 	str	r3, [fp, #-24]
  int digit;

  while (*s == ' ')
21f20f6c:	ea000002 	b	21f20f7c <parse_num+0x48>
    s++;
21f20f70:	e51b3028 	ldr	r3, [fp, #-40]
21f20f74:	e2833001 	add	r3, r3, #1	; 0x1
21f20f78:	e50b3028 	str	r3, [fp, #-40]
21f20f7c:	e51b3028 	ldr	r3, [fp, #-40]
21f20f80:	e5d33000 	ldrb	r3, [r3]
21f20f84:	e3530020 	cmp	r3, #32	; 0x20
21f20f88:	0afffff8 	beq	21f20f70 <parse_num+0x3c>
21f20f8c:	ea00004a 	b	21f210bc <parse_num+0x188>
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
21f20f90:	e51b3024 	ldr	r3, [fp, #-36]
21f20f94:	e3530000 	cmp	r3, #0	; 0x0
21f20f98:	0a000010 	beq	21f20fe0 <parse_num+0xac>
21f20f9c:	e51b3028 	ldr	r3, [fp, #-40]
21f20fa0:	e5d33000 	ldrb	r3, [r3]
21f20fa4:	e3530030 	cmp	r3, #48	; 0x30
21f20fa8:	1a00000c 	bne	21f20fe0 <parse_num+0xac>
21f20fac:	e51b3028 	ldr	r3, [fp, #-40]
21f20fb0:	e2833001 	add	r3, r3, #1	; 0x1
21f20fb4:	e5d33000 	ldrb	r3, [r3]
21f20fb8:	e1a00003 	mov	r0, r3
21f20fbc:	eb00009b 	bl	21f21230 <_tolower>
21f20fc0:	e1a03000 	mov	r3, r0
21f20fc4:	e3530078 	cmp	r3, #120	; 0x78
21f20fc8:	1a000004 	bne	21f20fe0 <parse_num+0xac>
	{
	  radix = 16;
21f20fcc:	e3a03010 	mov	r3, #16	; 0x10
21f20fd0:	e50b3020 	str	r3, [fp, #-32]
	  s += 2;
21f20fd4:	e51b3028 	ldr	r3, [fp, #-40]
21f20fd8:	e2833002 	add	r3, r3, #2	; 0x2
21f20fdc:	e50b3028 	str	r3, [fp, #-40]
	}
      first = false;
21f20fe0:	e3a03000 	mov	r3, #0	; 0x0
21f20fe4:	e50b3024 	str	r3, [fp, #-36]
      c = *s++;
21f20fe8:	e51b3028 	ldr	r3, [fp, #-40]
21f20fec:	e5d33000 	ldrb	r3, [r3]
21f20ff0:	e54b3019 	strb	r3, [fp, #-25]
21f20ff4:	e51b3028 	ldr	r3, [fp, #-40]
21f20ff8:	e2833001 	add	r3, r3, #1	; 0x1
21f20ffc:	e50b3028 	str	r3, [fp, #-40]
      if (_is_hex (c) && ((digit = _from_hex (c)) < radix))
21f21000:	e55b3019 	ldrb	r3, [fp, #-25]
21f21004:	e1a00003 	mov	r0, r3
21f21008:	eb000067 	bl	21f211ac <_is_hex>
21f2100c:	e1a03000 	mov	r3, r0
21f21010:	e3530000 	cmp	r3, #0	; 0x0
21f21014:	0a00000f 	beq	21f21058 <parse_num+0x124>
21f21018:	e55b3019 	ldrb	r3, [fp, #-25]
21f2101c:	e1a00003 	mov	r0, r3
21f21020:	eb000038 	bl	21f21108 <_from_hex>
21f21024:	e1a03000 	mov	r3, r0
21f21028:	e50b3014 	str	r3, [fp, #-20]
21f2102c:	e51b2014 	ldr	r2, [fp, #-20]
21f21030:	e51b3020 	ldr	r3, [fp, #-32]
21f21034:	e1520003 	cmp	r2, r3
21f21038:	aa000006 	bge	21f21058 <parse_num+0x124>
	{
	  /* Valid digit */
#ifdef CYGPKG_HAL_MIPS
	  /* FIXME: tx49 compiler generates 0x2539018 for MUL which */
	  /* isn't any good. */
	  if (16 == radix)
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
21f2103c:	e51b2020 	ldr	r2, [fp, #-32]
21f21040:	e51b3018 	ldr	r3, [fp, #-24]
21f21044:	e0020293 	mul	r2, r3, r2
21f21048:	e51b3014 	ldr	r3, [fp, #-20]
21f2104c:	e0823003 	add	r3, r2, r3
21f21050:	e50b3018 	str	r3, [fp, #-24]
21f21054:	ea000018 	b	21f210bc <parse_num+0x188>
#endif
	}
      else
	{
	  if (delim != (char *) 0)
21f21058:	e51b3034 	ldr	r3, [fp, #-52]
21f2105c:	e3530000 	cmp	r3, #0	; 0x0
21f21060:	0a000012 	beq	21f210b0 <parse_num+0x17c>
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
21f21064:	e51b3034 	ldr	r3, [fp, #-52]
21f21068:	e50b3010 	str	r3, [fp, #-16]
	      while (*dp && (c != *dp))
21f2106c:	ea000002 	b	21f2107c <parse_num+0x148>
		dp++;
21f21070:	e51b3010 	ldr	r3, [fp, #-16]
21f21074:	e2833001 	add	r3, r3, #1	; 0x1
21f21078:	e50b3010 	str	r3, [fp, #-16]
21f2107c:	e51b3010 	ldr	r3, [fp, #-16]
21f21080:	e5d33000 	ldrb	r3, [r3]
21f21084:	e3530000 	cmp	r3, #0	; 0x0
21f21088:	0a000004 	beq	21f210a0 <parse_num+0x16c>
21f2108c:	e51b3010 	ldr	r3, [fp, #-16]
21f21090:	e5d32000 	ldrb	r2, [r3]
21f21094:	e55b3019 	ldrb	r3, [fp, #-25]
21f21098:	e1530002 	cmp	r3, r2
21f2109c:	1afffff3 	bne	21f21070 <parse_num+0x13c>
	      if (*dp)
21f210a0:	e51b3010 	ldr	r3, [fp, #-16]
21f210a4:	e5d33000 	ldrb	r3, [r3]
21f210a8:	e3530000 	cmp	r3, #0	; 0x0
21f210ac:	1a000006 	bne	21f210cc <parse_num+0x198>
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
21f210b0:	e3a03000 	mov	r3, #0	; 0x0
21f210b4:	e50b3038 	str	r3, [fp, #-56]
21f210b8:	ea00000e 	b	21f210f8 <parse_num+0x1c4>
21f210bc:	e51b3028 	ldr	r3, [fp, #-40]
21f210c0:	e5d33000 	ldrb	r3, [r3]
21f210c4:	e3530000 	cmp	r3, #0	; 0x0
21f210c8:	1affffb0 	bne	21f20f90 <parse_num+0x5c>
	}
    }
  *val = result;
21f210cc:	e51b302c 	ldr	r3, [fp, #-44]
21f210d0:	e51b2018 	ldr	r2, [fp, #-24]
21f210d4:	e5832000 	str	r2, [r3]
  if (es != (char **) 0)
21f210d8:	e51b3030 	ldr	r3, [fp, #-48]
21f210dc:	e3530000 	cmp	r3, #0	; 0x0
21f210e0:	0a000002 	beq	21f210f0 <parse_num+0x1bc>
    {
      *es = s;
21f210e4:	e51b2030 	ldr	r2, [fp, #-48]
21f210e8:	e51b3028 	ldr	r3, [fp, #-40]
21f210ec:	e5823000 	str	r3, [r2]
    }
  return true;
21f210f0:	e3a03001 	mov	r3, #1	; 0x1
21f210f4:	e50b3038 	str	r3, [fp, #-56]
21f210f8:	e51b3038 	ldr	r3, [fp, #-56]
}
21f210fc:	e1a00003 	mov	r0, r3
21f21100:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f21104:	e89da800 	ldmia	sp, {fp, sp, pc}

21f21108 <_from_hex>:
21f21108:	e1a0c00d 	mov	ip, sp
21f2110c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f21110:	e24cb004 	sub	fp, ip, #4	; 0x4
21f21114:	e24dd008 	sub	sp, sp, #8	; 0x8
21f21118:	e1a03000 	mov	r3, r0
21f2111c:	e54b3014 	strb	r3, [fp, #-20]
21f21120:	e3a03000 	mov	r3, #0	; 0x0
21f21124:	e50b3010 	str	r3, [fp, #-16]
21f21128:	e55b3014 	ldrb	r3, [fp, #-20]
21f2112c:	e353002f 	cmp	r3, #47	; 0x2f
21f21130:	9a000006 	bls	21f21150 <_from_hex+0x48>
21f21134:	e55b3014 	ldrb	r3, [fp, #-20]
21f21138:	e3530039 	cmp	r3, #57	; 0x39
21f2113c:	8a000003 	bhi	21f21150 <_from_hex+0x48>
21f21140:	e55b3014 	ldrb	r3, [fp, #-20]
21f21144:	e2433030 	sub	r3, r3, #48	; 0x30
21f21148:	e50b3010 	str	r3, [fp, #-16]
21f2114c:	ea000012 	b	21f2119c <_from_hex+0x94>
21f21150:	e55b3014 	ldrb	r3, [fp, #-20]
21f21154:	e3530060 	cmp	r3, #96	; 0x60
21f21158:	9a000006 	bls	21f21178 <_from_hex+0x70>
21f2115c:	e55b3014 	ldrb	r3, [fp, #-20]
21f21160:	e3530066 	cmp	r3, #102	; 0x66
21f21164:	8a000003 	bhi	21f21178 <_from_hex+0x70>
21f21168:	e55b3014 	ldrb	r3, [fp, #-20]
21f2116c:	e2433057 	sub	r3, r3, #87	; 0x57
21f21170:	e50b3010 	str	r3, [fp, #-16]
21f21174:	ea000008 	b	21f2119c <_from_hex+0x94>
21f21178:	e55b3014 	ldrb	r3, [fp, #-20]
21f2117c:	e3530040 	cmp	r3, #64	; 0x40
21f21180:	9a000005 	bls	21f2119c <_from_hex+0x94>
21f21184:	e55b3014 	ldrb	r3, [fp, #-20]
21f21188:	e3530046 	cmp	r3, #70	; 0x46
21f2118c:	8a000002 	bhi	21f2119c <_from_hex+0x94>
21f21190:	e55b3014 	ldrb	r3, [fp, #-20]
21f21194:	e2433037 	sub	r3, r3, #55	; 0x37
21f21198:	e50b3010 	str	r3, [fp, #-16]
21f2119c:	e51b3010 	ldr	r3, [fp, #-16]
21f211a0:	e1a00003 	mov	r0, r3
21f211a4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f211a8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f211ac <_is_hex>:
21f211ac:	e1a0c00d 	mov	ip, sp
21f211b0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f211b4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f211b8:	e24dd008 	sub	sp, sp, #8	; 0x8
21f211bc:	e1a03000 	mov	r3, r0
21f211c0:	e54b3010 	strb	r3, [fp, #-16]
21f211c4:	e55b3010 	ldrb	r3, [fp, #-16]
21f211c8:	e353002f 	cmp	r3, #47	; 0x2f
21f211cc:	9a000002 	bls	21f211dc <_is_hex+0x30>
21f211d0:	e55b3010 	ldrb	r3, [fp, #-16]
21f211d4:	e3530039 	cmp	r3, #57	; 0x39
21f211d8:	9a00000b 	bls	21f2120c <_is_hex+0x60>
21f211dc:	e55b3010 	ldrb	r3, [fp, #-16]
21f211e0:	e3530040 	cmp	r3, #64	; 0x40
21f211e4:	9a000002 	bls	21f211f4 <_is_hex+0x48>
21f211e8:	e55b3010 	ldrb	r3, [fp, #-16]
21f211ec:	e3530046 	cmp	r3, #70	; 0x46
21f211f0:	9a000005 	bls	21f2120c <_is_hex+0x60>
21f211f4:	e55b3010 	ldrb	r3, [fp, #-16]
21f211f8:	e3530060 	cmp	r3, #96	; 0x60
21f211fc:	9a000005 	bls	21f21218 <_is_hex+0x6c>
21f21200:	e55b3010 	ldrb	r3, [fp, #-16]
21f21204:	e3530066 	cmp	r3, #102	; 0x66
21f21208:	8a000002 	bhi	21f21218 <_is_hex+0x6c>
21f2120c:	e3a03001 	mov	r3, #1	; 0x1
21f21210:	e50b3014 	str	r3, [fp, #-20]
21f21214:	ea000001 	b	21f21220 <_is_hex+0x74>
21f21218:	e3a03000 	mov	r3, #0	; 0x0
21f2121c:	e50b3014 	str	r3, [fp, #-20]
21f21220:	e51b3014 	ldr	r3, [fp, #-20]
21f21224:	e1a00003 	mov	r0, r3
21f21228:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2122c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f21230 <_tolower>:
21f21230:	e1a0c00d 	mov	ip, sp
21f21234:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f21238:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2123c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f21240:	e1a03000 	mov	r3, r0
21f21244:	e54b3010 	strb	r3, [fp, #-16]
21f21248:	e55b3010 	ldrb	r3, [fp, #-16]
21f2124c:	e3530040 	cmp	r3, #64	; 0x40
21f21250:	9a000006 	bls	21f21270 <_tolower+0x40>
21f21254:	e55b3010 	ldrb	r3, [fp, #-16]
21f21258:	e353005a 	cmp	r3, #90	; 0x5a
21f2125c:	8a000003 	bhi	21f21270 <_tolower+0x40>
21f21260:	e55b3010 	ldrb	r3, [fp, #-16]
21f21264:	e2833020 	add	r3, r3, #32	; 0x20
21f21268:	e20330ff 	and	r3, r3, #255	; 0xff
21f2126c:	e54b3010 	strb	r3, [fp, #-16]
21f21270:	e55b3010 	ldrb	r3, [fp, #-16]
21f21274:	e1a00003 	mov	r0, r3
21f21278:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2127c <xyzModem_flush>:

#endif

#define USE_SPRINTF
#ifdef DEBUG
#ifndef USE_SPRINTF
/*
 * Note: this debug setup only works if the target platform has two serial ports
 * available so that the other one (currently only port 1) can be used for debug
 * messages.
 */
static int
zm_dprintf (char *fmt, ...)
{
  int cur_console;
  va_list args;

  va_start (args, fmt);
#ifdef REDBOOT
  cur_console =
    CYGACC_CALL_IF_SET_CONSOLE_COMM
    (CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
  CYGACC_CALL_IF_SET_CONSOLE_COMM (1);
#endif
  diag_vprintf (fmt, args);
#ifdef REDBOOT
  CYGACC_CALL_IF_SET_CONSOLE_COMM (cur_console);
#endif
}

static void
zm_flush (void)
{
}

#else
/*
 * Note: this debug setup works by storing the strings in a fixed buffer
 */
#define FINAL
#ifdef FINAL
static char *zm_out = (char *) 0x00380000;
static char *zm_out_start = (char *) 0x00380000;
#else
static char zm_buf[8192];
static char *zm_out = zm_buf;
static char *zm_out_start = zm_buf;

#endif
static int
zm_dprintf (char *fmt, ...)
{
  int len;
  va_list args;

  va_start (args, fmt);
  len = diag_vsprintf (zm_out, fmt, args);
  zm_out += len;
  return len;
}

static void
zm_flush (void)
{
#ifdef REDBOOT
  char *p = zm_out_start;
  while (*p)
    mon_write_char (*p++);
#endif
  zm_out = zm_out_start;
}
#endif

static void
zm_dump_buf (void *buf, int len)
{
#ifdef REDBOOT
  diag_vdump_buf_with_offset (zm_dprintf, buf, len, 0);
#else

#endif
}

static unsigned char zm_buf[2048];
static unsigned char *zm_bp;

static void
zm_new (void)
{
  zm_bp = zm_buf;
}

static void
zm_save (unsigned char c)
{
  *zm_bp++ = c;
}

static void
zm_dump (int line)
{
  zm_dprintf ("Packet at line: %d\n", line);
  zm_dump_buf (zm_buf, zm_bp - zm_buf);
}

#define ZM_DEBUG(x) x
#else
#define ZM_DEBUG(x)
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
21f2127c:	e1a0c00d 	mov	ip, sp
21f21280:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f21284:	e24cb004 	sub	fp, ip, #4	; 0x4
21f21288:	e24dd008 	sub	sp, sp, #8	; 0x8
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
21f2128c:	e59f3034 	ldr	r3, [pc, #52]	; 21f212c8 <.text+0x212c8>
21f21290:	e5933000 	ldr	r3, [r3]
21f21294:	e5933000 	ldr	r3, [r3]
21f21298:	e20330ff 	and	r3, r3, #255	; 0xff
21f2129c:	e24b2011 	sub	r2, fp, #17	; 0x11
21f212a0:	e1a00003 	mov	r0, r3
21f212a4:	e1a01002 	mov	r1, r2
21f212a8:	ebfffee8 	bl	21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>
21f212ac:	e1a03000 	mov	r3, r0
21f212b0:	e50b3010 	str	r3, [fp, #-16]
      if (!res)
21f212b4:	e51b3010 	ldr	r3, [fp, #-16]
21f212b8:	e3530000 	cmp	r3, #0	; 0x0
21f212bc:	1afffff2 	bne	21f2128c <xyzModem_flush+0x10>
	return;
    }
}
21f212c0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f212c4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f212c8:	21f677b8 	ldrcsh	r7, [r6, #120]!

21f212cc <xyzModem_get_hdr>:

static int
xyzModem_get_hdr (void)
{
21f212cc:	e1a0c00d 	mov	ip, sp
21f212d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f212d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f212d8:	e24dd024 	sub	sp, sp, #36	; 0x24
  char c;
  int res;
  bool hdr_found = false;
21f212dc:	e3a03000 	mov	r3, #0	; 0x0
21f212e0:	e50b3020 	str	r3, [fp, #-32]
  int i, can_total, hdr_chars;
  unsigned short cksum;

  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
21f212e4:	e3a03000 	mov	r3, #0	; 0x0
21f212e8:	e50b3018 	str	r3, [fp, #-24]
  hdr_chars = 0;
21f212ec:	e3a03000 	mov	r3, #0	; 0x0
21f212f0:	e50b3014 	str	r3, [fp, #-20]

  if (xyz.tx_ack)
21f212f4:	e59f34bc 	ldr	r3, [pc, #1212]	; 21f217b8 <.text+0x217b8>
21f212f8:	e5933430 	ldr	r3, [r3, #1072]
21f212fc:	e3530000 	cmp	r3, #0	; 0x0
21f21300:	0a000069 	beq	21f214ac <.text+0x214ac>
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
21f21304:	e59f34ac 	ldr	r3, [pc, #1196]	; 21f217b8 <.text+0x217b8>
21f21308:	e5933000 	ldr	r3, [r3]
21f2130c:	e5933000 	ldr	r3, [r3]
21f21310:	e20330ff 	and	r3, r3, #255	; 0xff
21f21314:	e1a00003 	mov	r0, r3
21f21318:	e3a01006 	mov	r1, #6	; 0x6
21f2131c:	ebfffef6 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
      xyz.tx_ack = false;
21f21320:	e59f2490 	ldr	r2, [pc, #1168]	; 21f217b8 <.text+0x217b8>
21f21324:	e3a03000 	mov	r3, #0	; 0x0
21f21328:	e5823430 	str	r3, [r2, #1072]
21f2132c:	ea00005e 	b	21f214ac <.text+0x214ac>
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
21f21330:	e59f3480 	ldr	r3, [pc, #1152]	; 21f217b8 <.text+0x217b8>
21f21334:	e5933000 	ldr	r3, [r3]
21f21338:	e5933000 	ldr	r3, [r3]
21f2133c:	e20330ff 	and	r3, r3, #255	; 0xff
21f21340:	e24b2025 	sub	r2, fp, #37	; 0x25
21f21344:	e1a00003 	mov	r0, r3
21f21348:	e1a01002 	mov	r1, r2
21f2134c:	ebfffebf 	bl	21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>
21f21350:	e1a03000 	mov	r3, r0
21f21354:	e50b3024 	str	r3, [fp, #-36]
      ZM_DEBUG (zm_save (c));
      if (res)
21f21358:	e51b3024 	ldr	r3, [fp, #-36]
21f2135c:	e3530000 	cmp	r3, #0	; 0x0
21f21360:	0a00004a 	beq	21f21490 <.text+0x21490>
	{
	  hdr_chars++;
21f21364:	e51b3014 	ldr	r3, [fp, #-20]
21f21368:	e2833001 	add	r3, r3, #1	; 0x1
21f2136c:	e50b3014 	str	r3, [fp, #-20]
	  switch (c)
21f21370:	e55b3025 	ldrb	r3, [fp, #-37]
21f21374:	e2433001 	sub	r3, r3, #1	; 0x1
21f21378:	e3530017 	cmp	r3, #23	; 0x17
21f2137c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f21380:	ea000049 	b	21f214ac <.text+0x214ac>
21f21384:	21f213e4 	mvncss	r1, r4, ror #7
21f21388:	21f213f8 	ldrcssh	r1, [r2, #56]!
21f2138c:	21f214ac 	mvncss	r1, ip, lsr #9
21f21390:	21f2145c 	mvncss	r1, ip, asr r4
21f21394:	21f214ac 	mvncss	r1, ip, lsr #9
21f21398:	21f214ac 	mvncss	r1, ip, lsr #9
21f2139c:	21f214ac 	mvncss	r1, ip, lsr #9
21f213a0:	21f214ac 	mvncss	r1, ip, lsr #9
21f213a4:	21f214ac 	mvncss	r1, ip, lsr #9
21f213a8:	21f214ac 	mvncss	r1, ip, lsr #9
21f213ac:	21f214ac 	mvncss	r1, ip, lsr #9
21f213b0:	21f214ac 	mvncss	r1, ip, lsr #9
21f213b4:	21f214ac 	mvncss	r1, ip, lsr #9
21f213b8:	21f214ac 	mvncss	r1, ip, lsr #9
21f213bc:	21f214ac 	mvncss	r1, ip, lsr #9
21f213c0:	21f214ac 	mvncss	r1, ip, lsr #9
21f213c4:	21f214ac 	mvncss	r1, ip, lsr #9
21f213c8:	21f214ac 	mvncss	r1, ip, lsr #9
21f213cc:	21f214ac 	mvncss	r1, ip, lsr #9
21f213d0:	21f214ac 	mvncss	r1, ip, lsr #9
21f213d4:	21f214ac 	mvncss	r1, ip, lsr #9
21f213d8:	21f214ac 	mvncss	r1, ip, lsr #9
21f213dc:	21f214ac 	mvncss	r1, ip, lsr #9
21f213e0:	21f21424 	mvncss	r1, r4, lsr #8
	    {
	    case SOH:
	      xyz.total_SOH++;
21f213e4:	e59f33cc 	ldr	r3, [pc, #972]	; 21f217b8 <.text+0x217b8>
21f213e8:	e593341c 	ldr	r3, [r3, #1052]
21f213ec:	e2832001 	add	r2, r3, #1	; 0x1
21f213f0:	e59f33c0 	ldr	r3, [pc, #960]	; 21f217b8 <.text+0x217b8>
21f213f4:	e583241c 	str	r2, [r3, #1052]
	    case STX:
	      if (c == STX)
21f213f8:	e55b3025 	ldrb	r3, [fp, #-37]
21f213fc:	e3530002 	cmp	r3, #2	; 0x2
21f21400:	1a000004 	bne	21f21418 <.text+0x21418>
		xyz.total_STX++;
21f21404:	e59f33ac 	ldr	r3, [pc, #940]	; 21f217b8 <.text+0x217b8>
21f21408:	e5933420 	ldr	r3, [r3, #1056]
21f2140c:	e2832001 	add	r2, r3, #1	; 0x1
21f21410:	e59f33a0 	ldr	r3, [pc, #928]	; 21f217b8 <.text+0x217b8>
21f21414:	e5832420 	str	r2, [r3, #1056]
	      hdr_found = true;
21f21418:	e3a03001 	mov	r3, #1	; 0x1
21f2141c:	e50b3020 	str	r3, [fp, #-32]
	      break;
21f21420:	ea000021 	b	21f214ac <.text+0x214ac>
	    case CAN:
	      xyz.total_CAN++;
21f21424:	e59f338c 	ldr	r3, [pc, #908]	; 21f217b8 <.text+0x217b8>
21f21428:	e5933424 	ldr	r3, [r3, #1060]
21f2142c:	e2832001 	add	r2, r3, #1	; 0x1
21f21430:	e59f3380 	ldr	r3, [pc, #896]	; 21f217b8 <.text+0x217b8>
21f21434:	e5832424 	str	r2, [r3, #1060]
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
21f21438:	e51b3018 	ldr	r3, [fp, #-24]
21f2143c:	e2833001 	add	r3, r3, #1	; 0x1
21f21440:	e50b3018 	str	r3, [fp, #-24]
21f21444:	e51b3018 	ldr	r3, [fp, #-24]
21f21448:	e3530003 	cmp	r3, #3	; 0x3
21f2144c:	1a000016 	bne	21f214ac <.text+0x214ac>
		{
		  return xyzModem_cancel;
21f21450:	e3e02004 	mvn	r2, #4	; 0x4
21f21454:	e50b2030 	str	r2, [fp, #-48]
21f21458:	ea0000d2 	b	21f217a8 <.text+0x217a8>
		}
	      else
		{
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
21f2145c:	e51b3014 	ldr	r3, [fp, #-20]
21f21460:	e3530001 	cmp	r3, #1	; 0x1
21f21464:	1a000010 	bne	21f214ac <.text+0x214ac>
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
21f21468:	e59f3348 	ldr	r3, [pc, #840]	; 21f217b8 <.text+0x217b8>
21f2146c:	e5933000 	ldr	r3, [r3]
21f21470:	e5933000 	ldr	r3, [r3]
21f21474:	e20330ff 	and	r3, r3, #255	; 0xff
21f21478:	e1a00003 	mov	r0, r3
21f2147c:	e3a01006 	mov	r1, #6	; 0x6
21f21480:	ebfffe9d 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
21f21484:	e3e03003 	mvn	r3, #3	; 0x3
21f21488:	e50b3030 	str	r3, [fp, #-48]
21f2148c:	ea0000c5 	b	21f217a8 <.text+0x217a8>
		}
	    default:
	      /* Ignore, waiting for start of header */
	      ;
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
21f21490:	ebffff79 	bl	21f2127c <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
21f21494:	e3a00a3d 	mov	r0, #249856	; 0x3d000
21f21498:	e2800090 	add	r0, r0, #144	; 0x90
21f2149c:	ebff7d81 	bl	21f00aa8 <udelay>
	  return xyzModem_timeout;
21f214a0:	e3e02002 	mvn	r2, #2	; 0x2
21f214a4:	e50b2030 	str	r2, [fp, #-48]
21f214a8:	ea0000be 	b	21f217a8 <.text+0x217a8>
21f214ac:	e51b3020 	ldr	r3, [fp, #-32]
21f214b0:	e3530000 	cmp	r3, #0	; 0x0
21f214b4:	0affff9d 	beq	21f21330 <xyzModem_get_hdr+0x64>
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
21f214b8:	e59f32f8 	ldr	r3, [pc, #760]	; 21f217b8 <.text+0x217b8>
21f214bc:	e5933000 	ldr	r3, [r3]
21f214c0:	e5933000 	ldr	r3, [r3]
21f214c4:	e20330ff 	and	r3, r3, #255	; 0xff
21f214c8:	e59f22ec 	ldr	r2, [pc, #748]	; 21f217bc <.text+0x217bc>
21f214cc:	e1a00003 	mov	r0, r3
21f214d0:	e1a01002 	mov	r1, r2
21f214d4:	ebfffe5d 	bl	21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>
21f214d8:	e1a03000 	mov	r3, r0
21f214dc:	e50b3024 	str	r3, [fp, #-36]
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
21f214e0:	e51b3024 	ldr	r3, [fp, #-36]
21f214e4:	e3530000 	cmp	r3, #0	; 0x0
21f214e8:	1a000002 	bne	21f214f8 <.text+0x214f8>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
21f214ec:	e3e03002 	mvn	r3, #2	; 0x2
21f214f0:	e50b3030 	str	r3, [fp, #-48]
21f214f4:	ea0000ab 	b	21f217a8 <.text+0x217a8>
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
21f214f8:	e59f32b8 	ldr	r3, [pc, #696]	; 21f217b8 <.text+0x217b8>
21f214fc:	e5933000 	ldr	r3, [r3]
21f21500:	e5933000 	ldr	r3, [r3]
21f21504:	e20330ff 	and	r3, r3, #255	; 0xff
21f21508:	e59f22b0 	ldr	r2, [pc, #688]	; 21f217c0 <.text+0x217c0>
21f2150c:	e1a00003 	mov	r0, r3
21f21510:	e1a01002 	mov	r1, r2
21f21514:	ebfffe4d 	bl	21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>
21f21518:	e1a03000 	mov	r3, r0
21f2151c:	e50b3024 	str	r3, [fp, #-36]
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
21f21520:	e51b3024 	ldr	r3, [fp, #-36]
21f21524:	e3530000 	cmp	r3, #0	; 0x0
21f21528:	1a000002 	bne	21f21538 <.text+0x21538>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
21f2152c:	e3e02002 	mvn	r2, #2	; 0x2
21f21530:	e50b2030 	str	r2, [fp, #-48]
21f21534:	ea00009b 	b	21f217a8 <.text+0x217a8>
    }
  xyz.len = (c == SOH) ? 128 : 1024;
21f21538:	e55b3025 	ldrb	r3, [fp, #-37]
21f2153c:	e3530001 	cmp	r3, #1	; 0x1
21f21540:	1a000002 	bne	21f21550 <.text+0x21550>
21f21544:	e3a03080 	mov	r3, #128	; 0x80
21f21548:	e50b302c 	str	r3, [fp, #-44]
21f2154c:	ea000001 	b	21f21558 <.text+0x21558>
21f21550:	e3a02b01 	mov	r2, #1024	; 0x400
21f21554:	e50b202c 	str	r2, [fp, #-44]
21f21558:	e59f3258 	ldr	r3, [pc, #600]	; 21f217b8 <.text+0x217b8>
21f2155c:	e51b202c 	ldr	r2, [fp, #-44]
21f21560:	e5832410 	str	r2, [r3, #1040]
  xyz.bufp = xyz.pkt;
21f21564:	e59f224c 	ldr	r2, [pc, #588]	; 21f217b8 <.text+0x217b8>
21f21568:	e59f3254 	ldr	r3, [pc, #596]	; 21f217c4 <.text+0x217c4>
21f2156c:	e5823404 	str	r3, [r2, #1028]
  for (i = 0; i < xyz.len; i++)
21f21570:	e3a03000 	mov	r3, #0	; 0x0
21f21574:	e50b301c 	str	r3, [fp, #-28]
21f21578:	ea00001b 	b	21f215ec <.text+0x215ec>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
21f2157c:	e59f3234 	ldr	r3, [pc, #564]	; 21f217b8 <.text+0x217b8>
21f21580:	e5933000 	ldr	r3, [r3]
21f21584:	e5933000 	ldr	r3, [r3]
21f21588:	e20330ff 	and	r3, r3, #255	; 0xff
21f2158c:	e24b2025 	sub	r2, fp, #37	; 0x25
21f21590:	e1a00003 	mov	r0, r3
21f21594:	e1a01002 	mov	r1, r2
21f21598:	ebfffe2c 	bl	21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>
21f2159c:	e1a03000 	mov	r3, r0
21f215a0:	e50b3024 	str	r3, [fp, #-36]
      ZM_DEBUG (zm_save (c));
      if (res)
21f215a4:	e51b3024 	ldr	r3, [fp, #-36]
21f215a8:	e3530000 	cmp	r3, #0	; 0x0
21f215ac:	0a00000b 	beq	21f215e0 <.text+0x215e0>
	{
	  xyz.pkt[i] = c;
21f215b0:	e51b101c 	ldr	r1, [fp, #-28]
21f215b4:	e55b0025 	ldrb	r0, [fp, #-37]
21f215b8:	e59f31f8 	ldr	r3, [pc, #504]	; 21f217b8 <.text+0x217b8>
21f215bc:	e3a02004 	mov	r2, #4	; 0x4
21f215c0:	e0813003 	add	r3, r1, r3
21f215c4:	e0832002 	add	r2, r3, r2
21f215c8:	e1a03000 	mov	r3, r0
21f215cc:	e5c23000 	strb	r3, [r2]
21f215d0:	e51b301c 	ldr	r3, [fp, #-28]
21f215d4:	e2833001 	add	r3, r3, #1	; 0x1
21f215d8:	e50b301c 	str	r3, [fp, #-28]
21f215dc:	ea000002 	b	21f215ec <.text+0x215ec>
	}
      else
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
21f215e0:	e3e03002 	mvn	r3, #2	; 0x2
21f215e4:	e50b3030 	str	r3, [fp, #-48]
21f215e8:	ea00006e 	b	21f217a8 <.text+0x217a8>
21f215ec:	e59f31c4 	ldr	r3, [pc, #452]	; 21f217b8 <.text+0x217b8>
21f215f0:	e5932410 	ldr	r2, [r3, #1040]
21f215f4:	e51b301c 	ldr	r3, [fp, #-28]
21f215f8:	e1520003 	cmp	r2, r3
21f215fc:	caffffde 	bgt	21f2157c <.text+0x2157c>
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
21f21600:	e59f31b0 	ldr	r3, [pc, #432]	; 21f217b8 <.text+0x217b8>
21f21604:	e5933000 	ldr	r3, [r3]
21f21608:	e5933000 	ldr	r3, [r3]
21f2160c:	e20330ff 	and	r3, r3, #255	; 0xff
21f21610:	e59f21b0 	ldr	r2, [pc, #432]	; 21f217c8 <.text+0x217c8>
21f21614:	e1a00003 	mov	r0, r3
21f21618:	e1a01002 	mov	r1, r2
21f2161c:	ebfffe0b 	bl	21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>
21f21620:	e1a03000 	mov	r3, r0
21f21624:	e50b3024 	str	r3, [fp, #-36]
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
21f21628:	e51b3024 	ldr	r3, [fp, #-36]
21f2162c:	e3530000 	cmp	r3, #0	; 0x0
21f21630:	1a000002 	bne	21f21640 <.text+0x21640>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
21f21634:	e3e02002 	mvn	r2, #2	; 0x2
21f21638:	e50b2030 	str	r2, [fp, #-48]
21f2163c:	ea000059 	b	21f217a8 <.text+0x217a8>
    }
  if (xyz.crc_mode)
21f21640:	e59f3170 	ldr	r3, [pc, #368]	; 21f217b8 <.text+0x217b8>
21f21644:	e5933428 	ldr	r3, [r3, #1064]
21f21648:	e3530000 	cmp	r3, #0	; 0x0
21f2164c:	0a00000f 	beq	21f21690 <.text+0x21690>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
21f21650:	e59f3160 	ldr	r3, [pc, #352]	; 21f217b8 <.text+0x217b8>
21f21654:	e5933000 	ldr	r3, [r3]
21f21658:	e5933000 	ldr	r3, [r3]
21f2165c:	e20330ff 	and	r3, r3, #255	; 0xff
21f21660:	e59f2164 	ldr	r2, [pc, #356]	; 21f217cc <.text+0x217cc>
21f21664:	e1a00003 	mov	r0, r3
21f21668:	e1a01002 	mov	r1, r2
21f2166c:	ebfffdf7 	bl	21f20e50 <CYGACC_COMM_IF_GETC_TIMEOUT>
21f21670:	e1a03000 	mov	r3, r0
21f21674:	e50b3024 	str	r3, [fp, #-36]
      ZM_DEBUG (zm_save (xyz.crc2));
      if (!res)
21f21678:	e51b3024 	ldr	r3, [fp, #-36]
21f2167c:	e3530000 	cmp	r3, #0	; 0x0
21f21680:	1a000002 	bne	21f21690 <.text+0x21690>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
21f21684:	e3e03002 	mvn	r3, #2	; 0x2
21f21688:	e50b3030 	str	r3, [fp, #-48]
21f2168c:	ea000045 	b	21f217a8 <.text+0x217a8>
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
21f21690:	e59f3120 	ldr	r3, [pc, #288]	; 21f217b8 <.text+0x217b8>
21f21694:	e5d32408 	ldrb	r2, [r3, #1032]
21f21698:	e59f3118 	ldr	r3, [pc, #280]	; 21f217b8 <.text+0x217b8>
21f2169c:	e5d33409 	ldrb	r3, [r3, #1033]
21f216a0:	e0223003 	eor	r3, r2, r3
21f216a4:	e20330ff 	and	r3, r3, #255	; 0xff
21f216a8:	e35300ff 	cmp	r3, #255	; 0xff
21f216ac:	0a000003 	beq	21f216c0 <.text+0x216c0>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
21f216b0:	ebfffef1 	bl	21f2127c <xyzModem_flush>
      return xyzModem_frame;
21f216b4:	e3e02005 	mvn	r2, #5	; 0x5
21f216b8:	e50b2030 	str	r2, [fp, #-48]
21f216bc:	ea000039 	b	21f217a8 <.text+0x217a8>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
21f216c0:	e59f30f0 	ldr	r3, [pc, #240]	; 21f217b8 <.text+0x217b8>
21f216c4:	e5933428 	ldr	r3, [r3, #1064]
21f216c8:	e3530000 	cmp	r3, #0	; 0x0
21f216cc:	0a000012 	beq	21f2171c <.text+0x2171c>
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
21f216d0:	e59f30e0 	ldr	r3, [pc, #224]	; 21f217b8 <.text+0x217b8>
21f216d4:	e5933410 	ldr	r3, [r3, #1040]
21f216d8:	e59f00e4 	ldr	r0, [pc, #228]	; 21f217c4 <.text+0x217c4>
21f216dc:	e1a01003 	mov	r1, r3
21f216e0:	eb0002d4 	bl	21f22238 <cyg_crc16>
21f216e4:	e1a03000 	mov	r3, r0
21f216e8:	e14b30be 	strh	r3, [fp, #-14]
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
21f216ec:	e15b10be 	ldrh	r1, [fp, #-14]
21f216f0:	e59f30c0 	ldr	r3, [pc, #192]	; 21f217b8 <.text+0x217b8>
21f216f4:	e5d3340a 	ldrb	r3, [r3, #1034]
21f216f8:	e1a02403 	mov	r2, r3, lsl #8
21f216fc:	e59f30b4 	ldr	r3, [pc, #180]	; 21f217b8 <.text+0x217b8>
21f21700:	e5d3340b 	ldrb	r3, [r3, #1035]
21f21704:	e1823003 	orr	r3, r2, r3
21f21708:	e1510003 	cmp	r1, r3
21f2170c:	0a000023 	beq	21f217a0 <.text+0x217a0>
	{
	  ZM_DEBUG (zm_dprintf ("CRC error - recvd: %02x%02x, computed: %x\n",
				xyz.crc1, xyz.crc2, cksum & 0xFFFF));
	  return xyzModem_cksum;
21f21710:	e3e03006 	mvn	r3, #6	; 0x6
21f21714:	e50b3030 	str	r3, [fp, #-48]
21f21718:	ea000022 	b	21f217a8 <.text+0x217a8>
	}
    }
  else
    {
      cksum = 0;
21f2171c:	e3a03000 	mov	r3, #0	; 0x0
21f21720:	e14b30be 	strh	r3, [fp, #-14]
      for (i = 0; i < xyz.len; i++)
21f21724:	e3a03000 	mov	r3, #0	; 0x0
21f21728:	e50b301c 	str	r3, [fp, #-28]
21f2172c:	ea00000c 	b	21f21764 <.text+0x21764>
	{
	  cksum += xyz.pkt[i];
21f21730:	e51b101c 	ldr	r1, [fp, #-28]
21f21734:	e59f307c 	ldr	r3, [pc, #124]	; 21f217b8 <.text+0x217b8>
21f21738:	e3a02004 	mov	r2, #4	; 0x4
21f2173c:	e0813003 	add	r3, r1, r3
21f21740:	e0833002 	add	r3, r3, r2
21f21744:	e5d33000 	ldrb	r3, [r3]
21f21748:	e1a02003 	mov	r2, r3
21f2174c:	e15b30be 	ldrh	r3, [fp, #-14]
21f21750:	e0823003 	add	r3, r2, r3
21f21754:	e14b30be 	strh	r3, [fp, #-14]
21f21758:	e51b301c 	ldr	r3, [fp, #-28]
21f2175c:	e2833001 	add	r3, r3, #1	; 0x1
21f21760:	e50b301c 	str	r3, [fp, #-28]
21f21764:	e59f304c 	ldr	r3, [pc, #76]	; 21f217b8 <.text+0x217b8>
21f21768:	e5932410 	ldr	r2, [r3, #1040]
21f2176c:	e51b301c 	ldr	r3, [fp, #-28]
21f21770:	e1520003 	cmp	r2, r3
21f21774:	caffffed 	bgt	21f21730 <.text+0x21730>
	}
      if (xyz.crc1 != (cksum & 0xFF))
21f21778:	e59f3038 	ldr	r3, [pc, #56]	; 21f217b8 <.text+0x217b8>
21f2177c:	e5d3340a 	ldrb	r3, [r3, #1034]
21f21780:	e1a02003 	mov	r2, r3
21f21784:	e15b30be 	ldrh	r3, [fp, #-14]
21f21788:	e20330ff 	and	r3, r3, #255	; 0xff
21f2178c:	e1520003 	cmp	r2, r3
21f21790:	0a000002 	beq	21f217a0 <.text+0x217a0>
	{
	  ZM_DEBUG (zm_dprintf
		    ("Checksum error - recvd: %x, computed: %x\n", xyz.crc1,
		     cksum & 0xFF));
	  return xyzModem_cksum;
21f21794:	e3e02006 	mvn	r2, #6	; 0x6
21f21798:	e50b2030 	str	r2, [fp, #-48]
21f2179c:	ea000001 	b	21f217a8 <.text+0x217a8>
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
21f217a0:	e3a03000 	mov	r3, #0	; 0x0
21f217a4:	e50b3030 	str	r3, [fp, #-48]
21f217a8:	e51b3030 	ldr	r3, [fp, #-48]
}
21f217ac:	e1a00003 	mov	r0, r3
21f217b0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f217b4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f217b8:	21f677b8 	ldrcsh	r7, [r6, #120]!
21f217bc:	21f67bc0 	mvncss	r7, r0, asr #23
21f217c0:	21f67bc1 	mvncss	r7, r1, asr #23
21f217c4:	21f677bc 	ldrcsh	r7, [r6, #124]!
21f217c8:	21f67bc2 	mvncss	r7, r2, asr #23
21f217cc:	21f67bc3 	mvncss	r7, r3, asr #23

21f217d0 <xyzModem_stream_open>:

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
21f217d0:	e1a0c00d 	mov	ip, sp
21f217d4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f217d8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f217dc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
21f217e0:	e50b0020 	str	r0, [fp, #-32]
21f217e4:	e50b1024 	str	r1, [fp, #-36]
#ifdef REDBOOT
  int console_chan;
#endif
  int stat = 0;
21f217e8:	e3a03000 	mov	r3, #0	; 0x0
21f217ec:	e50b3018 	str	r3, [fp, #-24]
  int retries = xyzModem_MAX_RETRIES;
21f217f0:	e3a03014 	mov	r3, #20	; 0x14
21f217f4:	e50b3014 	str	r3, [fp, #-20]
  int crc_retries = xyzModem_MAX_RETRIES_WITH_CRC;
21f217f8:	e3a0300a 	mov	r3, #10	; 0xa
21f217fc:	e50b3010 	str	r3, [fp, #-16]

/*    ZM_DEBUG(zm_out = zm_out_start); */
#ifdef xyzModem_zmodem
  if (info->mode == xyzModem_zmodem)
    {
      *err = xyzModem_noZmodem;
      return -1;
    }
#endif

#ifdef REDBOOT
  /* Set up the I/O channel.  Note: this allows for using a different port in the future */
  console_chan =
    CYGACC_CALL_IF_SET_CONSOLE_COMM
    (CYGNUM_CALL_IF_SET_COMM_ID_QUERY_CURRENT);
  if (info->chan >= 0)
    {
      CYGACC_CALL_IF_SET_CONSOLE_COMM (info->chan);
    }
  else
    {
      CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
    }
  xyz.__chan = CYGACC_CALL_IF_CONSOLE_PROCS ();

  CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy;
  xyz.__chan = &dummy;
21f21800:	e59f2288 	ldr	r2, [pc, #648]	; 21f21a90 <.text+0x21a90>
21f21804:	e24b301c 	sub	r3, fp, #28	; 0x1c
21f21808:	e5823000 	str	r3, [r2]
#endif
  xyz.len = 0;
21f2180c:	e59f227c 	ldr	r2, [pc, #636]	; 21f21a90 <.text+0x21a90>
21f21810:	e3a03000 	mov	r3, #0	; 0x0
21f21814:	e5823410 	str	r3, [r2, #1040]
  xyz.crc_mode = true;
21f21818:	e59f2270 	ldr	r2, [pc, #624]	; 21f21a90 <.text+0x21a90>
21f2181c:	e3a03001 	mov	r3, #1	; 0x1
21f21820:	e5823428 	str	r3, [r2, #1064]
  xyz.at_eof = false;
21f21824:	e59f2264 	ldr	r2, [pc, #612]	; 21f21a90 <.text+0x21a90>
21f21828:	e3a03000 	mov	r3, #0	; 0x0
21f2182c:	e582342c 	str	r3, [r2, #1068]
  xyz.tx_ack = false;
21f21830:	e59f2258 	ldr	r2, [pc, #600]	; 21f21a90 <.text+0x21a90>
21f21834:	e3a03000 	mov	r3, #0	; 0x0
21f21838:	e5823430 	str	r3, [r2, #1072]
  xyz.mode = info->mode;
21f2183c:	e51b3020 	ldr	r3, [fp, #-32]
21f21840:	e5932004 	ldr	r2, [r3, #4]
21f21844:	e59f3244 	ldr	r3, [pc, #580]	; 21f21a90 <.text+0x21a90>
21f21848:	e5832414 	str	r2, [r3, #1044]
  xyz.total_retries = 0;
21f2184c:	e59f223c 	ldr	r2, [pc, #572]	; 21f21a90 <.text+0x21a90>
21f21850:	e3a03000 	mov	r3, #0	; 0x0
21f21854:	e5823418 	str	r3, [r2, #1048]
  xyz.total_SOH = 0;
21f21858:	e59f2230 	ldr	r2, [pc, #560]	; 21f21a90 <.text+0x21a90>
21f2185c:	e3a03000 	mov	r3, #0	; 0x0
21f21860:	e582341c 	str	r3, [r2, #1052]
  xyz.total_STX = 0;
21f21864:	e59f2224 	ldr	r2, [pc, #548]	; 21f21a90 <.text+0x21a90>
21f21868:	e3a03000 	mov	r3, #0	; 0x0
21f2186c:	e5823420 	str	r3, [r2, #1056]
  xyz.total_CAN = 0;
21f21870:	e59f2218 	ldr	r2, [pc, #536]	; 21f21a90 <.text+0x21a90>
21f21874:	e3a03000 	mov	r3, #0	; 0x0
21f21878:	e5823424 	str	r3, [r2, #1060]
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
21f2187c:	e59f220c 	ldr	r2, [pc, #524]	; 21f21a90 <.text+0x21a90>
21f21880:	e3a03000 	mov	r3, #0	; 0x0
21f21884:	e5823438 	str	r3, [r2, #1080]
  xyz.file_length = 0;
21f21888:	e59f2200 	ldr	r2, [pc, #512]	; 21f21a90 <.text+0x21a90>
21f2188c:	e3a03000 	mov	r3, #0	; 0x0
21f21890:	e5823434 	str	r3, [r2, #1076]
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
21f21894:	e59f31f4 	ldr	r3, [pc, #500]	; 21f21a90 <.text+0x21a90>
21f21898:	e5933000 	ldr	r3, [r3]
21f2189c:	e5933000 	ldr	r3, [r3]
21f218a0:	e20330ff 	and	r3, r3, #255	; 0xff
21f218a4:	e50b3038 	str	r3, [fp, #-56]
21f218a8:	e59f31e0 	ldr	r3, [pc, #480]	; 21f21a90 <.text+0x21a90>
21f218ac:	e5933428 	ldr	r3, [r3, #1064]
21f218b0:	e3530000 	cmp	r3, #0	; 0x0
21f218b4:	0a000002 	beq	21f218c4 <xyzModem_stream_open+0xf4>
21f218b8:	e3a03043 	mov	r3, #67	; 0x43
21f218bc:	e50b3034 	str	r3, [fp, #-52]
21f218c0:	ea000001 	b	21f218cc <xyzModem_stream_open+0xfc>
21f218c4:	e3a03015 	mov	r3, #21	; 0x15
21f218c8:	e50b3034 	str	r3, [fp, #-52]
21f218cc:	e51b0038 	ldr	r0, [fp, #-56]
21f218d0:	e51b1034 	ldr	r1, [fp, #-52]
21f218d4:	ebfffd88 	bl	21f20efc <CYGACC_COMM_IF_PUTC>

  if (xyz.mode == xyzModem_xmodem)
21f218d8:	e59f31b0 	ldr	r3, [pc, #432]	; 21f21a90 <.text+0x21a90>
21f218dc:	e5933414 	ldr	r3, [r3, #1044]
21f218e0:	e3530001 	cmp	r3, #1	; 0x1
21f218e4:	1a000056 	bne	21f21a44 <xyzModem_stream_open+0x274>
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
21f218e8:	e59f31a0 	ldr	r3, [pc, #416]	; 21f21a90 <.text+0x21a90>
21f218ec:	e3a02001 	mov	r2, #1	; 0x1
21f218f0:	e5c3240c 	strb	r2, [r3, #1036]
      return 0;
21f218f4:	e3a03000 	mov	r3, #0	; 0x0
21f218f8:	e50b3030 	str	r3, [fp, #-48]
21f218fc:	ea00005f 	b	21f21a80 <xyzModem_stream_open+0x2b0>
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
21f21900:	ebfffe71 	bl	21f212cc <xyzModem_get_hdr>
21f21904:	e1a03000 	mov	r3, r0
21f21908:	e50b3018 	str	r3, [fp, #-24]
      if (stat == 0)
21f2190c:	e51b3018 	ldr	r3, [fp, #-24]
21f21910:	e3530000 	cmp	r3, #0	; 0x0
21f21914:	1a000022 	bne	21f219a4 <xyzModem_stream_open+0x1d4>
	{
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
21f21918:	e59f3170 	ldr	r3, [pc, #368]	; 21f21a90 <.text+0x21a90>
21f2191c:	e5d33408 	ldrb	r3, [r3, #1032]
21f21920:	e3530000 	cmp	r3, #0	; 0x0
21f21924:	1a000015 	bne	21f21980 <xyzModem_stream_open+0x1b0>
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
21f21928:	e59f3160 	ldr	r3, [pc, #352]	; 21f21a90 <.text+0x21a90>
21f2192c:	e5932404 	ldr	r2, [r3, #1028]
21f21930:	e5d23000 	ldrb	r3, [r2]
21f21934:	e3530000 	cmp	r3, #0	; 0x0
21f21938:	03a03000 	moveq	r3, #0	; 0x0
21f2193c:	13a03001 	movne	r3, #1	; 0x1
21f21940:	e20310ff 	and	r1, r3, #255	; 0xff
21f21944:	e2822001 	add	r2, r2, #1	; 0x1
21f21948:	e59f3140 	ldr	r3, [pc, #320]	; 21f21a90 <.text+0x21a90>
21f2194c:	e5832404 	str	r2, [r3, #1028]
21f21950:	e3510000 	cmp	r1, #0	; 0x0
21f21954:	1afffff3 	bne	21f21928 <xyzModem_stream_open+0x158>
	      /* get the length */
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
21f21958:	e59f3130 	ldr	r3, [pc, #304]	; 21f21a90 <.text+0x21a90>
21f2195c:	e5933404 	ldr	r3, [r3, #1028]
21f21960:	e1a00003 	mov	r0, r3
21f21964:	e59f1128 	ldr	r1, [pc, #296]	; 21f21a94 <.text+0x21a94>
21f21968:	e3a02000 	mov	r2, #0	; 0x0
21f2196c:	e59f3124 	ldr	r3, [pc, #292]	; 21f21a98 <.text+0x21a98>
21f21970:	ebfffd6f 	bl	21f20f34 <parse_num>
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
21f21974:	e59f2114 	ldr	r2, [pc, #276]	; 21f21a90 <.text+0x21a90>
21f21978:	e3a03001 	mov	r3, #1	; 0x1
21f2197c:	e5823430 	str	r3, [r2, #1072]
	    }
	  xyz.next_blk = 1;
21f21980:	e59f2108 	ldr	r2, [pc, #264]	; 21f21a90 <.text+0x21a90>
21f21984:	e3a03001 	mov	r3, #1	; 0x1
21f21988:	e5c2340c 	strb	r3, [r2, #1036]
	  xyz.len = 0;
21f2198c:	e59f20fc 	ldr	r2, [pc, #252]	; 21f21a90 <.text+0x21a90>
21f21990:	e3a03000 	mov	r3, #0	; 0x0
21f21994:	e5823410 	str	r3, [r2, #1040]
	  return 0;
21f21998:	e3a03000 	mov	r3, #0	; 0x0
21f2199c:	e50b3030 	str	r3, [fp, #-48]
21f219a0:	ea000036 	b	21f21a80 <xyzModem_stream_open+0x2b0>
	}
      else if (stat == xyzModem_timeout)
21f219a4:	e51b3018 	ldr	r3, [fp, #-24]
21f219a8:	e3730003 	cmn	r3, #3	; 0x3
21f219ac:	1a000021 	bne	21f21a38 <xyzModem_stream_open+0x268>
	{
	  if (--crc_retries <= 0)
21f219b0:	e51b3010 	ldr	r3, [fp, #-16]
21f219b4:	e2433001 	sub	r3, r3, #1	; 0x1
21f219b8:	e50b3010 	str	r3, [fp, #-16]
21f219bc:	e51b3010 	ldr	r3, [fp, #-16]
21f219c0:	e3530000 	cmp	r3, #0	; 0x0
21f219c4:	ca000002 	bgt	21f219d4 <xyzModem_stream_open+0x204>
	    xyz.crc_mode = false;
21f219c8:	e59f20c0 	ldr	r2, [pc, #192]	; 21f21a90 <.text+0x21a90>
21f219cc:	e3a03000 	mov	r3, #0	; 0x0
21f219d0:	e5823428 	str	r3, [r2, #1064]
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
21f219d4:	e3a00a7a 	mov	r0, #499712	; 0x7a000
21f219d8:	e2800e12 	add	r0, r0, #288	; 0x120
21f219dc:	ebff7c31 	bl	21f00aa8 <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
21f219e0:	e59f30a8 	ldr	r3, [pc, #168]	; 21f21a90 <.text+0x21a90>
21f219e4:	e5933000 	ldr	r3, [r3]
21f219e8:	e5933000 	ldr	r3, [r3]
21f219ec:	e20330ff 	and	r3, r3, #255	; 0xff
21f219f0:	e50b302c 	str	r3, [fp, #-44]
21f219f4:	e59f3094 	ldr	r3, [pc, #148]	; 21f21a90 <.text+0x21a90>
21f219f8:	e5933428 	ldr	r3, [r3, #1064]
21f219fc:	e3530000 	cmp	r3, #0	; 0x0
21f21a00:	0a000002 	beq	21f21a10 <xyzModem_stream_open+0x240>
21f21a04:	e3a03043 	mov	r3, #67	; 0x43
21f21a08:	e50b3028 	str	r3, [fp, #-40]
21f21a0c:	ea000001 	b	21f21a18 <xyzModem_stream_open+0x248>
21f21a10:	e3a03015 	mov	r3, #21	; 0x15
21f21a14:	e50b3028 	str	r3, [fp, #-40]
21f21a18:	e51b002c 	ldr	r0, [fp, #-44]
21f21a1c:	e51b1028 	ldr	r1, [fp, #-40]
21f21a20:	ebfffd35 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  xyz.total_retries++;
21f21a24:	e59f3064 	ldr	r3, [pc, #100]	; 21f21a90 <.text+0x21a90>
21f21a28:	e5933418 	ldr	r3, [r3, #1048]
21f21a2c:	e2832001 	add	r2, r3, #1	; 0x1
21f21a30:	e59f3058 	ldr	r3, [pc, #88]	; 21f21a90 <.text+0x21a90>
21f21a34:	e5832418 	str	r2, [r3, #1048]
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
21f21a38:	e51b3018 	ldr	r3, [fp, #-24]
21f21a3c:	e3730005 	cmn	r3, #5	; 0x5
21f21a40:	0a000009 	beq	21f21a6c <xyzModem_stream_open+0x29c>
21f21a44:	e51b3014 	ldr	r3, [fp, #-20]
21f21a48:	e3530000 	cmp	r3, #0	; 0x0
21f21a4c:	d3a03000 	movle	r3, #0	; 0x0
21f21a50:	c3a03001 	movgt	r3, #1	; 0x1
21f21a54:	e20320ff 	and	r2, r3, #255	; 0xff
21f21a58:	e51b3014 	ldr	r3, [fp, #-20]
21f21a5c:	e2433001 	sub	r3, r3, #1	; 0x1
21f21a60:	e50b3014 	str	r3, [fp, #-20]
21f21a64:	e3520000 	cmp	r2, #0	; 0x0
21f21a68:	1affffa4 	bne	21f21900 <xyzModem_stream_open+0x130>
	{
	  break;
	}
    }
  *err = stat;
21f21a6c:	e51b2024 	ldr	r2, [fp, #-36]
21f21a70:	e51b3018 	ldr	r3, [fp, #-24]
21f21a74:	e5823000 	str	r3, [r2]
  ZM_DEBUG (zm_flush ());
  return -1;
21f21a78:	e3e03000 	mvn	r3, #0	; 0x0
21f21a7c:	e50b3030 	str	r3, [fp, #-48]
21f21a80:	e51b3030 	ldr	r3, [fp, #-48]
}
21f21a84:	e1a00003 	mov	r0, r3
21f21a88:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f21a8c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f21a90:	21f677b8 	ldrcsh	r7, [r6, #120]!
21f21a94:	21f67bec 	mvncss	r7, ip, ror #23
21f21a98:	21f32564 	mvncss	r2, r4, ror #10

21f21a9c <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
21f21a9c:	e1a0c00d 	mov	ip, sp
21f21aa0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f21aa4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f21aa8:	e24dd030 	sub	sp, sp, #48	; 0x30
21f21aac:	e50b0020 	str	r0, [fp, #-32]
21f21ab0:	e50b1024 	str	r1, [fp, #-36]
21f21ab4:	e50b2028 	str	r2, [fp, #-40]
  int stat, total, len;
  int retries;

  total = 0;
21f21ab8:	e3a03000 	mov	r3, #0	; 0x0
21f21abc:	e50b3018 	str	r3, [fp, #-24]
  stat = xyzModem_cancel;
21f21ac0:	e3e03004 	mvn	r3, #4	; 0x4
21f21ac4:	e50b301c 	str	r3, [fp, #-28]
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
21f21ac8:	ea000117 	b	21f21f2c <xyzModem_stream_read+0x490>
    {
      if (xyz.len == 0)
21f21acc:	e59f348c 	ldr	r3, [pc, #1164]	; 21f21f60 <.text+0x21f60>
21f21ad0:	e5933410 	ldr	r3, [r3, #1040]
21f21ad4:	e3530000 	cmp	r3, #0	; 0x0
21f21ad8:	1a0000e7 	bne	21f21e7c <xyzModem_stream_read+0x3e0>
	{
	  retries = xyzModem_MAX_RETRIES;
21f21adc:	e3a03014 	mov	r3, #20	; 0x14
21f21ae0:	e50b3010 	str	r3, [fp, #-16]
	  while (retries-- > 0)
21f21ae4:	ea0000ce 	b	21f21e24 <xyzModem_stream_read+0x388>
	    {
	      stat = xyzModem_get_hdr ();
21f21ae8:	ebfffdf7 	bl	21f212cc <xyzModem_get_hdr>
21f21aec:	e1a03000 	mov	r3, r0
21f21af0:	e50b301c 	str	r3, [fp, #-28]
	      if (stat == 0)
21f21af4:	e51b301c 	ldr	r3, [fp, #-28]
21f21af8:	e3530000 	cmp	r3, #0	; 0x0
21f21afc:	1a00007d 	bne	21f21cf8 <xyzModem_stream_read+0x25c>
		{
		  if (xyz.blk == xyz.next_blk)
21f21b00:	e59f3458 	ldr	r3, [pc, #1112]	; 21f21f60 <.text+0x21f60>
21f21b04:	e5d32408 	ldrb	r2, [r3, #1032]
21f21b08:	e59f3450 	ldr	r3, [pc, #1104]	; 21f21f60 <.text+0x21f60>
21f21b0c:	e5d3340c 	ldrb	r3, [r3, #1036]
21f21b10:	e1520003 	cmp	r2, r3
21f21b14:	1a000064 	bne	21f21cac <xyzModem_stream_read+0x210>
		    {
		      xyz.tx_ack = true;
21f21b18:	e59f2440 	ldr	r2, [pc, #1088]	; 21f21f60 <.text+0x21f60>
21f21b1c:	e3a03001 	mov	r3, #1	; 0x1
21f21b20:	e5823430 	str	r3, [r2, #1072]
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
21f21b24:	e59f3434 	ldr	r3, [pc, #1076]	; 21f21f60 <.text+0x21f60>
21f21b28:	e5d3340c 	ldrb	r3, [r3, #1036]
21f21b2c:	e2833001 	add	r3, r3, #1	; 0x1
21f21b30:	e20330ff 	and	r3, r3, #255	; 0xff
21f21b34:	e20320ff 	and	r2, r3, #255	; 0xff
21f21b38:	e3a030ff 	mov	r3, #255	; 0xff
21f21b3c:	e0023003 	and	r3, r2, r3
21f21b40:	e20330ff 	and	r3, r3, #255	; 0xff
21f21b44:	e59f2414 	ldr	r2, [pc, #1044]	; 21f21f60 <.text+0x21f60>
21f21b48:	e5c2340c 	strb	r3, [r2, #1036]

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
21f21b4c:	e59f340c 	ldr	r3, [pc, #1036]	; 21f21f60 <.text+0x21f60>
21f21b50:	e5933414 	ldr	r3, [r3, #1044]
21f21b54:	e3530001 	cmp	r3, #1	; 0x1
21f21b58:	0a000003 	beq	21f21b6c <xyzModem_stream_read+0xd0>
21f21b5c:	e59f33fc 	ldr	r3, [pc, #1020]	; 21f21f60 <.text+0x21f60>
21f21b60:	e5933434 	ldr	r3, [r3, #1076]
21f21b64:	e3530000 	cmp	r3, #0	; 0x0
21f21b68:	1a00002d 	bne	21f21c24 <xyzModem_stream_read+0x188>
			{
#else
		      if (1)
			{
#endif
			  /* Data blocks can be padded with ^Z (EOF) characters */
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
21f21b6c:	e59f33ec 	ldr	r3, [pc, #1004]	; 21f21f60 <.text+0x21f60>
21f21b70:	e5932404 	ldr	r2, [r3, #1028]
21f21b74:	e59f33e4 	ldr	r3, [pc, #996]	; 21f21f60 <.text+0x21f60>
21f21b78:	e5933410 	ldr	r3, [r3, #1040]
21f21b7c:	e0823003 	add	r3, r2, r3
21f21b80:	e2433001 	sub	r3, r3, #1	; 0x1
21f21b84:	e5d33000 	ldrb	r3, [r3]
21f21b88:	e353001a 	cmp	r3, #26	; 0x1a
21f21b8c:	1a000024 	bne	21f21c24 <xyzModem_stream_read+0x188>
21f21b90:	e59f33c8 	ldr	r3, [pc, #968]	; 21f21f60 <.text+0x21f60>
21f21b94:	e5932404 	ldr	r2, [r3, #1028]
21f21b98:	e59f33c0 	ldr	r3, [pc, #960]	; 21f21f60 <.text+0x21f60>
21f21b9c:	e5933410 	ldr	r3, [r3, #1040]
21f21ba0:	e0823003 	add	r3, r2, r3
21f21ba4:	e2433002 	sub	r3, r3, #2	; 0x2
21f21ba8:	e5d33000 	ldrb	r3, [r3]
21f21bac:	e353001a 	cmp	r3, #26	; 0x1a
21f21bb0:	1a00001b 	bne	21f21c24 <xyzModem_stream_read+0x188>
21f21bb4:	e59f33a4 	ldr	r3, [pc, #932]	; 21f21f60 <.text+0x21f60>
21f21bb8:	e5932404 	ldr	r2, [r3, #1028]
21f21bbc:	e59f339c 	ldr	r3, [pc, #924]	; 21f21f60 <.text+0x21f60>
21f21bc0:	e5933410 	ldr	r3, [r3, #1040]
21f21bc4:	e0823003 	add	r3, r2, r3
21f21bc8:	e2433003 	sub	r3, r3, #3	; 0x3
21f21bcc:	e5d33000 	ldrb	r3, [r3]
21f21bd0:	e353001a 	cmp	r3, #26	; 0x1a
21f21bd4:	0a000005 	beq	21f21bf0 <xyzModem_stream_read+0x154>
21f21bd8:	ea000011 	b	21f21c24 <xyzModem_stream_read+0x188>
			      (xyz.bufp[xyz.len - 2] == EOF) &&
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
				     && (xyz.bufp[xyz.len - 1] == EOF))
				{
				  xyz.len--;
21f21bdc:	e59f337c 	ldr	r3, [pc, #892]	; 21f21f60 <.text+0x21f60>
21f21be0:	e5933410 	ldr	r3, [r3, #1040]
21f21be4:	e2432001 	sub	r2, r3, #1	; 0x1
21f21be8:	e59f3370 	ldr	r3, [pc, #880]	; 21f21f60 <.text+0x21f60>
21f21bec:	e5832410 	str	r2, [r3, #1040]
21f21bf0:	e59f3368 	ldr	r3, [pc, #872]	; 21f21f60 <.text+0x21f60>
21f21bf4:	e5933410 	ldr	r3, [r3, #1040]
21f21bf8:	e3530000 	cmp	r3, #0	; 0x0
21f21bfc:	0a000008 	beq	21f21c24 <xyzModem_stream_read+0x188>
21f21c00:	e59f3358 	ldr	r3, [pc, #856]	; 21f21f60 <.text+0x21f60>
21f21c04:	e5932404 	ldr	r2, [r3, #1028]
21f21c08:	e59f3350 	ldr	r3, [pc, #848]	; 21f21f60 <.text+0x21f60>
21f21c0c:	e5933410 	ldr	r3, [r3, #1040]
21f21c10:	e0823003 	add	r3, r2, r3
21f21c14:	e2433001 	sub	r3, r3, #1	; 0x1
21f21c18:	e5d33000 	ldrb	r3, [r3]
21f21c1c:	e353001a 	cmp	r3, #26	; 0x1a
21f21c20:	0affffed 	beq	21f21bdc <xyzModem_stream_read+0x140>
				}
			    }
			}

#ifdef USE_YMODEM_LENGTH
		      /*
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
21f21c24:	e59f3334 	ldr	r3, [pc, #820]	; 21f21f60 <.text+0x21f60>
21f21c28:	e5933414 	ldr	r3, [r3, #1044]
21f21c2c:	e3530001 	cmp	r3, #1	; 0x1
21f21c30:	0a000085 	beq	21f21e4c <xyzModem_stream_read+0x3b0>
21f21c34:	e59f3324 	ldr	r3, [pc, #804]	; 21f21f60 <.text+0x21f60>
21f21c38:	e5933434 	ldr	r3, [r3, #1076]
21f21c3c:	e3530000 	cmp	r3, #0	; 0x0
21f21c40:	0a000081 	beq	21f21e4c <xyzModem_stream_read+0x3b0>
			{
			  xyz.read_length += xyz.len;
21f21c44:	e59f3314 	ldr	r3, [pc, #788]	; 21f21f60 <.text+0x21f60>
21f21c48:	e5932438 	ldr	r2, [r3, #1080]
21f21c4c:	e59f330c 	ldr	r3, [pc, #780]	; 21f21f60 <.text+0x21f60>
21f21c50:	e5933410 	ldr	r3, [r3, #1040]
21f21c54:	e0822003 	add	r2, r2, r3
21f21c58:	e59f3300 	ldr	r3, [pc, #768]	; 21f21f60 <.text+0x21f60>
21f21c5c:	e5832438 	str	r2, [r3, #1080]
			  if (xyz.read_length > xyz.file_length)
21f21c60:	e59f32f8 	ldr	r3, [pc, #760]	; 21f21f60 <.text+0x21f60>
21f21c64:	e5932438 	ldr	r2, [r3, #1080]
21f21c68:	e59f32f0 	ldr	r3, [pc, #752]	; 21f21f60 <.text+0x21f60>
21f21c6c:	e5933434 	ldr	r3, [r3, #1076]
21f21c70:	e1520003 	cmp	r2, r3
21f21c74:	9a000074 	bls	21f21e4c <xyzModem_stream_read+0x3b0>
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
21f21c78:	e59f32e0 	ldr	r3, [pc, #736]	; 21f21f60 <.text+0x21f60>
21f21c7c:	e5933410 	ldr	r3, [r3, #1040]
21f21c80:	e1a01003 	mov	r1, r3
21f21c84:	e59f32d4 	ldr	r3, [pc, #724]	; 21f21f60 <.text+0x21f60>
21f21c88:	e5932438 	ldr	r2, [r3, #1080]
21f21c8c:	e59f32cc 	ldr	r3, [pc, #716]	; 21f21f60 <.text+0x21f60>
21f21c90:	e5933434 	ldr	r3, [r3, #1076]
21f21c94:	e0633002 	rsb	r3, r3, r2
21f21c98:	e0633001 	rsb	r3, r3, r1
21f21c9c:	e1a02003 	mov	r2, r3
21f21ca0:	e59f32b8 	ldr	r3, [pc, #696]	; 21f21f60 <.text+0x21f60>
21f21ca4:	e5832410 	str	r2, [r3, #1040]
21f21ca8:	ea000067 	b	21f21e4c <xyzModem_stream_read+0x3b0>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
21f21cac:	e59f32ac 	ldr	r3, [pc, #684]	; 21f21f60 <.text+0x21f60>
21f21cb0:	e5d33408 	ldrb	r3, [r3, #1032]
21f21cb4:	e1a02003 	mov	r2, r3
21f21cb8:	e59f32a0 	ldr	r3, [pc, #672]	; 21f21f60 <.text+0x21f60>
21f21cbc:	e5d3340c 	ldrb	r3, [r3, #1036]
21f21cc0:	e2433001 	sub	r3, r3, #1	; 0x1
21f21cc4:	e20330ff 	and	r3, r3, #255	; 0xff
21f21cc8:	e1520003 	cmp	r2, r3
21f21ccc:	1a000007 	bne	21f21cf0 <xyzModem_stream_read+0x254>
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
21f21cd0:	e59f3288 	ldr	r3, [pc, #648]	; 21f21f60 <.text+0x21f60>
21f21cd4:	e5933000 	ldr	r3, [r3]
21f21cd8:	e5933000 	ldr	r3, [r3]
21f21cdc:	e20330ff 	and	r3, r3, #255	; 0xff
21f21ce0:	e1a00003 	mov	r0, r3
21f21ce4:	e3a01006 	mov	r1, #6	; 0x6
21f21ce8:	ebfffc83 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
		      continue;	/* Need new header */
21f21cec:	ea00004c 	b	21f21e24 <xyzModem_stream_read+0x388>
		    }
		  else
		    {
		      stat = xyzModem_sequence;
21f21cf0:	e3e03007 	mvn	r3, #7	; 0x7
21f21cf4:	e50b301c 	str	r3, [fp, #-28]
		    }
		}
	      if (stat == xyzModem_cancel)
21f21cf8:	e51b301c 	ldr	r3, [fp, #-28]
21f21cfc:	e3730005 	cmn	r3, #5	; 0x5
21f21d00:	0a000051 	beq	21f21e4c <xyzModem_stream_read+0x3b0>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
21f21d04:	e51b301c 	ldr	r3, [fp, #-28]
21f21d08:	e3730004 	cmn	r3, #4	; 0x4
21f21d0c:	1a00002e 	bne	21f21dcc <xyzModem_stream_read+0x330>
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
21f21d10:	e59f3248 	ldr	r3, [pc, #584]	; 21f21f60 <.text+0x21f60>
21f21d14:	e5933000 	ldr	r3, [r3]
21f21d18:	e5933000 	ldr	r3, [r3]
21f21d1c:	e20330ff 	and	r3, r3, #255	; 0xff
21f21d20:	e1a00003 	mov	r0, r3
21f21d24:	e3a01006 	mov	r1, #6	; 0x6
21f21d28:	ebfffc73 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
21f21d2c:	e59f322c 	ldr	r3, [pc, #556]	; 21f21f60 <.text+0x21f60>
21f21d30:	e5933414 	ldr	r3, [r3, #1044]
21f21d34:	e3530002 	cmp	r3, #2	; 0x2
21f21d38:	1a00001f 	bne	21f21dbc <xyzModem_stream_read+0x320>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
21f21d3c:	e59f321c 	ldr	r3, [pc, #540]	; 21f21f60 <.text+0x21f60>
21f21d40:	e5933000 	ldr	r3, [r3]
21f21d44:	e5933000 	ldr	r3, [r3]
21f21d48:	e20330ff 	and	r3, r3, #255	; 0xff
21f21d4c:	e50b303c 	str	r3, [fp, #-60]
21f21d50:	e59f3208 	ldr	r3, [pc, #520]	; 21f21f60 <.text+0x21f60>
21f21d54:	e5933428 	ldr	r3, [r3, #1064]
21f21d58:	e3530000 	cmp	r3, #0	; 0x0
21f21d5c:	0a000002 	beq	21f21d6c <xyzModem_stream_read+0x2d0>
21f21d60:	e3a03043 	mov	r3, #67	; 0x43
21f21d64:	e50b3038 	str	r3, [fp, #-56]
21f21d68:	ea000001 	b	21f21d74 <xyzModem_stream_read+0x2d8>
21f21d6c:	e3a03015 	mov	r3, #21	; 0x15
21f21d70:	e50b3038 	str	r3, [fp, #-56]
21f21d74:	e51b003c 	ldr	r0, [fp, #-60]
21f21d78:	e51b1038 	ldr	r1, [fp, #-56]
21f21d7c:	ebfffc5e 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
21f21d80:	e59f31d8 	ldr	r3, [pc, #472]	; 21f21f60 <.text+0x21f60>
21f21d84:	e5933418 	ldr	r3, [r3, #1048]
21f21d88:	e2832001 	add	r2, r3, #1	; 0x1
21f21d8c:	e59f31cc 	ldr	r3, [pc, #460]	; 21f21f60 <.text+0x21f60>
21f21d90:	e5832418 	str	r2, [r3, #1048]
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
21f21d94:	ebfffd4c 	bl	21f212cc <xyzModem_get_hdr>
21f21d98:	e1a03000 	mov	r3, r0
21f21d9c:	e50b301c 	str	r3, [fp, #-28]
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
21f21da0:	e59f31b8 	ldr	r3, [pc, #440]	; 21f21f60 <.text+0x21f60>
21f21da4:	e5933000 	ldr	r3, [r3]
21f21da8:	e5933000 	ldr	r3, [r3]
21f21dac:	e20330ff 	and	r3, r3, #255	; 0xff
21f21db0:	e1a00003 	mov	r0, r3
21f21db4:	e3a01006 	mov	r1, #6	; 0x6
21f21db8:	ebfffc4f 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
21f21dbc:	e59f219c 	ldr	r2, [pc, #412]	; 21f21f60 <.text+0x21f60>
21f21dc0:	e3a03001 	mov	r3, #1	; 0x1
21f21dc4:	e582342c 	str	r3, [r2, #1068]
		  break;
21f21dc8:	ea00001f 	b	21f21e4c <xyzModem_stream_read+0x3b0>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
21f21dcc:	e59f318c 	ldr	r3, [pc, #396]	; 21f21f60 <.text+0x21f60>
21f21dd0:	e5933000 	ldr	r3, [r3]
21f21dd4:	e5933000 	ldr	r3, [r3]
21f21dd8:	e20330ff 	and	r3, r3, #255	; 0xff
21f21ddc:	e50b3034 	str	r3, [fp, #-52]
21f21de0:	e59f3178 	ldr	r3, [pc, #376]	; 21f21f60 <.text+0x21f60>
21f21de4:	e5933428 	ldr	r3, [r3, #1064]
21f21de8:	e3530000 	cmp	r3, #0	; 0x0
21f21dec:	0a000002 	beq	21f21dfc <xyzModem_stream_read+0x360>
21f21df0:	e3a03043 	mov	r3, #67	; 0x43
21f21df4:	e50b3030 	str	r3, [fp, #-48]
21f21df8:	ea000001 	b	21f21e04 <xyzModem_stream_read+0x368>
21f21dfc:	e3a03015 	mov	r3, #21	; 0x15
21f21e00:	e50b3030 	str	r3, [fp, #-48]
21f21e04:	e51b0034 	ldr	r0, [fp, #-52]
21f21e08:	e51b1030 	ldr	r1, [fp, #-48]
21f21e0c:	ebfffc3a 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	      xyz.total_retries++;
21f21e10:	e59f3148 	ldr	r3, [pc, #328]	; 21f21f60 <.text+0x21f60>
21f21e14:	e5933418 	ldr	r3, [r3, #1048]
21f21e18:	e2832001 	add	r2, r3, #1	; 0x1
21f21e1c:	e59f313c 	ldr	r3, [pc, #316]	; 21f21f60 <.text+0x21f60>
21f21e20:	e5832418 	str	r2, [r3, #1048]
21f21e24:	e51b3010 	ldr	r3, [fp, #-16]
21f21e28:	e3530000 	cmp	r3, #0	; 0x0
21f21e2c:	d3a03000 	movle	r3, #0	; 0x0
21f21e30:	c3a03001 	movgt	r3, #1	; 0x1
21f21e34:	e20320ff 	and	r2, r3, #255	; 0xff
21f21e38:	e51b3010 	ldr	r3, [fp, #-16]
21f21e3c:	e2433001 	sub	r3, r3, #1	; 0x1
21f21e40:	e50b3010 	str	r3, [fp, #-16]
21f21e44:	e3520000 	cmp	r2, #0	; 0x0
21f21e48:	1affff26 	bne	21f21ae8 <xyzModem_stream_read+0x4c>
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
21f21e4c:	e51b301c 	ldr	r3, [fp, #-28]
21f21e50:	e3530000 	cmp	r3, #0	; 0x0
21f21e54:	aa000008 	bge	21f21e7c <xyzModem_stream_read+0x3e0>
	    {
	      *err = stat;
21f21e58:	e51b2028 	ldr	r2, [fp, #-40]
21f21e5c:	e51b301c 	ldr	r3, [fp, #-28]
21f21e60:	e5823000 	str	r3, [r2]
	      xyz.len = -1;
21f21e64:	e59f20f4 	ldr	r2, [pc, #244]	; 21f21f60 <.text+0x21f60>
21f21e68:	e3e03000 	mvn	r3, #0	; 0x0
21f21e6c:	e5823410 	str	r3, [r2, #1040]
	      return total;
21f21e70:	e51b3018 	ldr	r3, [fp, #-24]
21f21e74:	e50b302c 	str	r3, [fp, #-44]
21f21e78:	ea000034 	b	21f21f50 <xyzModem_stream_read+0x4b4>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
21f21e7c:	e59f30dc 	ldr	r3, [pc, #220]	; 21f21f60 <.text+0x21f60>
21f21e80:	e593342c 	ldr	r3, [r3, #1068]
21f21e84:	e3530000 	cmp	r3, #0	; 0x0
21f21e88:	1a000027 	bne	21f21f2c <xyzModem_stream_read+0x490>
	{
	  len = xyz.len;
21f21e8c:	e59f30cc 	ldr	r3, [pc, #204]	; 21f21f60 <.text+0x21f60>
21f21e90:	e5933410 	ldr	r3, [r3, #1040]
21f21e94:	e50b3014 	str	r3, [fp, #-20]
	  if (size < len)
21f21e98:	e51b2024 	ldr	r2, [fp, #-36]
21f21e9c:	e51b3014 	ldr	r3, [fp, #-20]
21f21ea0:	e1520003 	cmp	r2, r3
21f21ea4:	aa000001 	bge	21f21eb0 <xyzModem_stream_read+0x414>
	    len = size;
21f21ea8:	e51b3024 	ldr	r3, [fp, #-36]
21f21eac:	e50b3014 	str	r3, [fp, #-20]
	  memcpy (buf, xyz.bufp, len);
21f21eb0:	e59f30a8 	ldr	r3, [pc, #168]	; 21f21f60 <.text+0x21f60>
21f21eb4:	e5933404 	ldr	r3, [r3, #1028]
21f21eb8:	e51b2014 	ldr	r2, [fp, #-20]
21f21ebc:	e51b0020 	ldr	r0, [fp, #-32]
21f21ec0:	e1a01003 	mov	r1, r3
21f21ec4:	eb0004c0 	bl	21f231cc <memcpy>
	  size -= len;
21f21ec8:	e51b2024 	ldr	r2, [fp, #-36]
21f21ecc:	e51b3014 	ldr	r3, [fp, #-20]
21f21ed0:	e0633002 	rsb	r3, r3, r2
21f21ed4:	e50b3024 	str	r3, [fp, #-36]
	  buf += len;
21f21ed8:	e51b3014 	ldr	r3, [fp, #-20]
21f21edc:	e1a02003 	mov	r2, r3
21f21ee0:	e51b3020 	ldr	r3, [fp, #-32]
21f21ee4:	e0833002 	add	r3, r3, r2
21f21ee8:	e50b3020 	str	r3, [fp, #-32]
	  total += len;
21f21eec:	e51b2018 	ldr	r2, [fp, #-24]
21f21ef0:	e51b3014 	ldr	r3, [fp, #-20]
21f21ef4:	e0823003 	add	r3, r2, r3
21f21ef8:	e50b3018 	str	r3, [fp, #-24]
	  xyz.len -= len;
21f21efc:	e59f305c 	ldr	r3, [pc, #92]	; 21f21f60 <.text+0x21f60>
21f21f00:	e5932410 	ldr	r2, [r3, #1040]
21f21f04:	e51b3014 	ldr	r3, [fp, #-20]
21f21f08:	e0632002 	rsb	r2, r3, r2
21f21f0c:	e59f304c 	ldr	r3, [pc, #76]	; 21f21f60 <.text+0x21f60>
21f21f10:	e5832410 	str	r2, [r3, #1040]
	  xyz.bufp += len;
21f21f14:	e59f3044 	ldr	r3, [pc, #68]	; 21f21f60 <.text+0x21f60>
21f21f18:	e5932404 	ldr	r2, [r3, #1028]
21f21f1c:	e51b3014 	ldr	r3, [fp, #-20]
21f21f20:	e0822003 	add	r2, r2, r3
21f21f24:	e59f3034 	ldr	r3, [pc, #52]	; 21f21f60 <.text+0x21f60>
21f21f28:	e5832404 	str	r2, [r3, #1028]
21f21f2c:	e59f302c 	ldr	r3, [pc, #44]	; 21f21f60 <.text+0x21f60>
21f21f30:	e593342c 	ldr	r3, [r3, #1068]
21f21f34:	e3530000 	cmp	r3, #0	; 0x0
21f21f38:	1a000002 	bne	21f21f48 <xyzModem_stream_read+0x4ac>
21f21f3c:	e51b3024 	ldr	r3, [fp, #-36]
21f21f40:	e3530000 	cmp	r3, #0	; 0x0
21f21f44:	cafffee0 	bgt	21f21acc <xyzModem_stream_read+0x30>
	}
    }
  return total;
21f21f48:	e51b3018 	ldr	r3, [fp, #-24]
21f21f4c:	e50b302c 	str	r3, [fp, #-44]
21f21f50:	e51b302c 	ldr	r3, [fp, #-44]
}
21f21f54:	e1a00003 	mov	r0, r3
21f21f58:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f21f5c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f21f60:	21f677b8 	ldrcsh	r7, [r6, #120]!

21f21f64 <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
21f21f64:	e1a0c00d 	mov	ip, sp
21f21f68:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f21f6c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f21f70:	e24dd010 	sub	sp, sp, #16	; 0x10
21f21f74:	e50b0010 	str	r0, [fp, #-16]
  diag_printf
21f21f78:	e59f3060 	ldr	r3, [pc, #96]	; 21f21fe0 <.text+0x21fe0>
21f21f7c:	e5933428 	ldr	r3, [r3, #1064]
21f21f80:	e3530000 	cmp	r3, #0	; 0x0
21f21f84:	0a000002 	beq	21f21f94 <xyzModem_stream_close+0x30>
21f21f88:	e59f3054 	ldr	r3, [pc, #84]	; 21f21fe4 <.text+0x21fe4>
21f21f8c:	e50b3014 	str	r3, [fp, #-20]
21f21f90:	ea000001 	b	21f21f9c <xyzModem_stream_close+0x38>
21f21f94:	e59f304c 	ldr	r3, [pc, #76]	; 21f21fe8 <.text+0x21fe8>
21f21f98:	e50b3014 	str	r3, [fp, #-20]
21f21f9c:	e59f303c 	ldr	r3, [pc, #60]	; 21f21fe0 <.text+0x21fe0>
21f21fa0:	e593e41c 	ldr	lr, [r3, #1052]
21f21fa4:	e59f3034 	ldr	r3, [pc, #52]	; 21f21fe0 <.text+0x21fe0>
21f21fa8:	e593c420 	ldr	ip, [r3, #1056]
21f21fac:	e59f302c 	ldr	r3, [pc, #44]	; 21f21fe0 <.text+0x21fe0>
21f21fb0:	e5932424 	ldr	r2, [r3, #1060]
21f21fb4:	e59f3024 	ldr	r3, [pc, #36]	; 21f21fe0 <.text+0x21fe0>
21f21fb8:	e5933418 	ldr	r3, [r3, #1048]
21f21fbc:	e58d2000 	str	r2, [sp]
21f21fc0:	e58d3004 	str	r3, [sp, #4]
21f21fc4:	e59f0020 	ldr	r0, [pc, #32]	; 21f21fec <.text+0x21fec>
21f21fc8:	e51b1014 	ldr	r1, [fp, #-20]
21f21fcc:	e1a0200e 	mov	r2, lr
21f21fd0:	e1a0300c 	mov	r3, ip
21f21fd4:	ebffe6ac 	bl	21f1ba8c <printf>
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
     xyz.total_CAN, xyz.total_retries);
  ZM_DEBUG (zm_flush ());
}
21f21fd8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f21fdc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f21fe0:	21f677b8 	ldrcsh	r7, [r6, #120]!
21f21fe4:	21f32568 	mvncss	r2, r8, ror #10
21f21fe8:	21f3256c 	mvncss	r2, ip, ror #10
21f21fec:	21f32574 	mvncss	r2, r4, ror r5

21f21ff0 <xyzModem_stream_terminate>:

/* Need to be able to clean out the input buffer, so have to take the */
/* getc */
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
21f21ff0:	e1a0c00d 	mov	ip, sp
21f21ff4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f21ff8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f21ffc:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f22000:	e50b0014 	str	r0, [fp, #-20]
21f22004:	e50b1018 	str	r1, [fp, #-24]
  int c;

  if (abort)
21f22008:	e51b3014 	ldr	r3, [fp, #-20]
21f2200c:	e3530000 	cmp	r3, #0	; 0x0
21f22010:	0a000041 	beq	21f2211c <xyzModem_stream_terminate+0x12c>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
21f22014:	e59f3134 	ldr	r3, [pc, #308]	; 21f22150 <.text+0x22150>
21f22018:	e5933414 	ldr	r3, [r3, #1044]
21f2201c:	e2433001 	sub	r3, r3, #1	; 0x1
21f22020:	e3530001 	cmp	r3, #1	; 0x1
21f22024:	8a000047 	bhi	21f22148 <xyzModem_stream_terminate+0x158>
	{
	case xyzModem_xmodem:
	case xyzModem_ymodem:
	  /* The X/YMODEM Spec seems to suggest that multiple CAN followed by an equal */
	  /* number of Backspaces is a friendly way to get the other end to abort. */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
21f22028:	e59f3120 	ldr	r3, [pc, #288]	; 21f22150 <.text+0x22150>
21f2202c:	e5933000 	ldr	r3, [r3]
21f22030:	e5933000 	ldr	r3, [r3]
21f22034:	e20330ff 	and	r3, r3, #255	; 0xff
21f22038:	e1a00003 	mov	r0, r3
21f2203c:	e3a01018 	mov	r1, #24	; 0x18
21f22040:	ebfffbad 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
21f22044:	e59f3104 	ldr	r3, [pc, #260]	; 21f22150 <.text+0x22150>
21f22048:	e5933000 	ldr	r3, [r3]
21f2204c:	e5933000 	ldr	r3, [r3]
21f22050:	e20330ff 	and	r3, r3, #255	; 0xff
21f22054:	e1a00003 	mov	r0, r3
21f22058:	e3a01018 	mov	r1, #24	; 0x18
21f2205c:	ebfffba6 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
21f22060:	e59f30e8 	ldr	r3, [pc, #232]	; 21f22150 <.text+0x22150>
21f22064:	e5933000 	ldr	r3, [r3]
21f22068:	e5933000 	ldr	r3, [r3]
21f2206c:	e20330ff 	and	r3, r3, #255	; 0xff
21f22070:	e1a00003 	mov	r0, r3
21f22074:	e3a01018 	mov	r1, #24	; 0x18
21f22078:	ebfffb9f 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, CAN);
21f2207c:	e59f30cc 	ldr	r3, [pc, #204]	; 21f22150 <.text+0x22150>
21f22080:	e5933000 	ldr	r3, [r3]
21f22084:	e5933000 	ldr	r3, [r3]
21f22088:	e20330ff 	and	r3, r3, #255	; 0xff
21f2208c:	e1a00003 	mov	r0, r3
21f22090:	e3a01018 	mov	r1, #24	; 0x18
21f22094:	ebfffb98 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
21f22098:	e59f30b0 	ldr	r3, [pc, #176]	; 21f22150 <.text+0x22150>
21f2209c:	e5933000 	ldr	r3, [r3]
21f220a0:	e5933000 	ldr	r3, [r3]
21f220a4:	e20330ff 	and	r3, r3, #255	; 0xff
21f220a8:	e1a00003 	mov	r0, r3
21f220ac:	e3a01008 	mov	r1, #8	; 0x8
21f220b0:	ebfffb91 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
21f220b4:	e59f3094 	ldr	r3, [pc, #148]	; 21f22150 <.text+0x22150>
21f220b8:	e5933000 	ldr	r3, [r3]
21f220bc:	e5933000 	ldr	r3, [r3]
21f220c0:	e20330ff 	and	r3, r3, #255	; 0xff
21f220c4:	e1a00003 	mov	r0, r3
21f220c8:	e3a01008 	mov	r1, #8	; 0x8
21f220cc:	ebfffb8a 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
21f220d0:	e59f3078 	ldr	r3, [pc, #120]	; 21f22150 <.text+0x22150>
21f220d4:	e5933000 	ldr	r3, [r3]
21f220d8:	e5933000 	ldr	r3, [r3]
21f220dc:	e20330ff 	and	r3, r3, #255	; 0xff
21f220e0:	e1a00003 	mov	r0, r3
21f220e4:	e3a01008 	mov	r1, #8	; 0x8
21f220e8:	ebfffb83 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
21f220ec:	e59f305c 	ldr	r3, [pc, #92]	; 21f22150 <.text+0x22150>
21f220f0:	e5933000 	ldr	r3, [r3]
21f220f4:	e5933000 	ldr	r3, [r3]
21f220f8:	e20330ff 	and	r3, r3, #255	; 0xff
21f220fc:	e1a00003 	mov	r0, r3
21f22100:	e3a01008 	mov	r1, #8	; 0x8
21f22104:	ebfffb7c 	bl	21f20efc <CYGACC_COMM_IF_PUTC>
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
21f22108:	ebfffc5b 	bl	21f2127c <xyzModem_flush>
	  xyz.at_eof = true;
21f2210c:	e59f203c 	ldr	r2, [pc, #60]	; 21f22150 <.text+0x22150>
21f22110:	e3a03001 	mov	r3, #1	; 0x1
21f22114:	e582342c 	str	r3, [r2, #1068]
21f22118:	ea00000a 	b	21f22148 <xyzModem_stream_terminate+0x158>
	  break;
#ifdef xyzModem_zmodem
	case xyzModem_zmodem:
	  /* Might support it some day I suppose. */
#endif
	  break;
	}
    }
  else
    {
      ZM_DEBUG (zm_dprintf ("Engaging cleanup mode...\n"));
      /*
       * Consume any trailing crap left in the inbuffer from
       * previous recieved blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
21f2211c:	e51b3018 	ldr	r3, [fp, #-24]
21f22120:	e1a0e00f 	mov	lr, pc
21f22124:	e1a0f003 	mov	pc, r3
21f22128:	e1a03000 	mov	r3, r0
21f2212c:	e50b3010 	str	r3, [fp, #-16]
21f22130:	e51b3010 	ldr	r3, [fp, #-16]
21f22134:	e3730001 	cmn	r3, #1	; 0x1
21f22138:	cafffff7 	bgt	21f2211c <xyzModem_stream_terminate+0x12c>
      ZM_DEBUG (zm_dprintf ("\n"));
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
21f2213c:	e3a00a3d 	mov	r0, #249856	; 0x3d000
21f22140:	e2800090 	add	r0, r0, #144	; 0x90
21f22144:	ebff7a57 	bl	21f00aa8 <udelay>
    }
}
21f22148:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2214c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f22150:	21f677b8 	ldrcsh	r7, [r6, #120]!

21f22154 <xyzModem_error>:

char *
xyzModem_error (int err)
{
21f22154:	e1a0c00d 	mov	ip, sp
21f22158:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2215c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22160:	e24dd008 	sub	sp, sp, #8	; 0x8
21f22164:	e50b0010 	str	r0, [fp, #-16]
  switch (err)
21f22168:	e51b3010 	ldr	r3, [fp, #-16]
21f2216c:	e2833008 	add	r3, r3, #8	; 0x8
21f22170:	e3530007 	cmp	r3, #7	; 0x7
21f22174:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f22178:	ea00001f 	b	21f221fc <.text+0x221fc>
21f2217c:	21f221f0 	ldrcssh	r2, [r2, #16]!
21f22180:	21f221e4 	mvncss	r2, r4, ror #3
21f22184:	21f221d8 	ldrcssb	r2, [r2, #24]!
21f22188:	21f221cc 	mvncss	r2, ip, asr #3
21f2218c:	21f221c0 	mvncss	r2, r0, asr #3
21f22190:	21f221b4 	ldrcsh	r2, [r2, #20]!
21f22194:	21f221a8 	mvncss	r2, r8, lsr #3
21f22198:	21f2219c 	ldrcsb	r2, [r2, #28]!
    {
    case xyzModem_access:
      return "Can't access file";
21f2219c:	e59f3070 	ldr	r3, [pc, #112]	; 21f22214 <.text+0x22214>
21f221a0:	e50b3014 	str	r3, [fp, #-20]
21f221a4:	ea000016 	b	21f22204 <.text+0x22204>
      break;
    case xyzModem_noZmodem:
      return "Sorry, zModem not available yet";
21f221a8:	e59f3068 	ldr	r3, [pc, #104]	; 21f22218 <.text+0x22218>
21f221ac:	e50b3014 	str	r3, [fp, #-20]
21f221b0:	ea000013 	b	21f22204 <.text+0x22204>
      break;
    case xyzModem_timeout:
      return "Timed out";
21f221b4:	e59f3060 	ldr	r3, [pc, #96]	; 21f2221c <.text+0x2221c>
21f221b8:	e50b3014 	str	r3, [fp, #-20]
21f221bc:	ea000010 	b	21f22204 <.text+0x22204>
      break;
    case xyzModem_eof:
      return "End of file";
21f221c0:	e59f3058 	ldr	r3, [pc, #88]	; 21f22220 <.text+0x22220>
21f221c4:	e50b3014 	str	r3, [fp, #-20]
21f221c8:	ea00000d 	b	21f22204 <.text+0x22204>
      break;
    case xyzModem_cancel:
      return "Cancelled";
21f221cc:	e59f3050 	ldr	r3, [pc, #80]	; 21f22224 <.text+0x22224>
21f221d0:	e50b3014 	str	r3, [fp, #-20]
21f221d4:	ea00000a 	b	21f22204 <.text+0x22204>
      break;
    case xyzModem_frame:
      return "Invalid framing";
21f221d8:	e59f3048 	ldr	r3, [pc, #72]	; 21f22228 <.text+0x22228>
21f221dc:	e50b3014 	str	r3, [fp, #-20]
21f221e0:	ea000007 	b	21f22204 <.text+0x22204>
      break;
    case xyzModem_cksum:
      return "CRC/checksum error";
21f221e4:	e59f3040 	ldr	r3, [pc, #64]	; 21f2222c <.text+0x2222c>
21f221e8:	e50b3014 	str	r3, [fp, #-20]
21f221ec:	ea000004 	b	21f22204 <.text+0x22204>
      break;
    case xyzModem_sequence:
      return "Block sequence error";
21f221f0:	e59f3038 	ldr	r3, [pc, #56]	; 21f22230 <.text+0x22230>
21f221f4:	e50b3014 	str	r3, [fp, #-20]
21f221f8:	ea000001 	b	21f22204 <.text+0x22204>
      break;
    default:
      return "Unknown error";
21f221fc:	e59f3030 	ldr	r3, [pc, #48]	; 21f22234 <.text+0x22234>
21f22200:	e50b3014 	str	r3, [fp, #-20]
21f22204:	e51b3014 	ldr	r3, [fp, #-20]
      break;
    }
}
21f22208:	e1a00003 	mov	r0, r3
21f2220c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22210:	e89da800 	ldmia	sp, {fp, sp, pc}
21f22214:	21f325b8 	ldrcsh	r2, [r3, #88]!
21f22218:	21f325cc 	mvncss	r2, ip, asr #11
21f2221c:	21f325ec 	mvncss	r2, ip, ror #11
21f22220:	21f325f8 	ldrcssh	r2, [r3, #88]!
21f22224:	21f32604 	mvncss	r2, r4, lsl #12
21f22228:	21f32610 	mvncss	r2, r0, lsl r6
21f2222c:	21f32620 	mvncss	r2, r0, lsr #12
21f22230:	21f32634 	mvncss	r2, r4, lsr r6
21f22234:	21f3264c 	mvncss	r2, ip, asr #12

21f22238 <cyg_crc16>:
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
21f22238:	e1a0c00d 	mov	ip, sp
21f2223c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22240:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22244:	e24dd010 	sub	sp, sp, #16	; 0x10
21f22248:	e50b0018 	str	r0, [fp, #-24]
21f2224c:	e50b101c 	str	r1, [fp, #-28]
    int i;
    uint16_t cksum;

    cksum = 0;
21f22250:	e3a03000 	mov	r3, #0	; 0x0
21f22254:	e14b30be 	strh	r3, [fp, #-14]
    for (i = 0;  i < len;  i++) {
21f22258:	e3a03000 	mov	r3, #0	; 0x0
21f2225c:	e50b3014 	str	r3, [fp, #-20]
21f22260:	ea00001b 	b	21f222d4 <cyg_crc16+0x9c>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
21f22264:	e15b30be 	ldrh	r3, [fp, #-14]
21f22268:	e1a03423 	mov	r3, r3, lsr #8
21f2226c:	e1a03803 	mov	r3, r3, lsl #16
21f22270:	e1a03823 	mov	r3, r3, lsr #16
21f22274:	e1a02003 	mov	r2, r3
21f22278:	e51b3018 	ldr	r3, [fp, #-24]
21f2227c:	e5d33000 	ldrb	r3, [r3]
21f22280:	e0223003 	eor	r3, r2, r3
21f22284:	e20330ff 	and	r3, r3, #255	; 0xff
21f22288:	e59f2064 	ldr	r2, [pc, #100]	; 21f222f4 <.text+0x222f4>
21f2228c:	e1a03083 	mov	r3, r3, lsl #1
21f22290:	e0833002 	add	r3, r3, r2
21f22294:	e1d330b0 	ldrh	r3, [r3]
21f22298:	e1a02003 	mov	r2, r3
21f2229c:	e15b30be 	ldrh	r3, [fp, #-14]
21f222a0:	e1a03403 	mov	r3, r3, lsl #8
21f222a4:	e1a03803 	mov	r3, r3, lsl #16
21f222a8:	e1a03823 	mov	r3, r3, lsr #16
21f222ac:	e0223003 	eor	r3, r2, r3
21f222b0:	e1a03803 	mov	r3, r3, lsl #16
21f222b4:	e1a03823 	mov	r3, r3, lsr #16
21f222b8:	e14b30be 	strh	r3, [fp, #-14]
21f222bc:	e51b3018 	ldr	r3, [fp, #-24]
21f222c0:	e2833001 	add	r3, r3, #1	; 0x1
21f222c4:	e50b3018 	str	r3, [fp, #-24]
21f222c8:	e51b3014 	ldr	r3, [fp, #-20]
21f222cc:	e2833001 	add	r3, r3, #1	; 0x1
21f222d0:	e50b3014 	str	r3, [fp, #-20]
21f222d4:	e51b2014 	ldr	r2, [fp, #-20]
21f222d8:	e51b301c 	ldr	r3, [fp, #-28]
21f222dc:	e1520003 	cmp	r2, r3
21f222e0:	baffffdf 	blt	21f22264 <cyg_crc16+0x2c>
    }
    return cksum;
21f222e4:	e15b30be 	ldrh	r3, [fp, #-14]
}
21f222e8:	e1a00003 	mov	r0, r3
21f222ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f222f0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f222f4:	21f3265c 	mvncss	r2, ip, asr r6

21f222f8 <crc32>:
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
21f222f8:	e1a0c00d 	mov	ip, sp
21f222fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22300:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22304:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f22308:	e50b0010 	str	r0, [fp, #-16]
21f2230c:	e50b1014 	str	r1, [fp, #-20]
21f22310:	e50b2018 	str	r2, [fp, #-24]
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
21f22314:	e51b3010 	ldr	r3, [fp, #-16]
21f22318:	e1e03003 	mvn	r3, r3
21f2231c:	e50b3010 	str	r3, [fp, #-16]
    while (len >= 8)
21f22320:	ea00007a 	b	21f22510 <crc32+0x218>
    {
      DO8(buf);
21f22324:	e51b3014 	ldr	r3, [fp, #-20]
21f22328:	e5d33000 	ldrb	r3, [r3]
21f2232c:	e1a02003 	mov	r2, r3
21f22330:	e51b3010 	ldr	r3, [fp, #-16]
21f22334:	e0223003 	eor	r3, r2, r3
21f22338:	e20320ff 	and	r2, r3, #255	; 0xff
21f2233c:	e59f324c 	ldr	r3, [pc, #588]	; 21f22590 <.text+0x22590>
21f22340:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f22344:	e51b3010 	ldr	r3, [fp, #-16]
21f22348:	e1a03423 	mov	r3, r3, lsr #8
21f2234c:	e0223003 	eor	r3, r2, r3
21f22350:	e50b3010 	str	r3, [fp, #-16]
21f22354:	e51b3014 	ldr	r3, [fp, #-20]
21f22358:	e2833001 	add	r3, r3, #1	; 0x1
21f2235c:	e50b3014 	str	r3, [fp, #-20]
21f22360:	e51b3014 	ldr	r3, [fp, #-20]
21f22364:	e5d33000 	ldrb	r3, [r3]
21f22368:	e1a02003 	mov	r2, r3
21f2236c:	e51b3010 	ldr	r3, [fp, #-16]
21f22370:	e0223003 	eor	r3, r2, r3
21f22374:	e20320ff 	and	r2, r3, #255	; 0xff
21f22378:	e59f3210 	ldr	r3, [pc, #528]	; 21f22590 <.text+0x22590>
21f2237c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f22380:	e51b3010 	ldr	r3, [fp, #-16]
21f22384:	e1a03423 	mov	r3, r3, lsr #8
21f22388:	e0223003 	eor	r3, r2, r3
21f2238c:	e50b3010 	str	r3, [fp, #-16]
21f22390:	e51b3014 	ldr	r3, [fp, #-20]
21f22394:	e2833001 	add	r3, r3, #1	; 0x1
21f22398:	e50b3014 	str	r3, [fp, #-20]
21f2239c:	e51b3014 	ldr	r3, [fp, #-20]
21f223a0:	e5d33000 	ldrb	r3, [r3]
21f223a4:	e1a02003 	mov	r2, r3
21f223a8:	e51b3010 	ldr	r3, [fp, #-16]
21f223ac:	e0223003 	eor	r3, r2, r3
21f223b0:	e20320ff 	and	r2, r3, #255	; 0xff
21f223b4:	e59f31d4 	ldr	r3, [pc, #468]	; 21f22590 <.text+0x22590>
21f223b8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f223bc:	e51b3010 	ldr	r3, [fp, #-16]
21f223c0:	e1a03423 	mov	r3, r3, lsr #8
21f223c4:	e0223003 	eor	r3, r2, r3
21f223c8:	e50b3010 	str	r3, [fp, #-16]
21f223cc:	e51b3014 	ldr	r3, [fp, #-20]
21f223d0:	e2833001 	add	r3, r3, #1	; 0x1
21f223d4:	e50b3014 	str	r3, [fp, #-20]
21f223d8:	e51b3014 	ldr	r3, [fp, #-20]
21f223dc:	e5d33000 	ldrb	r3, [r3]
21f223e0:	e1a02003 	mov	r2, r3
21f223e4:	e51b3010 	ldr	r3, [fp, #-16]
21f223e8:	e0223003 	eor	r3, r2, r3
21f223ec:	e20320ff 	and	r2, r3, #255	; 0xff
21f223f0:	e59f3198 	ldr	r3, [pc, #408]	; 21f22590 <.text+0x22590>
21f223f4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f223f8:	e51b3010 	ldr	r3, [fp, #-16]
21f223fc:	e1a03423 	mov	r3, r3, lsr #8
21f22400:	e0223003 	eor	r3, r2, r3
21f22404:	e50b3010 	str	r3, [fp, #-16]
21f22408:	e51b3014 	ldr	r3, [fp, #-20]
21f2240c:	e2833001 	add	r3, r3, #1	; 0x1
21f22410:	e50b3014 	str	r3, [fp, #-20]
21f22414:	e51b3014 	ldr	r3, [fp, #-20]
21f22418:	e5d33000 	ldrb	r3, [r3]
21f2241c:	e1a02003 	mov	r2, r3
21f22420:	e51b3010 	ldr	r3, [fp, #-16]
21f22424:	e0223003 	eor	r3, r2, r3
21f22428:	e20320ff 	and	r2, r3, #255	; 0xff
21f2242c:	e59f315c 	ldr	r3, [pc, #348]	; 21f22590 <.text+0x22590>
21f22430:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f22434:	e51b3010 	ldr	r3, [fp, #-16]
21f22438:	e1a03423 	mov	r3, r3, lsr #8
21f2243c:	e0223003 	eor	r3, r2, r3
21f22440:	e50b3010 	str	r3, [fp, #-16]
21f22444:	e51b3014 	ldr	r3, [fp, #-20]
21f22448:	e2833001 	add	r3, r3, #1	; 0x1
21f2244c:	e50b3014 	str	r3, [fp, #-20]
21f22450:	e51b3014 	ldr	r3, [fp, #-20]
21f22454:	e5d33000 	ldrb	r3, [r3]
21f22458:	e1a02003 	mov	r2, r3
21f2245c:	e51b3010 	ldr	r3, [fp, #-16]
21f22460:	e0223003 	eor	r3, r2, r3
21f22464:	e20320ff 	and	r2, r3, #255	; 0xff
21f22468:	e59f3120 	ldr	r3, [pc, #288]	; 21f22590 <.text+0x22590>
21f2246c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f22470:	e51b3010 	ldr	r3, [fp, #-16]
21f22474:	e1a03423 	mov	r3, r3, lsr #8
21f22478:	e0223003 	eor	r3, r2, r3
21f2247c:	e50b3010 	str	r3, [fp, #-16]
21f22480:	e51b3014 	ldr	r3, [fp, #-20]
21f22484:	e2833001 	add	r3, r3, #1	; 0x1
21f22488:	e50b3014 	str	r3, [fp, #-20]
21f2248c:	e51b3014 	ldr	r3, [fp, #-20]
21f22490:	e5d33000 	ldrb	r3, [r3]
21f22494:	e1a02003 	mov	r2, r3
21f22498:	e51b3010 	ldr	r3, [fp, #-16]
21f2249c:	e0223003 	eor	r3, r2, r3
21f224a0:	e20320ff 	and	r2, r3, #255	; 0xff
21f224a4:	e59f30e4 	ldr	r3, [pc, #228]	; 21f22590 <.text+0x22590>
21f224a8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f224ac:	e51b3010 	ldr	r3, [fp, #-16]
21f224b0:	e1a03423 	mov	r3, r3, lsr #8
21f224b4:	e0223003 	eor	r3, r2, r3
21f224b8:	e50b3010 	str	r3, [fp, #-16]
21f224bc:	e51b3014 	ldr	r3, [fp, #-20]
21f224c0:	e2833001 	add	r3, r3, #1	; 0x1
21f224c4:	e50b3014 	str	r3, [fp, #-20]
21f224c8:	e51b3014 	ldr	r3, [fp, #-20]
21f224cc:	e5d33000 	ldrb	r3, [r3]
21f224d0:	e1a02003 	mov	r2, r3
21f224d4:	e51b3010 	ldr	r3, [fp, #-16]
21f224d8:	e0223003 	eor	r3, r2, r3
21f224dc:	e20320ff 	and	r2, r3, #255	; 0xff
21f224e0:	e59f30a8 	ldr	r3, [pc, #168]	; 21f22590 <.text+0x22590>
21f224e4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f224e8:	e51b3010 	ldr	r3, [fp, #-16]
21f224ec:	e1a03423 	mov	r3, r3, lsr #8
21f224f0:	e0223003 	eor	r3, r2, r3
21f224f4:	e50b3010 	str	r3, [fp, #-16]
21f224f8:	e51b3014 	ldr	r3, [fp, #-20]
21f224fc:	e2833001 	add	r3, r3, #1	; 0x1
21f22500:	e50b3014 	str	r3, [fp, #-20]
      len -= 8;
21f22504:	e51b3018 	ldr	r3, [fp, #-24]
21f22508:	e2433008 	sub	r3, r3, #8	; 0x8
21f2250c:	e50b3018 	str	r3, [fp, #-24]
21f22510:	e51b3018 	ldr	r3, [fp, #-24]
21f22514:	e3530007 	cmp	r3, #7	; 0x7
21f22518:	8affff81 	bhi	21f22324 <crc32+0x2c>
    }
    if (len) do {
21f2251c:	e51b3018 	ldr	r3, [fp, #-24]
21f22520:	e3530000 	cmp	r3, #0	; 0x0
21f22524:	0a000014 	beq	21f2257c <crc32+0x284>
      DO1(buf);
21f22528:	e51b3014 	ldr	r3, [fp, #-20]
21f2252c:	e5d33000 	ldrb	r3, [r3]
21f22530:	e1a02003 	mov	r2, r3
21f22534:	e51b3010 	ldr	r3, [fp, #-16]
21f22538:	e0223003 	eor	r3, r2, r3
21f2253c:	e20320ff 	and	r2, r3, #255	; 0xff
21f22540:	e59f3048 	ldr	r3, [pc, #72]	; 21f22590 <.text+0x22590>
21f22544:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f22548:	e51b3010 	ldr	r3, [fp, #-16]
21f2254c:	e1a03423 	mov	r3, r3, lsr #8
21f22550:	e0223003 	eor	r3, r2, r3
21f22554:	e50b3010 	str	r3, [fp, #-16]
21f22558:	e51b3014 	ldr	r3, [fp, #-20]
21f2255c:	e2833001 	add	r3, r3, #1	; 0x1
21f22560:	e50b3014 	str	r3, [fp, #-20]
    } while (--len);
21f22564:	e51b3018 	ldr	r3, [fp, #-24]
21f22568:	e2433001 	sub	r3, r3, #1	; 0x1
21f2256c:	e50b3018 	str	r3, [fp, #-24]
21f22570:	e51b3018 	ldr	r3, [fp, #-24]
21f22574:	e3530000 	cmp	r3, #0	; 0x0
21f22578:	1affffea 	bne	21f22528 <crc32+0x230>
    return crc ^ 0xffffffffL;
21f2257c:	e51b3010 	ldr	r3, [fp, #-16]
21f22580:	e1e03003 	mvn	r3, r3
}
21f22584:	e1a00003 	mov	r0, r3
21f22588:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2258c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f22590:	21f3285c 	mvncss	r2, ip, asr r8

21f22594 <display_options>:

#include <common.h>

int display_options (void)
{
21f22594:	e1a0c00d 	mov	ip, sp
21f22598:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2259c:	e24cb004 	sub	fp, ip, #4	; 0x4
	extern char version_string[];

#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
21f225a0:	e59f0010 	ldr	r0, [pc, #16]	; 21f225b8 <.text+0x225b8>
21f225a4:	e59f1010 	ldr	r1, [pc, #16]	; 21f225bc <.text+0x225bc>
21f225a8:	ebffe537 	bl	21f1ba8c <printf>
#endif
	return 0;
21f225ac:	e3a03000 	mov	r3, #0	; 0x0
}
21f225b0:	e1a00003 	mov	r0, r3
21f225b4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f225b8:	21f32c5c 	mvncss	r2, ip, asr ip
21f225bc:	21f2f244 	mvncss	pc, r4, asr #4

21f225c0 <print_size>:

/*
 * print sizes as "xxx kB", "xxx.y kB", "xxx MB" or "xxx.y MB" as needed;
 * allow for optional trailing string (like "\n")
 */
void print_size (ulong size, const char *s)
{
21f225c0:	e1a0c00d 	mov	ip, sp
21f225c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f225c8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f225cc:	e24dd018 	sub	sp, sp, #24	; 0x18
21f225d0:	e50b0020 	str	r0, [fp, #-32]
21f225d4:	e50b1024 	str	r1, [fp, #-36]
	ulong m, n;
	ulong d = 1 << 20;		/* 1 MB */
21f225d8:	e3a03601 	mov	r3, #1048576	; 0x100000
21f225dc:	e50b3014 	str	r3, [fp, #-20]
	char  c = 'M';
21f225e0:	e3a0304d 	mov	r3, #77	; 0x4d
21f225e4:	e54b300d 	strb	r3, [fp, #-13]

	if (size < d) {			/* print in kB */
21f225e8:	e51b2020 	ldr	r2, [fp, #-32]
21f225ec:	e51b3014 	ldr	r3, [fp, #-20]
21f225f0:	e1520003 	cmp	r2, r3
21f225f4:	2a000003 	bcs	21f22608 <print_size+0x48>
		c = 'k';
21f225f8:	e3a0306b 	mov	r3, #107	; 0x6b
21f225fc:	e54b300d 	strb	r3, [fp, #-13]
		d = 1 << 10;
21f22600:	e3a03b01 	mov	r3, #1024	; 0x400
21f22604:	e50b3014 	str	r3, [fp, #-20]
	}

	n = size / d;
21f22608:	e51b0020 	ldr	r0, [fp, #-32]
21f2260c:	e51b1014 	ldr	r1, [fp, #-20]
21f22610:	ebff8d27 	bl	21f05ab4 <__udivsi3>
21f22614:	e1a03000 	mov	r3, r0
21f22618:	e50b3018 	str	r3, [fp, #-24]

	m = (10 * (size - (n * d)) + (d / 2) ) / d;
21f2261c:	e51b2018 	ldr	r2, [fp, #-24]
21f22620:	e51b3014 	ldr	r3, [fp, #-20]
21f22624:	e0020293 	mul	r2, r3, r2
21f22628:	e51b3020 	ldr	r3, [fp, #-32]
21f2262c:	e0622003 	rsb	r2, r2, r3
21f22630:	e1a03002 	mov	r3, r2
21f22634:	e1a03103 	mov	r3, r3, lsl #2
21f22638:	e0833002 	add	r3, r3, r2
21f2263c:	e1a03083 	mov	r3, r3, lsl #1
21f22640:	e1a02003 	mov	r2, r3
21f22644:	e51b3014 	ldr	r3, [fp, #-20]
21f22648:	e1a030a3 	mov	r3, r3, lsr #1
21f2264c:	e0823003 	add	r3, r2, r3
21f22650:	e1a00003 	mov	r0, r3
21f22654:	e51b1014 	ldr	r1, [fp, #-20]
21f22658:	ebff8d15 	bl	21f05ab4 <__udivsi3>
21f2265c:	e1a03000 	mov	r3, r0
21f22660:	e50b301c 	str	r3, [fp, #-28]

	if (m >= 10) {
21f22664:	e51b301c 	ldr	r3, [fp, #-28]
21f22668:	e3530009 	cmp	r3, #9	; 0x9
21f2266c:	9a000005 	bls	21f22688 <print_size+0xc8>
		m -= 10;
21f22670:	e51b301c 	ldr	r3, [fp, #-28]
21f22674:	e243300a 	sub	r3, r3, #10	; 0xa
21f22678:	e50b301c 	str	r3, [fp, #-28]
		n += 1;
21f2267c:	e51b3018 	ldr	r3, [fp, #-24]
21f22680:	e2833001 	add	r3, r3, #1	; 0x1
21f22684:	e50b3018 	str	r3, [fp, #-24]
	}

	printf ("%2ld", n);
21f22688:	e59f0038 	ldr	r0, [pc, #56]	; 21f226c8 <.text+0x226c8>
21f2268c:	e51b1018 	ldr	r1, [fp, #-24]
21f22690:	ebffe4fd 	bl	21f1ba8c <printf>
	if (m) {
21f22694:	e51b301c 	ldr	r3, [fp, #-28]
21f22698:	e3530000 	cmp	r3, #0	; 0x0
21f2269c:	0a000002 	beq	21f226ac <print_size+0xec>
		printf (".%ld", m);
21f226a0:	e59f0024 	ldr	r0, [pc, #36]	; 21f226cc <.text+0x226cc>
21f226a4:	e51b101c 	ldr	r1, [fp, #-28]
21f226a8:	ebffe4f7 	bl	21f1ba8c <printf>
	}
	printf (" %cB%s", c, s);
21f226ac:	e55b300d 	ldrb	r3, [fp, #-13]
21f226b0:	e59f0018 	ldr	r0, [pc, #24]	; 21f226d0 <.text+0x226d0>
21f226b4:	e1a01003 	mov	r1, r3
21f226b8:	e51b2024 	ldr	r2, [fp, #-36]
21f226bc:	ebffe4f2 	bl	21f1ba8c <printf>
}
21f226c0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f226c4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f226c8:	21f32c64 	mvncss	r2, r4, ror #24
21f226cc:	21f32c6c 	mvncss	r2, ip, ror #24
21f226d0:	21f32c74 	mvncss	r2, r4, ror ip

21f226d4 <strcpy>:
 * @dest: Where to copy the string to
 * @src: Where to copy the string from
 */
char * strcpy(char * dest,const char *src)
{
21f226d4:	e1a0c00d 	mov	ip, sp
21f226d8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f226dc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f226e0:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f226e4:	e50b0014 	str	r0, [fp, #-20]
21f226e8:	e50b1018 	str	r1, [fp, #-24]
	char *tmp = dest;
21f226ec:	e51b3014 	ldr	r3, [fp, #-20]
21f226f0:	e50b3010 	str	r3, [fp, #-16]

	while ((*dest++ = *src++) != '\0')
21f226f4:	e51b3018 	ldr	r3, [fp, #-24]
21f226f8:	e5d33000 	ldrb	r3, [r3]
21f226fc:	e51b2014 	ldr	r2, [fp, #-20]
21f22700:	e5c23000 	strb	r3, [r2]
21f22704:	e51b3014 	ldr	r3, [fp, #-20]
21f22708:	e5d33000 	ldrb	r3, [r3]
21f2270c:	e3530000 	cmp	r3, #0	; 0x0
21f22710:	03a03000 	moveq	r3, #0	; 0x0
21f22714:	13a03001 	movne	r3, #1	; 0x1
21f22718:	e20320ff 	and	r2, r3, #255	; 0xff
21f2271c:	e51b3014 	ldr	r3, [fp, #-20]
21f22720:	e2833001 	add	r3, r3, #1	; 0x1
21f22724:	e50b3014 	str	r3, [fp, #-20]
21f22728:	e51b3018 	ldr	r3, [fp, #-24]
21f2272c:	e2833001 	add	r3, r3, #1	; 0x1
21f22730:	e50b3018 	str	r3, [fp, #-24]
21f22734:	e3520000 	cmp	r2, #0	; 0x0
21f22738:	1affffed 	bne	21f226f4 <strcpy+0x20>
		/* nothing */;
	return tmp;
21f2273c:	e51b3010 	ldr	r3, [fp, #-16]
}
21f22740:	e1a00003 	mov	r0, r3
21f22744:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22748:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2274c <strncpy>:
#endif

#ifndef __HAVE_ARCH_STRNCPY
/**
 * strncpy - Copy a length-limited, %NUL-terminated string
 * @dest: Where to copy the string to
 * @src: Where to copy the string from
 * @count: The maximum number of bytes to copy
 *
 * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
 * However, the result is not %NUL-terminated if the source exceeds
 * @count bytes.
 */
char * strncpy(char * dest,const char *src,size_t count)
{
21f2274c:	e1a0c00d 	mov	ip, sp
21f22750:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22754:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22758:	e24dd010 	sub	sp, sp, #16	; 0x10
21f2275c:	e50b0014 	str	r0, [fp, #-20]
21f22760:	e50b1018 	str	r1, [fp, #-24]
21f22764:	e50b201c 	str	r2, [fp, #-28]
	char *tmp = dest;
21f22768:	e51b3014 	ldr	r3, [fp, #-20]
21f2276c:	e50b3010 	str	r3, [fp, #-16]

	while (count-- && (*dest++ = *src++) != '\0')
21f22770:	e51b301c 	ldr	r3, [fp, #-28]
21f22774:	e2433001 	sub	r3, r3, #1	; 0x1
21f22778:	e50b301c 	str	r3, [fp, #-28]
21f2277c:	e51b301c 	ldr	r3, [fp, #-28]
21f22780:	e3730001 	cmn	r3, #1	; 0x1
21f22784:	0a000011 	beq	21f227d0 <strncpy+0x84>
21f22788:	e51b3018 	ldr	r3, [fp, #-24]
21f2278c:	e5d33000 	ldrb	r3, [r3]
21f22790:	e51b2014 	ldr	r2, [fp, #-20]
21f22794:	e5c23000 	strb	r3, [r2]
21f22798:	e51b3014 	ldr	r3, [fp, #-20]
21f2279c:	e5d33000 	ldrb	r3, [r3]
21f227a0:	e3530000 	cmp	r3, #0	; 0x0
21f227a4:	03a03000 	moveq	r3, #0	; 0x0
21f227a8:	13a03001 	movne	r3, #1	; 0x1
21f227ac:	e20320ff 	and	r2, r3, #255	; 0xff
21f227b0:	e51b3014 	ldr	r3, [fp, #-20]
21f227b4:	e2833001 	add	r3, r3, #1	; 0x1
21f227b8:	e50b3014 	str	r3, [fp, #-20]
21f227bc:	e51b3018 	ldr	r3, [fp, #-24]
21f227c0:	e2833001 	add	r3, r3, #1	; 0x1
21f227c4:	e50b3018 	str	r3, [fp, #-24]
21f227c8:	e3520000 	cmp	r2, #0	; 0x0
21f227cc:	1affffe7 	bne	21f22770 <strncpy+0x24>
		/* nothing */;

	return tmp;
21f227d0:	e51b3010 	ldr	r3, [fp, #-16]
}
21f227d4:	e1a00003 	mov	r0, r3
21f227d8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f227dc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f227e0 <strcat>:
#endif

#ifndef __HAVE_ARCH_STRCAT
/**
 * strcat - Append one %NUL-terminated string to another
 * @dest: The string to be appended to
 * @src: The string to append to it
 */
char * strcat(char * dest, const char * src)
{
21f227e0:	e1a0c00d 	mov	ip, sp
21f227e4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f227e8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f227ec:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f227f0:	e50b0014 	str	r0, [fp, #-20]
21f227f4:	e50b1018 	str	r1, [fp, #-24]
	char *tmp = dest;
21f227f8:	e51b3014 	ldr	r3, [fp, #-20]
21f227fc:	e50b3010 	str	r3, [fp, #-16]

	while (*dest)
21f22800:	ea000002 	b	21f22810 <strcat+0x30>
		dest++;
21f22804:	e51b3014 	ldr	r3, [fp, #-20]
21f22808:	e2833001 	add	r3, r3, #1	; 0x1
21f2280c:	e50b3014 	str	r3, [fp, #-20]
21f22810:	e51b3014 	ldr	r3, [fp, #-20]
21f22814:	e5d33000 	ldrb	r3, [r3]
21f22818:	e3530000 	cmp	r3, #0	; 0x0
21f2281c:	1afffff8 	bne	21f22804 <strcat+0x24>
	while ((*dest++ = *src++) != '\0')
21f22820:	e51b3018 	ldr	r3, [fp, #-24]
21f22824:	e5d33000 	ldrb	r3, [r3]
21f22828:	e51b2014 	ldr	r2, [fp, #-20]
21f2282c:	e5c23000 	strb	r3, [r2]
21f22830:	e51b3014 	ldr	r3, [fp, #-20]
21f22834:	e5d33000 	ldrb	r3, [r3]
21f22838:	e3530000 	cmp	r3, #0	; 0x0
21f2283c:	03a03000 	moveq	r3, #0	; 0x0
21f22840:	13a03001 	movne	r3, #1	; 0x1
21f22844:	e20320ff 	and	r2, r3, #255	; 0xff
21f22848:	e51b3014 	ldr	r3, [fp, #-20]
21f2284c:	e2833001 	add	r3, r3, #1	; 0x1
21f22850:	e50b3014 	str	r3, [fp, #-20]
21f22854:	e51b3018 	ldr	r3, [fp, #-24]
21f22858:	e2833001 	add	r3, r3, #1	; 0x1
21f2285c:	e50b3018 	str	r3, [fp, #-24]
21f22860:	e3520000 	cmp	r2, #0	; 0x0
21f22864:	1affffed 	bne	21f22820 <strcat+0x40>
		;

	return tmp;
21f22868:	e51b3010 	ldr	r3, [fp, #-16]
}
21f2286c:	e1a00003 	mov	r0, r3
21f22870:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22874:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22878 <strncat>:
#endif

#ifndef __HAVE_ARCH_STRNCAT
/**
 * strncat - Append a length-limited, %NUL-terminated string to another
 * @dest: The string to be appended to
 * @src: The string to append to it
 * @count: The maximum numbers of bytes to copy
 *
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
21f22878:	e1a0c00d 	mov	ip, sp
21f2287c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22880:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22884:	e24dd010 	sub	sp, sp, #16	; 0x10
21f22888:	e50b0014 	str	r0, [fp, #-20]
21f2288c:	e50b1018 	str	r1, [fp, #-24]
21f22890:	e50b201c 	str	r2, [fp, #-28]
	char *tmp = dest;
21f22894:	e51b3014 	ldr	r3, [fp, #-20]
21f22898:	e50b3010 	str	r3, [fp, #-16]

	if (count) {
21f2289c:	e51b301c 	ldr	r3, [fp, #-28]
21f228a0:	e3530000 	cmp	r3, #0	; 0x0
21f228a4:	1a000003 	bne	21f228b8 <strncat+0x40>
21f228a8:	ea000023 	b	21f2293c <strncat+0xc4>
		while (*dest)
			dest++;
21f228ac:	e51b3014 	ldr	r3, [fp, #-20]
21f228b0:	e2833001 	add	r3, r3, #1	; 0x1
21f228b4:	e50b3014 	str	r3, [fp, #-20]
21f228b8:	e51b3014 	ldr	r3, [fp, #-20]
21f228bc:	e5d33000 	ldrb	r3, [r3]
21f228c0:	e3530000 	cmp	r3, #0	; 0x0
21f228c4:	1afffff8 	bne	21f228ac <strncat+0x34>
21f228c8:	ea000009 	b	21f228f4 <strncat+0x7c>
		while ((*dest++ = *src++)) {
			if (--count == 0) {
21f228cc:	e51b301c 	ldr	r3, [fp, #-28]
21f228d0:	e2433001 	sub	r3, r3, #1	; 0x1
21f228d4:	e50b301c 	str	r3, [fp, #-28]
21f228d8:	e51b301c 	ldr	r3, [fp, #-28]
21f228dc:	e3530000 	cmp	r3, #0	; 0x0
21f228e0:	1a000003 	bne	21f228f4 <strncat+0x7c>
				*dest = '\0';
21f228e4:	e51b3014 	ldr	r3, [fp, #-20]
21f228e8:	e3a02000 	mov	r2, #0	; 0x0
21f228ec:	e5c32000 	strb	r2, [r3]
				break;
21f228f0:	ea000011 	b	21f2293c <strncat+0xc4>
21f228f4:	e51b3018 	ldr	r3, [fp, #-24]
21f228f8:	e5d33000 	ldrb	r3, [r3]
21f228fc:	e51b2014 	ldr	r2, [fp, #-20]
21f22900:	e5c23000 	strb	r3, [r2]
21f22904:	e51b3014 	ldr	r3, [fp, #-20]
21f22908:	e5d33000 	ldrb	r3, [r3]
21f2290c:	e3530000 	cmp	r3, #0	; 0x0
21f22910:	03a03000 	moveq	r3, #0	; 0x0
21f22914:	13a03001 	movne	r3, #1	; 0x1
21f22918:	e20320ff 	and	r2, r3, #255	; 0xff
21f2291c:	e51b3014 	ldr	r3, [fp, #-20]
21f22920:	e2833001 	add	r3, r3, #1	; 0x1
21f22924:	e50b3014 	str	r3, [fp, #-20]
21f22928:	e51b3018 	ldr	r3, [fp, #-24]
21f2292c:	e2833001 	add	r3, r3, #1	; 0x1
21f22930:	e50b3018 	str	r3, [fp, #-24]
21f22934:	e3520000 	cmp	r2, #0	; 0x0
21f22938:	1affffe3 	bne	21f228cc <strncat+0x54>
			}
		}
	}

	return tmp;
21f2293c:	e51b3010 	ldr	r3, [fp, #-16]
}
21f22940:	e1a00003 	mov	r0, r3
21f22944:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22948:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2294c <strcmp>:
#endif

#ifndef __HAVE_ARCH_STRCMP
/**
 * strcmp - Compare two strings
 * @cs: One string
 * @ct: Another string
 */
int strcmp(const char * cs,const char * ct)
{
21f2294c:	e1a0c00d 	mov	ip, sp
21f22950:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22954:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22958:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2295c:	e50b0010 	str	r0, [fp, #-16]
21f22960:	e50b1014 	str	r1, [fp, #-20]
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
21f22964:	e51b3010 	ldr	r3, [fp, #-16]
21f22968:	e5d32000 	ldrb	r2, [r3]
21f2296c:	e51b3014 	ldr	r3, [fp, #-20]
21f22970:	e5d33000 	ldrb	r3, [r3]
21f22974:	e0633002 	rsb	r3, r3, r2
21f22978:	e20330ff 	and	r3, r3, #255	; 0xff
21f2297c:	e50b3018 	str	r3, [fp, #-24]
21f22980:	e51b2018 	ldr	r2, [fp, #-24]
21f22984:	e1a03c02 	mov	r3, r2, lsl #24
21f22988:	e1a03c43 	mov	r3, r3, asr #24
21f2298c:	e3530000 	cmp	r3, #0	; 0x0
21f22990:	03a03000 	moveq	r3, #0	; 0x0
21f22994:	13a03001 	movne	r3, #1	; 0x1
21f22998:	e20320ff 	and	r2, r3, #255	; 0xff
21f2299c:	e51b3014 	ldr	r3, [fp, #-20]
21f229a0:	e2833001 	add	r3, r3, #1	; 0x1
21f229a4:	e50b3014 	str	r3, [fp, #-20]
21f229a8:	e3520000 	cmp	r2, #0	; 0x0
21f229ac:	1a00000a 	bne	21f229dc <strcmp+0x90>
21f229b0:	e51b3010 	ldr	r3, [fp, #-16]
21f229b4:	e5d33000 	ldrb	r3, [r3]
21f229b8:	e3530000 	cmp	r3, #0	; 0x0
21f229bc:	13a03000 	movne	r3, #0	; 0x0
21f229c0:	03a03001 	moveq	r3, #1	; 0x1
21f229c4:	e20320ff 	and	r2, r3, #255	; 0xff
21f229c8:	e51b3010 	ldr	r3, [fp, #-16]
21f229cc:	e2833001 	add	r3, r3, #1	; 0x1
21f229d0:	e50b3010 	str	r3, [fp, #-16]
21f229d4:	e3520000 	cmp	r2, #0	; 0x0
21f229d8:	0affffe1 	beq	21f22964 <strcmp+0x18>
			break;
	}

	return __res;
21f229dc:	e51b2018 	ldr	r2, [fp, #-24]
21f229e0:	e1a03c02 	mov	r3, r2, lsl #24
21f229e4:	e1a03c43 	mov	r3, r3, asr #24
}
21f229e8:	e1a00003 	mov	r0, r3
21f229ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f229f0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f229f4 <strncmp>:
#endif

#ifndef __HAVE_ARCH_STRNCMP
/**
 * strncmp - Compare two length-limited strings
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
21f229f4:	e1a0c00d 	mov	ip, sp
21f229f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f229fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22a00:	e24dd010 	sub	sp, sp, #16	; 0x10
21f22a04:	e50b0010 	str	r0, [fp, #-16]
21f22a08:	e50b1014 	str	r1, [fp, #-20]
21f22a0c:	e50b2018 	str	r2, [fp, #-24]
	register signed char __res = 0;
21f22a10:	e3a02000 	mov	r2, #0	; 0x0
21f22a14:	e50b201c 	str	r2, [fp, #-28]

	while (count) {
21f22a18:	ea000020 	b	21f22aa0 <strncmp+0xac>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
21f22a1c:	e51b3010 	ldr	r3, [fp, #-16]
21f22a20:	e5d32000 	ldrb	r2, [r3]
21f22a24:	e51b3014 	ldr	r3, [fp, #-20]
21f22a28:	e5d33000 	ldrb	r3, [r3]
21f22a2c:	e0633002 	rsb	r3, r3, r2
21f22a30:	e20330ff 	and	r3, r3, #255	; 0xff
21f22a34:	e50b301c 	str	r3, [fp, #-28]
21f22a38:	e51b201c 	ldr	r2, [fp, #-28]
21f22a3c:	e1a03c02 	mov	r3, r2, lsl #24
21f22a40:	e1a03c43 	mov	r3, r3, asr #24
21f22a44:	e3530000 	cmp	r3, #0	; 0x0
21f22a48:	03a03000 	moveq	r3, #0	; 0x0
21f22a4c:	13a03001 	movne	r3, #1	; 0x1
21f22a50:	e20320ff 	and	r2, r3, #255	; 0xff
21f22a54:	e51b3014 	ldr	r3, [fp, #-20]
21f22a58:	e2833001 	add	r3, r3, #1	; 0x1
21f22a5c:	e50b3014 	str	r3, [fp, #-20]
21f22a60:	e3520000 	cmp	r2, #0	; 0x0
21f22a64:	1a000010 	bne	21f22aac <strncmp+0xb8>
21f22a68:	e51b3010 	ldr	r3, [fp, #-16]
21f22a6c:	e5d33000 	ldrb	r3, [r3]
21f22a70:	e3530000 	cmp	r3, #0	; 0x0
21f22a74:	13a03000 	movne	r3, #0	; 0x0
21f22a78:	03a03001 	moveq	r3, #1	; 0x1
21f22a7c:	e20320ff 	and	r2, r3, #255	; 0xff
21f22a80:	e51b3010 	ldr	r3, [fp, #-16]
21f22a84:	e2833001 	add	r3, r3, #1	; 0x1
21f22a88:	e50b3010 	str	r3, [fp, #-16]
21f22a8c:	e3520000 	cmp	r2, #0	; 0x0
21f22a90:	1a000005 	bne	21f22aac <strncmp+0xb8>
			break;
		count--;
21f22a94:	e51b3018 	ldr	r3, [fp, #-24]
21f22a98:	e2433001 	sub	r3, r3, #1	; 0x1
21f22a9c:	e50b3018 	str	r3, [fp, #-24]
21f22aa0:	e51b3018 	ldr	r3, [fp, #-24]
21f22aa4:	e3530000 	cmp	r3, #0	; 0x0
21f22aa8:	1affffdb 	bne	21f22a1c <strncmp+0x28>
	}

	return __res;
21f22aac:	e51b201c 	ldr	r2, [fp, #-28]
21f22ab0:	e1a03c02 	mov	r3, r2, lsl #24
21f22ab4:	e1a03c43 	mov	r3, r3, asr #24
}
21f22ab8:	e1a00003 	mov	r0, r3
21f22abc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22ac0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22ac4 <strchr>:
#endif

#ifndef __HAVE_ARCH_STRCHR
/**
 * strchr - Find the first occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
21f22ac4:	e1a0c00d 	mov	ip, sp
21f22ac8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22acc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22ad0:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f22ad4:	e50b0010 	str	r0, [fp, #-16]
21f22ad8:	e50b1014 	str	r1, [fp, #-20]
	for(; *s != (char) c; ++s)
21f22adc:	ea000009 	b	21f22b08 <strchr+0x44>
		if (*s == '\0')
21f22ae0:	e51b3010 	ldr	r3, [fp, #-16]
21f22ae4:	e5d33000 	ldrb	r3, [r3]
21f22ae8:	e3530000 	cmp	r3, #0	; 0x0
21f22aec:	1a000002 	bne	21f22afc <strchr+0x38>
			return NULL;
21f22af0:	e3a03000 	mov	r3, #0	; 0x0
21f22af4:	e50b3018 	str	r3, [fp, #-24]
21f22af8:	ea00000a 	b	21f22b28 <strchr+0x64>
21f22afc:	e51b3010 	ldr	r3, [fp, #-16]
21f22b00:	e2833001 	add	r3, r3, #1	; 0x1
21f22b04:	e50b3010 	str	r3, [fp, #-16]
21f22b08:	e51b3010 	ldr	r3, [fp, #-16]
21f22b0c:	e5d32000 	ldrb	r2, [r3]
21f22b10:	e51b3014 	ldr	r3, [fp, #-20]
21f22b14:	e20330ff 	and	r3, r3, #255	; 0xff
21f22b18:	e1520003 	cmp	r2, r3
21f22b1c:	1affffef 	bne	21f22ae0 <strchr+0x1c>
	return (char *) s;
21f22b20:	e51b3010 	ldr	r3, [fp, #-16]
21f22b24:	e50b3018 	str	r3, [fp, #-24]
21f22b28:	e51b3018 	ldr	r3, [fp, #-24]
}
21f22b2c:	e1a00003 	mov	r0, r3
21f22b30:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22b34:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22b38 <strrchr>:
#endif

#ifndef __HAVE_ARCH_STRRCHR
/**
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
21f22b38:	e1a0c00d 	mov	ip, sp
21f22b3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22b40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22b44:	e24dd010 	sub	sp, sp, #16	; 0x10
21f22b48:	e50b0014 	str	r0, [fp, #-20]
21f22b4c:	e50b1018 	str	r1, [fp, #-24]
       const char *p = s + strlen(s);
21f22b50:	e51b0014 	ldr	r0, [fp, #-20]
21f22b54:	eb00001a 	bl	21f22bc4 <strlen>
21f22b58:	e1a03000 	mov	r3, r0
21f22b5c:	e1a02003 	mov	r2, r3
21f22b60:	e51b3014 	ldr	r3, [fp, #-20]
21f22b64:	e0823003 	add	r3, r2, r3
21f22b68:	e50b3010 	str	r3, [fp, #-16]
       do {
	   if (*p == (char)c)
21f22b6c:	e51b3010 	ldr	r3, [fp, #-16]
21f22b70:	e5d32000 	ldrb	r2, [r3]
21f22b74:	e51b3018 	ldr	r3, [fp, #-24]
21f22b78:	e20330ff 	and	r3, r3, #255	; 0xff
21f22b7c:	e1520003 	cmp	r2, r3
21f22b80:	1a000002 	bne	21f22b90 <strrchr+0x58>
	       return (char *)p;
21f22b84:	e51b3010 	ldr	r3, [fp, #-16]
21f22b88:	e50b301c 	str	r3, [fp, #-28]
21f22b8c:	ea000008 	b	21f22bb4 <strrchr+0x7c>
       } while (--p >= s);
21f22b90:	e51b3010 	ldr	r3, [fp, #-16]
21f22b94:	e2433001 	sub	r3, r3, #1	; 0x1
21f22b98:	e50b3010 	str	r3, [fp, #-16]
21f22b9c:	e51b2010 	ldr	r2, [fp, #-16]
21f22ba0:	e51b3014 	ldr	r3, [fp, #-20]
21f22ba4:	e1520003 	cmp	r2, r3
21f22ba8:	2affffef 	bcs	21f22b6c <strrchr+0x34>
       return NULL;
21f22bac:	e3a03000 	mov	r3, #0	; 0x0
21f22bb0:	e50b301c 	str	r3, [fp, #-28]
21f22bb4:	e51b301c 	ldr	r3, [fp, #-28]
}
21f22bb8:	e1a00003 	mov	r0, r3
21f22bbc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22bc0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22bc4 <strlen>:
#endif

#ifndef __HAVE_ARCH_STRLEN
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
21f22bc4:	e1a0c00d 	mov	ip, sp
21f22bc8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22bcc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22bd0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f22bd4:	e50b0014 	str	r0, [fp, #-20]
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
21f22bd8:	e51b3014 	ldr	r3, [fp, #-20]
21f22bdc:	e50b3010 	str	r3, [fp, #-16]
21f22be0:	ea000002 	b	21f22bf0 <strlen+0x2c>
21f22be4:	e51b3010 	ldr	r3, [fp, #-16]
21f22be8:	e2833001 	add	r3, r3, #1	; 0x1
21f22bec:	e50b3010 	str	r3, [fp, #-16]
21f22bf0:	e51b3010 	ldr	r3, [fp, #-16]
21f22bf4:	e5d33000 	ldrb	r3, [r3]
21f22bf8:	e3530000 	cmp	r3, #0	; 0x0
21f22bfc:	1afffff8 	bne	21f22be4 <strlen+0x20>
		/* nothing */;
	return sc - s;
21f22c00:	e51b2010 	ldr	r2, [fp, #-16]
21f22c04:	e51b3014 	ldr	r3, [fp, #-20]
21f22c08:	e0633002 	rsb	r3, r3, r2
}
21f22c0c:	e1a00003 	mov	r0, r3
21f22c10:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22c14:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22c18 <strnlen>:
#endif

#ifndef __HAVE_ARCH_STRNLEN
/**
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
21f22c18:	e1a0c00d 	mov	ip, sp
21f22c1c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22c20:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22c24:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f22c28:	e50b0014 	str	r0, [fp, #-20]
21f22c2c:	e50b1018 	str	r1, [fp, #-24]
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
21f22c30:	e51b3014 	ldr	r3, [fp, #-20]
21f22c34:	e50b3010 	str	r3, [fp, #-16]
21f22c38:	ea000002 	b	21f22c48 <strnlen+0x30>
21f22c3c:	e51b3010 	ldr	r3, [fp, #-16]
21f22c40:	e2833001 	add	r3, r3, #1	; 0x1
21f22c44:	e50b3010 	str	r3, [fp, #-16]
21f22c48:	e51b3018 	ldr	r3, [fp, #-24]
21f22c4c:	e2433001 	sub	r3, r3, #1	; 0x1
21f22c50:	e50b3018 	str	r3, [fp, #-24]
21f22c54:	e51b3018 	ldr	r3, [fp, #-24]
21f22c58:	e3730001 	cmn	r3, #1	; 0x1
21f22c5c:	0a000003 	beq	21f22c70 <strnlen+0x58>
21f22c60:	e51b3010 	ldr	r3, [fp, #-16]
21f22c64:	e5d33000 	ldrb	r3, [r3]
21f22c68:	e3530000 	cmp	r3, #0	; 0x0
21f22c6c:	1afffff2 	bne	21f22c3c <strnlen+0x24>
		/* nothing */;
	return sc - s;
21f22c70:	e51b2010 	ldr	r2, [fp, #-16]
21f22c74:	e51b3014 	ldr	r3, [fp, #-20]
21f22c78:	e0633002 	rsb	r3, r3, r2
}
21f22c7c:	e1a00003 	mov	r0, r3
21f22c80:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22c84:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22c88 <strdup>:
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
21f22c88:	e1a0c00d 	mov	ip, sp
21f22c8c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22c90:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22c94:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f22c98:	e50b0014 	str	r0, [fp, #-20]
	char *new;

	if ((s == NULL)	||
21f22c9c:	e51b3014 	ldr	r3, [fp, #-20]
21f22ca0:	e3530000 	cmp	r3, #0	; 0x0
21f22ca4:	0a00000a 	beq	21f22cd4 <strdup+0x4c>
21f22ca8:	e51b0014 	ldr	r0, [fp, #-20]
21f22cac:	ebffffc4 	bl	21f22bc4 <strlen>
21f22cb0:	e1a03000 	mov	r3, r0
21f22cb4:	e2833001 	add	r3, r3, #1	; 0x1
21f22cb8:	e1a00003 	mov	r0, r3
21f22cbc:	ebffe639 	bl	21f1c5a8 <malloc>
21f22cc0:	e1a03000 	mov	r3, r0
21f22cc4:	e50b3010 	str	r3, [fp, #-16]
21f22cc8:	e51b3010 	ldr	r3, [fp, #-16]
21f22ccc:	e3530000 	cmp	r3, #0	; 0x0
21f22cd0:	1a000002 	bne	21f22ce0 <strdup+0x58>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
21f22cd4:	e3a03000 	mov	r3, #0	; 0x0
21f22cd8:	e50b3018 	str	r3, [fp, #-24]
21f22cdc:	ea000004 	b	21f22cf4 <strdup+0x6c>
	}

	strcpy (new, s);
21f22ce0:	e51b0010 	ldr	r0, [fp, #-16]
21f22ce4:	e51b1014 	ldr	r1, [fp, #-20]
21f22ce8:	ebfffe79 	bl	21f226d4 <strcpy>
	return new;
21f22cec:	e51b3010 	ldr	r3, [fp, #-16]
21f22cf0:	e50b3018 	str	r3, [fp, #-24]
21f22cf4:	e51b3018 	ldr	r3, [fp, #-24]
}
21f22cf8:	e1a00003 	mov	r0, r3
21f22cfc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22d00:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22d04 <strspn>:
#endif

#ifndef __HAVE_ARCH_STRSPN
/**
 * strspn - Calculate the length of the initial substring of @s which only
 * 	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
size_t strspn(const char *s, const char *accept)
{
21f22d04:	e1a0c00d 	mov	ip, sp
21f22d08:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22d0c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22d10:	e24dd018 	sub	sp, sp, #24	; 0x18
21f22d14:	e50b001c 	str	r0, [fp, #-28]
21f22d18:	e50b1020 	str	r1, [fp, #-32]
	const char *p;
	const char *a;
	size_t count = 0;
21f22d1c:	e3a03000 	mov	r3, #0	; 0x0
21f22d20:	e50b3010 	str	r3, [fp, #-16]

	for (p = s; *p != '\0'; ++p) {
21f22d24:	e51b301c 	ldr	r3, [fp, #-28]
21f22d28:	e50b3018 	str	r3, [fp, #-24]
21f22d2c:	ea00001c 	b	21f22da4 <strspn+0xa0>
		for (a = accept; *a != '\0'; ++a) {
21f22d30:	e51b3020 	ldr	r3, [fp, #-32]
21f22d34:	e50b3014 	str	r3, [fp, #-20]
21f22d38:	ea000008 	b	21f22d60 <strspn+0x5c>
			if (*p == *a)
21f22d3c:	e51b3018 	ldr	r3, [fp, #-24]
21f22d40:	e5d32000 	ldrb	r2, [r3]
21f22d44:	e51b3014 	ldr	r3, [fp, #-20]
21f22d48:	e5d33000 	ldrb	r3, [r3]
21f22d4c:	e1520003 	cmp	r2, r3
21f22d50:	0a000006 	beq	21f22d70 <strspn+0x6c>
21f22d54:	e51b3014 	ldr	r3, [fp, #-20]
21f22d58:	e2833001 	add	r3, r3, #1	; 0x1
21f22d5c:	e50b3014 	str	r3, [fp, #-20]
21f22d60:	e51b3014 	ldr	r3, [fp, #-20]
21f22d64:	e5d33000 	ldrb	r3, [r3]
21f22d68:	e3530000 	cmp	r3, #0	; 0x0
21f22d6c:	1afffff2 	bne	21f22d3c <strspn+0x38>
				break;
		}
		if (*a == '\0')
21f22d70:	e51b3014 	ldr	r3, [fp, #-20]
21f22d74:	e5d33000 	ldrb	r3, [r3]
21f22d78:	e3530000 	cmp	r3, #0	; 0x0
21f22d7c:	1a000002 	bne	21f22d8c <strspn+0x88>
			return count;
21f22d80:	e51b3010 	ldr	r3, [fp, #-16]
21f22d84:	e50b3024 	str	r3, [fp, #-36]
21f22d88:	ea00000b 	b	21f22dbc <strspn+0xb8>
		++count;
21f22d8c:	e51b3010 	ldr	r3, [fp, #-16]
21f22d90:	e2833001 	add	r3, r3, #1	; 0x1
21f22d94:	e50b3010 	str	r3, [fp, #-16]
21f22d98:	e51b3018 	ldr	r3, [fp, #-24]
21f22d9c:	e2833001 	add	r3, r3, #1	; 0x1
21f22da0:	e50b3018 	str	r3, [fp, #-24]
21f22da4:	e51b3018 	ldr	r3, [fp, #-24]
21f22da8:	e5d33000 	ldrb	r3, [r3]
21f22dac:	e3530000 	cmp	r3, #0	; 0x0
21f22db0:	1affffde 	bne	21f22d30 <strspn+0x2c>
	}

	return count;
21f22db4:	e51b3010 	ldr	r3, [fp, #-16]
21f22db8:	e50b3024 	str	r3, [fp, #-36]
21f22dbc:	e51b3024 	ldr	r3, [fp, #-36]
}
21f22dc0:	e1a00003 	mov	r0, r3
21f22dc4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22dc8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22dcc <strpbrk>:
#endif

#ifndef __HAVE_ARCH_STRPBRK
/**
 * strpbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
char * strpbrk(const char * cs,const char * ct)
{
21f22dcc:	e1a0c00d 	mov	ip, sp
21f22dd0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22dd4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22dd8:	e24dd014 	sub	sp, sp, #20	; 0x14
21f22ddc:	e50b0018 	str	r0, [fp, #-24]
21f22de0:	e50b101c 	str	r1, [fp, #-28]
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
21f22de4:	e51b3018 	ldr	r3, [fp, #-24]
21f22de8:	e50b3014 	str	r3, [fp, #-20]
21f22dec:	ea000015 	b	21f22e48 <strpbrk+0x7c>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
21f22df0:	e51b301c 	ldr	r3, [fp, #-28]
21f22df4:	e50b3010 	str	r3, [fp, #-16]
21f22df8:	ea00000b 	b	21f22e2c <strpbrk+0x60>
			if (*sc1 == *sc2)
21f22dfc:	e51b3014 	ldr	r3, [fp, #-20]
21f22e00:	e5d32000 	ldrb	r2, [r3]
21f22e04:	e51b3010 	ldr	r3, [fp, #-16]
21f22e08:	e5d33000 	ldrb	r3, [r3]
21f22e0c:	e1520003 	cmp	r2, r3
21f22e10:	1a000002 	bne	21f22e20 <strpbrk+0x54>
				return (char *) sc1;
21f22e14:	e51b3014 	ldr	r3, [fp, #-20]
21f22e18:	e50b3020 	str	r3, [fp, #-32]
21f22e1c:	ea00000f 	b	21f22e60 <strpbrk+0x94>
21f22e20:	e51b3010 	ldr	r3, [fp, #-16]
21f22e24:	e2833001 	add	r3, r3, #1	; 0x1
21f22e28:	e50b3010 	str	r3, [fp, #-16]
21f22e2c:	e51b3010 	ldr	r3, [fp, #-16]
21f22e30:	e5d33000 	ldrb	r3, [r3]
21f22e34:	e3530000 	cmp	r3, #0	; 0x0
21f22e38:	1affffef 	bne	21f22dfc <strpbrk+0x30>
21f22e3c:	e51b3014 	ldr	r3, [fp, #-20]
21f22e40:	e2833001 	add	r3, r3, #1	; 0x1
21f22e44:	e50b3014 	str	r3, [fp, #-20]
21f22e48:	e51b3014 	ldr	r3, [fp, #-20]
21f22e4c:	e5d33000 	ldrb	r3, [r3]
21f22e50:	e3530000 	cmp	r3, #0	; 0x0
21f22e54:	1affffe5 	bne	21f22df0 <strpbrk+0x24>
		}
	}
	return NULL;
21f22e58:	e3a03000 	mov	r3, #0	; 0x0
21f22e5c:	e50b3020 	str	r3, [fp, #-32]
21f22e60:	e51b3020 	ldr	r3, [fp, #-32]
}
21f22e64:	e1a00003 	mov	r0, r3
21f22e68:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22e6c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f22e70 <strtok>:
#endif

#ifndef __HAVE_ARCH_STRTOK
/**
 * strtok - Split a string into tokens
 * @s: The string to be searched
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
21f22e70:	e1a0c00d 	mov	ip, sp
21f22e74:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22e78:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22e7c:	e24dd018 	sub	sp, sp, #24	; 0x18
21f22e80:	e50b0018 	str	r0, [fp, #-24]
21f22e84:	e50b101c 	str	r1, [fp, #-28]
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
21f22e88:	e51b3018 	ldr	r3, [fp, #-24]
21f22e8c:	e3530000 	cmp	r3, #0	; 0x0
21f22e90:	0a000002 	beq	21f22ea0 <strtok+0x30>
21f22e94:	e51b3018 	ldr	r3, [fp, #-24]
21f22e98:	e50b3024 	str	r3, [fp, #-36]
21f22e9c:	ea000002 	b	21f22eac <strtok+0x3c>
21f22ea0:	e59f30d8 	ldr	r3, [pc, #216]	; 21f22f80 <.text+0x22f80>
21f22ea4:	e5933000 	ldr	r3, [r3]
21f22ea8:	e50b3024 	str	r3, [fp, #-36]
21f22eac:	e51b3024 	ldr	r3, [fp, #-36]
21f22eb0:	e50b3014 	str	r3, [fp, #-20]
	if (!sbegin) {
21f22eb4:	e51b3014 	ldr	r3, [fp, #-20]
21f22eb8:	e3530000 	cmp	r3, #0	; 0x0
21f22ebc:	1a000002 	bne	21f22ecc <strtok+0x5c>
		return NULL;
21f22ec0:	e3a03000 	mov	r3, #0	; 0x0
21f22ec4:	e50b3020 	str	r3, [fp, #-32]
21f22ec8:	ea000028 	b	21f22f70 <strtok+0x100>
	}
	sbegin += strspn(sbegin,ct);
21f22ecc:	e51b0014 	ldr	r0, [fp, #-20]
21f22ed0:	e51b101c 	ldr	r1, [fp, #-28]
21f22ed4:	ebffff8a 	bl	21f22d04 <strspn>
21f22ed8:	e1a03000 	mov	r3, r0
21f22edc:	e1a02003 	mov	r2, r3
21f22ee0:	e51b3014 	ldr	r3, [fp, #-20]
21f22ee4:	e0833002 	add	r3, r3, r2
21f22ee8:	e50b3014 	str	r3, [fp, #-20]
	if (*sbegin == '\0') {
21f22eec:	e51b3014 	ldr	r3, [fp, #-20]
21f22ef0:	e5d33000 	ldrb	r3, [r3]
21f22ef4:	e3530000 	cmp	r3, #0	; 0x0
21f22ef8:	1a000005 	bne	21f22f14 <strtok+0xa4>
		___strtok = NULL;
21f22efc:	e59f207c 	ldr	r2, [pc, #124]	; 21f22f80 <.text+0x22f80>
21f22f00:	e3a03000 	mov	r3, #0	; 0x0
21f22f04:	e5823000 	str	r3, [r2]
		return( NULL );
21f22f08:	e3a03000 	mov	r3, #0	; 0x0
21f22f0c:	e50b3020 	str	r3, [fp, #-32]
21f22f10:	ea000016 	b	21f22f70 <strtok+0x100>
	}
	send = strpbrk( sbegin, ct);
21f22f14:	e51b0014 	ldr	r0, [fp, #-20]
21f22f18:	e51b101c 	ldr	r1, [fp, #-28]
21f22f1c:	ebffffaa 	bl	21f22dcc <strpbrk>
21f22f20:	e1a03000 	mov	r3, r0
21f22f24:	e50b3010 	str	r3, [fp, #-16]
	if (send && *send != '\0')
21f22f28:	e51b3010 	ldr	r3, [fp, #-16]
21f22f2c:	e3530000 	cmp	r3, #0	; 0x0
21f22f30:	0a000009 	beq	21f22f5c <strtok+0xec>
21f22f34:	e51b3010 	ldr	r3, [fp, #-16]
21f22f38:	e5d33000 	ldrb	r3, [r3]
21f22f3c:	e3530000 	cmp	r3, #0	; 0x0
21f22f40:	0a000005 	beq	21f22f5c <strtok+0xec>
		*send++ = '\0';
21f22f44:	e51b2010 	ldr	r2, [fp, #-16]
21f22f48:	e3a03000 	mov	r3, #0	; 0x0
21f22f4c:	e5c23000 	strb	r3, [r2]
21f22f50:	e51b3010 	ldr	r3, [fp, #-16]
21f22f54:	e2833001 	add	r3, r3, #1	; 0x1
21f22f58:	e50b3010 	str	r3, [fp, #-16]
	___strtok = send;
21f22f5c:	e59f201c 	ldr	r2, [pc, #28]	; 21f22f80 <.text+0x22f80>
21f22f60:	e51b3010 	ldr	r3, [fp, #-16]
21f22f64:	e5823000 	str	r3, [r2]
	return (sbegin);
21f22f68:	e51b3014 	ldr	r3, [fp, #-20]
21f22f6c:	e50b3020 	str	r3, [fp, #-32]
21f22f70:	e51b3020 	ldr	r3, [fp, #-32]
}
21f22f74:	e1a00003 	mov	r0, r3
21f22f78:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f22f7c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f22f80:	21f67bf4 	ldrcssh	r7, [r6, #180]!

21f22f84 <strsep>:
#endif

#ifndef __HAVE_ARCH_STRSEP
/**
 * strsep - Split a string into tokens
 * @s: The string to be searched
 * @ct: The characters to search for
 *
 * strsep() updates @s to point after the token, ready for the next call.
 *
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
21f22f84:	e1a0c00d 	mov	ip, sp
21f22f88:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f22f8c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f22f90:	e24dd014 	sub	sp, sp, #20	; 0x14
21f22f94:	e50b0018 	str	r0, [fp, #-24]
21f22f98:	e50b101c 	str	r1, [fp, #-28]
	char *sbegin = *s, *end;
21f22f9c:	e51b3018 	ldr	r3, [fp, #-24]
21f22fa0:	e5933000 	ldr	r3, [r3]
21f22fa4:	e50b3014 	str	r3, [fp, #-20]

	if (sbegin == NULL)
21f22fa8:	e51b3014 	ldr	r3, [fp, #-20]
21f22fac:	e3530000 	cmp	r3, #0	; 0x0
21f22fb0:	1a000002 	bne	21f22fc0 <strsep+0x3c>
		return NULL;
21f22fb4:	e3a03000 	mov	r3, #0	; 0x0
21f22fb8:	e50b3020 	str	r3, [fp, #-32]
21f22fbc:	ea000012 	b	21f2300c <strsep+0x88>

	end = strpbrk(sbegin, ct);
21f22fc0:	e51b0014 	ldr	r0, [fp, #-20]
21f22fc4:	e51b101c 	ldr	r1, [fp, #-28]
21f22fc8:	ebffff7f 	bl	21f22dcc <strpbrk>
21f22fcc:	e1a03000 	mov	r3, r0
21f22fd0:	e50b3010 	str	r3, [fp, #-16]
	if (end)
21f22fd4:	e51b3010 	ldr	r3, [fp, #-16]
21f22fd8:	e3530000 	cmp	r3, #0	; 0x0
21f22fdc:	0a000005 	beq	21f22ff8 <strsep+0x74>
		*end++ = '\0';
21f22fe0:	e51b2010 	ldr	r2, [fp, #-16]
21f22fe4:	e3a03000 	mov	r3, #0	; 0x0
21f22fe8:	e5c23000 	strb	r3, [r2]
21f22fec:	e51b3010 	ldr	r3, [fp, #-16]
21f22ff0:	e2833001 	add	r3, r3, #1	; 0x1
21f22ff4:	e50b3010 	str	r3, [fp, #-16]
	*s = end;
21f22ff8:	e51b2018 	ldr	r2, [fp, #-24]
21f22ffc:	e51b3010 	ldr	r3, [fp, #-16]
21f23000:	e5823000 	str	r3, [r2]

	return sbegin;
21f23004:	e51b3014 	ldr	r3, [fp, #-20]
21f23008:	e50b3020 	str	r3, [fp, #-32]
21f2300c:	e51b3020 	ldr	r3, [fp, #-32]
}
21f23010:	e1a00003 	mov	r0, r3
21f23014:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23018:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2301c <strswab>:
#endif

#ifndef __HAVE_ARCH_STRSWAB
/**
 * strswab - swap adjacent even and odd bytes in %NUL-terminated string
 * s: address of the string
 *
 * returns the address of the swapped string or NULL on error. If
 * string length is odd, last byte is untouched.
 */
char *strswab(const char *s)
{
21f2301c:	e1a0c00d 	mov	ip, sp
21f23020:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f23024:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23028:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2302c:	e50b001c 	str	r0, [fp, #-28]
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
21f23030:	e51b301c 	ldr	r3, [fp, #-28]
21f23034:	e3530000 	cmp	r3, #0	; 0x0
21f23038:	0a000003 	beq	21f2304c <strswab+0x30>
21f2303c:	e51b301c 	ldr	r3, [fp, #-28]
21f23040:	e5d33000 	ldrb	r3, [r3]
21f23044:	e3530000 	cmp	r3, #0	; 0x0
21f23048:	1a000002 	bne	21f23058 <strswab+0x3c>
		return (NULL);
21f2304c:	e3a03000 	mov	r3, #0	; 0x0
21f23050:	e50b3020 	str	r3, [fp, #-32]
21f23054:	ea00001f 	b	21f230d8 <strswab+0xbc>
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
21f23058:	e51b301c 	ldr	r3, [fp, #-28]
21f2305c:	e50b3018 	str	r3, [fp, #-24]
21f23060:	e51b3018 	ldr	r3, [fp, #-24]
21f23064:	e2833001 	add	r3, r3, #1	; 0x1
21f23068:	e50b3014 	str	r3, [fp, #-20]
21f2306c:	ea00000f 	b	21f230b0 <strswab+0x94>
		char  tmp;

		tmp = *p;
21f23070:	e51b3018 	ldr	r3, [fp, #-24]
21f23074:	e5d33000 	ldrb	r3, [r3]
21f23078:	e54b300d 	strb	r3, [fp, #-13]
		*p  = *q;
21f2307c:	e51b3014 	ldr	r3, [fp, #-20]
21f23080:	e5d33000 	ldrb	r3, [r3]
21f23084:	e51b2018 	ldr	r2, [fp, #-24]
21f23088:	e5c23000 	strb	r3, [r2]
		*q  = tmp;
21f2308c:	e51b2014 	ldr	r2, [fp, #-20]
21f23090:	e55b300d 	ldrb	r3, [fp, #-13]
21f23094:	e5c23000 	strb	r3, [r2]
21f23098:	e51b3018 	ldr	r3, [fp, #-24]
21f2309c:	e2833002 	add	r3, r3, #2	; 0x2
21f230a0:	e50b3018 	str	r3, [fp, #-24]
21f230a4:	e51b3014 	ldr	r3, [fp, #-20]
21f230a8:	e2833002 	add	r3, r3, #2	; 0x2
21f230ac:	e50b3014 	str	r3, [fp, #-20]
21f230b0:	e51b3018 	ldr	r3, [fp, #-24]
21f230b4:	e5d33000 	ldrb	r3, [r3]
21f230b8:	e3530000 	cmp	r3, #0	; 0x0
21f230bc:	0a000003 	beq	21f230d0 <strswab+0xb4>
21f230c0:	e51b3014 	ldr	r3, [fp, #-20]
21f230c4:	e5d33000 	ldrb	r3, [r3]
21f230c8:	e3530000 	cmp	r3, #0	; 0x0
21f230cc:	1affffe7 	bne	21f23070 <strswab+0x54>
	}

	return (char *) s;
21f230d0:	e51b301c 	ldr	r3, [fp, #-28]
21f230d4:	e50b3020 	str	r3, [fp, #-32]
21f230d8:	e51b3020 	ldr	r3, [fp, #-32]
}
21f230dc:	e1a00003 	mov	r0, r3
21f230e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f230e4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f230e8 <memset>:
#endif

#ifndef __HAVE_ARCH_MEMSET
/**
 * memset - Fill a region of memory with the given value
 * @s: Pointer to the start of the area.
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
21f230e8:	e1a0c00d 	mov	ip, sp
21f230ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f230f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f230f4:	e24dd010 	sub	sp, sp, #16	; 0x10
21f230f8:	e50b0014 	str	r0, [fp, #-20]
21f230fc:	e50b1018 	str	r1, [fp, #-24]
21f23100:	e50b201c 	str	r2, [fp, #-28]
	char *xs = (char *) s;
21f23104:	e51b3014 	ldr	r3, [fp, #-20]
21f23108:	e50b3010 	str	r3, [fp, #-16]

	while (count--)
21f2310c:	ea000006 	b	21f2312c <memset+0x44>
		*xs++ = c;
21f23110:	e51b3018 	ldr	r3, [fp, #-24]
21f23114:	e20330ff 	and	r3, r3, #255	; 0xff
21f23118:	e51b2010 	ldr	r2, [fp, #-16]
21f2311c:	e5c23000 	strb	r3, [r2]
21f23120:	e51b3010 	ldr	r3, [fp, #-16]
21f23124:	e2833001 	add	r3, r3, #1	; 0x1
21f23128:	e50b3010 	str	r3, [fp, #-16]
21f2312c:	e51b301c 	ldr	r3, [fp, #-28]
21f23130:	e2433001 	sub	r3, r3, #1	; 0x1
21f23134:	e50b301c 	str	r3, [fp, #-28]
21f23138:	e51b301c 	ldr	r3, [fp, #-28]
21f2313c:	e3730001 	cmn	r3, #1	; 0x1
21f23140:	1afffff2 	bne	21f23110 <memset+0x28>

	return s;
21f23144:	e51b3014 	ldr	r3, [fp, #-20]
}
21f23148:	e1a00003 	mov	r0, r3
21f2314c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23150:	e89da800 	ldmia	sp, {fp, sp, pc}

21f23154 <bcopy>:
#endif

#ifndef __HAVE_ARCH_BCOPY
/**
 * bcopy - Copy one area of memory to another
 * @src: Where to copy from
 * @dest: Where to copy to
 * @count: The size of the area.
 *
 * Note that this is the same as memcpy(), with the arguments reversed.
 * memcpy() is the standard, bcopy() is a legacy BSD function.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
21f23154:	e1a0c00d 	mov	ip, sp
21f23158:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2315c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23160:	e24dd010 	sub	sp, sp, #16	; 0x10
21f23164:	e50b0014 	str	r0, [fp, #-20]
21f23168:	e50b1018 	str	r1, [fp, #-24]
21f2316c:	e50b201c 	str	r2, [fp, #-28]
	char *tmp = dest;
21f23170:	e51b3018 	ldr	r3, [fp, #-24]
21f23174:	e50b3010 	str	r3, [fp, #-16]

	while (count--)
21f23178:	ea000009 	b	21f231a4 <bcopy+0x50>
		*tmp++ = *src++;
21f2317c:	e51b3014 	ldr	r3, [fp, #-20]
21f23180:	e5d33000 	ldrb	r3, [r3]
21f23184:	e51b2010 	ldr	r2, [fp, #-16]
21f23188:	e5c23000 	strb	r3, [r2]
21f2318c:	e51b3010 	ldr	r3, [fp, #-16]
21f23190:	e2833001 	add	r3, r3, #1	; 0x1
21f23194:	e50b3010 	str	r3, [fp, #-16]
21f23198:	e51b3014 	ldr	r3, [fp, #-20]
21f2319c:	e2833001 	add	r3, r3, #1	; 0x1
21f231a0:	e50b3014 	str	r3, [fp, #-20]
21f231a4:	e51b301c 	ldr	r3, [fp, #-28]
21f231a8:	e2433001 	sub	r3, r3, #1	; 0x1
21f231ac:	e50b301c 	str	r3, [fp, #-28]
21f231b0:	e51b301c 	ldr	r3, [fp, #-28]
21f231b4:	e3730001 	cmn	r3, #1	; 0x1
21f231b8:	1affffef 	bne	21f2317c <bcopy+0x28>

	return dest;
21f231bc:	e51b3018 	ldr	r3, [fp, #-24]
}
21f231c0:	e1a00003 	mov	r0, r3
21f231c4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f231c8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f231cc <memcpy>:
#endif

#ifndef __HAVE_ARCH_MEMCPY
/**
 * memcpy - Copy one area of memory to another
 * @dest: Where to copy to
 * @src: Where to copy from
 * @count: The size of the area.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void * dest,const void *src,size_t count)
{
21f231cc:	e1a0c00d 	mov	ip, sp
21f231d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f231d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f231d8:	e24dd014 	sub	sp, sp, #20	; 0x14
21f231dc:	e50b0018 	str	r0, [fp, #-24]
21f231e0:	e50b101c 	str	r1, [fp, #-28]
21f231e4:	e50b2020 	str	r2, [fp, #-32]
	char *tmp = (char *) dest, *s = (char *) src;
21f231e8:	e51b3018 	ldr	r3, [fp, #-24]
21f231ec:	e50b3014 	str	r3, [fp, #-20]
21f231f0:	e51b301c 	ldr	r3, [fp, #-28]
21f231f4:	e50b3010 	str	r3, [fp, #-16]

	while (count--)
21f231f8:	ea000009 	b	21f23224 <memcpy+0x58>
		*tmp++ = *s++;
21f231fc:	e51b3010 	ldr	r3, [fp, #-16]
21f23200:	e5d33000 	ldrb	r3, [r3]
21f23204:	e51b2014 	ldr	r2, [fp, #-20]
21f23208:	e5c23000 	strb	r3, [r2]
21f2320c:	e51b3014 	ldr	r3, [fp, #-20]
21f23210:	e2833001 	add	r3, r3, #1	; 0x1
21f23214:	e50b3014 	str	r3, [fp, #-20]
21f23218:	e51b3010 	ldr	r3, [fp, #-16]
21f2321c:	e2833001 	add	r3, r3, #1	; 0x1
21f23220:	e50b3010 	str	r3, [fp, #-16]
21f23224:	e51b3020 	ldr	r3, [fp, #-32]
21f23228:	e2433001 	sub	r3, r3, #1	; 0x1
21f2322c:	e50b3020 	str	r3, [fp, #-32]
21f23230:	e51b3020 	ldr	r3, [fp, #-32]
21f23234:	e3730001 	cmn	r3, #1	; 0x1
21f23238:	1affffef 	bne	21f231fc <memcpy+0x30>

	return dest;
21f2323c:	e51b3018 	ldr	r3, [fp, #-24]
}
21f23240:	e1a00003 	mov	r0, r3
21f23244:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23248:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2324c <memmove>:
#endif

#ifndef __HAVE_ARCH_MEMMOVE
/**
 * memmove - Copy one area of memory to another
 * @dest: Where to copy to
 * @src: Where to copy from
 * @count: The size of the area.
 *
 * Unlike memcpy(), memmove() copes with overlapping areas.
 */
void * memmove(void * dest,const void *src,size_t count)
{
21f2324c:	e1a0c00d 	mov	ip, sp
21f23250:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f23254:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23258:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2325c:	e50b0018 	str	r0, [fp, #-24]
21f23260:	e50b101c 	str	r1, [fp, #-28]
21f23264:	e50b2020 	str	r2, [fp, #-32]
	char *tmp, *s;

	if (dest <= src) {
21f23268:	e51b2018 	ldr	r2, [fp, #-24]
21f2326c:	e51b301c 	ldr	r3, [fp, #-28]
21f23270:	e1520003 	cmp	r2, r3
21f23274:	8a000015 	bhi	21f232d0 <memmove+0x84>
		tmp = (char *) dest;
21f23278:	e51b3018 	ldr	r3, [fp, #-24]
21f2327c:	e50b3014 	str	r3, [fp, #-20]
		s = (char *) src;
21f23280:	e51b301c 	ldr	r3, [fp, #-28]
21f23284:	e50b3010 	str	r3, [fp, #-16]
		while (count--)
21f23288:	ea000009 	b	21f232b4 <memmove+0x68>
			*tmp++ = *s++;
21f2328c:	e51b3010 	ldr	r3, [fp, #-16]
21f23290:	e5d33000 	ldrb	r3, [r3]
21f23294:	e51b2014 	ldr	r2, [fp, #-20]
21f23298:	e5c23000 	strb	r3, [r2]
21f2329c:	e51b3014 	ldr	r3, [fp, #-20]
21f232a0:	e2833001 	add	r3, r3, #1	; 0x1
21f232a4:	e50b3014 	str	r3, [fp, #-20]
21f232a8:	e51b3010 	ldr	r3, [fp, #-16]
21f232ac:	e2833001 	add	r3, r3, #1	; 0x1
21f232b0:	e50b3010 	str	r3, [fp, #-16]
21f232b4:	e51b3020 	ldr	r3, [fp, #-32]
21f232b8:	e2433001 	sub	r3, r3, #1	; 0x1
21f232bc:	e50b3020 	str	r3, [fp, #-32]
21f232c0:	e51b3020 	ldr	r3, [fp, #-32]
21f232c4:	e3730001 	cmn	r3, #1	; 0x1
21f232c8:	1affffef 	bne	21f2328c <memmove+0x40>
21f232cc:	ea000018 	b	21f23334 <memmove+0xe8>
		}
	else {
		tmp = (char *) dest + count;
21f232d0:	e51b2018 	ldr	r2, [fp, #-24]
21f232d4:	e51b3020 	ldr	r3, [fp, #-32]
21f232d8:	e0823003 	add	r3, r2, r3
21f232dc:	e50b3014 	str	r3, [fp, #-20]
		s = (char *) src + count;
21f232e0:	e51b201c 	ldr	r2, [fp, #-28]
21f232e4:	e51b3020 	ldr	r3, [fp, #-32]
21f232e8:	e0823003 	add	r3, r2, r3
21f232ec:	e50b3010 	str	r3, [fp, #-16]
		while (count--)
21f232f0:	ea000009 	b	21f2331c <memmove+0xd0>
			*--tmp = *--s;
21f232f4:	e51b3014 	ldr	r3, [fp, #-20]
21f232f8:	e2433001 	sub	r3, r3, #1	; 0x1
21f232fc:	e50b3014 	str	r3, [fp, #-20]
21f23300:	e51b3010 	ldr	r3, [fp, #-16]
21f23304:	e2433001 	sub	r3, r3, #1	; 0x1
21f23308:	e50b3010 	str	r3, [fp, #-16]
21f2330c:	e51b3010 	ldr	r3, [fp, #-16]
21f23310:	e5d33000 	ldrb	r3, [r3]
21f23314:	e51b2014 	ldr	r2, [fp, #-20]
21f23318:	e5c23000 	strb	r3, [r2]
21f2331c:	e51b3020 	ldr	r3, [fp, #-32]
21f23320:	e2433001 	sub	r3, r3, #1	; 0x1
21f23324:	e50b3020 	str	r3, [fp, #-32]
21f23328:	e51b3020 	ldr	r3, [fp, #-32]
21f2332c:	e3730001 	cmn	r3, #1	; 0x1
21f23330:	1affffef 	bne	21f232f4 <memmove+0xa8>
		}

	return dest;
21f23334:	e51b3018 	ldr	r3, [fp, #-24]
}
21f23338:	e1a00003 	mov	r0, r3
21f2333c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23340:	e89da800 	ldmia	sp, {fp, sp, pc}

21f23344 <memcmp>:
#endif

#ifndef __HAVE_ARCH_MEMCMP
/**
 * memcmp - Compare two areas of memory
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
21f23344:	e1a0c00d 	mov	ip, sp
21f23348:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2334c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23350:	e24dd018 	sub	sp, sp, #24	; 0x18
21f23354:	e50b001c 	str	r0, [fp, #-28]
21f23358:	e50b1020 	str	r1, [fp, #-32]
21f2335c:	e50b2024 	str	r2, [fp, #-36]
	const unsigned char *su1, *su2;
	int res = 0;
21f23360:	e3a03000 	mov	r3, #0	; 0x0
21f23364:	e50b3010 	str	r3, [fp, #-16]

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
21f23368:	e51b301c 	ldr	r3, [fp, #-28]
21f2336c:	e50b3018 	str	r3, [fp, #-24]
21f23370:	e51b3020 	ldr	r3, [fp, #-32]
21f23374:	e50b3014 	str	r3, [fp, #-20]
21f23378:	ea000012 	b	21f233c8 <memcmp+0x84>
		if ((res = *su1 - *su2) != 0)
21f2337c:	e51b3018 	ldr	r3, [fp, #-24]
21f23380:	e5d33000 	ldrb	r3, [r3]
21f23384:	e1a02003 	mov	r2, r3
21f23388:	e51b3014 	ldr	r3, [fp, #-20]
21f2338c:	e5d33000 	ldrb	r3, [r3]
21f23390:	e0633002 	rsb	r3, r3, r2
21f23394:	e50b3010 	str	r3, [fp, #-16]
21f23398:	e51b3010 	ldr	r3, [fp, #-16]
21f2339c:	e3530000 	cmp	r3, #0	; 0x0
21f233a0:	1a00000b 	bne	21f233d4 <memcmp+0x90>
21f233a4:	e51b3018 	ldr	r3, [fp, #-24]
21f233a8:	e2833001 	add	r3, r3, #1	; 0x1
21f233ac:	e50b3018 	str	r3, [fp, #-24]
21f233b0:	e51b3014 	ldr	r3, [fp, #-20]
21f233b4:	e2833001 	add	r3, r3, #1	; 0x1
21f233b8:	e50b3014 	str	r3, [fp, #-20]
21f233bc:	e51b3024 	ldr	r3, [fp, #-36]
21f233c0:	e2433001 	sub	r3, r3, #1	; 0x1
21f233c4:	e50b3024 	str	r3, [fp, #-36]
21f233c8:	e51b3024 	ldr	r3, [fp, #-36]
21f233cc:	e3530000 	cmp	r3, #0	; 0x0
21f233d0:	1affffe9 	bne	21f2337c <memcmp+0x38>
			break;
	return res;
21f233d4:	e51b3010 	ldr	r3, [fp, #-16]
}
21f233d8:	e1a00003 	mov	r0, r3
21f233dc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f233e0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f233e4 <memscan>:
#endif

#ifndef __HAVE_ARCH_MEMSCAN
/**
 * memscan - Find a character in an area of memory.
 * @addr: The memory area
 * @c: The byte to search for
 * @size: The size of the area.
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
21f233e4:	e1a0c00d 	mov	ip, sp
21f233e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f233ec:	e24cb004 	sub	fp, ip, #4	; 0x4
21f233f0:	e24dd014 	sub	sp, sp, #20	; 0x14
21f233f4:	e50b0014 	str	r0, [fp, #-20]
21f233f8:	e50b1018 	str	r1, [fp, #-24]
21f233fc:	e50b201c 	str	r2, [fp, #-28]
	unsigned char * p = (unsigned char *) addr;
21f23400:	e51b3014 	ldr	r3, [fp, #-20]
21f23404:	e50b3010 	str	r3, [fp, #-16]

	while (size) {
21f23408:	ea00000e 	b	21f23448 <memscan+0x64>
		if (*p == c)
21f2340c:	e51b3010 	ldr	r3, [fp, #-16]
21f23410:	e5d33000 	ldrb	r3, [r3]
21f23414:	e1a02003 	mov	r2, r3
21f23418:	e51b3018 	ldr	r3, [fp, #-24]
21f2341c:	e1520003 	cmp	r2, r3
21f23420:	1a000002 	bne	21f23430 <memscan+0x4c>
			return (void *) p;
21f23424:	e51b3010 	ldr	r3, [fp, #-16]
21f23428:	e50b3020 	str	r3, [fp, #-32]
21f2342c:	ea00000a 	b	21f2345c <memscan+0x78>
		p++;
21f23430:	e51b3010 	ldr	r3, [fp, #-16]
21f23434:	e2833001 	add	r3, r3, #1	; 0x1
21f23438:	e50b3010 	str	r3, [fp, #-16]
		size--;
21f2343c:	e51b301c 	ldr	r3, [fp, #-28]
21f23440:	e2433001 	sub	r3, r3, #1	; 0x1
21f23444:	e50b301c 	str	r3, [fp, #-28]
21f23448:	e51b301c 	ldr	r3, [fp, #-28]
21f2344c:	e3530000 	cmp	r3, #0	; 0x0
21f23450:	1affffed 	bne	21f2340c <memscan+0x28>
	}
	return (void *) p;
21f23454:	e51b3010 	ldr	r3, [fp, #-16]
21f23458:	e50b3020 	str	r3, [fp, #-32]
21f2345c:	e51b3020 	ldr	r3, [fp, #-32]
}
21f23460:	e1a00003 	mov	r0, r3
21f23464:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23468:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2346c <strstr>:
#endif

#ifndef __HAVE_ARCH_STRSTR
/**
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
21f2346c:	e1a0c00d 	mov	ip, sp
21f23470:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f23474:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23478:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2347c:	e50b0018 	str	r0, [fp, #-24]
21f23480:	e50b101c 	str	r1, [fp, #-28]
	int l1, l2;

	l2 = strlen(s2);
21f23484:	e51b001c 	ldr	r0, [fp, #-28]
21f23488:	ebfffdcd 	bl	21f22bc4 <strlen>
21f2348c:	e1a03000 	mov	r3, r0
21f23490:	e50b3010 	str	r3, [fp, #-16]
	if (!l2)
21f23494:	e51b3010 	ldr	r3, [fp, #-16]
21f23498:	e3530000 	cmp	r3, #0	; 0x0
21f2349c:	1a000002 	bne	21f234ac <strstr+0x40>
		return (char *) s1;
21f234a0:	e51b3018 	ldr	r3, [fp, #-24]
21f234a4:	e50b3020 	str	r3, [fp, #-32]
21f234a8:	ea00001b 	b	21f2351c <strstr+0xb0>
	l1 = strlen(s1);
21f234ac:	e51b0018 	ldr	r0, [fp, #-24]
21f234b0:	ebfffdc3 	bl	21f22bc4 <strlen>
21f234b4:	e1a03000 	mov	r3, r0
21f234b8:	e50b3014 	str	r3, [fp, #-20]
	while (l1 >= l2) {
21f234bc:	ea000010 	b	21f23504 <strstr+0x98>
		l1--;
21f234c0:	e51b3014 	ldr	r3, [fp, #-20]
21f234c4:	e2433001 	sub	r3, r3, #1	; 0x1
21f234c8:	e50b3014 	str	r3, [fp, #-20]
		if (!memcmp(s1,s2,l2))
21f234cc:	e51b3010 	ldr	r3, [fp, #-16]
21f234d0:	e51b0018 	ldr	r0, [fp, #-24]
21f234d4:	e51b101c 	ldr	r1, [fp, #-28]
21f234d8:	e1a02003 	mov	r2, r3
21f234dc:	ebffff98 	bl	21f23344 <memcmp>
21f234e0:	e1a03000 	mov	r3, r0
21f234e4:	e3530000 	cmp	r3, #0	; 0x0
21f234e8:	1a000002 	bne	21f234f8 <strstr+0x8c>
			return (char *) s1;
21f234ec:	e51b3018 	ldr	r3, [fp, #-24]
21f234f0:	e50b3020 	str	r3, [fp, #-32]
21f234f4:	ea000008 	b	21f2351c <strstr+0xb0>
		s1++;
21f234f8:	e51b3018 	ldr	r3, [fp, #-24]
21f234fc:	e2833001 	add	r3, r3, #1	; 0x1
21f23500:	e50b3018 	str	r3, [fp, #-24]
21f23504:	e51b2014 	ldr	r2, [fp, #-20]
21f23508:	e51b3010 	ldr	r3, [fp, #-16]
21f2350c:	e1520003 	cmp	r2, r3
21f23510:	aaffffea 	bge	21f234c0 <strstr+0x54>
	}
	return NULL;
21f23514:	e3a03000 	mov	r3, #0	; 0x0
21f23518:	e50b3020 	str	r3, [fp, #-32]
21f2351c:	e51b3020 	ldr	r3, [fp, #-32]
}
21f23520:	e1a00003 	mov	r0, r3
21f23524:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23528:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2352c <memchr>:
#endif

#ifndef __HAVE_ARCH_MEMCHR
/**
 * memchr - Find a character in an area of memory.
 * @s: The memory area
 * @c: The byte to search for
 * @n: The size of the area.
 *
 * returns the address of the first occurrence of @c, or %NULL
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
21f2352c:	e1a0c00d 	mov	ip, sp
21f23530:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f23534:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23538:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2353c:	e50b0014 	str	r0, [fp, #-20]
21f23540:	e50b1018 	str	r1, [fp, #-24]
21f23544:	e50b201c 	str	r2, [fp, #-28]
	const unsigned char *p = s;
21f23548:	e51b3014 	ldr	r3, [fp, #-20]
21f2354c:	e50b3010 	str	r3, [fp, #-16]
	while (n-- != 0) {
21f23550:	ea000010 	b	21f23598 <memchr+0x6c>
		if ((unsigned char)c == *p++) {
21f23554:	e51b3018 	ldr	r3, [fp, #-24]
21f23558:	e20320ff 	and	r2, r3, #255	; 0xff
21f2355c:	e51b3010 	ldr	r3, [fp, #-16]
21f23560:	e5d33000 	ldrb	r3, [r3]
21f23564:	e1520003 	cmp	r2, r3
21f23568:	13a03000 	movne	r3, #0	; 0x0
21f2356c:	03a03001 	moveq	r3, #1	; 0x1
21f23570:	e20320ff 	and	r2, r3, #255	; 0xff
21f23574:	e51b3010 	ldr	r3, [fp, #-16]
21f23578:	e2833001 	add	r3, r3, #1	; 0x1
21f2357c:	e50b3010 	str	r3, [fp, #-16]
21f23580:	e3520000 	cmp	r2, #0	; 0x0
21f23584:	0a000003 	beq	21f23598 <memchr+0x6c>
			return (void *)(p-1);
21f23588:	e51b3010 	ldr	r3, [fp, #-16]
21f2358c:	e2433001 	sub	r3, r3, #1	; 0x1
21f23590:	e50b3020 	str	r3, [fp, #-32]
21f23594:	ea000007 	b	21f235b8 <memchr+0x8c>
21f23598:	e51b301c 	ldr	r3, [fp, #-28]
21f2359c:	e2433001 	sub	r3, r3, #1	; 0x1
21f235a0:	e50b301c 	str	r3, [fp, #-28]
21f235a4:	e51b301c 	ldr	r3, [fp, #-28]
21f235a8:	e3730001 	cmn	r3, #1	; 0x1
21f235ac:	1affffe8 	bne	21f23554 <memchr+0x28>
		}
	}
	return NULL;
21f235b0:	e3a03000 	mov	r3, #0	; 0x0
21f235b4:	e50b3020 	str	r3, [fp, #-32]
21f235b8:	e51b3020 	ldr	r3, [fp, #-32]
}
21f235bc:	e1a00003 	mov	r0, r3
21f235c0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f235c4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f235c8 <simple_strtoul>:
extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
#endif

unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
{
21f235c8:	e1a0c00d 	mov	ip, sp
21f235cc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f235d0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f235d4:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f235d8:	e50b0018 	str	r0, [fp, #-24]
21f235dc:	e50b101c 	str	r1, [fp, #-28]
21f235e0:	e50b2020 	str	r2, [fp, #-32]
	unsigned long result = 0,value;
21f235e4:	e3a03000 	mov	r3, #0	; 0x0
21f235e8:	e50b3014 	str	r3, [fp, #-20]

	if (*cp == '0') {
21f235ec:	e51b3018 	ldr	r3, [fp, #-24]
21f235f0:	e5d33000 	ldrb	r3, [r3]
21f235f4:	e3530030 	cmp	r3, #48	; 0x30
21f235f8:	1a000019 	bne	21f23664 <simple_strtoul+0x9c>
		cp++;
21f235fc:	e51b3018 	ldr	r3, [fp, #-24]
21f23600:	e2833001 	add	r3, r3, #1	; 0x1
21f23604:	e50b3018 	str	r3, [fp, #-24]
		if ((*cp == 'x') && isxdigit(cp[1])) {
21f23608:	e51b3018 	ldr	r3, [fp, #-24]
21f2360c:	e5d33000 	ldrb	r3, [r3]
21f23610:	e3530078 	cmp	r3, #120	; 0x78
21f23614:	1a00000d 	bne	21f23650 <simple_strtoul+0x88>
21f23618:	e51b3018 	ldr	r3, [fp, #-24]
21f2361c:	e2833001 	add	r3, r3, #1	; 0x1
21f23620:	e5d33000 	ldrb	r3, [r3]
21f23624:	e1a02003 	mov	r2, r3
21f23628:	e59f316c 	ldr	r3, [pc, #364]	; 21f2379c <.text+0x2379c>
21f2362c:	e7d33002 	ldrb	r3, [r3, r2]
21f23630:	e2033044 	and	r3, r3, #68	; 0x44
21f23634:	e3530000 	cmp	r3, #0	; 0x0
21f23638:	0a000004 	beq	21f23650 <simple_strtoul+0x88>
			base = 16;
21f2363c:	e3a03010 	mov	r3, #16	; 0x10
21f23640:	e50b3020 	str	r3, [fp, #-32]
			cp++;
21f23644:	e51b3018 	ldr	r3, [fp, #-24]
21f23648:	e2833001 	add	r3, r3, #1	; 0x1
21f2364c:	e50b3018 	str	r3, [fp, #-24]
		}
		if (!base) {
21f23650:	e51b3020 	ldr	r3, [fp, #-32]
21f23654:	e3530000 	cmp	r3, #0	; 0x0
21f23658:	1a000001 	bne	21f23664 <simple_strtoul+0x9c>
			base = 8;
21f2365c:	e3a03008 	mov	r3, #8	; 0x8
21f23660:	e50b3020 	str	r3, [fp, #-32]
		}
	}
	if (!base) {
21f23664:	e51b3020 	ldr	r3, [fp, #-32]
21f23668:	e3530000 	cmp	r3, #0	; 0x0
21f2366c:	1a00000b 	bne	21f236a0 <simple_strtoul+0xd8>
		base = 10;
21f23670:	e3a0300a 	mov	r3, #10	; 0xa
21f23674:	e50b3020 	str	r3, [fp, #-32]
21f23678:	ea000008 	b	21f236a0 <simple_strtoul+0xd8>
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
21f2367c:	e51b2014 	ldr	r2, [fp, #-20]
21f23680:	e51b3020 	ldr	r3, [fp, #-32]
21f23684:	e0020293 	mul	r2, r3, r2
21f23688:	e51b3010 	ldr	r3, [fp, #-16]
21f2368c:	e0823003 	add	r3, r2, r3
21f23690:	e50b3014 	str	r3, [fp, #-20]
		cp++;
21f23694:	e51b3018 	ldr	r3, [fp, #-24]
21f23698:	e2833001 	add	r3, r3, #1	; 0x1
21f2369c:	e50b3018 	str	r3, [fp, #-24]
21f236a0:	e51b3018 	ldr	r3, [fp, #-24]
21f236a4:	e5d33000 	ldrb	r3, [r3]
21f236a8:	e1a02003 	mov	r2, r3
21f236ac:	e59f30e8 	ldr	r3, [pc, #232]	; 21f2379c <.text+0x2379c>
21f236b0:	e7d33002 	ldrb	r3, [r3, r2]
21f236b4:	e2033044 	and	r3, r3, #68	; 0x44
21f236b8:	e3530000 	cmp	r3, #0	; 0x0
21f236bc:	0a00002c 	beq	21f23774 <simple_strtoul+0x1ac>
21f236c0:	e51b3018 	ldr	r3, [fp, #-24]
21f236c4:	e5d33000 	ldrb	r3, [r3]
21f236c8:	e1a02003 	mov	r2, r3
21f236cc:	e59f30c8 	ldr	r3, [pc, #200]	; 21f2379c <.text+0x2379c>
21f236d0:	e7d33002 	ldrb	r3, [r3, r2]
21f236d4:	e1a03123 	mov	r3, r3, lsr #2
21f236d8:	e2033001 	and	r3, r3, #1	; 0x1
21f236dc:	e20330ff 	and	r3, r3, #255	; 0xff
21f236e0:	e3530000 	cmp	r3, #0	; 0x0
21f236e4:	0a000004 	beq	21f236fc <simple_strtoul+0x134>
21f236e8:	e51b3018 	ldr	r3, [fp, #-24]
21f236ec:	e5d33000 	ldrb	r3, [r3]
21f236f0:	e2433030 	sub	r3, r3, #48	; 0x30
21f236f4:	e50b3028 	str	r3, [fp, #-40]
21f236f8:	ea000017 	b	21f2375c <simple_strtoul+0x194>
21f236fc:	e51b3018 	ldr	r3, [fp, #-24]
21f23700:	e5d33000 	ldrb	r3, [r3]
21f23704:	e1a02003 	mov	r2, r3
21f23708:	e59f308c 	ldr	r3, [pc, #140]	; 21f2379c <.text+0x2379c>
21f2370c:	e7d33002 	ldrb	r3, [r3, r2]
21f23710:	e1a030a3 	mov	r3, r3, lsr #1
21f23714:	e2033001 	and	r3, r3, #1	; 0x1
21f23718:	e20330ff 	and	r3, r3, #255	; 0xff
21f2371c:	e3530000 	cmp	r3, #0	; 0x0
21f23720:	0a000007 	beq	21f23744 <simple_strtoul+0x17c>
21f23724:	e51b3018 	ldr	r3, [fp, #-24]
21f23728:	e5d33000 	ldrb	r3, [r3]
21f2372c:	e1a00003 	mov	r0, r3
21f23730:	eb00001a 	bl	21f237a0 <__toupper>
21f23734:	e1a03000 	mov	r3, r0
21f23738:	e2433037 	sub	r3, r3, #55	; 0x37
21f2373c:	e50b3024 	str	r3, [fp, #-36]
21f23740:	ea000003 	b	21f23754 <simple_strtoul+0x18c>
21f23744:	e51b3018 	ldr	r3, [fp, #-24]
21f23748:	e5d33000 	ldrb	r3, [r3]
21f2374c:	e2433037 	sub	r3, r3, #55	; 0x37
21f23750:	e50b3024 	str	r3, [fp, #-36]
21f23754:	e51b3024 	ldr	r3, [fp, #-36]
21f23758:	e50b3028 	str	r3, [fp, #-40]
21f2375c:	e51b3028 	ldr	r3, [fp, #-40]
21f23760:	e50b3010 	str	r3, [fp, #-16]
21f23764:	e51b2010 	ldr	r2, [fp, #-16]
21f23768:	e51b3020 	ldr	r3, [fp, #-32]
21f2376c:	e1520003 	cmp	r2, r3
21f23770:	3affffc1 	bcc	21f2367c <simple_strtoul+0xb4>
	}
	if (endp)
21f23774:	e51b301c 	ldr	r3, [fp, #-28]
21f23778:	e3530000 	cmp	r3, #0	; 0x0
21f2377c:	0a000002 	beq	21f2378c <simple_strtoul+0x1c4>
		*endp = (char *)cp;
21f23780:	e51b201c 	ldr	r2, [fp, #-28]
21f23784:	e51b3018 	ldr	r3, [fp, #-24]
21f23788:	e5823000 	str	r3, [r2]
	return result;
21f2378c:	e51b3014 	ldr	r3, [fp, #-20]
}
21f23790:	e1a00003 	mov	r0, r3
21f23794:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23798:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2379c:	21f33c74 	mvncss	r3, r4, ror ip

21f237a0 <__toupper>:
	return c;
}

static inline unsigned char __toupper(unsigned char c)
{
21f237a0:	e1a0c00d 	mov	ip, sp
21f237a4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f237a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f237ac:	e24dd004 	sub	sp, sp, #4	; 0x4
21f237b0:	e1a03000 	mov	r3, r0
21f237b4:	e54b3010 	strb	r3, [fp, #-16]
	if (islower(c))
21f237b8:	e55b2010 	ldrb	r2, [fp, #-16]
21f237bc:	e59f3030 	ldr	r3, [pc, #48]	; 21f237f4 <.text+0x237f4>
21f237c0:	e7d33002 	ldrb	r3, [r3, r2]
21f237c4:	e1a030a3 	mov	r3, r3, lsr #1
21f237c8:	e2033001 	and	r3, r3, #1	; 0x1
21f237cc:	e20330ff 	and	r3, r3, #255	; 0xff
21f237d0:	e3530000 	cmp	r3, #0	; 0x0
21f237d4:	0a000003 	beq	21f237e8 <__toupper+0x48>
		c -= 'a'-'A';
21f237d8:	e55b3010 	ldrb	r3, [fp, #-16]
21f237dc:	e2433020 	sub	r3, r3, #32	; 0x20
21f237e0:	e20330ff 	and	r3, r3, #255	; 0xff
21f237e4:	e54b3010 	strb	r3, [fp, #-16]
	return c;
21f237e8:	e55b3010 	ldrb	r3, [fp, #-16]
}
21f237ec:	e1a00003 	mov	r0, r3
21f237f0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f237f4:	21f33c74 	mvncss	r3, r4, ror ip

21f237f8 <simple_strtol>:

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
21f237f8:	e1a0c00d 	mov	ip, sp
21f237fc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f23800:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23804:	e24dd010 	sub	sp, sp, #16	; 0x10
21f23808:	e50b0010 	str	r0, [fp, #-16]
21f2380c:	e50b1014 	str	r1, [fp, #-20]
21f23810:	e50b2018 	str	r2, [fp, #-24]
	if(*cp=='-')
21f23814:	e51b3010 	ldr	r3, [fp, #-16]
21f23818:	e5d33000 	ldrb	r3, [r3]
21f2381c:	e353002d 	cmp	r3, #45	; 0x2d
21f23820:	1a000009 	bne	21f2384c <simple_strtol+0x54>
		return -simple_strtoul(cp+1,endp,base);
21f23824:	e51b3010 	ldr	r3, [fp, #-16]
21f23828:	e2833001 	add	r3, r3, #1	; 0x1
21f2382c:	e1a00003 	mov	r0, r3
21f23830:	e51b1014 	ldr	r1, [fp, #-20]
21f23834:	e51b2018 	ldr	r2, [fp, #-24]
21f23838:	ebffff62 	bl	21f235c8 <simple_strtoul>
21f2383c:	e1a03000 	mov	r3, r0
21f23840:	e2633000 	rsb	r3, r3, #0	; 0x0
21f23844:	e50b301c 	str	r3, [fp, #-28]
21f23848:	ea000005 	b	21f23864 <simple_strtol+0x6c>
	return simple_strtoul(cp,endp,base);
21f2384c:	e51b0010 	ldr	r0, [fp, #-16]
21f23850:	e51b1014 	ldr	r1, [fp, #-20]
21f23854:	e51b2018 	ldr	r2, [fp, #-24]
21f23858:	ebffff5a 	bl	21f235c8 <simple_strtoul>
21f2385c:	e1a03000 	mov	r3, r0
21f23860:	e50b301c 	str	r3, [fp, #-28]
21f23864:	e51b301c 	ldr	r3, [fp, #-28]
}
21f23868:	e1a00003 	mov	r0, r3
21f2386c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23870:	e89da800 	ldmia	sp, {fp, sp, pc}

21f23874 <skip_atoi>:

#ifdef CFG_64BIT_STRTOUL
unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
{
	unsigned long long result = 0, value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
		result = result * base + value;
		cp++;
	}
	if (endp)
		*endp = (char *) cp;
	return result;
}
#endif /* CFG_64BIT_STRTOUL */

/* we use this so that we can do without the ctype library */
#define is_digit(c)	((c) >= '0' && (c) <= '9')

static int skip_atoi(const char **s)
{
21f23874:	e1a0c00d 	mov	ip, sp
21f23878:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2387c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23880:	e24dd008 	sub	sp, sp, #8	; 0x8
21f23884:	e50b0014 	str	r0, [fp, #-20]
	int i=0;
21f23888:	e3a03000 	mov	r3, #0	; 0x0
21f2388c:	e50b3010 	str	r3, [fp, #-16]

	while (is_digit(**s))
21f23890:	ea00000e 	b	21f238d0 <skip_atoi+0x5c>
		i = i*10 + *((*s)++) - '0';
21f23894:	e51b2010 	ldr	r2, [fp, #-16]
21f23898:	e1a03002 	mov	r3, r2
21f2389c:	e1a03103 	mov	r3, r3, lsl #2
21f238a0:	e0833002 	add	r3, r3, r2
21f238a4:	e1a03083 	mov	r3, r3, lsl #1
21f238a8:	e1a02003 	mov	r2, r3
21f238ac:	e51b3014 	ldr	r3, [fp, #-20]
21f238b0:	e5931000 	ldr	r1, [r3]
21f238b4:	e5d13000 	ldrb	r3, [r1]
21f238b8:	e0823003 	add	r3, r2, r3
21f238bc:	e2433030 	sub	r3, r3, #48	; 0x30
21f238c0:	e50b3010 	str	r3, [fp, #-16]
21f238c4:	e2812001 	add	r2, r1, #1	; 0x1
21f238c8:	e51b3014 	ldr	r3, [fp, #-20]
21f238cc:	e5832000 	str	r2, [r3]
21f238d0:	e51b3014 	ldr	r3, [fp, #-20]
21f238d4:	e5933000 	ldr	r3, [r3]
21f238d8:	e5d33000 	ldrb	r3, [r3]
21f238dc:	e353002f 	cmp	r3, #47	; 0x2f
21f238e0:	9a000004 	bls	21f238f8 <skip_atoi+0x84>
21f238e4:	e51b3014 	ldr	r3, [fp, #-20]
21f238e8:	e5933000 	ldr	r3, [r3]
21f238ec:	e5d33000 	ldrb	r3, [r3]
21f238f0:	e3530039 	cmp	r3, #57	; 0x39
21f238f4:	9affffe6 	bls	21f23894 <skip_atoi+0x20>
	return i;
21f238f8:	e51b3010 	ldr	r3, [fp, #-16]
}
21f238fc:	e1a00003 	mov	r0, r3
21f23900:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f23904:	e89da800 	ldmia	sp, {fp, sp, pc}

21f23908 <number>:

#define ZEROPAD	1		/* pad with zero */
#define SIGN	2		/* unsigned/signed long */
#define PLUS	4		/* show plus */
#define SPACE	8		/* space if plus */
#define LEFT	16		/* left justified */
#define SPECIAL	32		/* 0x */
#define LARGE	64		/* use 'ABCDEF' instead of 'abcdef' */

#define do_div(n,base) ({ \
	int __res; \
	__res = ((unsigned long) n) % (unsigned) base; \
	n = ((unsigned long) n) / (unsigned) base; \
	__res; \
})

#ifdef CFG_64BIT_VSPRINTF
static char * number(char * str, long long num, int base, int size, int precision ,int type)
#else
static char * number(char * str, long num, int base, int size, int precision ,int type)
#endif
{
21f23908:	e1a0c00d 	mov	ip, sp
21f2390c:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f23910:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23914:	e24dd068 	sub	sp, sp, #104	; 0x68
21f23918:	e50b0064 	str	r0, [fp, #-100]
21f2391c:	e50b1068 	str	r1, [fp, #-104]
21f23920:	e50b206c 	str	r2, [fp, #-108]
21f23924:	e50b3070 	str	r3, [fp, #-112]
	char c,sign,tmp[66];
	const char *digits="0123456789abcdefghijklmnopqrstuvwxyz";
21f23928:	e59f34cc 	ldr	r3, [pc, #1228]	; 21f23dfc <.text+0x23dfc>
21f2392c:	e50b301c 	str	r3, [fp, #-28]
	int i;

	if (type & LARGE)
21f23930:	e59b3008 	ldr	r3, [fp, #8]
21f23934:	e1a03323 	mov	r3, r3, lsr #6
21f23938:	e2033001 	and	r3, r3, #1	; 0x1
21f2393c:	e20330ff 	and	r3, r3, #255	; 0xff
21f23940:	e3530000 	cmp	r3, #0	; 0x0
21f23944:	0a000001 	beq	21f23950 <number+0x48>
		digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
21f23948:	e59f34b0 	ldr	r3, [pc, #1200]	; 21f23e00 <.text+0x23e00>
21f2394c:	e50b301c 	str	r3, [fp, #-28]
	if (type & LEFT)
21f23950:	e59b3008 	ldr	r3, [fp, #8]
21f23954:	e1a03223 	mov	r3, r3, lsr #4
21f23958:	e2033001 	and	r3, r3, #1	; 0x1
21f2395c:	e20330ff 	and	r3, r3, #255	; 0xff
21f23960:	e3530000 	cmp	r3, #0	; 0x0
21f23964:	0a000002 	beq	21f23974 <number+0x6c>
		type &= ~ZEROPAD;
21f23968:	e59b3008 	ldr	r3, [fp, #8]
21f2396c:	e3c33001 	bic	r3, r3, #1	; 0x1
21f23970:	e58b3008 	str	r3, [fp, #8]
	if (base < 2 || base > 36)
21f23974:	e51b306c 	ldr	r3, [fp, #-108]
21f23978:	e3530001 	cmp	r3, #1	; 0x1
21f2397c:	da000002 	ble	21f2398c <number+0x84>
21f23980:	e51b306c 	ldr	r3, [fp, #-108]
21f23984:	e3530024 	cmp	r3, #36	; 0x24
21f23988:	da000002 	ble	21f23998 <number+0x90>
		return 0;
21f2398c:	e3a00000 	mov	r0, #0	; 0x0
21f23990:	e50b0078 	str	r0, [fp, #-120]
21f23994:	ea000114 	b	21f23dec <number+0x4e4>
	c = (type & ZEROPAD) ? '0' : ' ';
21f23998:	e59b3008 	ldr	r3, [fp, #8]
21f2399c:	e2033001 	and	r3, r3, #1	; 0x1
21f239a0:	e20330ff 	and	r3, r3, #255	; 0xff
21f239a4:	e3530000 	cmp	r3, #0	; 0x0
21f239a8:	0a000002 	beq	21f239b8 <number+0xb0>
21f239ac:	e3a01030 	mov	r1, #48	; 0x30
21f239b0:	e50b1074 	str	r1, [fp, #-116]
21f239b4:	ea000001 	b	21f239c0 <number+0xb8>
21f239b8:	e3a02020 	mov	r2, #32	; 0x20
21f239bc:	e50b2074 	str	r2, [fp, #-116]
21f239c0:	e51b0074 	ldr	r0, [fp, #-116]
21f239c4:	e1a03000 	mov	r3, r0
21f239c8:	e54b301e 	strb	r3, [fp, #-30]
	sign = 0;
21f239cc:	e3a03000 	mov	r3, #0	; 0x0
21f239d0:	e54b301d 	strb	r3, [fp, #-29]
	if (type & SIGN) {
21f239d4:	e59b3008 	ldr	r3, [fp, #8]
21f239d8:	e1a030a3 	mov	r3, r3, lsr #1
21f239dc:	e2033001 	and	r3, r3, #1	; 0x1
21f239e0:	e20330ff 	and	r3, r3, #255	; 0xff
21f239e4:	e3530000 	cmp	r3, #0	; 0x0
21f239e8:	0a000022 	beq	21f23a78 <number+0x170>
		if (num < 0) {
21f239ec:	e51b3068 	ldr	r3, [fp, #-104]
21f239f0:	e3530000 	cmp	r3, #0	; 0x0
21f239f4:	aa000008 	bge	21f23a1c <number+0x114>
			sign = '-';
21f239f8:	e3a0302d 	mov	r3, #45	; 0x2d
21f239fc:	e54b301d 	strb	r3, [fp, #-29]
			num = -num;
21f23a00:	e51b3068 	ldr	r3, [fp, #-104]
21f23a04:	e2633000 	rsb	r3, r3, #0	; 0x0
21f23a08:	e50b3068 	str	r3, [fp, #-104]
			size--;
21f23a0c:	e51b3070 	ldr	r3, [fp, #-112]
21f23a10:	e2433001 	sub	r3, r3, #1	; 0x1
21f23a14:	e50b3070 	str	r3, [fp, #-112]
21f23a18:	ea000016 	b	21f23a78 <number+0x170>
		} else if (type & PLUS) {
21f23a1c:	e59b3008 	ldr	r3, [fp, #8]
21f23a20:	e1a03123 	mov	r3, r3, lsr #2
21f23a24:	e2033001 	and	r3, r3, #1	; 0x1
21f23a28:	e20330ff 	and	r3, r3, #255	; 0xff
21f23a2c:	e3530000 	cmp	r3, #0	; 0x0
21f23a30:	0a000005 	beq	21f23a4c <number+0x144>
			sign = '+';
21f23a34:	e3a0302b 	mov	r3, #43	; 0x2b
21f23a38:	e54b301d 	strb	r3, [fp, #-29]
			size--;
21f23a3c:	e51b3070 	ldr	r3, [fp, #-112]
21f23a40:	e2433001 	sub	r3, r3, #1	; 0x1
21f23a44:	e50b3070 	str	r3, [fp, #-112]
21f23a48:	ea00000a 	b	21f23a78 <number+0x170>
		} else if (type & SPACE) {
21f23a4c:	e59b3008 	ldr	r3, [fp, #8]
21f23a50:	e1a031a3 	mov	r3, r3, lsr #3
21f23a54:	e2033001 	and	r3, r3, #1	; 0x1
21f23a58:	e20330ff 	and	r3, r3, #255	; 0xff
21f23a5c:	e3530000 	cmp	r3, #0	; 0x0
21f23a60:	0a000004 	beq	21f23a78 <number+0x170>
			sign = ' ';
21f23a64:	e3a03020 	mov	r3, #32	; 0x20
21f23a68:	e54b301d 	strb	r3, [fp, #-29]
			size--;
21f23a6c:	e51b3070 	ldr	r3, [fp, #-112]
21f23a70:	e2433001 	sub	r3, r3, #1	; 0x1
21f23a74:	e50b3070 	str	r3, [fp, #-112]
		}
	}
	if (type & SPECIAL) {
21f23a78:	e59b3008 	ldr	r3, [fp, #8]
21f23a7c:	e1a032a3 	mov	r3, r3, lsr #5
21f23a80:	e2033001 	and	r3, r3, #1	; 0x1
21f23a84:	e20330ff 	and	r3, r3, #255	; 0xff
21f23a88:	e3530000 	cmp	r3, #0	; 0x0
21f23a8c:	0a00000c 	beq	21f23ac4 <number+0x1bc>
		if (base == 16)
21f23a90:	e51b306c 	ldr	r3, [fp, #-108]
21f23a94:	e3530010 	cmp	r3, #16	; 0x10
21f23a98:	1a000003 	bne	21f23aac <number+0x1a4>
			size -= 2;
21f23a9c:	e51b3070 	ldr	r3, [fp, #-112]
21f23aa0:	e2433002 	sub	r3, r3, #2	; 0x2
21f23aa4:	e50b3070 	str	r3, [fp, #-112]
21f23aa8:	ea000005 	b	21f23ac4 <number+0x1bc>
		else if (base == 8)
21f23aac:	e51b306c 	ldr	r3, [fp, #-108]
21f23ab0:	e3530008 	cmp	r3, #8	; 0x8
21f23ab4:	1a000002 	bne	21f23ac4 <number+0x1bc>
			size--;
21f23ab8:	e51b3070 	ldr	r3, [fp, #-112]
21f23abc:	e2433001 	sub	r3, r3, #1	; 0x1
21f23ac0:	e50b3070 	str	r3, [fp, #-112]
	}
	i = 0;
21f23ac4:	e3a03000 	mov	r3, #0	; 0x0
21f23ac8:	e50b3018 	str	r3, [fp, #-24]
	if (num == 0)
21f23acc:	e51b3068 	ldr	r3, [fp, #-104]
21f23ad0:	e3530000 	cmp	r3, #0	; 0x0
21f23ad4:	1a000027 	bne	21f23b78 <number+0x270>
		tmp[i++]='0';
21f23ad8:	e51b3018 	ldr	r3, [fp, #-24]
21f23adc:	e3e0204f 	mvn	r2, #79	; 0x4f
21f23ae0:	e24b1010 	sub	r1, fp, #16	; 0x10
21f23ae4:	e0813003 	add	r3, r1, r3
21f23ae8:	e0832002 	add	r2, r3, r2
21f23aec:	e3a03030 	mov	r3, #48	; 0x30
21f23af0:	e5c23000 	strb	r3, [r2]
21f23af4:	e51b3018 	ldr	r3, [fp, #-24]
21f23af8:	e2833001 	add	r3, r3, #1	; 0x1
21f23afc:	e50b3018 	str	r3, [fp, #-24]
21f23b00:	ea00001f 	b	21f23b84 <number+0x27c>
	else while (num != 0)
		tmp[i++] = digits[do_div(num,base)];
21f23b04:	e51b4018 	ldr	r4, [fp, #-24]
21f23b08:	e51b3068 	ldr	r3, [fp, #-104]
21f23b0c:	e51b206c 	ldr	r2, [fp, #-108]
21f23b10:	e1a00003 	mov	r0, r3
21f23b14:	e1a01002 	mov	r1, r2
21f23b18:	ebff880b 	bl	21f05b4c <__umodsi3>
21f23b1c:	e1a03000 	mov	r3, r0
21f23b20:	e50b3014 	str	r3, [fp, #-20]
21f23b24:	e51b3068 	ldr	r3, [fp, #-104]
21f23b28:	e51b206c 	ldr	r2, [fp, #-108]
21f23b2c:	e1a00003 	mov	r0, r3
21f23b30:	e1a01002 	mov	r1, r2
21f23b34:	ebff87de 	bl	21f05ab4 <__udivsi3>
21f23b38:	e1a03000 	mov	r3, r0
21f23b3c:	e50b3068 	str	r3, [fp, #-104]
21f23b40:	e51b3014 	ldr	r3, [fp, #-20]
21f23b44:	e1a02003 	mov	r2, r3
21f23b48:	e51b301c 	ldr	r3, [fp, #-28]
21f23b4c:	e0823003 	add	r3, r2, r3
21f23b50:	e5d31000 	ldrb	r1, [r3]
21f23b54:	e3e0204f 	mvn	r2, #79	; 0x4f
21f23b58:	e24b0010 	sub	r0, fp, #16	; 0x10
21f23b5c:	e0803004 	add	r3, r0, r4
21f23b60:	e0832002 	add	r2, r3, r2
21f23b64:	e1a03001 	mov	r3, r1
21f23b68:	e5c23000 	strb	r3, [r2]
21f23b6c:	e51b3018 	ldr	r3, [fp, #-24]
21f23b70:	e2833001 	add	r3, r3, #1	; 0x1
21f23b74:	e50b3018 	str	r3, [fp, #-24]
21f23b78:	e51b3068 	ldr	r3, [fp, #-104]
21f23b7c:	e3530000 	cmp	r3, #0	; 0x0
21f23b80:	1affffdf 	bne	21f23b04 <number+0x1fc>
	if (i > precision)
21f23b84:	e51b2018 	ldr	r2, [fp, #-24]
21f23b88:	e59b3004 	ldr	r3, [fp, #4]
21f23b8c:	e1520003 	cmp	r2, r3
21f23b90:	da000001 	ble	21f23b9c <number+0x294>
		precision = i;
21f23b94:	e51b3018 	ldr	r3, [fp, #-24]
21f23b98:	e58b3004 	str	r3, [fp, #4]
	size -= precision;
21f23b9c:	e51b2070 	ldr	r2, [fp, #-112]
21f23ba0:	e59b3004 	ldr	r3, [fp, #4]
21f23ba4:	e0633002 	rsb	r3, r3, r2
21f23ba8:	e50b3070 	str	r3, [fp, #-112]
	if (!(type&(ZEROPAD+LEFT)))
21f23bac:	e59b3008 	ldr	r3, [fp, #8]
21f23bb0:	e2033011 	and	r3, r3, #17	; 0x11
21f23bb4:	e3530000 	cmp	r3, #0	; 0x0
21f23bb8:	0a000006 	beq	21f23bd8 <number+0x2d0>
21f23bbc:	ea00000f 	b	21f23c00 <number+0x2f8>
		while(size-->0)
			*str++ = ' ';
21f23bc0:	e51b2064 	ldr	r2, [fp, #-100]
21f23bc4:	e3a03020 	mov	r3, #32	; 0x20
21f23bc8:	e5c23000 	strb	r3, [r2]
21f23bcc:	e51b3064 	ldr	r3, [fp, #-100]
21f23bd0:	e2833001 	add	r3, r3, #1	; 0x1
21f23bd4:	e50b3064 	str	r3, [fp, #-100]
21f23bd8:	e51b3070 	ldr	r3, [fp, #-112]
21f23bdc:	e3530000 	cmp	r3, #0	; 0x0
21f23be0:	d3a03000 	movle	r3, #0	; 0x0
21f23be4:	c3a03001 	movgt	r3, #1	; 0x1
21f23be8:	e20320ff 	and	r2, r3, #255	; 0xff
21f23bec:	e51b3070 	ldr	r3, [fp, #-112]
21f23bf0:	e2433001 	sub	r3, r3, #1	; 0x1
21f23bf4:	e50b3070 	str	r3, [fp, #-112]
21f23bf8:	e3520000 	cmp	r2, #0	; 0x0
21f23bfc:	1affffef 	bne	21f23bc0 <number+0x2b8>
	if (sign)
21f23c00:	e55b301d 	ldrb	r3, [fp, #-29]
21f23c04:	e3530000 	cmp	r3, #0	; 0x0
21f23c08:	0a000005 	beq	21f23c24 <number+0x31c>
		*str++ = sign;
21f23c0c:	e51b2064 	ldr	r2, [fp, #-100]
21f23c10:	e55b301d 	ldrb	r3, [fp, #-29]
21f23c14:	e5c23000 	strb	r3, [r2]
21f23c18:	e51b3064 	ldr	r3, [fp, #-100]
21f23c1c:	e2833001 	add	r3, r3, #1	; 0x1
21f23c20:	e50b3064 	str	r3, [fp, #-100]
	if (type & SPECIAL) {
21f23c24:	e59b3008 	ldr	r3, [fp, #8]
21f23c28:	e1a032a3 	mov	r3, r3, lsr #5
21f23c2c:	e2033001 	and	r3, r3, #1	; 0x1
21f23c30:	e20330ff 	and	r3, r3, #255	; 0xff
21f23c34:	e3530000 	cmp	r3, #0	; 0x0
21f23c38:	0a00001a 	beq	21f23ca8 <number+0x3a0>
		if (base==8)
21f23c3c:	e51b306c 	ldr	r3, [fp, #-108]
21f23c40:	e3530008 	cmp	r3, #8	; 0x8
21f23c44:	1a000006 	bne	21f23c64 <number+0x35c>
			*str++ = '0';
21f23c48:	e51b2064 	ldr	r2, [fp, #-100]
21f23c4c:	e3a03030 	mov	r3, #48	; 0x30
21f23c50:	e5c23000 	strb	r3, [r2]
21f23c54:	e51b3064 	ldr	r3, [fp, #-100]
21f23c58:	e2833001 	add	r3, r3, #1	; 0x1
21f23c5c:	e50b3064 	str	r3, [fp, #-100]
21f23c60:	ea000010 	b	21f23ca8 <number+0x3a0>
		else if (base==16) {
21f23c64:	e51b306c 	ldr	r3, [fp, #-108]
21f23c68:	e3530010 	cmp	r3, #16	; 0x10
21f23c6c:	1a00000d 	bne	21f23ca8 <number+0x3a0>
			*str++ = '0';
21f23c70:	e51b2064 	ldr	r2, [fp, #-100]
21f23c74:	e3a03030 	mov	r3, #48	; 0x30
21f23c78:	e5c23000 	strb	r3, [r2]
21f23c7c:	e51b3064 	ldr	r3, [fp, #-100]
21f23c80:	e2833001 	add	r3, r3, #1	; 0x1
21f23c84:	e50b3064 	str	r3, [fp, #-100]
			*str++ = digits[33];
21f23c88:	e51b301c 	ldr	r3, [fp, #-28]
21f23c8c:	e2833021 	add	r3, r3, #33	; 0x21
21f23c90:	e5d33000 	ldrb	r3, [r3]
21f23c94:	e51b2064 	ldr	r2, [fp, #-100]
21f23c98:	e5c23000 	strb	r3, [r2]
21f23c9c:	e51b3064 	ldr	r3, [fp, #-100]
21f23ca0:	e2833001 	add	r3, r3, #1	; 0x1
21f23ca4:	e50b3064 	str	r3, [fp, #-100]
		}
	}
	if (!(type & LEFT))
21f23ca8:	e59b3008 	ldr	r3, [fp, #8]
21f23cac:	e1a03223 	mov	r3, r3, lsr #4
21f23cb0:	e2033001 	and	r3, r3, #1	; 0x1
21f23cb4:	e3530000 	cmp	r3, #0	; 0x0
21f23cb8:	0a000006 	beq	21f23cd8 <number+0x3d0>
21f23cbc:	ea000016 	b	21f23d1c <number+0x414>
		while (size-- > 0)
			*str++ = c;
21f23cc0:	e51b2064 	ldr	r2, [fp, #-100]
21f23cc4:	e55b301e 	ldrb	r3, [fp, #-30]
21f23cc8:	e5c23000 	strb	r3, [r2]
21f23ccc:	e51b3064 	ldr	r3, [fp, #-100]
21f23cd0:	e2833001 	add	r3, r3, #1	; 0x1
21f23cd4:	e50b3064 	str	r3, [fp, #-100]
21f23cd8:	e51b3070 	ldr	r3, [fp, #-112]
21f23cdc:	e3530000 	cmp	r3, #0	; 0x0
21f23ce0:	d3a03000 	movle	r3, #0	; 0x0
21f23ce4:	c3a03001 	movgt	r3, #1	; 0x1
21f23ce8:	e20320ff 	and	r2, r3, #255	; 0xff
21f23cec:	e51b3070 	ldr	r3, [fp, #-112]
21f23cf0:	e2433001 	sub	r3, r3, #1	; 0x1
21f23cf4:	e50b3070 	str	r3, [fp, #-112]
21f23cf8:	e3520000 	cmp	r2, #0	; 0x0
21f23cfc:	1affffef 	bne	21f23cc0 <number+0x3b8>
21f23d00:	ea000005 	b	21f23d1c <number+0x414>
	while (i < precision--)
		*str++ = '0';
21f23d04:	e51b2064 	ldr	r2, [fp, #-100]
21f23d08:	e3a03030 	mov	r3, #48	; 0x30
21f23d0c:	e5c23000 	strb	r3, [r2]
21f23d10:	e51b3064 	ldr	r3, [fp, #-100]
21f23d14:	e2833001 	add	r3, r3, #1	; 0x1
21f23d18:	e50b3064 	str	r3, [fp, #-100]
21f23d1c:	e59b2004 	ldr	r2, [fp, #4]
21f23d20:	e51b3018 	ldr	r3, [fp, #-24]
21f23d24:	e1520003 	cmp	r2, r3
21f23d28:	d3a03000 	movle	r3, #0	; 0x0
21f23d2c:	c3a03001 	movgt	r3, #1	; 0x1
21f23d30:	e20320ff 	and	r2, r3, #255	; 0xff
21f23d34:	e59b3004 	ldr	r3, [fp, #4]
21f23d38:	e2433001 	sub	r3, r3, #1	; 0x1
21f23d3c:	e58b3004 	str	r3, [fp, #4]
21f23d40:	e3520000 	cmp	r2, #0	; 0x0
21f23d44:	1affffee 	bne	21f23d04 <number+0x3fc>
21f23d48:	ea00000a 	b	21f23d78 <number+0x470>
	while (i-- > 0)
		*str++ = tmp[i];
21f23d4c:	e51b3018 	ldr	r3, [fp, #-24]
21f23d50:	e3e0204f 	mvn	r2, #79	; 0x4f
21f23d54:	e24b1010 	sub	r1, fp, #16	; 0x10
21f23d58:	e0813003 	add	r3, r1, r3
21f23d5c:	e0833002 	add	r3, r3, r2
21f23d60:	e5d33000 	ldrb	r3, [r3]
21f23d64:	e51b2064 	ldr	r2, [fp, #-100]
21f23d68:	e5c23000 	strb	r3, [r2]
21f23d6c:	e51b3064 	ldr	r3, [fp, #-100]
21f23d70:	e2833001 	add	r3, r3, #1	; 0x1
21f23d74:	e50b3064 	str	r3, [fp, #-100]
21f23d78:	e51b3018 	ldr	r3, [fp, #-24]
21f23d7c:	e3530000 	cmp	r3, #0	; 0x0
21f23d80:	d3a03000 	movle	r3, #0	; 0x0
21f23d84:	c3a03001 	movgt	r3, #1	; 0x1
21f23d88:	e20320ff 	and	r2, r3, #255	; 0xff
21f23d8c:	e51b3018 	ldr	r3, [fp, #-24]
21f23d90:	e2433001 	sub	r3, r3, #1	; 0x1
21f23d94:	e50b3018 	str	r3, [fp, #-24]
21f23d98:	e3520000 	cmp	r2, #0	; 0x0
21f23d9c:	1affffea 	bne	21f23d4c <number+0x444>
21f23da0:	ea000005 	b	21f23dbc <number+0x4b4>
	while (size-- > 0)
		*str++ = ' ';
21f23da4:	e51b2064 	ldr	r2, [fp, #-100]
21f23da8:	e3a03020 	mov	r3, #32	; 0x20
21f23dac:	e5c23000 	strb	r3, [r2]
21f23db0:	e51b3064 	ldr	r3, [fp, #-100]
21f23db4:	e2833001 	add	r3, r3, #1	; 0x1
21f23db8:	e50b3064 	str	r3, [fp, #-100]
21f23dbc:	e51b3070 	ldr	r3, [fp, #-112]
21f23dc0:	e3530000 	cmp	r3, #0	; 0x0
21f23dc4:	d3a03000 	movle	r3, #0	; 0x0
21f23dc8:	c3a03001 	movgt	r3, #1	; 0x1
21f23dcc:	e20320ff 	and	r2, r3, #255	; 0xff
21f23dd0:	e51b3070 	ldr	r3, [fp, #-112]
21f23dd4:	e2433001 	sub	r3, r3, #1	; 0x1
21f23dd8:	e50b3070 	str	r3, [fp, #-112]
21f23ddc:	e3520000 	cmp	r2, #0	; 0x0
21f23de0:	1affffef 	bne	21f23da4 <number+0x49c>
	return str;
21f23de4:	e51b2064 	ldr	r2, [fp, #-100]
21f23de8:	e50b2078 	str	r2, [fp, #-120]
21f23dec:	e51b3078 	ldr	r3, [fp, #-120]
}
21f23df0:	e1a00003 	mov	r0, r3
21f23df4:	e24bd010 	sub	sp, fp, #16	; 0x10
21f23df8:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f23dfc:	21f32c7c 	mvncss	r2, ip, ror ip
21f23e00:	21f32ca4 	mvncss	r2, r4, lsr #25

21f23e04 <vsprintf>:

/* Forward decl. needed for IP address printing stuff... */
int sprintf(char * buf, const char *fmt, ...);

int vsprintf(char *buf, const char *fmt, va_list args)
{
21f23e04:	e1a0c00d 	mov	ip, sp
21f23e08:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f23e0c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f23e10:	e24dd044 	sub	sp, sp, #68	; 0x44
21f23e14:	e50b0040 	str	r0, [fp, #-64]
21f23e18:	e50b1044 	str	r1, [fp, #-68]
21f23e1c:	e50b2048 	str	r2, [fp, #-72]
	int len;
#ifdef CFG_64BIT_VSPRINTF
	unsigned long long num;
#else
	unsigned long num;
#endif
	int i, base;
	char * str;
	const char *s;

	int flags;		/* flags to number() */

	int field_width;	/* width of output field */
	int precision;		/* min. # of digits for integers; max
				   number of chars for from string */
	int qualifier;		/* 'h', 'l', or 'q' for integer fields */

	for (str=buf ; *fmt ; ++fmt) {
21f23e20:	e51b3040 	ldr	r3, [fp, #-64]
21f23e24:	e50b302c 	str	r3, [fp, #-44]
21f23e28:	ea000218 	b	21f24690 <.text+0x24690>
		if (*fmt != '%') {
21f23e2c:	e51b3044 	ldr	r3, [fp, #-68]
21f23e30:	e5d33000 	ldrb	r3, [r3]
21f23e34:	e3530025 	cmp	r3, #37	; 0x25
21f23e38:	0a000007 	beq	21f23e5c <vsprintf+0x58>
			*str++ = *fmt;
21f23e3c:	e51b3044 	ldr	r3, [fp, #-68]
21f23e40:	e5d33000 	ldrb	r3, [r3]
21f23e44:	e51b202c 	ldr	r2, [fp, #-44]
21f23e48:	e5c23000 	strb	r3, [r2]
21f23e4c:	e51b302c 	ldr	r3, [fp, #-44]
21f23e50:	e2833001 	add	r3, r3, #1	; 0x1
21f23e54:	e50b302c 	str	r3, [fp, #-44]
			continue;
21f23e58:	ea000209 	b	21f24684 <.text+0x24684>
		}

		/* process flags */
		flags = 0;
21f23e5c:	e3a03000 	mov	r3, #0	; 0x0
21f23e60:	e50b3024 	str	r3, [fp, #-36]
21f23e64:	eaffffff 	b	21f23e68 <vsprintf+0x64>
		repeat:
			++fmt;		/* this also skips first '%' */
21f23e68:	e51b3044 	ldr	r3, [fp, #-68]
21f23e6c:	e2833001 	add	r3, r3, #1	; 0x1
21f23e70:	e50b3044 	str	r3, [fp, #-68]
			switch (*fmt) {
21f23e74:	e51b3044 	ldr	r3, [fp, #-68]
21f23e78:	e5d33000 	ldrb	r3, [r3]
21f23e7c:	e2433020 	sub	r3, r3, #32	; 0x20
21f23e80:	e3530010 	cmp	r3, #16	; 0x10
21f23e84:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f23e88:	ea000024 	b	21f23f20 <.text+0x23f20>
21f23e8c:	21f23ef0 	ldrcssh	r3, [r2, #224]!
21f23e90:	21f23f20 	mvncss	r3, r0, lsr #30
21f23e94:	21f23f20 	mvncss	r3, r0, lsr #30
21f23e98:	21f23f00 	mvncss	r3, r0, lsl #30
21f23e9c:	21f23f20 	mvncss	r3, r0, lsr #30
21f23ea0:	21f23f20 	mvncss	r3, r0, lsr #30
21f23ea4:	21f23f20 	mvncss	r3, r0, lsr #30
21f23ea8:	21f23f20 	mvncss	r3, r0, lsr #30
21f23eac:	21f23f20 	mvncss	r3, r0, lsr #30
21f23eb0:	21f23f20 	mvncss	r3, r0, lsr #30
21f23eb4:	21f23f20 	mvncss	r3, r0, lsr #30
21f23eb8:	21f23ee0 	mvncss	r3, r0, ror #29
21f23ebc:	21f23f20 	mvncss	r3, r0, lsr #30
21f23ec0:	21f23ed0 	ldrcssb	r3, [r2, #224]!
21f23ec4:	21f23f20 	mvncss	r3, r0, lsr #30
21f23ec8:	21f23f20 	mvncss	r3, r0, lsr #30
21f23ecc:	21f23f10 	mvncss	r3, r0, lsl pc
				case '-': flags |= LEFT; goto repeat;
21f23ed0:	e51b3024 	ldr	r3, [fp, #-36]
21f23ed4:	e3833010 	orr	r3, r3, #16	; 0x10
21f23ed8:	e50b3024 	str	r3, [fp, #-36]
21f23edc:	eaffffe1 	b	21f23e68 <vsprintf+0x64>
				case '+': flags |= PLUS; goto repeat;
21f23ee0:	e51b3024 	ldr	r3, [fp, #-36]
21f23ee4:	e3833004 	orr	r3, r3, #4	; 0x4
21f23ee8:	e50b3024 	str	r3, [fp, #-36]
21f23eec:	eaffffdd 	b	21f23e68 <vsprintf+0x64>
				case ' ': flags |= SPACE; goto repeat;
21f23ef0:	e51b3024 	ldr	r3, [fp, #-36]
21f23ef4:	e3833008 	orr	r3, r3, #8	; 0x8
21f23ef8:	e50b3024 	str	r3, [fp, #-36]
21f23efc:	eaffffd9 	b	21f23e68 <vsprintf+0x64>
				case '#': flags |= SPECIAL; goto repeat;
21f23f00:	e51b3024 	ldr	r3, [fp, #-36]
21f23f04:	e3833020 	orr	r3, r3, #32	; 0x20
21f23f08:	e50b3024 	str	r3, [fp, #-36]
21f23f0c:	eaffffd5 	b	21f23e68 <vsprintf+0x64>
				case '0': flags |= ZEROPAD; goto repeat;
21f23f10:	e51b3024 	ldr	r3, [fp, #-36]
21f23f14:	e3833001 	orr	r3, r3, #1	; 0x1
21f23f18:	e50b3024 	str	r3, [fp, #-36]
21f23f1c:	eaffffd1 	b	21f23e68 <vsprintf+0x64>
				}

		/* get field width */
		field_width = -1;
21f23f20:	e3e03000 	mvn	r3, #0	; 0x0
21f23f24:	e50b3020 	str	r3, [fp, #-32]
		if (is_digit(*fmt))
21f23f28:	e51b3044 	ldr	r3, [fp, #-68]
21f23f2c:	e5d33000 	ldrb	r3, [r3]
21f23f30:	e353002f 	cmp	r3, #47	; 0x2f
21f23f34:	9a000009 	bls	21f23f60 <.text+0x23f60>
21f23f38:	e51b3044 	ldr	r3, [fp, #-68]
21f23f3c:	e5d33000 	ldrb	r3, [r3]
21f23f40:	e3530039 	cmp	r3, #57	; 0x39
21f23f44:	8a000005 	bhi	21f23f60 <.text+0x23f60>
			field_width = skip_atoi(&fmt);
21f23f48:	e24b3044 	sub	r3, fp, #68	; 0x44
21f23f4c:	e1a00003 	mov	r0, r3
21f23f50:	ebfffe47 	bl	21f23874 <skip_atoi>
21f23f54:	e1a03000 	mov	r3, r0
21f23f58:	e50b3020 	str	r3, [fp, #-32]
21f23f5c:	ea000015 	b	21f23fb8 <.text+0x23fb8>
		else if (*fmt == '*') {
21f23f60:	e51b3044 	ldr	r3, [fp, #-68]
21f23f64:	e5d33000 	ldrb	r3, [r3]
21f23f68:	e353002a 	cmp	r3, #42	; 0x2a
21f23f6c:	1a000011 	bne	21f23fb8 <.text+0x23fb8>
			++fmt;
21f23f70:	e51b3044 	ldr	r3, [fp, #-68]
21f23f74:	e2833001 	add	r3, r3, #1	; 0x1
21f23f78:	e50b3044 	str	r3, [fp, #-68]
			/* it's the next argument */
			field_width = va_arg(args, int);
21f23f7c:	e51b2048 	ldr	r2, [fp, #-72]
21f23f80:	e2823004 	add	r3, r2, #4	; 0x4
21f23f84:	e50b3048 	str	r3, [fp, #-72]
21f23f88:	e1a03002 	mov	r3, r2
21f23f8c:	e5933000 	ldr	r3, [r3]
21f23f90:	e50b3020 	str	r3, [fp, #-32]
			if (field_width < 0) {
21f23f94:	e51b3020 	ldr	r3, [fp, #-32]
21f23f98:	e3530000 	cmp	r3, #0	; 0x0
21f23f9c:	aa000005 	bge	21f23fb8 <.text+0x23fb8>
				field_width = -field_width;
21f23fa0:	e51b3020 	ldr	r3, [fp, #-32]
21f23fa4:	e2633000 	rsb	r3, r3, #0	; 0x0
21f23fa8:	e50b3020 	str	r3, [fp, #-32]
				flags |= LEFT;
21f23fac:	e51b3024 	ldr	r3, [fp, #-36]
21f23fb0:	e3833010 	orr	r3, r3, #16	; 0x10
21f23fb4:	e50b3024 	str	r3, [fp, #-36]
			}
		}

		/* get the precision */
		precision = -1;
21f23fb8:	e3e03000 	mvn	r3, #0	; 0x0
21f23fbc:	e50b301c 	str	r3, [fp, #-28]
		if (*fmt == '.') {
21f23fc0:	e51b3044 	ldr	r3, [fp, #-68]
21f23fc4:	e5d33000 	ldrb	r3, [r3]
21f23fc8:	e353002e 	cmp	r3, #46	; 0x2e
21f23fcc:	1a000022 	bne	21f2405c <.text+0x2405c>
			++fmt;
21f23fd0:	e51b3044 	ldr	r3, [fp, #-68]
21f23fd4:	e2833001 	add	r3, r3, #1	; 0x1
21f23fd8:	e50b3044 	str	r3, [fp, #-68]
			if (is_digit(*fmt))
21f23fdc:	e51b3044 	ldr	r3, [fp, #-68]
21f23fe0:	e5d33000 	ldrb	r3, [r3]
21f23fe4:	e353002f 	cmp	r3, #47	; 0x2f
21f23fe8:	9a000009 	bls	21f24014 <.text+0x24014>
21f23fec:	e51b3044 	ldr	r3, [fp, #-68]
21f23ff0:	e5d33000 	ldrb	r3, [r3]
21f23ff4:	e3530039 	cmp	r3, #57	; 0x39
21f23ff8:	8a000005 	bhi	21f24014 <.text+0x24014>
				precision = skip_atoi(&fmt);
21f23ffc:	e24b3044 	sub	r3, fp, #68	; 0x44
21f24000:	e1a00003 	mov	r0, r3
21f24004:	ebfffe1a 	bl	21f23874 <skip_atoi>
21f24008:	e1a03000 	mov	r3, r0
21f2400c:	e50b301c 	str	r3, [fp, #-28]
21f24010:	ea00000c 	b	21f24048 <.text+0x24048>
			else if (*fmt == '*') {
21f24014:	e51b3044 	ldr	r3, [fp, #-68]
21f24018:	e5d33000 	ldrb	r3, [r3]
21f2401c:	e353002a 	cmp	r3, #42	; 0x2a
21f24020:	1a000008 	bne	21f24048 <.text+0x24048>
				++fmt;
21f24024:	e51b3044 	ldr	r3, [fp, #-68]
21f24028:	e2833001 	add	r3, r3, #1	; 0x1
21f2402c:	e50b3044 	str	r3, [fp, #-68]
				/* it's the next argument */
				precision = va_arg(args, int);
21f24030:	e51b2048 	ldr	r2, [fp, #-72]
21f24034:	e2823004 	add	r3, r2, #4	; 0x4
21f24038:	e50b3048 	str	r3, [fp, #-72]
21f2403c:	e1a03002 	mov	r3, r2
21f24040:	e5933000 	ldr	r3, [r3]
21f24044:	e50b301c 	str	r3, [fp, #-28]
			}
			if (precision < 0)
21f24048:	e51b301c 	ldr	r3, [fp, #-28]
21f2404c:	e3530000 	cmp	r3, #0	; 0x0
21f24050:	aa000001 	bge	21f2405c <.text+0x2405c>
				precision = 0;
21f24054:	e3a03000 	mov	r3, #0	; 0x0
21f24058:	e50b301c 	str	r3, [fp, #-28]
		}

		/* get the conversion qualifier */
		qualifier = -1;
21f2405c:	e3e03000 	mvn	r3, #0	; 0x0
21f24060:	e50b3018 	str	r3, [fp, #-24]
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'q') {
21f24064:	e51b3044 	ldr	r3, [fp, #-68]
21f24068:	e5d33000 	ldrb	r3, [r3]
21f2406c:	e3530068 	cmp	r3, #104	; 0x68
21f24070:	0a000007 	beq	21f24094 <.text+0x24094>
21f24074:	e51b3044 	ldr	r3, [fp, #-68]
21f24078:	e5d33000 	ldrb	r3, [r3]
21f2407c:	e353006c 	cmp	r3, #108	; 0x6c
21f24080:	0a000003 	beq	21f24094 <.text+0x24094>
21f24084:	e51b3044 	ldr	r3, [fp, #-68]
21f24088:	e5d33000 	ldrb	r3, [r3]
21f2408c:	e3530071 	cmp	r3, #113	; 0x71
21f24090:	1a000005 	bne	21f240ac <.text+0x240ac>
			qualifier = *fmt;
21f24094:	e51b3044 	ldr	r3, [fp, #-68]
21f24098:	e5d33000 	ldrb	r3, [r3]
21f2409c:	e50b3018 	str	r3, [fp, #-24]
			++fmt;
21f240a0:	e51b3044 	ldr	r3, [fp, #-68]
21f240a4:	e2833001 	add	r3, r3, #1	; 0x1
21f240a8:	e50b3044 	str	r3, [fp, #-68]
		}

		/* default base */
		base = 10;
21f240ac:	e3a0300a 	mov	r3, #10	; 0xa
21f240b0:	e50b3030 	str	r3, [fp, #-48]

		switch (*fmt) {
21f240b4:	e51b3044 	ldr	r3, [fp, #-68]
21f240b8:	e5d33000 	ldrb	r3, [r3]
21f240bc:	e2433025 	sub	r3, r3, #37	; 0x25
21f240c0:	e3530053 	cmp	r3, #83	; 0x53
21f240c4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f240c8:	ea000116 	b	21f24528 <.text+0x24528>
21f240cc:	21f244d8 	ldrcssb	r4, [r2, #72]!
21f240d0:	21f24528 	mvncss	r4, r8, lsr #10
21f240d4:	21f24528 	mvncss	r4, r8, lsr #10
21f240d8:	21f24528 	mvncss	r4, r8, lsr #10
21f240dc:	21f24528 	mvncss	r4, r8, lsr #10
21f240e0:	21f24528 	mvncss	r4, r8, lsr #10
21f240e4:	21f24528 	mvncss	r4, r8, lsr #10
21f240e8:	21f24528 	mvncss	r4, r8, lsr #10
21f240ec:	21f24528 	mvncss	r4, r8, lsr #10
21f240f0:	21f24528 	mvncss	r4, r8, lsr #10
21f240f4:	21f24528 	mvncss	r4, r8, lsr #10
21f240f8:	21f24528 	mvncss	r4, r8, lsr #10
21f240fc:	21f24528 	mvncss	r4, r8, lsr #10
21f24100:	21f24528 	mvncss	r4, r8, lsr #10
21f24104:	21f24528 	mvncss	r4, r8, lsr #10
21f24108:	21f24528 	mvncss	r4, r8, lsr #10
21f2410c:	21f24528 	mvncss	r4, r8, lsr #10
21f24110:	21f24528 	mvncss	r4, r8, lsr #10
21f24114:	21f24528 	mvncss	r4, r8, lsr #10
21f24118:	21f24528 	mvncss	r4, r8, lsr #10
21f2411c:	21f24528 	mvncss	r4, r8, lsr #10
21f24120:	21f24528 	mvncss	r4, r8, lsr #10
21f24124:	21f24528 	mvncss	r4, r8, lsr #10
21f24128:	21f24528 	mvncss	r4, r8, lsr #10
21f2412c:	21f24528 	mvncss	r4, r8, lsr #10
21f24130:	21f24528 	mvncss	r4, r8, lsr #10
21f24134:	21f24528 	mvncss	r4, r8, lsr #10
21f24138:	21f24528 	mvncss	r4, r8, lsr #10
21f2413c:	21f24528 	mvncss	r4, r8, lsr #10
21f24140:	21f24528 	mvncss	r4, r8, lsr #10
21f24144:	21f24528 	mvncss	r4, r8, lsr #10
21f24148:	21f24528 	mvncss	r4, r8, lsr #10
21f2414c:	21f24528 	mvncss	r4, r8, lsr #10
21f24150:	21f24528 	mvncss	r4, r8, lsr #10
21f24154:	21f24528 	mvncss	r4, r8, lsr #10
21f24158:	21f24528 	mvncss	r4, r8, lsr #10
21f2415c:	21f24528 	mvncss	r4, r8, lsr #10
21f24160:	21f24528 	mvncss	r4, r8, lsr #10
21f24164:	21f24528 	mvncss	r4, r8, lsr #10
21f24168:	21f24528 	mvncss	r4, r8, lsr #10
21f2416c:	21f24528 	mvncss	r4, r8, lsr #10
21f24170:	21f24528 	mvncss	r4, r8, lsr #10
21f24174:	21f24528 	mvncss	r4, r8, lsr #10
21f24178:	21f24528 	mvncss	r4, r8, lsr #10
21f2417c:	21f24528 	mvncss	r4, r8, lsr #10
21f24180:	21f24528 	mvncss	r4, r8, lsr #10
21f24184:	21f24528 	mvncss	r4, r8, lsr #10
21f24188:	21f24528 	mvncss	r4, r8, lsr #10
21f2418c:	21f24528 	mvncss	r4, r8, lsr #10
21f24190:	21f24528 	mvncss	r4, r8, lsr #10
21f24194:	21f24528 	mvncss	r4, r8, lsr #10
21f24198:	21f24500 	mvncss	r4, r0, lsl #10
21f2419c:	21f24528 	mvncss	r4, r8, lsr #10
21f241a0:	21f24528 	mvncss	r4, r8, lsr #10
21f241a4:	21f24528 	mvncss	r4, r8, lsr #10
21f241a8:	21f24528 	mvncss	r4, r8, lsr #10
21f241ac:	21f24528 	mvncss	r4, r8, lsr #10
21f241b0:	21f24528 	mvncss	r4, r8, lsr #10
21f241b4:	21f24528 	mvncss	r4, r8, lsr #10
21f241b8:	21f24528 	mvncss	r4, r8, lsr #10
21f241bc:	21f24528 	mvncss	r4, r8, lsr #10
21f241c0:	21f24528 	mvncss	r4, r8, lsr #10
21f241c4:	21f2421c 	mvncss	r4, ip, lsl r2
21f241c8:	21f24518 	mvncss	r4, r8, lsl r5
21f241cc:	21f24528 	mvncss	r4, r8, lsr #10
21f241d0:	21f24528 	mvncss	r4, r8, lsr #10
21f241d4:	21f24528 	mvncss	r4, r8, lsr #10
21f241d8:	21f24528 	mvncss	r4, r8, lsr #10
21f241dc:	21f24518 	mvncss	r4, r8, lsl r5
21f241e0:	21f24528 	mvncss	r4, r8, lsr #10
21f241e4:	21f24528 	mvncss	r4, r8, lsr #10
21f241e8:	21f24528 	mvncss	r4, r8, lsr #10
21f241ec:	21f24528 	mvncss	r4, r8, lsr #10
21f241f0:	21f2446c 	mvncss	r4, ip, ror #8
21f241f4:	21f244f4 	ldrcssh	r4, [r2, #68]!
21f241f8:	21f24404 	mvncss	r4, r4, lsl #8
21f241fc:	21f24528 	mvncss	r4, r8, lsr #10
21f24200:	21f24528 	mvncss	r4, r8, lsr #10
21f24204:	21f242c8 	mvncss	r4, r8, asr #5
21f24208:	21f24528 	mvncss	r4, r8, lsr #10
21f2420c:	21f24580 	mvncss	r4, r0, lsl #11
21f24210:	21f24528 	mvncss	r4, r8, lsr #10
21f24214:	21f24528 	mvncss	r4, r8, lsr #10
21f24218:	21f2450c 	mvncss	r4, ip, lsl #10
		case 'c':
			if (!(flags & LEFT))
21f2421c:	e51b3024 	ldr	r3, [fp, #-36]
21f24220:	e1a03223 	mov	r3, r3, lsr #4
21f24224:	e2033001 	and	r3, r3, #1	; 0x1
21f24228:	e3530000 	cmp	r3, #0	; 0x0
21f2422c:	0a000006 	beq	21f2424c <.text+0x2424c>
21f24230:	ea00000b 	b	21f24264 <.text+0x24264>
				while (--field_width > 0)
					*str++ = ' ';
21f24234:	e51b202c 	ldr	r2, [fp, #-44]
21f24238:	e3a03020 	mov	r3, #32	; 0x20
21f2423c:	e5c23000 	strb	r3, [r2]
21f24240:	e51b302c 	ldr	r3, [fp, #-44]
21f24244:	e2833001 	add	r3, r3, #1	; 0x1
21f24248:	e50b302c 	str	r3, [fp, #-44]
21f2424c:	e51b3020 	ldr	r3, [fp, #-32]
21f24250:	e2433001 	sub	r3, r3, #1	; 0x1
21f24254:	e50b3020 	str	r3, [fp, #-32]
21f24258:	e51b3020 	ldr	r3, [fp, #-32]
21f2425c:	e3530000 	cmp	r3, #0	; 0x0
21f24260:	cafffff3 	bgt	21f24234 <.text+0x24234>
			*str++ = (unsigned char) va_arg(args, int);
21f24264:	e51b2048 	ldr	r2, [fp, #-72]
21f24268:	e2823004 	add	r3, r2, #4	; 0x4
21f2426c:	e50b3048 	str	r3, [fp, #-72]
21f24270:	e1a03002 	mov	r3, r2
21f24274:	e5933000 	ldr	r3, [r3]
21f24278:	e20330ff 	and	r3, r3, #255	; 0xff
21f2427c:	e51b202c 	ldr	r2, [fp, #-44]
21f24280:	e5c23000 	strb	r3, [r2]
21f24284:	e51b302c 	ldr	r3, [fp, #-44]
21f24288:	e2833001 	add	r3, r3, #1	; 0x1
21f2428c:	e50b302c 	str	r3, [fp, #-44]
			while (--field_width > 0)
21f24290:	ea000005 	b	21f242ac <.text+0x242ac>
				*str++ = ' ';
21f24294:	e51b202c 	ldr	r2, [fp, #-44]
21f24298:	e3a03020 	mov	r3, #32	; 0x20
21f2429c:	e5c23000 	strb	r3, [r2]
21f242a0:	e51b302c 	ldr	r3, [fp, #-44]
21f242a4:	e2833001 	add	r3, r3, #1	; 0x1
21f242a8:	e50b302c 	str	r3, [fp, #-44]
21f242ac:	e51b3020 	ldr	r3, [fp, #-32]
21f242b0:	e2433001 	sub	r3, r3, #1	; 0x1
21f242b4:	e50b3020 	str	r3, [fp, #-32]
21f242b8:	e51b3020 	ldr	r3, [fp, #-32]
21f242bc:	e3530000 	cmp	r3, #0	; 0x0
21f242c0:	cafffff3 	bgt	21f24294 <.text+0x24294>
21f242c4:	ea0000ee 	b	21f24684 <.text+0x24684>
			continue;

		case 's':
			s = va_arg(args, char *);
21f242c8:	e51b2048 	ldr	r2, [fp, #-72]
21f242cc:	e2823004 	add	r3, r2, #4	; 0x4
21f242d0:	e50b3048 	str	r3, [fp, #-72]
21f242d4:	e1a03002 	mov	r3, r2
21f242d8:	e5933000 	ldr	r3, [r3]
21f242dc:	e50b3028 	str	r3, [fp, #-40]
			if (!s)
21f242e0:	e51b3028 	ldr	r3, [fp, #-40]
21f242e4:	e3530000 	cmp	r3, #0	; 0x0
21f242e8:	1a000001 	bne	21f242f4 <.text+0x242f4>
				s = "<NULL>";
21f242ec:	e59f33d0 	ldr	r3, [pc, #976]	; 21f246c4 <.text+0x246c4>
21f242f0:	e50b3028 	str	r3, [fp, #-40]

			len = strnlen(s, precision);
21f242f4:	e51b301c 	ldr	r3, [fp, #-28]
21f242f8:	e51b0028 	ldr	r0, [fp, #-40]
21f242fc:	e1a01003 	mov	r1, r3
21f24300:	ebfffa44 	bl	21f22c18 <strnlen>
21f24304:	e1a03000 	mov	r3, r0
21f24308:	e50b303c 	str	r3, [fp, #-60]

			if (!(flags & LEFT))
21f2430c:	e51b3024 	ldr	r3, [fp, #-36]
21f24310:	e1a03223 	mov	r3, r3, lsr #4
21f24314:	e2033001 	and	r3, r3, #1	; 0x1
21f24318:	e3530000 	cmp	r3, #0	; 0x0
21f2431c:	0a000006 	beq	21f2433c <.text+0x2433c>
21f24320:	ea000010 	b	21f24368 <.text+0x24368>
				while (len < field_width--)
					*str++ = ' ';
21f24324:	e51b202c 	ldr	r2, [fp, #-44]
21f24328:	e3a03020 	mov	r3, #32	; 0x20
21f2432c:	e5c23000 	strb	r3, [r2]
21f24330:	e51b302c 	ldr	r3, [fp, #-44]
21f24334:	e2833001 	add	r3, r3, #1	; 0x1
21f24338:	e50b302c 	str	r3, [fp, #-44]
21f2433c:	e51b2020 	ldr	r2, [fp, #-32]
21f24340:	e51b303c 	ldr	r3, [fp, #-60]
21f24344:	e1520003 	cmp	r2, r3
21f24348:	d3a03000 	movle	r3, #0	; 0x0
21f2434c:	c3a03001 	movgt	r3, #1	; 0x1
21f24350:	e20320ff 	and	r2, r3, #255	; 0xff
21f24354:	e51b3020 	ldr	r3, [fp, #-32]
21f24358:	e2433001 	sub	r3, r3, #1	; 0x1
21f2435c:	e50b3020 	str	r3, [fp, #-32]
21f24360:	e3520000 	cmp	r2, #0	; 0x0
21f24364:	1affffee 	bne	21f24324 <.text+0x24324>
			for (i = 0; i < len; ++i)
21f24368:	e3a03000 	mov	r3, #0	; 0x0
21f2436c:	e50b3034 	str	r3, [fp, #-52]
21f24370:	ea00000c 	b	21f243a8 <.text+0x243a8>
				*str++ = *s++;
21f24374:	e51b3028 	ldr	r3, [fp, #-40]
21f24378:	e5d33000 	ldrb	r3, [r3]
21f2437c:	e51b202c 	ldr	r2, [fp, #-44]
21f24380:	e5c23000 	strb	r3, [r2]
21f24384:	e51b302c 	ldr	r3, [fp, #-44]
21f24388:	e2833001 	add	r3, r3, #1	; 0x1
21f2438c:	e50b302c 	str	r3, [fp, #-44]
21f24390:	e51b3028 	ldr	r3, [fp, #-40]
21f24394:	e2833001 	add	r3, r3, #1	; 0x1
21f24398:	e50b3028 	str	r3, [fp, #-40]
21f2439c:	e51b3034 	ldr	r3, [fp, #-52]
21f243a0:	e2833001 	add	r3, r3, #1	; 0x1
21f243a4:	e50b3034 	str	r3, [fp, #-52]
21f243a8:	e51b2034 	ldr	r2, [fp, #-52]
21f243ac:	e51b303c 	ldr	r3, [fp, #-60]
21f243b0:	e1520003 	cmp	r2, r3
21f243b4:	baffffee 	blt	21f24374 <.text+0x24374>
21f243b8:	ea000005 	b	21f243d4 <.text+0x243d4>
			while (len < field_width--)
				*str++ = ' ';
21f243bc:	e51b202c 	ldr	r2, [fp, #-44]
21f243c0:	e3a03020 	mov	r3, #32	; 0x20
21f243c4:	e5c23000 	strb	r3, [r2]
21f243c8:	e51b302c 	ldr	r3, [fp, #-44]
21f243cc:	e2833001 	add	r3, r3, #1	; 0x1
21f243d0:	e50b302c 	str	r3, [fp, #-44]
21f243d4:	e51b2020 	ldr	r2, [fp, #-32]
21f243d8:	e51b303c 	ldr	r3, [fp, #-60]
21f243dc:	e1520003 	cmp	r2, r3
21f243e0:	d3a03000 	movle	r3, #0	; 0x0
21f243e4:	c3a03001 	movgt	r3, #1	; 0x1
21f243e8:	e20320ff 	and	r2, r3, #255	; 0xff
21f243ec:	e51b3020 	ldr	r3, [fp, #-32]
21f243f0:	e2433001 	sub	r3, r3, #1	; 0x1
21f243f4:	e50b3020 	str	r3, [fp, #-32]
21f243f8:	e3520000 	cmp	r2, #0	; 0x0
21f243fc:	1affffee 	bne	21f243bc <.text+0x243bc>
21f24400:	ea00009f 	b	21f24684 <.text+0x24684>
			continue;

		case 'p':
			if (field_width == -1) {
21f24404:	e51b3020 	ldr	r3, [fp, #-32]
21f24408:	e3730001 	cmn	r3, #1	; 0x1
21f2440c:	1a000004 	bne	21f24424 <.text+0x24424>
				field_width = 2*sizeof(void *);
21f24410:	e3a03008 	mov	r3, #8	; 0x8
21f24414:	e50b3020 	str	r3, [fp, #-32]
				flags |= ZEROPAD;
21f24418:	e51b3024 	ldr	r3, [fp, #-36]
21f2441c:	e3833001 	orr	r3, r3, #1	; 0x1
21f24420:	e50b3024 	str	r3, [fp, #-36]
			}
			str = number(str,
21f24424:	e51b2048 	ldr	r2, [fp, #-72]
21f24428:	e2823004 	add	r3, r2, #4	; 0x4
21f2442c:	e50b3048 	str	r3, [fp, #-72]
21f24430:	e1a03002 	mov	r3, r2
21f24434:	e5933000 	ldr	r3, [r3]
21f24438:	e1a02003 	mov	r2, r3
21f2443c:	e51b301c 	ldr	r3, [fp, #-28]
21f24440:	e58d3000 	str	r3, [sp]
21f24444:	e51b3024 	ldr	r3, [fp, #-36]
21f24448:	e58d3004 	str	r3, [sp, #4]
21f2444c:	e51b002c 	ldr	r0, [fp, #-44]
21f24450:	e1a01002 	mov	r1, r2
21f24454:	e3a02010 	mov	r2, #16	; 0x10
21f24458:	e51b3020 	ldr	r3, [fp, #-32]
21f2445c:	ebfffd29 	bl	21f23908 <number>
21f24460:	e1a03000 	mov	r3, r0
21f24464:	e50b302c 	str	r3, [fp, #-44]
				(unsigned long) va_arg(args, void *), 16,
				field_width, precision, flags);
			continue;
21f24468:	ea000085 	b	21f24684 <.text+0x24684>


		case 'n':
			if (qualifier == 'l') {
21f2446c:	e51b3018 	ldr	r3, [fp, #-24]
21f24470:	e353006c 	cmp	r3, #108	; 0x6c
21f24474:	1a00000b 	bne	21f244a8 <.text+0x244a8>
				long * ip = va_arg(args, long *);
21f24478:	e51b2048 	ldr	r2, [fp, #-72]
21f2447c:	e2823004 	add	r3, r2, #4	; 0x4
21f24480:	e50b3048 	str	r3, [fp, #-72]
21f24484:	e1a03002 	mov	r3, r2
21f24488:	e5933000 	ldr	r3, [r3]
21f2448c:	e50b3014 	str	r3, [fp, #-20]
				*ip = (str - buf);
21f24490:	e51b202c 	ldr	r2, [fp, #-44]
21f24494:	e51b3040 	ldr	r3, [fp, #-64]
21f24498:	e0632002 	rsb	r2, r3, r2
21f2449c:	e51b3014 	ldr	r3, [fp, #-20]
21f244a0:	e5832000 	str	r2, [r3]
21f244a4:	ea000076 	b	21f24684 <.text+0x24684>
			} else {
				int * ip = va_arg(args, int *);
21f244a8:	e51b2048 	ldr	r2, [fp, #-72]
21f244ac:	e2823004 	add	r3, r2, #4	; 0x4
21f244b0:	e50b3048 	str	r3, [fp, #-72]
21f244b4:	e1a03002 	mov	r3, r2
21f244b8:	e5933000 	ldr	r3, [r3]
21f244bc:	e50b3010 	str	r3, [fp, #-16]
				*ip = (str - buf);
21f244c0:	e51b202c 	ldr	r2, [fp, #-44]
21f244c4:	e51b3040 	ldr	r3, [fp, #-64]
21f244c8:	e0632002 	rsb	r2, r3, r2
21f244cc:	e51b3010 	ldr	r3, [fp, #-16]
21f244d0:	e5832000 	str	r2, [r3]
21f244d4:	ea00006a 	b	21f24684 <.text+0x24684>
			}
			continue;

		case '%':
			*str++ = '%';
21f244d8:	e51b202c 	ldr	r2, [fp, #-44]
21f244dc:	e3a03025 	mov	r3, #37	; 0x25
21f244e0:	e5c23000 	strb	r3, [r2]
21f244e4:	e51b302c 	ldr	r3, [fp, #-44]
21f244e8:	e2833001 	add	r3, r3, #1	; 0x1
21f244ec:	e50b302c 	str	r3, [fp, #-44]
			continue;
21f244f0:	ea000063 	b	21f24684 <.text+0x24684>

		/* integer number formats - set up the flags and "break" */
		case 'o':
			base = 8;
21f244f4:	e3a03008 	mov	r3, #8	; 0x8
21f244f8:	e50b3030 	str	r3, [fp, #-48]
			break;
21f244fc:	ea00001f 	b	21f24580 <.text+0x24580>

		case 'X':
			flags |= LARGE;
21f24500:	e51b3024 	ldr	r3, [fp, #-36]
21f24504:	e3833040 	orr	r3, r3, #64	; 0x40
21f24508:	e50b3024 	str	r3, [fp, #-36]
		case 'x':
			base = 16;
21f2450c:	e3a03010 	mov	r3, #16	; 0x10
21f24510:	e50b3030 	str	r3, [fp, #-48]
			break;
21f24514:	ea000019 	b	21f24580 <.text+0x24580>

		case 'd':
		case 'i':
			flags |= SIGN;
21f24518:	e51b3024 	ldr	r3, [fp, #-36]
21f2451c:	e3833002 	orr	r3, r3, #2	; 0x2
21f24520:	e50b3024 	str	r3, [fp, #-36]
21f24524:	ea000015 	b	21f24580 <.text+0x24580>
		case 'u':
			break;

		default:
			*str++ = '%';
21f24528:	e51b202c 	ldr	r2, [fp, #-44]
21f2452c:	e3a03025 	mov	r3, #37	; 0x25
21f24530:	e5c23000 	strb	r3, [r2]
21f24534:	e51b302c 	ldr	r3, [fp, #-44]
21f24538:	e2833001 	add	r3, r3, #1	; 0x1
21f2453c:	e50b302c 	str	r3, [fp, #-44]
			if (*fmt)
21f24540:	e51b3044 	ldr	r3, [fp, #-68]
21f24544:	e5d33000 	ldrb	r3, [r3]
21f24548:	e3530000 	cmp	r3, #0	; 0x0
21f2454c:	0a000007 	beq	21f24570 <.text+0x24570>
				*str++ = *fmt;
21f24550:	e51b3044 	ldr	r3, [fp, #-68]
21f24554:	e5d33000 	ldrb	r3, [r3]
21f24558:	e51b202c 	ldr	r2, [fp, #-44]
21f2455c:	e5c23000 	strb	r3, [r2]
21f24560:	e51b302c 	ldr	r3, [fp, #-44]
21f24564:	e2833001 	add	r3, r3, #1	; 0x1
21f24568:	e50b302c 	str	r3, [fp, #-44]
21f2456c:	ea000044 	b	21f24684 <.text+0x24684>
			else
				--fmt;
21f24570:	e51b3044 	ldr	r3, [fp, #-68]
21f24574:	e2433001 	sub	r3, r3, #1	; 0x1
21f24578:	e50b3044 	str	r3, [fp, #-68]
21f2457c:	ea000040 	b	21f24684 <.text+0x24684>
			continue;
		}
#ifdef CFG_64BIT_VSPRINTF
		if (qualifier == 'q')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else
#endif
		if (qualifier == 'l')
21f24580:	e51b3018 	ldr	r3, [fp, #-24]
21f24584:	e353006c 	cmp	r3, #108	; 0x6c
21f24588:	1a000006 	bne	21f245a8 <.text+0x245a8>
			num = va_arg(args, unsigned long);
21f2458c:	e51b2048 	ldr	r2, [fp, #-72]
21f24590:	e2823004 	add	r3, r2, #4	; 0x4
21f24594:	e50b3048 	str	r3, [fp, #-72]
21f24598:	e1a03002 	mov	r3, r2
21f2459c:	e5933000 	ldr	r3, [r3]
21f245a0:	e50b3038 	str	r3, [fp, #-56]
21f245a4:	ea00002a 	b	21f24654 <.text+0x24654>
		else if (qualifier == 'h') {
21f245a8:	e51b3018 	ldr	r3, [fp, #-24]
21f245ac:	e3530068 	cmp	r3, #104	; 0x68
21f245b0:	1a000014 	bne	21f24608 <.text+0x24608>
			num = (unsigned short) va_arg(args, int);
21f245b4:	e51b2048 	ldr	r2, [fp, #-72]
21f245b8:	e2823004 	add	r3, r2, #4	; 0x4
21f245bc:	e50b3048 	str	r3, [fp, #-72]
21f245c0:	e1a03002 	mov	r3, r2
21f245c4:	e5933000 	ldr	r3, [r3]
21f245c8:	e1a03803 	mov	r3, r3, lsl #16
21f245cc:	e1a03823 	mov	r3, r3, lsr #16
21f245d0:	e50b3038 	str	r3, [fp, #-56]
			if (flags & SIGN)
21f245d4:	e51b3024 	ldr	r3, [fp, #-36]
21f245d8:	e1a030a3 	mov	r3, r3, lsr #1
21f245dc:	e2033001 	and	r3, r3, #1	; 0x1
21f245e0:	e20330ff 	and	r3, r3, #255	; 0xff
21f245e4:	e3530000 	cmp	r3, #0	; 0x0
21f245e8:	0a000019 	beq	21f24654 <.text+0x24654>
				num = (short) num;
21f245ec:	e51b3038 	ldr	r3, [fp, #-56]
21f245f0:	e1a03803 	mov	r3, r3, lsl #16
21f245f4:	e1a03823 	mov	r3, r3, lsr #16
21f245f8:	e1a03803 	mov	r3, r3, lsl #16
21f245fc:	e1a03843 	mov	r3, r3, asr #16
21f24600:	e50b3038 	str	r3, [fp, #-56]
21f24604:	ea000012 	b	21f24654 <.text+0x24654>
		} else if (flags & SIGN)
21f24608:	e51b3024 	ldr	r3, [fp, #-36]
21f2460c:	e1a030a3 	mov	r3, r3, lsr #1
21f24610:	e2033001 	and	r3, r3, #1	; 0x1
21f24614:	e20330ff 	and	r3, r3, #255	; 0xff
21f24618:	e3530000 	cmp	r3, #0	; 0x0
21f2461c:	0a000006 	beq	21f2463c <.text+0x2463c>
			num = va_arg(args, int);
21f24620:	e51b2048 	ldr	r2, [fp, #-72]
21f24624:	e2823004 	add	r3, r2, #4	; 0x4
21f24628:	e50b3048 	str	r3, [fp, #-72]
21f2462c:	e1a03002 	mov	r3, r2
21f24630:	e5933000 	ldr	r3, [r3]
21f24634:	e50b3038 	str	r3, [fp, #-56]
21f24638:	ea000005 	b	21f24654 <.text+0x24654>
		else
			num = va_arg(args, unsigned int);
21f2463c:	e51b2048 	ldr	r2, [fp, #-72]
21f24640:	e2823004 	add	r3, r2, #4	; 0x4
21f24644:	e50b3048 	str	r3, [fp, #-72]
21f24648:	e1a03002 	mov	r3, r2
21f2464c:	e5933000 	ldr	r3, [r3]
21f24650:	e50b3038 	str	r3, [fp, #-56]
		str = number(str, num, base, field_width, precision, flags);
21f24654:	e51b2038 	ldr	r2, [fp, #-56]
21f24658:	e51b301c 	ldr	r3, [fp, #-28]
21f2465c:	e58d3000 	str	r3, [sp]
21f24660:	e51b3024 	ldr	r3, [fp, #-36]
21f24664:	e58d3004 	str	r3, [sp, #4]
21f24668:	e51b002c 	ldr	r0, [fp, #-44]
21f2466c:	e1a01002 	mov	r1, r2
21f24670:	e51b2030 	ldr	r2, [fp, #-48]
21f24674:	e51b3020 	ldr	r3, [fp, #-32]
21f24678:	ebfffca2 	bl	21f23908 <number>
21f2467c:	e1a03000 	mov	r3, r0
21f24680:	e50b302c 	str	r3, [fp, #-44]
21f24684:	e51b3044 	ldr	r3, [fp, #-68]
21f24688:	e2833001 	add	r3, r3, #1	; 0x1
21f2468c:	e50b3044 	str	r3, [fp, #-68]
21f24690:	e51b3044 	ldr	r3, [fp, #-68]
21f24694:	e5d33000 	ldrb	r3, [r3]
21f24698:	e3530000 	cmp	r3, #0	; 0x0
21f2469c:	1afffde2 	bne	21f23e2c <vsprintf+0x28>
	}
	*str = '\0';
21f246a0:	e51b202c 	ldr	r2, [fp, #-44]
21f246a4:	e3a03000 	mov	r3, #0	; 0x0
21f246a8:	e5c23000 	strb	r3, [r2]
	return str-buf;
21f246ac:	e51b202c 	ldr	r2, [fp, #-44]
21f246b0:	e51b3040 	ldr	r3, [fp, #-64]
21f246b4:	e0633002 	rsb	r3, r3, r2
}
21f246b8:	e1a00003 	mov	r0, r3
21f246bc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f246c0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f246c4:	21f32ccc 	mvncss	r2, ip, asr #25

21f246c8 <sprintf>:

int sprintf(char * buf, const char *fmt, ...)
{
21f246c8:	e1a0c00d 	mov	ip, sp
21f246cc:	e92d000e 	stmdb	sp!, {r1, r2, r3}
21f246d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f246d4:	e24cb010 	sub	fp, ip, #16	; 0x10
21f246d8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f246dc:	e50b0018 	str	r0, [fp, #-24]
	va_list args;
	int i;

	va_start(args, fmt);
21f246e0:	e28b3008 	add	r3, fp, #8	; 0x8
21f246e4:	e50b3014 	str	r3, [fp, #-20]
	i=vsprintf(buf,fmt,args);
21f246e8:	e51b3014 	ldr	r3, [fp, #-20]
21f246ec:	e51b0018 	ldr	r0, [fp, #-24]
21f246f0:	e59b1004 	ldr	r1, [fp, #4]
21f246f4:	e1a02003 	mov	r2, r3
21f246f8:	ebfffdc1 	bl	21f23e04 <vsprintf>
21f246fc:	e1a03000 	mov	r3, r0
21f24700:	e50b3010 	str	r3, [fp, #-16]
	va_end(args);
	return i;
21f24704:	e51b3010 	ldr	r3, [fp, #-16]
}
21f24708:	e1a00003 	mov	r0, r3
21f2470c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f24710:	e89da800 	ldmia	sp, {fp, sp, pc}

21f24714 <panic>:

void panic(const char *fmt, ...)
{
21f24714:	e1a0c00d 	mov	ip, sp
21f24718:	e92d000f 	stmdb	sp!, {r0, r1, r2, r3}
21f2471c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f24720:	e24cb014 	sub	fp, ip, #20	; 0x14
21f24724:	e24dd004 	sub	sp, sp, #4	; 0x4
	va_list	args;
	va_start(args, fmt);
21f24728:	e28b3008 	add	r3, fp, #8	; 0x8
21f2472c:	e50b3010 	str	r3, [fp, #-16]
	vprintf(fmt, args);
21f24730:	e51b3010 	ldr	r3, [fp, #-16]
21f24734:	e59b0004 	ldr	r0, [fp, #4]
21f24738:	e1a01003 	mov	r1, r3
21f2473c:	ebffdce7 	bl	21f1bae0 <vprintf>
	putc('\n');
21f24740:	e3a0000a 	mov	r0, #10	; 0xa
21f24744:	ebffdca7 	bl	21f1b9e8 <putc>
	va_end(args);
#if defined (CONFIG_PANIC_HANG)
	hang();
#else
	udelay (100000);	/* allow messages to go out */
21f24748:	e3a00b61 	mov	r0, #99328	; 0x18400
21f2474c:	e2800e2a 	add	r0, r0, #672	; 0x2a0
21f24750:	ebff70d4 	bl	21f00aa8 <udelay>
	do_reset (NULL, 0, 0, NULL);
21f24754:	e3a00000 	mov	r0, #0	; 0x0
21f24758:	e3a01000 	mov	r1, #0	; 0x0
21f2475c:	e3a02000 	mov	r2, #0	; 0x0
21f24760:	e3a03000 	mov	r3, #0	; 0x0
21f24764:	eb00235f 	bl	21f2d4e8 <do_reset>
#endif
}
21f24768:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2476c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f24770 <inflateReset>:


int inflateReset(z)
z_stream *z;
{
21f24770:	e1a0c00d 	mov	ip, sp
21f24774:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f24778:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2477c:	e24dd014 	sub	sp, sp, #20	; 0x14
21f24780:	e50b0014 	str	r0, [fp, #-20]
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL)
21f24784:	e51b3014 	ldr	r3, [fp, #-20]
21f24788:	e3530000 	cmp	r3, #0	; 0x0
21f2478c:	0a000003 	beq	21f247a0 <inflateReset+0x30>
21f24790:	e51b3014 	ldr	r3, [fp, #-20]
21f24794:	e593301c 	ldr	r3, [r3, #28]
21f24798:	e3530000 	cmp	r3, #0	; 0x0
21f2479c:	1a000002 	bne	21f247ac <inflateReset+0x3c>
    return Z_STREAM_ERROR;
21f247a0:	e3e02001 	mvn	r2, #1	; 0x1
21f247a4:	e50b2020 	str	r2, [fp, #-32]
21f247a8:	ea000022 	b	21f24838 <inflateReset+0xc8>
  z->total_in = z->total_out = 0;
21f247ac:	e51b2014 	ldr	r2, [fp, #-20]
21f247b0:	e3a03000 	mov	r3, #0	; 0x0
21f247b4:	e5823014 	str	r3, [r2, #20]
21f247b8:	e51b3014 	ldr	r3, [fp, #-20]
21f247bc:	e5932014 	ldr	r2, [r3, #20]
21f247c0:	e51b3014 	ldr	r3, [fp, #-20]
21f247c4:	e5832008 	str	r2, [r3, #8]
  z->msg = Z_NULL;
21f247c8:	e51b2014 	ldr	r2, [fp, #-20]
21f247cc:	e3a03000 	mov	r3, #0	; 0x0
21f247d0:	e5823018 	str	r3, [r2, #24]
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
21f247d4:	e51b3014 	ldr	r3, [fp, #-20]
21f247d8:	e593301c 	ldr	r3, [r3, #28]
21f247dc:	e50b301c 	str	r3, [fp, #-28]
21f247e0:	e51b3014 	ldr	r3, [fp, #-20]
21f247e4:	e593301c 	ldr	r3, [r3, #28]
21f247e8:	e593300c 	ldr	r3, [r3, #12]
21f247ec:	e3530000 	cmp	r3, #0	; 0x0
21f247f0:	0a000002 	beq	21f24800 <inflateReset+0x90>
21f247f4:	e3a03002 	mov	r3, #2	; 0x2
21f247f8:	e50b3018 	str	r3, [fp, #-24]
21f247fc:	ea000001 	b	21f24808 <inflateReset+0x98>
21f24800:	e3a02000 	mov	r2, #0	; 0x0
21f24804:	e50b2018 	str	r2, [fp, #-24]
21f24808:	e51b2018 	ldr	r2, [fp, #-24]
21f2480c:	e51b301c 	ldr	r3, [fp, #-28]
21f24810:	e5832000 	str	r2, [r3]
  inflate_blocks_reset(z->state->blocks, z, &c);
21f24814:	e51b3014 	ldr	r3, [fp, #-20]
21f24818:	e593301c 	ldr	r3, [r3, #28]
21f2481c:	e5933014 	ldr	r3, [r3, #20]
21f24820:	e24b2010 	sub	r2, fp, #16	; 0x10
21f24824:	e1a00003 	mov	r0, r3
21f24828:	e51b1014 	ldr	r1, [fp, #-20]
21f2482c:	eb000307 	bl	21f25450 <inflate_blocks_reset>
  Trace((stderr, "inflate: reset\n"));
  return Z_OK;
21f24830:	e3a03000 	mov	r3, #0	; 0x0
21f24834:	e50b3020 	str	r3, [fp, #-32]
21f24838:	e51b3020 	ldr	r3, [fp, #-32]
}
21f2483c:	e1a00003 	mov	r0, r3
21f24840:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f24844:	e89da800 	ldmia	sp, {fp, sp, pc}

21f24848 <inflateEnd>:


int inflateEnd(z)
z_stream *z;
{
21f24848:	e1a0c00d 	mov	ip, sp
21f2484c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f24850:	e24cb004 	sub	fp, ip, #4	; 0x4
21f24854:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f24858:	e50b0014 	str	r0, [fp, #-20]
  uLong c;

  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
21f2485c:	e51b3014 	ldr	r3, [fp, #-20]
21f24860:	e3530000 	cmp	r3, #0	; 0x0
21f24864:	0a000007 	beq	21f24888 <inflateEnd+0x40>
21f24868:	e51b3014 	ldr	r3, [fp, #-20]
21f2486c:	e593301c 	ldr	r3, [r3, #28]
21f24870:	e3530000 	cmp	r3, #0	; 0x0
21f24874:	0a000003 	beq	21f24888 <inflateEnd+0x40>
21f24878:	e51b3014 	ldr	r3, [fp, #-20]
21f2487c:	e5933024 	ldr	r3, [r3, #36]
21f24880:	e3530000 	cmp	r3, #0	; 0x0
21f24884:	1a000002 	bne	21f24894 <inflateEnd+0x4c>
    return Z_STREAM_ERROR;
21f24888:	e3e03001 	mvn	r3, #1	; 0x1
21f2488c:	e50b3018 	str	r3, [fp, #-24]
21f24890:	ea00001b 	b	21f24904 <inflateEnd+0xbc>
  if (z->state->blocks != Z_NULL)
21f24894:	e51b3014 	ldr	r3, [fp, #-20]
21f24898:	e593301c 	ldr	r3, [r3, #28]
21f2489c:	e5933014 	ldr	r3, [r3, #20]
21f248a0:	e3530000 	cmp	r3, #0	; 0x0
21f248a4:	0a000006 	beq	21f248c4 <inflateEnd+0x7c>
    inflate_blocks_free(z->state->blocks, z, &c);
21f248a8:	e51b3014 	ldr	r3, [fp, #-20]
21f248ac:	e593301c 	ldr	r3, [r3, #28]
21f248b0:	e5933014 	ldr	r3, [r3, #20]
21f248b4:	e24b2010 	sub	r2, fp, #16	; 0x10
21f248b8:	e1a00003 	mov	r0, r3
21f248bc:	e51b1014 	ldr	r1, [fp, #-20]
21f248c0:	eb000a8b 	bl	21f272f4 <inflate_blocks_free>
  ZFREE(z, z->state, sizeof(struct internal_state));
21f248c4:	e51b3014 	ldr	r3, [fp, #-20]
21f248c8:	e593c024 	ldr	ip, [r3, #36]
21f248cc:	e51b3014 	ldr	r3, [fp, #-20]
21f248d0:	e5932028 	ldr	r2, [r3, #40]
21f248d4:	e51b3014 	ldr	r3, [fp, #-20]
21f248d8:	e593301c 	ldr	r3, [r3, #28]
21f248dc:	e1a00002 	mov	r0, r2
21f248e0:	e1a01003 	mov	r1, r3
21f248e4:	e3a02018 	mov	r2, #24	; 0x18
21f248e8:	e1a0e00f 	mov	lr, pc
21f248ec:	e1a0f00c 	mov	pc, ip
  z->state = Z_NULL;
21f248f0:	e51b2014 	ldr	r2, [fp, #-20]
21f248f4:	e3a03000 	mov	r3, #0	; 0x0
21f248f8:	e582301c 	str	r3, [r2, #28]
  Trace((stderr, "inflate: end\n"));
  return Z_OK;
21f248fc:	e3a03000 	mov	r3, #0	; 0x0
21f24900:	e50b3018 	str	r3, [fp, #-24]
21f24904:	e51b3018 	ldr	r3, [fp, #-24]
}
21f24908:	e1a00003 	mov	r0, r3
21f2490c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f24910:	e89da800 	ldmia	sp, {fp, sp, pc}

21f24914 <inflateInit2>:


int inflateInit2(z, w)
z_stream *z;
int w;
{
21f24914:	e1a0c00d 	mov	ip, sp
21f24918:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2491c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f24920:	e24dd014 	sub	sp, sp, #20	; 0x14
21f24924:	e50b0010 	str	r0, [fp, #-16]
21f24928:	e50b1014 	str	r1, [fp, #-20]
  /* initialize state */
  if (z == Z_NULL)
21f2492c:	e51b3010 	ldr	r3, [fp, #-16]
21f24930:	e3530000 	cmp	r3, #0	; 0x0
21f24934:	1a000002 	bne	21f24944 <inflateInit2+0x30>
    return Z_STREAM_ERROR;
21f24938:	e3e02001 	mvn	r2, #1	; 0x1
21f2493c:	e50b2020 	str	r2, [fp, #-32]
21f24940:	ea000058 	b	21f24aa8 <inflateInit2+0x194>
/*  if (z->zalloc == Z_NULL) z->zalloc = zcalloc; */
/*  if (z->zfree == Z_NULL) z->zfree = zcfree; */
  if ((z->state = (struct internal_state FAR *)
21f24944:	e51b3010 	ldr	r3, [fp, #-16]
21f24948:	e593c020 	ldr	ip, [r3, #32]
21f2494c:	e51b3010 	ldr	r3, [fp, #-16]
21f24950:	e5933028 	ldr	r3, [r3, #40]
21f24954:	e1a00003 	mov	r0, r3
21f24958:	e3a01001 	mov	r1, #1	; 0x1
21f2495c:	e3a02018 	mov	r2, #24	; 0x18
21f24960:	e1a0e00f 	mov	lr, pc
21f24964:	e1a0f00c 	mov	pc, ip
21f24968:	e1a03000 	mov	r3, r0
21f2496c:	e1a02003 	mov	r2, r3
21f24970:	e51b3010 	ldr	r3, [fp, #-16]
21f24974:	e583201c 	str	r2, [r3, #28]
21f24978:	e51b3010 	ldr	r3, [fp, #-16]
21f2497c:	e593301c 	ldr	r3, [r3, #28]
21f24980:	e3530000 	cmp	r3, #0	; 0x0
21f24984:	1a000002 	bne	21f24994 <inflateInit2+0x80>
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
21f24988:	e3e03003 	mvn	r3, #3	; 0x3
21f2498c:	e50b3020 	str	r3, [fp, #-32]
21f24990:	ea000044 	b	21f24aa8 <inflateInit2+0x194>
  z->state->blocks = Z_NULL;
21f24994:	e51b3010 	ldr	r3, [fp, #-16]
21f24998:	e593201c 	ldr	r2, [r3, #28]
21f2499c:	e3a03000 	mov	r3, #0	; 0x0
21f249a0:	e5823014 	str	r3, [r2, #20]

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
21f249a4:	e51b3010 	ldr	r3, [fp, #-16]
21f249a8:	e593201c 	ldr	r2, [r3, #28]
21f249ac:	e3a03000 	mov	r3, #0	; 0x0
21f249b0:	e582300c 	str	r3, [r2, #12]
  if (w < 0)
21f249b4:	e51b3014 	ldr	r3, [fp, #-20]
21f249b8:	e3530000 	cmp	r3, #0	; 0x0
21f249bc:	aa000006 	bge	21f249dc <inflateInit2+0xc8>
  {
    w = - w;
21f249c0:	e51b3014 	ldr	r3, [fp, #-20]
21f249c4:	e2633000 	rsb	r3, r3, #0	; 0x0
21f249c8:	e50b3014 	str	r3, [fp, #-20]
    z->state->nowrap = 1;
21f249cc:	e51b3010 	ldr	r3, [fp, #-16]
21f249d0:	e593201c 	ldr	r2, [r3, #28]
21f249d4:	e3a03001 	mov	r3, #1	; 0x1
21f249d8:	e582300c 	str	r3, [r2, #12]
  }

  /* set window size */
  if (w < 8 || w > 15)
21f249dc:	e51b3014 	ldr	r3, [fp, #-20]
21f249e0:	e3530007 	cmp	r3, #7	; 0x7
21f249e4:	da000002 	ble	21f249f4 <inflateInit2+0xe0>
21f249e8:	e51b3014 	ldr	r3, [fp, #-20]
21f249ec:	e353000f 	cmp	r3, #15	; 0xf
21f249f0:	da000004 	ble	21f24a08 <inflateInit2+0xf4>
  {
    inflateEnd(z);
21f249f4:	e51b0010 	ldr	r0, [fp, #-16]
21f249f8:	ebffff92 	bl	21f24848 <inflateEnd>
    return Z_STREAM_ERROR;
21f249fc:	e3e02001 	mvn	r2, #1	; 0x1
21f24a00:	e50b2020 	str	r2, [fp, #-32]
21f24a04:	ea000027 	b	21f24aa8 <inflateInit2+0x194>
  }
  z->state->wbits = (uInt)w;
21f24a08:	e51b3010 	ldr	r3, [fp, #-16]
21f24a0c:	e593201c 	ldr	r2, [r3, #28]
21f24a10:	e51b3014 	ldr	r3, [fp, #-20]
21f24a14:	e5823010 	str	r3, [r2, #16]

  /* create inflate_blocks state */
  if ((z->state->blocks =
21f24a18:	e51b3010 	ldr	r3, [fp, #-16]
21f24a1c:	e593301c 	ldr	r3, [r3, #28]
21f24a20:	e50b301c 	str	r3, [fp, #-28]
21f24a24:	e51b3010 	ldr	r3, [fp, #-16]
21f24a28:	e593301c 	ldr	r3, [r3, #28]
21f24a2c:	e593300c 	ldr	r3, [r3, #12]
21f24a30:	e3530000 	cmp	r3, #0	; 0x0
21f24a34:	1a000002 	bne	21f24a44 <inflateInit2+0x130>
21f24a38:	e59f3078 	ldr	r3, [pc, #120]	; 21f24ab8 <.text+0x24ab8>
21f24a3c:	e50b3018 	str	r3, [fp, #-24]
21f24a40:	ea000001 	b	21f24a4c <inflateInit2+0x138>
21f24a44:	e3a02000 	mov	r2, #0	; 0x0
21f24a48:	e50b2018 	str	r2, [fp, #-24]
21f24a4c:	e3a02001 	mov	r2, #1	; 0x1
21f24a50:	e51b3014 	ldr	r3, [fp, #-20]
21f24a54:	e1a03312 	mov	r3, r2, lsl r3
21f24a58:	e51b0010 	ldr	r0, [fp, #-16]
21f24a5c:	e51b1018 	ldr	r1, [fp, #-24]
21f24a60:	e1a02003 	mov	r2, r3
21f24a64:	eb0002db 	bl	21f255d8 <inflate_blocks_new>
21f24a68:	e1a03000 	mov	r3, r0
21f24a6c:	e51b201c 	ldr	r2, [fp, #-28]
21f24a70:	e5823014 	str	r3, [r2, #20]
21f24a74:	e51b201c 	ldr	r2, [fp, #-28]
21f24a78:	e5923014 	ldr	r3, [r2, #20]
21f24a7c:	e3530000 	cmp	r3, #0	; 0x0
21f24a80:	1a000004 	bne	21f24a98 <inflateInit2+0x184>
       inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, 1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
21f24a84:	e51b0010 	ldr	r0, [fp, #-16]
21f24a88:	ebffff6e 	bl	21f24848 <inflateEnd>
    return Z_MEM_ERROR;
21f24a8c:	e3e03003 	mvn	r3, #3	; 0x3
21f24a90:	e50b3020 	str	r3, [fp, #-32]
21f24a94:	ea000003 	b	21f24aa8 <inflateInit2+0x194>
  }
  Trace((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
21f24a98:	e51b0010 	ldr	r0, [fp, #-16]
21f24a9c:	ebffff33 	bl	21f24770 <inflateReset>
  return Z_OK;
21f24aa0:	e3a02000 	mov	r2, #0	; 0x0
21f24aa4:	e50b2020 	str	r2, [fp, #-32]
21f24aa8:	e51b3020 	ldr	r3, [fp, #-32]
}
21f24aac:	e1a00003 	mov	r0, r3
21f24ab0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f24ab4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f24ab8:	21f2a9c0 	mvncss	sl, r0, asr #19

21f24abc <inflateInit>:


int inflateInit(z)
z_stream *z;
{
21f24abc:	e1a0c00d 	mov	ip, sp
21f24ac0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f24ac4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f24ac8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f24acc:	e50b0010 	str	r0, [fp, #-16]
  return inflateInit2(z, DEF_WBITS);
21f24ad0:	e51b0010 	ldr	r0, [fp, #-16]
21f24ad4:	e3a0100f 	mov	r1, #15	; 0xf
21f24ad8:	ebffff8d 	bl	21f24914 <inflateInit2>
21f24adc:	e1a03000 	mov	r3, r0
}
21f24ae0:	e1a00003 	mov	r0, r3
21f24ae4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f24ae8 <inflate>:


#define NEEDBYTE {if(z->avail_in==0)goto empty;r=Z_OK;}
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int inflate(z, f)
z_stream *z;
int f;
{
21f24ae8:	e1a0c00d 	mov	ip, sp
21f24aec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f24af0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f24af4:	e24dd018 	sub	sp, sp, #24	; 0x18
21f24af8:	e50b0018 	str	r0, [fp, #-24]
21f24afc:	e50b101c 	str	r1, [fp, #-28]
  int r;
  uInt b;

  if (z == Z_NULL || z->next_in == Z_NULL)
21f24b00:	e51b3018 	ldr	r3, [fp, #-24]
21f24b04:	e3530000 	cmp	r3, #0	; 0x0
21f24b08:	0a000003 	beq	21f24b1c <inflate+0x34>
21f24b0c:	e51b3018 	ldr	r3, [fp, #-24]
21f24b10:	e5933000 	ldr	r3, [r3]
21f24b14:	e3530000 	cmp	r3, #0	; 0x0
21f24b18:	1a000002 	bne	21f24b28 <inflate+0x40>
    return Z_STREAM_ERROR;
21f24b1c:	e3e00001 	mvn	r0, #1	; 0x1
21f24b20:	e50b0024 	str	r0, [fp, #-36]
21f24b24:	ea0001a0 	b	21f251ac <.text+0x251ac>
  r = Z_BUF_ERROR;
21f24b28:	e3e03004 	mvn	r3, #4	; 0x4
21f24b2c:	e50b3014 	str	r3, [fp, #-20]
21f24b30:	eaffffff 	b	21f24b34 <inflate+0x4c>
  while (1) switch (z->state->mode)
21f24b34:	e51b3018 	ldr	r3, [fp, #-24]
21f24b38:	e593301c 	ldr	r3, [r3, #28]
21f24b3c:	e5933000 	ldr	r3, [r3]
21f24b40:	e3530008 	cmp	r3, #8	; 0x8
21f24b44:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f24b48:	ea000184 	b	21f25160 <.text+0x25160>
21f24b4c:	21f24b70 	mvncss	r4, r0, ror fp
21f24b50:	21f24c8c 	mvncss	r4, ip, lsl #25
21f24b54:	21f24dd0 	ldrcssb	r4, [r2, #208]!
21f24b58:	21f24eec 	mvncss	r4, ip, ror #29
21f24b5c:	21f24f64 	mvncss	r4, r4, ror #30
21f24b60:	21f24fec 	mvncss	r4, ip, ror #31
21f24b64:	21f25074 	mvncss	r5, r4, ror r0
21f24b68:	21f25148 	mvncss	r5, r8, asr #2
21f24b6c:	21f25154 	mvncss	r5, r4, asr r1
  {
    case METHOD:
      NEEDBYTE
21f24b70:	e51b3018 	ldr	r3, [fp, #-24]
21f24b74:	e5933004 	ldr	r3, [r3, #4]
21f24b78:	e3530000 	cmp	r3, #0	; 0x0
21f24b7c:	0a00017a 	beq	21f2516c <.text+0x2516c>
21f24b80:	e3a03000 	mov	r3, #0	; 0x0
21f24b84:	e50b3014 	str	r3, [fp, #-20]
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != DEFLATED)
21f24b88:	e51b3018 	ldr	r3, [fp, #-24]
21f24b8c:	e5933004 	ldr	r3, [r3, #4]
21f24b90:	e2432001 	sub	r2, r3, #1	; 0x1
21f24b94:	e51b3018 	ldr	r3, [fp, #-24]
21f24b98:	e5832004 	str	r2, [r3, #4]
21f24b9c:	e51b3018 	ldr	r3, [fp, #-24]
21f24ba0:	e5933008 	ldr	r3, [r3, #8]
21f24ba4:	e2832001 	add	r2, r3, #1	; 0x1
21f24ba8:	e51b3018 	ldr	r3, [fp, #-24]
21f24bac:	e5832008 	str	r2, [r3, #8]
21f24bb0:	e51b3018 	ldr	r3, [fp, #-24]
21f24bb4:	e593201c 	ldr	r2, [r3, #28]
21f24bb8:	e51b3018 	ldr	r3, [fp, #-24]
21f24bbc:	e5930000 	ldr	r0, [r3]
21f24bc0:	e5d03000 	ldrb	r3, [r0]
21f24bc4:	e5823004 	str	r3, [r2, #4]
21f24bc8:	e5923004 	ldr	r3, [r2, #4]
21f24bcc:	e203300f 	and	r3, r3, #15	; 0xf
21f24bd0:	e3530008 	cmp	r3, #8	; 0x8
21f24bd4:	03a03000 	moveq	r3, #0	; 0x0
21f24bd8:	13a03001 	movne	r3, #1	; 0x1
21f24bdc:	e20310ff 	and	r1, r3, #255	; 0xff
21f24be0:	e2802001 	add	r2, r0, #1	; 0x1
21f24be4:	e51b3018 	ldr	r3, [fp, #-24]
21f24be8:	e5832000 	str	r2, [r3]
21f24bec:	e3510000 	cmp	r1, #0	; 0x0
21f24bf0:	0a00000b 	beq	21f24c24 <.text+0x24c24>
      {
	z->state->mode = BAD;
21f24bf4:	e51b3018 	ldr	r3, [fp, #-24]
21f24bf8:	e593201c 	ldr	r2, [r3, #28]
21f24bfc:	e3a03008 	mov	r3, #8	; 0x8
21f24c00:	e5823000 	str	r3, [r2]
	z->msg = "unknown compression method";
21f24c04:	e51b2018 	ldr	r2, [fp, #-24]
21f24c08:	e59f35ac 	ldr	r3, [pc, #1452]	; 21f251bc <.text+0x251bc>
21f24c0c:	e5823018 	str	r3, [r2, #24]
	z->state->sub.marker = 5;       /* can't try inflateSync */
21f24c10:	e51b3018 	ldr	r3, [fp, #-24]
21f24c14:	e593201c 	ldr	r2, [r3, #28]
21f24c18:	e3a03005 	mov	r3, #5	; 0x5
21f24c1c:	e5823004 	str	r3, [r2, #4]
	break;
21f24c20:	eaffffc3 	b	21f24b34 <inflate+0x4c>
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
21f24c24:	e51b3018 	ldr	r3, [fp, #-24]
21f24c28:	e593301c 	ldr	r3, [r3, #28]
21f24c2c:	e5933004 	ldr	r3, [r3, #4]
21f24c30:	e1a03223 	mov	r3, r3, lsr #4
21f24c34:	e2832008 	add	r2, r3, #8	; 0x8
21f24c38:	e51b3018 	ldr	r3, [fp, #-24]
21f24c3c:	e593301c 	ldr	r3, [r3, #28]
21f24c40:	e5933010 	ldr	r3, [r3, #16]
21f24c44:	e1520003 	cmp	r2, r3
21f24c48:	9a00000b 	bls	21f24c7c <.text+0x24c7c>
      {
	z->state->mode = BAD;
21f24c4c:	e51b3018 	ldr	r3, [fp, #-24]
21f24c50:	e593201c 	ldr	r2, [r3, #28]
21f24c54:	e3a03008 	mov	r3, #8	; 0x8
21f24c58:	e5823000 	str	r3, [r2]
	z->msg = "invalid window size";
21f24c5c:	e51b2018 	ldr	r2, [fp, #-24]
21f24c60:	e59f3558 	ldr	r3, [pc, #1368]	; 21f251c0 <.text+0x251c0>
21f24c64:	e5823018 	str	r3, [r2, #24]
	z->state->sub.marker = 5;       /* can't try inflateSync */
21f24c68:	e51b3018 	ldr	r3, [fp, #-24]
21f24c6c:	e593201c 	ldr	r2, [r3, #28]
21f24c70:	e3a03005 	mov	r3, #5	; 0x5
21f24c74:	e5823004 	str	r3, [r2, #4]
	break;
21f24c78:	eaffffad 	b	21f24b34 <inflate+0x4c>
      }
      z->state->mode = FLAG;
21f24c7c:	e51b3018 	ldr	r3, [fp, #-24]
21f24c80:	e593201c 	ldr	r2, [r3, #28]
21f24c84:	e3a03001 	mov	r3, #1	; 0x1
21f24c88:	e5823000 	str	r3, [r2]
    case FLAG:
      NEEDBYTE
21f24c8c:	e51b3018 	ldr	r3, [fp, #-24]
21f24c90:	e5933004 	ldr	r3, [r3, #4]
21f24c94:	e3530000 	cmp	r3, #0	; 0x0
21f24c98:	0a000133 	beq	21f2516c <.text+0x2516c>
21f24c9c:	e3a03000 	mov	r3, #0	; 0x0
21f24ca0:	e50b3014 	str	r3, [fp, #-20]
      if ((b = NEXTBYTE) & 0x20)
21f24ca4:	e51b3018 	ldr	r3, [fp, #-24]
21f24ca8:	e5933004 	ldr	r3, [r3, #4]
21f24cac:	e2432001 	sub	r2, r3, #1	; 0x1
21f24cb0:	e51b3018 	ldr	r3, [fp, #-24]
21f24cb4:	e5832004 	str	r2, [r3, #4]
21f24cb8:	e51b3018 	ldr	r3, [fp, #-24]
21f24cbc:	e5933008 	ldr	r3, [r3, #8]
21f24cc0:	e2832001 	add	r2, r3, #1	; 0x1
21f24cc4:	e51b3018 	ldr	r3, [fp, #-24]
21f24cc8:	e5832008 	str	r2, [r3, #8]
21f24ccc:	e51b3018 	ldr	r3, [fp, #-24]
21f24cd0:	e5932000 	ldr	r2, [r3]
21f24cd4:	e5d23000 	ldrb	r3, [r2]
21f24cd8:	e50b3010 	str	r3, [fp, #-16]
21f24cdc:	e51b3010 	ldr	r3, [fp, #-16]
21f24ce0:	e1a032a3 	mov	r3, r3, lsr #5
21f24ce4:	e2033001 	and	r3, r3, #1	; 0x1
21f24ce8:	e20310ff 	and	r1, r3, #255	; 0xff
21f24cec:	e2822001 	add	r2, r2, #1	; 0x1
21f24cf0:	e51b3018 	ldr	r3, [fp, #-24]
21f24cf4:	e5832000 	str	r2, [r3]
21f24cf8:	e3510000 	cmp	r1, #0	; 0x0
21f24cfc:	0a00000b 	beq	21f24d30 <.text+0x24d30>
      {
	z->state->mode = BAD;
21f24d00:	e51b3018 	ldr	r3, [fp, #-24]
21f24d04:	e593201c 	ldr	r2, [r3, #28]
21f24d08:	e3a03008 	mov	r3, #8	; 0x8
21f24d0c:	e5823000 	str	r3, [r2]
	z->msg = "invalid reserved bit";
21f24d10:	e51b2018 	ldr	r2, [fp, #-24]
21f24d14:	e59f34a8 	ldr	r3, [pc, #1192]	; 21f251c4 <.text+0x251c4>
21f24d18:	e5823018 	str	r3, [r2, #24]
	z->state->sub.marker = 5;       /* can't try inflateSync */
21f24d1c:	e51b3018 	ldr	r3, [fp, #-24]
21f24d20:	e593201c 	ldr	r2, [r3, #28]
21f24d24:	e3a03005 	mov	r3, #5	; 0x5
21f24d28:	e5823004 	str	r3, [r2, #4]
	break;
21f24d2c:	eaffff80 	b	21f24b34 <inflate+0x4c>
      }
      if (((z->state->sub.method << 8) + b) % 31)
21f24d30:	e51b3018 	ldr	r3, [fp, #-24]
21f24d34:	e593301c 	ldr	r3, [r3, #28]
21f24d38:	e5933004 	ldr	r3, [r3, #4]
21f24d3c:	e1a02403 	mov	r2, r3, lsl #8
21f24d40:	e51b3010 	ldr	r3, [fp, #-16]
21f24d44:	e0821003 	add	r1, r2, r3
21f24d48:	e3a03521 	mov	r3, #138412032	; 0x8400000
21f24d4c:	e2833a21 	add	r3, r3, #135168	; 0x21000
21f24d50:	e2833085 	add	r3, r3, #133	; 0x85
21f24d54:	e0820193 	umull	r0, r2, r3, r1
21f24d58:	e0623001 	rsb	r3, r2, r1
21f24d5c:	e1a030a3 	mov	r3, r3, lsr #1
21f24d60:	e0823003 	add	r3, r2, r3
21f24d64:	e1a03223 	mov	r3, r3, lsr #4
21f24d68:	e50b3020 	str	r3, [fp, #-32]
21f24d6c:	e51b3020 	ldr	r3, [fp, #-32]
21f24d70:	e1a03283 	mov	r3, r3, lsl #5
21f24d74:	e51b2020 	ldr	r2, [fp, #-32]
21f24d78:	e0623003 	rsb	r3, r2, r3
21f24d7c:	e0631001 	rsb	r1, r3, r1
21f24d80:	e50b1020 	str	r1, [fp, #-32]
21f24d84:	e51b3020 	ldr	r3, [fp, #-32]
21f24d88:	e3530000 	cmp	r3, #0	; 0x0
21f24d8c:	0a00000b 	beq	21f24dc0 <.text+0x24dc0>
      {
	z->state->mode = BAD;
21f24d90:	e51b3018 	ldr	r3, [fp, #-24]
21f24d94:	e593201c 	ldr	r2, [r3, #28]
21f24d98:	e3a03008 	mov	r3, #8	; 0x8
21f24d9c:	e5823000 	str	r3, [r2]
	z->msg = "incorrect header check";
21f24da0:	e51b2018 	ldr	r2, [fp, #-24]
21f24da4:	e59f341c 	ldr	r3, [pc, #1052]	; 21f251c8 <.text+0x251c8>
21f24da8:	e5823018 	str	r3, [r2, #24]
	z->state->sub.marker = 5;       /* can't try inflateSync */
21f24dac:	e51b3018 	ldr	r3, [fp, #-24]
21f24db0:	e593201c 	ldr	r2, [r3, #28]
21f24db4:	e3a03005 	mov	r3, #5	; 0x5
21f24db8:	e5823004 	str	r3, [r2, #4]
	break;
21f24dbc:	eaffff5c 	b	21f24b34 <inflate+0x4c>
      }
      Trace((stderr, "inflate: zlib header ok\n"));
      z->state->mode = BLOCKS;
21f24dc0:	e51b3018 	ldr	r3, [fp, #-24]
21f24dc4:	e593201c 	ldr	r2, [r3, #28]
21f24dc8:	e3a03002 	mov	r3, #2	; 0x2
21f24dcc:	e5823000 	str	r3, [r2]
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
21f24dd0:	e51b3018 	ldr	r3, [fp, #-24]
21f24dd4:	e593301c 	ldr	r3, [r3, #28]
21f24dd8:	e5933014 	ldr	r3, [r3, #20]
21f24ddc:	e1a00003 	mov	r0, r3
21f24de0:	e51b1018 	ldr	r1, [fp, #-24]
21f24de4:	e51b2014 	ldr	r2, [fp, #-20]
21f24de8:	eb000247 	bl	21f2570c <inflate_blocks>
21f24dec:	e1a03000 	mov	r3, r0
21f24df0:	e50b3014 	str	r3, [fp, #-20]
      if (f == Z_PACKET_FLUSH && z->avail_in == 0 && z->avail_out != 0)
21f24df4:	e51b301c 	ldr	r3, [fp, #-28]
21f24df8:	e3530005 	cmp	r3, #5	; 0x5
21f24dfc:	1a00000e 	bne	21f24e3c <.text+0x24e3c>
21f24e00:	e51b3018 	ldr	r3, [fp, #-24]
21f24e04:	e5933004 	ldr	r3, [r3, #4]
21f24e08:	e3530000 	cmp	r3, #0	; 0x0
21f24e0c:	1a00000a 	bne	21f24e3c <.text+0x24e3c>
21f24e10:	e51b3018 	ldr	r3, [fp, #-24]
21f24e14:	e5933010 	ldr	r3, [r3, #16]
21f24e18:	e3530000 	cmp	r3, #0	; 0x0
21f24e1c:	0a000006 	beq	21f24e3c <.text+0x24e3c>
	  r = inflate_packet_flush(z->state->blocks);
21f24e20:	e51b3018 	ldr	r3, [fp, #-24]
21f24e24:	e593301c 	ldr	r3, [r3, #28]
21f24e28:	e5933014 	ldr	r3, [r3, #20]
21f24e2c:	e1a00003 	mov	r0, r3
21f24e30:	eb000a0d 	bl	21f2766c <inflate_packet_flush>
21f24e34:	e1a03000 	mov	r3, r0
21f24e38:	e50b3014 	str	r3, [fp, #-20]
      if (r == Z_DATA_ERROR)
21f24e3c:	e51b3014 	ldr	r3, [fp, #-20]
21f24e40:	e3730003 	cmn	r3, #3	; 0x3
21f24e44:	1a000008 	bne	21f24e6c <.text+0x24e6c>
      {
	z->state->mode = BAD;
21f24e48:	e51b3018 	ldr	r3, [fp, #-24]
21f24e4c:	e593201c 	ldr	r2, [r3, #28]
21f24e50:	e3a03008 	mov	r3, #8	; 0x8
21f24e54:	e5823000 	str	r3, [r2]
	z->state->sub.marker = 0;       /* can try inflateSync */
21f24e58:	e51b3018 	ldr	r3, [fp, #-24]
21f24e5c:	e593201c 	ldr	r2, [r3, #28]
21f24e60:	e3a03000 	mov	r3, #0	; 0x0
21f24e64:	e5823004 	str	r3, [r2, #4]
	break;
21f24e68:	eaffff31 	b	21f24b34 <inflate+0x4c>
      }
      if (r != Z_STREAM_END)
21f24e6c:	e51b3014 	ldr	r3, [fp, #-20]
21f24e70:	e3530001 	cmp	r3, #1	; 0x1
21f24e74:	0a000002 	beq	21f24e84 <.text+0x24e84>
	return r;
21f24e78:	e51b0014 	ldr	r0, [fp, #-20]
21f24e7c:	e50b0024 	str	r0, [fp, #-36]
21f24e80:	ea0000c9 	b	21f251ac <.text+0x251ac>
      r = Z_OK;
21f24e84:	e3a03000 	mov	r3, #0	; 0x0
21f24e88:	e50b3014 	str	r3, [fp, #-20]
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
21f24e8c:	e51b3018 	ldr	r3, [fp, #-24]
21f24e90:	e593301c 	ldr	r3, [r3, #28]
21f24e94:	e5932014 	ldr	r2, [r3, #20]
21f24e98:	e51b3018 	ldr	r3, [fp, #-24]
21f24e9c:	e593301c 	ldr	r3, [r3, #28]
21f24ea0:	e2833004 	add	r3, r3, #4	; 0x4
21f24ea4:	e1a00002 	mov	r0, r2
21f24ea8:	e51b1018 	ldr	r1, [fp, #-24]
21f24eac:	e1a02003 	mov	r2, r3
21f24eb0:	eb000166 	bl	21f25450 <inflate_blocks_reset>
      if (z->state->nowrap)
21f24eb4:	e51b3018 	ldr	r3, [fp, #-24]
21f24eb8:	e593301c 	ldr	r3, [r3, #28]
21f24ebc:	e593300c 	ldr	r3, [r3, #12]
21f24ec0:	e3530000 	cmp	r3, #0	; 0x0
21f24ec4:	0a000004 	beq	21f24edc <.text+0x24edc>
      {
	z->state->mode = DONE;
21f24ec8:	e51b3018 	ldr	r3, [fp, #-24]
21f24ecc:	e593201c 	ldr	r2, [r3, #28]
21f24ed0:	e3a03007 	mov	r3, #7	; 0x7
21f24ed4:	e5823000 	str	r3, [r2]
	break;
21f24ed8:	eaffff15 	b	21f24b34 <inflate+0x4c>
      }
      z->state->mode = CHECK4;
21f24edc:	e51b3018 	ldr	r3, [fp, #-24]
21f24ee0:	e593201c 	ldr	r2, [r3, #28]
21f24ee4:	e3a03003 	mov	r3, #3	; 0x3
21f24ee8:	e5823000 	str	r3, [r2]
    case CHECK4:
      NEEDBYTE
21f24eec:	e51b3018 	ldr	r3, [fp, #-24]
21f24ef0:	e5933004 	ldr	r3, [r3, #4]
21f24ef4:	e3530000 	cmp	r3, #0	; 0x0
21f24ef8:	0a00009b 	beq	21f2516c <.text+0x2516c>
21f24efc:	e3a03000 	mov	r3, #0	; 0x0
21f24f00:	e50b3014 	str	r3, [fp, #-20]
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
21f24f04:	e51b3018 	ldr	r3, [fp, #-24]
21f24f08:	e5933004 	ldr	r3, [r3, #4]
21f24f0c:	e2432001 	sub	r2, r3, #1	; 0x1
21f24f10:	e51b3018 	ldr	r3, [fp, #-24]
21f24f14:	e5832004 	str	r2, [r3, #4]
21f24f18:	e51b3018 	ldr	r3, [fp, #-24]
21f24f1c:	e5933008 	ldr	r3, [r3, #8]
21f24f20:	e2832001 	add	r2, r3, #1	; 0x1
21f24f24:	e51b3018 	ldr	r3, [fp, #-24]
21f24f28:	e5832008 	str	r2, [r3, #8]
21f24f2c:	e51b3018 	ldr	r3, [fp, #-24]
21f24f30:	e593101c 	ldr	r1, [r3, #28]
21f24f34:	e51b3018 	ldr	r3, [fp, #-24]
21f24f38:	e5932000 	ldr	r2, [r3]
21f24f3c:	e5d23000 	ldrb	r3, [r2]
21f24f40:	e1a03c03 	mov	r3, r3, lsl #24
21f24f44:	e5813008 	str	r3, [r1, #8]
21f24f48:	e2822001 	add	r2, r2, #1	; 0x1
21f24f4c:	e51b3018 	ldr	r3, [fp, #-24]
21f24f50:	e5832000 	str	r2, [r3]
      z->state->mode = CHECK3;
21f24f54:	e51b3018 	ldr	r3, [fp, #-24]
21f24f58:	e593201c 	ldr	r2, [r3, #28]
21f24f5c:	e3a03004 	mov	r3, #4	; 0x4
21f24f60:	e5823000 	str	r3, [r2]
    case CHECK3:
      NEEDBYTE
21f24f64:	e51b3018 	ldr	r3, [fp, #-24]
21f24f68:	e5933004 	ldr	r3, [r3, #4]
21f24f6c:	e3530000 	cmp	r3, #0	; 0x0
21f24f70:	0a00007d 	beq	21f2516c <.text+0x2516c>
21f24f74:	e3a03000 	mov	r3, #0	; 0x0
21f24f78:	e50b3014 	str	r3, [fp, #-20]
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
21f24f7c:	e51b3018 	ldr	r3, [fp, #-24]
21f24f80:	e5933004 	ldr	r3, [r3, #4]
21f24f84:	e2432001 	sub	r2, r3, #1	; 0x1
21f24f88:	e51b3018 	ldr	r3, [fp, #-24]
21f24f8c:	e5832004 	str	r2, [r3, #4]
21f24f90:	e51b3018 	ldr	r3, [fp, #-24]
21f24f94:	e5933008 	ldr	r3, [r3, #8]
21f24f98:	e2832001 	add	r2, r3, #1	; 0x1
21f24f9c:	e51b3018 	ldr	r3, [fp, #-24]
21f24fa0:	e5832008 	str	r2, [r3, #8]
21f24fa4:	e51b3018 	ldr	r3, [fp, #-24]
21f24fa8:	e593101c 	ldr	r1, [r3, #28]
21f24fac:	e51b3018 	ldr	r3, [fp, #-24]
21f24fb0:	e593301c 	ldr	r3, [r3, #28]
21f24fb4:	e5930008 	ldr	r0, [r3, #8]
21f24fb8:	e51b3018 	ldr	r3, [fp, #-24]
21f24fbc:	e5932000 	ldr	r2, [r3]
21f24fc0:	e5d23000 	ldrb	r3, [r2]
21f24fc4:	e1a03803 	mov	r3, r3, lsl #16
21f24fc8:	e0803003 	add	r3, r0, r3
21f24fcc:	e5813008 	str	r3, [r1, #8]
21f24fd0:	e2822001 	add	r2, r2, #1	; 0x1
21f24fd4:	e51b3018 	ldr	r3, [fp, #-24]
21f24fd8:	e5832000 	str	r2, [r3]
      z->state->mode = CHECK2;
21f24fdc:	e51b3018 	ldr	r3, [fp, #-24]
21f24fe0:	e593201c 	ldr	r2, [r3, #28]
21f24fe4:	e3a03005 	mov	r3, #5	; 0x5
21f24fe8:	e5823000 	str	r3, [r2]
    case CHECK2:
      NEEDBYTE
21f24fec:	e51b3018 	ldr	r3, [fp, #-24]
21f24ff0:	e5933004 	ldr	r3, [r3, #4]
21f24ff4:	e3530000 	cmp	r3, #0	; 0x0
21f24ff8:	0a00005b 	beq	21f2516c <.text+0x2516c>
21f24ffc:	e3a03000 	mov	r3, #0	; 0x0
21f25000:	e50b3014 	str	r3, [fp, #-20]
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
21f25004:	e51b3018 	ldr	r3, [fp, #-24]
21f25008:	e5933004 	ldr	r3, [r3, #4]
21f2500c:	e2432001 	sub	r2, r3, #1	; 0x1
21f25010:	e51b3018 	ldr	r3, [fp, #-24]
21f25014:	e5832004 	str	r2, [r3, #4]
21f25018:	e51b3018 	ldr	r3, [fp, #-24]
21f2501c:	e5933008 	ldr	r3, [r3, #8]
21f25020:	e2832001 	add	r2, r3, #1	; 0x1
21f25024:	e51b3018 	ldr	r3, [fp, #-24]
21f25028:	e5832008 	str	r2, [r3, #8]
21f2502c:	e51b3018 	ldr	r3, [fp, #-24]
21f25030:	e593101c 	ldr	r1, [r3, #28]
21f25034:	e51b3018 	ldr	r3, [fp, #-24]
21f25038:	e593301c 	ldr	r3, [r3, #28]
21f2503c:	e5930008 	ldr	r0, [r3, #8]
21f25040:	e51b3018 	ldr	r3, [fp, #-24]
21f25044:	e5932000 	ldr	r2, [r3]
21f25048:	e5d23000 	ldrb	r3, [r2]
21f2504c:	e1a03403 	mov	r3, r3, lsl #8
21f25050:	e0803003 	add	r3, r0, r3
21f25054:	e5813008 	str	r3, [r1, #8]
21f25058:	e2822001 	add	r2, r2, #1	; 0x1
21f2505c:	e51b3018 	ldr	r3, [fp, #-24]
21f25060:	e5832000 	str	r2, [r3]
      z->state->mode = CHECK1;
21f25064:	e51b3018 	ldr	r3, [fp, #-24]
21f25068:	e593201c 	ldr	r2, [r3, #28]
21f2506c:	e3a03006 	mov	r3, #6	; 0x6
21f25070:	e5823000 	str	r3, [r2]
    case CHECK1:
      NEEDBYTE
21f25074:	e51b3018 	ldr	r3, [fp, #-24]
21f25078:	e5933004 	ldr	r3, [r3, #4]
21f2507c:	e3530000 	cmp	r3, #0	; 0x0
21f25080:	0a000039 	beq	21f2516c <.text+0x2516c>
21f25084:	e3a03000 	mov	r3, #0	; 0x0
21f25088:	e50b3014 	str	r3, [fp, #-20]
      z->state->sub.check.need += (uLong)NEXTBYTE;
21f2508c:	e51b3018 	ldr	r3, [fp, #-24]
21f25090:	e5933004 	ldr	r3, [r3, #4]
21f25094:	e2432001 	sub	r2, r3, #1	; 0x1
21f25098:	e51b3018 	ldr	r3, [fp, #-24]
21f2509c:	e5832004 	str	r2, [r3, #4]
21f250a0:	e51b3018 	ldr	r3, [fp, #-24]
21f250a4:	e5933008 	ldr	r3, [r3, #8]
21f250a8:	e2832001 	add	r2, r3, #1	; 0x1
21f250ac:	e51b3018 	ldr	r3, [fp, #-24]
21f250b0:	e5832008 	str	r2, [r3, #8]
21f250b4:	e51b3018 	ldr	r3, [fp, #-24]
21f250b8:	e593001c 	ldr	r0, [r3, #28]
21f250bc:	e51b3018 	ldr	r3, [fp, #-24]
21f250c0:	e593301c 	ldr	r3, [r3, #28]
21f250c4:	e5931008 	ldr	r1, [r3, #8]
21f250c8:	e51b3018 	ldr	r3, [fp, #-24]
21f250cc:	e5932000 	ldr	r2, [r3]
21f250d0:	e5d23000 	ldrb	r3, [r2]
21f250d4:	e0813003 	add	r3, r1, r3
21f250d8:	e5803008 	str	r3, [r0, #8]
21f250dc:	e2822001 	add	r2, r2, #1	; 0x1
21f250e0:	e51b3018 	ldr	r3, [fp, #-24]
21f250e4:	e5832000 	str	r2, [r3]

      if (z->state->sub.check.was != z->state->sub.check.need)
21f250e8:	e51b3018 	ldr	r3, [fp, #-24]
21f250ec:	e593301c 	ldr	r3, [r3, #28]
21f250f0:	e5932004 	ldr	r2, [r3, #4]
21f250f4:	e51b3018 	ldr	r3, [fp, #-24]
21f250f8:	e593301c 	ldr	r3, [r3, #28]
21f250fc:	e5933008 	ldr	r3, [r3, #8]
21f25100:	e1520003 	cmp	r2, r3
21f25104:	0a00000b 	beq	21f25138 <.text+0x25138>
      {
	z->state->mode = BAD;
21f25108:	e51b3018 	ldr	r3, [fp, #-24]
21f2510c:	e593201c 	ldr	r2, [r3, #28]
21f25110:	e3a03008 	mov	r3, #8	; 0x8
21f25114:	e5823000 	str	r3, [r2]
	z->msg = "incorrect data check";
21f25118:	e51b2018 	ldr	r2, [fp, #-24]
21f2511c:	e59f30a8 	ldr	r3, [pc, #168]	; 21f251cc <.text+0x251cc>
21f25120:	e5823018 	str	r3, [r2, #24]
	z->state->sub.marker = 5;       /* can't try inflateSync */
21f25124:	e51b3018 	ldr	r3, [fp, #-24]
21f25128:	e593201c 	ldr	r2, [r3, #28]
21f2512c:	e3a03005 	mov	r3, #5	; 0x5
21f25130:	e5823004 	str	r3, [r2, #4]
	break;
21f25134:	eafffe7e 	b	21f24b34 <inflate+0x4c>
      }
      Trace((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
21f25138:	e51b3018 	ldr	r3, [fp, #-24]
21f2513c:	e593201c 	ldr	r2, [r3, #28]
21f25140:	e3a03007 	mov	r3, #7	; 0x7
21f25144:	e5823000 	str	r3, [r2]
    case DONE:
      return Z_STREAM_END;
21f25148:	e3a02001 	mov	r2, #1	; 0x1
21f2514c:	e50b2024 	str	r2, [fp, #-36]
21f25150:	ea000015 	b	21f251ac <.text+0x251ac>
    case BAD:
      return Z_DATA_ERROR;
21f25154:	e3e03002 	mvn	r3, #2	; 0x2
21f25158:	e50b3024 	str	r3, [fp, #-36]
21f2515c:	ea000012 	b	21f251ac <.text+0x251ac>
    default:
      return Z_STREAM_ERROR;
21f25160:	e3e00001 	mvn	r0, #1	; 0x1
21f25164:	e50b0024 	str	r0, [fp, #-36]
21f25168:	ea00000f 	b	21f251ac <.text+0x251ac>
  }

 empty:
  if (f != Z_PACKET_FLUSH)
21f2516c:	e51b301c 	ldr	r3, [fp, #-28]
21f25170:	e3530005 	cmp	r3, #5	; 0x5
21f25174:	0a000002 	beq	21f25184 <.text+0x25184>
    return r;
21f25178:	e51b2014 	ldr	r2, [fp, #-20]
21f2517c:	e50b2024 	str	r2, [fp, #-36]
21f25180:	ea000009 	b	21f251ac <.text+0x251ac>
  z->state->mode = BAD;
21f25184:	e51b3018 	ldr	r3, [fp, #-24]
21f25188:	e593201c 	ldr	r2, [r3, #28]
21f2518c:	e3a03008 	mov	r3, #8	; 0x8
21f25190:	e5823000 	str	r3, [r2]
  z->state->sub.marker = 0;       /* can try inflateSync */
21f25194:	e51b3018 	ldr	r3, [fp, #-24]
21f25198:	e593201c 	ldr	r2, [r3, #28]
21f2519c:	e3a03000 	mov	r3, #0	; 0x0
21f251a0:	e5823004 	str	r3, [r2, #4]
  return Z_DATA_ERROR;
21f251a4:	e3e03002 	mvn	r3, #2	; 0x2
21f251a8:	e50b3024 	str	r3, [fp, #-36]
21f251ac:	e51b3024 	ldr	r3, [fp, #-36]
}
21f251b0:	e1a00003 	mov	r0, r3
21f251b4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f251b8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f251bc:	21f32cd4 	ldrcssb	r2, [r3, #196]!
21f251c0:	21f32cf0 	ldrcssh	r2, [r3, #192]!
21f251c4:	21f32d04 	mvncss	r2, r4, lsl #26
21f251c8:	21f32d1c 	mvncss	r2, ip, lsl sp
21f251cc:	21f32d34 	mvncss	r2, r4, lsr sp

21f251d0 <inflateIncomp>:

/*
 * This subroutine adds the data at next_in/avail_in to the output history
 * without performing any output.  The output buffer must be "caught up";
 * i.e. no pending output (hence s->read equals s->write), and the state must
 * be BLOCKS (i.e. we should be willing to see the start of a series of
 * BLOCKS).  On exit, the output will also be caught up, and the checksum
 * will have been updated if need be.
 */

int inflateIncomp(z)
z_stream *z;
{
21f251d0:	e1a0c00d 	mov	ip, sp
21f251d4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f251d8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f251dc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f251e0:	e50b0010 	str	r0, [fp, #-16]
    if (z->state->mode != BLOCKS)
21f251e4:	e51b3010 	ldr	r3, [fp, #-16]
21f251e8:	e593301c 	ldr	r3, [r3, #28]
21f251ec:	e5933000 	ldr	r3, [r3]
21f251f0:	e3530002 	cmp	r3, #2	; 0x2
21f251f4:	0a000002 	beq	21f25204 <inflateIncomp+0x34>
	return Z_DATA_ERROR;
21f251f8:	e3e03002 	mvn	r3, #2	; 0x2
21f251fc:	e50b3014 	str	r3, [fp, #-20]
21f25200:	ea000007 	b	21f25224 <inflateIncomp+0x54>
    return inflate_addhistory(z->state->blocks, z);
21f25204:	e51b3010 	ldr	r3, [fp, #-16]
21f25208:	e593301c 	ldr	r3, [r3, #28]
21f2520c:	e5933014 	ldr	r3, [r3, #20]
21f25210:	e1a00003 	mov	r0, r3
21f25214:	e51b1010 	ldr	r1, [fp, #-16]
21f25218:	eb00085c 	bl	21f27390 <inflate_addhistory>
21f2521c:	e1a03000 	mov	r3, r0
21f25220:	e50b3014 	str	r3, [fp, #-20]
21f25224:	e51b3014 	ldr	r3, [fp, #-20]
}
21f25228:	e1a00003 	mov	r0, r3
21f2522c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f25230:	e89da800 	ldmia	sp, {fp, sp, pc}

21f25234 <inflateSync>:


int inflateSync(z)
z_stream *z;
{
21f25234:	e1a0c00d 	mov	ip, sp
21f25238:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2523c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f25240:	e24dd024 	sub	sp, sp, #36	; 0x24
21f25244:	e50b0024 	str	r0, [fp, #-36]
  uInt n;       /* number of bytes to look at */
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
21f25248:	e51b3024 	ldr	r3, [fp, #-36]
21f2524c:	e3530000 	cmp	r3, #0	; 0x0
21f25250:	0a000003 	beq	21f25264 <inflateSync+0x30>
21f25254:	e51b3024 	ldr	r3, [fp, #-36]
21f25258:	e593301c 	ldr	r3, [r3, #28]
21f2525c:	e3530000 	cmp	r3, #0	; 0x0
21f25260:	1a000002 	bne	21f25270 <inflateSync+0x3c>
    return Z_STREAM_ERROR;
21f25264:	e3e02001 	mvn	r2, #1	; 0x1
21f25268:	e50b2030 	str	r2, [fp, #-48]
21f2526c:	ea000073 	b	21f25440 <inflateSync+0x20c>
  if (z->state->mode != BAD)
21f25270:	e51b3024 	ldr	r3, [fp, #-36]
21f25274:	e593301c 	ldr	r3, [r3, #28]
21f25278:	e5933000 	ldr	r3, [r3]
21f2527c:	e3530008 	cmp	r3, #8	; 0x8
21f25280:	0a000007 	beq	21f252a4 <inflateSync+0x70>
  {
    z->state->mode = BAD;
21f25284:	e51b3024 	ldr	r3, [fp, #-36]
21f25288:	e593201c 	ldr	r2, [r3, #28]
21f2528c:	e3a03008 	mov	r3, #8	; 0x8
21f25290:	e5823000 	str	r3, [r2]
    z->state->sub.marker = 0;
21f25294:	e51b3024 	ldr	r3, [fp, #-36]
21f25298:	e593201c 	ldr	r2, [r3, #28]
21f2529c:	e3a03000 	mov	r3, #0	; 0x0
21f252a0:	e5823004 	str	r3, [r2, #4]
  }
  if ((n = z->avail_in) == 0)
21f252a4:	e51b3024 	ldr	r3, [fp, #-36]
21f252a8:	e5933004 	ldr	r3, [r3, #4]
21f252ac:	e50b3020 	str	r3, [fp, #-32]
21f252b0:	e51b3020 	ldr	r3, [fp, #-32]
21f252b4:	e3530000 	cmp	r3, #0	; 0x0
21f252b8:	1a000002 	bne	21f252c8 <inflateSync+0x94>
    return Z_BUF_ERROR;
21f252bc:	e3e03004 	mvn	r3, #4	; 0x4
21f252c0:	e50b3030 	str	r3, [fp, #-48]
21f252c4:	ea00005d 	b	21f25440 <inflateSync+0x20c>
  p = z->next_in;
21f252c8:	e51b3024 	ldr	r3, [fp, #-36]
21f252cc:	e5933000 	ldr	r3, [r3]
21f252d0:	e50b301c 	str	r3, [fp, #-28]
  m = z->state->sub.marker;
21f252d4:	e51b3024 	ldr	r3, [fp, #-36]
21f252d8:	e593301c 	ldr	r3, [r3, #28]
21f252dc:	e5933004 	ldr	r3, [r3, #4]
21f252e0:	e50b3018 	str	r3, [fp, #-24]

  /* search */
  while (n && m < 4)
21f252e4:	ea000022 	b	21f25374 <inflateSync+0x140>
  {
    if (*p == (Byte)(m < 2 ? 0 : 0xff))
21f252e8:	e51b301c 	ldr	r3, [fp, #-28]
21f252ec:	e5d33000 	ldrb	r3, [r3]
21f252f0:	e50b302c 	str	r3, [fp, #-44]
21f252f4:	e51b3018 	ldr	r3, [fp, #-24]
21f252f8:	e3530001 	cmp	r3, #1	; 0x1
21f252fc:	8a000002 	bhi	21f2530c <inflateSync+0xd8>
21f25300:	e3a02000 	mov	r2, #0	; 0x0
21f25304:	e50b2028 	str	r2, [fp, #-40]
21f25308:	ea000001 	b	21f25314 <inflateSync+0xe0>
21f2530c:	e3a030ff 	mov	r3, #255	; 0xff
21f25310:	e50b3028 	str	r3, [fp, #-40]
21f25314:	e51b202c 	ldr	r2, [fp, #-44]
21f25318:	e51b3028 	ldr	r3, [fp, #-40]
21f2531c:	e1520003 	cmp	r2, r3
21f25320:	1a000003 	bne	21f25334 <inflateSync+0x100>
      m++;
21f25324:	e51b3018 	ldr	r3, [fp, #-24]
21f25328:	e2833001 	add	r3, r3, #1	; 0x1
21f2532c:	e50b3018 	str	r3, [fp, #-24]
21f25330:	ea000009 	b	21f2535c <inflateSync+0x128>
    else if (*p)
21f25334:	e51b301c 	ldr	r3, [fp, #-28]
21f25338:	e5d33000 	ldrb	r3, [r3]
21f2533c:	e3530000 	cmp	r3, #0	; 0x0
21f25340:	0a000002 	beq	21f25350 <inflateSync+0x11c>
      m = 0;
21f25344:	e3a03000 	mov	r3, #0	; 0x0
21f25348:	e50b3018 	str	r3, [fp, #-24]
21f2534c:	ea000002 	b	21f2535c <inflateSync+0x128>
    else
      m = 4 - m;
21f25350:	e51b3018 	ldr	r3, [fp, #-24]
21f25354:	e2633004 	rsb	r3, r3, #4	; 0x4
21f25358:	e50b3018 	str	r3, [fp, #-24]
    p++, n--;
21f2535c:	e51b301c 	ldr	r3, [fp, #-28]
21f25360:	e2833001 	add	r3, r3, #1	; 0x1
21f25364:	e50b301c 	str	r3, [fp, #-28]
21f25368:	e51b3020 	ldr	r3, [fp, #-32]
21f2536c:	e2433001 	sub	r3, r3, #1	; 0x1
21f25370:	e50b3020 	str	r3, [fp, #-32]
21f25374:	e51b3020 	ldr	r3, [fp, #-32]
21f25378:	e3530000 	cmp	r3, #0	; 0x0
21f2537c:	0a000002 	beq	21f2538c <inflateSync+0x158>
21f25380:	e51b3018 	ldr	r3, [fp, #-24]
21f25384:	e3530003 	cmp	r3, #3	; 0x3
21f25388:	9affffd6 	bls	21f252e8 <inflateSync+0xb4>
  }

  /* restore */
  z->total_in += p - z->next_in;
21f2538c:	e51b3024 	ldr	r3, [fp, #-36]
21f25390:	e5931008 	ldr	r1, [r3, #8]
21f25394:	e51b201c 	ldr	r2, [fp, #-28]
21f25398:	e51b3024 	ldr	r3, [fp, #-36]
21f2539c:	e5933000 	ldr	r3, [r3]
21f253a0:	e0633002 	rsb	r3, r3, r2
21f253a4:	e0812003 	add	r2, r1, r3
21f253a8:	e51b3024 	ldr	r3, [fp, #-36]
21f253ac:	e5832008 	str	r2, [r3, #8]
  z->next_in = p;
21f253b0:	e51b2024 	ldr	r2, [fp, #-36]
21f253b4:	e51b301c 	ldr	r3, [fp, #-28]
21f253b8:	e5823000 	str	r3, [r2]
  z->avail_in = n;
21f253bc:	e51b2024 	ldr	r2, [fp, #-36]
21f253c0:	e51b3020 	ldr	r3, [fp, #-32]
21f253c4:	e5823004 	str	r3, [r2, #4]
  z->state->sub.marker = m;
21f253c8:	e51b3024 	ldr	r3, [fp, #-36]
21f253cc:	e593201c 	ldr	r2, [r3, #28]
21f253d0:	e51b3018 	ldr	r3, [fp, #-24]
21f253d4:	e5823004 	str	r3, [r2, #4]

  /* return no joy or set up to restart on a new block */
  if (m != 4)
21f253d8:	e51b3018 	ldr	r3, [fp, #-24]
21f253dc:	e3530004 	cmp	r3, #4	; 0x4
21f253e0:	0a000002 	beq	21f253f0 <inflateSync+0x1bc>
    return Z_DATA_ERROR;
21f253e4:	e3e02002 	mvn	r2, #2	; 0x2
21f253e8:	e50b2030 	str	r2, [fp, #-48]
21f253ec:	ea000013 	b	21f25440 <inflateSync+0x20c>
  r = z->total_in;  w = z->total_out;
21f253f0:	e51b3024 	ldr	r3, [fp, #-36]
21f253f4:	e5933008 	ldr	r3, [r3, #8]
21f253f8:	e50b3014 	str	r3, [fp, #-20]
21f253fc:	e51b3024 	ldr	r3, [fp, #-36]
21f25400:	e5933014 	ldr	r3, [r3, #20]
21f25404:	e50b3010 	str	r3, [fp, #-16]
  inflateReset(z);
21f25408:	e51b0024 	ldr	r0, [fp, #-36]
21f2540c:	ebfffcd7 	bl	21f24770 <inflateReset>
  z->total_in = r;  z->total_out = w;
21f25410:	e51b2024 	ldr	r2, [fp, #-36]
21f25414:	e51b3014 	ldr	r3, [fp, #-20]
21f25418:	e5823008 	str	r3, [r2, #8]
21f2541c:	e51b2024 	ldr	r2, [fp, #-36]
21f25420:	e51b3010 	ldr	r3, [fp, #-16]
21f25424:	e5823014 	str	r3, [r2, #20]
  z->state->mode = BLOCKS;
21f25428:	e51b3024 	ldr	r3, [fp, #-36]
21f2542c:	e593201c 	ldr	r2, [r3, #28]
21f25430:	e3a03002 	mov	r3, #2	; 0x2
21f25434:	e5823000 	str	r3, [r2]
  return Z_OK;
21f25438:	e3a03000 	mov	r3, #0	; 0x0
21f2543c:	e50b3030 	str	r3, [fp, #-48]
21f25440:	e51b3030 	ldr	r3, [fp, #-48]
}
21f25444:	e1a00003 	mov	r0, r3
21f25448:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2544c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f25450 <inflate_blocks_reset>:

#undef NEEDBYTE
#undef NEXTBYTE

/*+++++*/
/* infutil.h -- types and macros common to blocks and codes
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* inflate blocks semi-private state */
struct inflate_blocks_state {

  /* mode */
  enum {
      TYPE,     /* get type bits (3, including end bit) */
      LENS,     /* get lengths for stored */
      STORED,   /* processing stored block */
      TABLE,    /* get table lengths */
      BTREE,    /* get bit lengths tree for a dynamic block */
      DTREE,    /* get length, distance trees for a dynamic block */
      CODES,    /* processing fixed or dynamic block */
      DRY,      /* output remaining window bytes */
      DONEB,     /* finished last block, done */
      BADB}      /* got a data error--stuck here */
    mode;               /* current inflate_block mode */

  /* mode dependent information */
  union {
    uInt left;          /* if STORED, bytes left to copy */
    struct {
      uInt table;               /* table lengths (14 bits) */
      uInt index;               /* index into blens (or border) */
      uIntf *blens;             /* bit lengths of codes */
      uInt bb;                  /* bit length tree depth */
      inflate_huft *tb;         /* bit length decoding tree */
      int nblens;		/* # elements allocated at blens */
    } trees;            /* if DTREE, decoding info for trees */
    struct {
      inflate_huft *tl, *td;    /* trees to free */
      inflate_codes_statef
	 *codes;
    } decode;           /* if CODES, current state */
  } sub;                /* submode */
  uInt last;            /* true if this block is the last block */

  /* mode independent information */
  uInt bitk;            /* bits in bit buffer */
  uLong bitb;           /* bit buffer */
  Bytef *window;        /* sliding window */
  Bytef *end;           /* one byte after sliding window */
  Bytef *read;          /* window read pointer */
  Bytef *write;         /* window write pointer */
  check_func checkfn;   /* check function */
  uLong check;          /* check on output */

};


/* defines for inflate input/output */
/*   update pointers and return */
#define UPDBITS {s->bitb=b;s->bitk=k;}
#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
#define UPDOUT {s->write=q;}
#define UPDATE {UPDBITS UPDIN UPDOUT}
#define LEAVE {UPDATE return inflate_flush(s,z,r);}
/*   get bytes and bits */
#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
#define NEXTBYTE (n--,*p++)
#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define DUMPBITS(j) {b>>=(j);k-=(j);}
/*   output bytes */
#define WAVAIL (q<s->read?s->read-q-1:s->end-q)
#define LOADOUT {q=s->write;m=WAVAIL;}
#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=WAVAIL;}}
#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
/*   load local pointers */
#define LOAD {LOADIN LOADOUT}

/*
 * The IBM 150 firmware munges the data right after _etext[].  This
 * protects it. -- Cort
 */
#if 0
local uInt protect_mask[] = {0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0 ,0};
#endif
/* And'ing with mask[n] masks the lower n bits */
local uInt inflate_mask[] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};

/* copy as much as possible from the sliding window to the output area */
local int inflate_flush OF((
    inflate_blocks_statef *,
    z_stream *,
    int));

/*+++++*/
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

local int inflate_fast OF((
    uInt,
    uInt,
    inflate_huft *,
    inflate_huft *,
    inflate_blocks_statef *,
    z_stream *));


/*+++++*/
/* infblock.c -- interpret and process block types to last block
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* Table for deflate from PKZIP's appnote.txt. */
local uInt border[] = { /* Order of the bit length code lengths */
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarily, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */


local void inflate_blocks_reset(s, z, c)
inflate_blocks_statef *s;
z_stream *z;
uLongf *c;
{
21f25450:	e1a0c00d 	mov	ip, sp
21f25454:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f25458:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2545c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f25460:	e50b0010 	str	r0, [fp, #-16]
21f25464:	e50b1014 	str	r1, [fp, #-20]
21f25468:	e50b2018 	str	r2, [fp, #-24]
  if (s->checkfn != Z_NULL)
21f2546c:	e51b3010 	ldr	r3, [fp, #-16]
21f25470:	e5933038 	ldr	r3, [r3, #56]
21f25474:	e3530000 	cmp	r3, #0	; 0x0
21f25478:	0a000003 	beq	21f2548c <inflate_blocks_reset+0x3c>
    *c = s->check;
21f2547c:	e51b3010 	ldr	r3, [fp, #-16]
21f25480:	e593203c 	ldr	r2, [r3, #60]
21f25484:	e51b3018 	ldr	r3, [fp, #-24]
21f25488:	e5832000 	str	r2, [r3]
  if (s->mode == BTREE || s->mode == DTREE)
21f2548c:	e51b3010 	ldr	r3, [fp, #-16]
21f25490:	e5933000 	ldr	r3, [r3]
21f25494:	e3530004 	cmp	r3, #4	; 0x4
21f25498:	0a000003 	beq	21f254ac <inflate_blocks_reset+0x5c>
21f2549c:	e51b3010 	ldr	r3, [fp, #-16]
21f254a0:	e5933000 	ldr	r3, [r3]
21f254a4:	e3530005 	cmp	r3, #5	; 0x5
21f254a8:	1a00000c 	bne	21f254e0 <inflate_blocks_reset+0x90>
    ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
21f254ac:	e51b3014 	ldr	r3, [fp, #-20]
21f254b0:	e593c024 	ldr	ip, [r3, #36]
21f254b4:	e51b3014 	ldr	r3, [fp, #-20]
21f254b8:	e5932028 	ldr	r2, [r3, #40]
21f254bc:	e51b3010 	ldr	r3, [fp, #-16]
21f254c0:	e593100c 	ldr	r1, [r3, #12]
21f254c4:	e51b3010 	ldr	r3, [fp, #-16]
21f254c8:	e5933018 	ldr	r3, [r3, #24]
21f254cc:	e1a03103 	mov	r3, r3, lsl #2
21f254d0:	e1a00002 	mov	r0, r2
21f254d4:	e1a02003 	mov	r2, r3
21f254d8:	e1a0e00f 	mov	lr, pc
21f254dc:	e1a0f00c 	mov	pc, ip
  if (s->mode == CODES)
21f254e0:	e51b3010 	ldr	r3, [fp, #-16]
21f254e4:	e5933000 	ldr	r3, [r3]
21f254e8:	e3530006 	cmp	r3, #6	; 0x6
21f254ec:	1a00000e 	bne	21f2552c <inflate_blocks_reset+0xdc>
  {
    inflate_codes_free(s->sub.decode.codes, z);
21f254f0:	e51b3010 	ldr	r3, [fp, #-16]
21f254f4:	e593300c 	ldr	r3, [r3, #12]
21f254f8:	e1a00003 	mov	r0, r3
21f254fc:	e51b1014 	ldr	r1, [fp, #-20]
21f25500:	eb001203 	bl	21f29d14 <inflate_codes_free>
    inflate_trees_free(s->sub.decode.td, z);
21f25504:	e51b3010 	ldr	r3, [fp, #-16]
21f25508:	e5933008 	ldr	r3, [r3, #8]
21f2550c:	e1a00003 	mov	r0, r3
21f25510:	e51b1014 	ldr	r1, [fp, #-20]
21f25514:	eb000cda 	bl	21f28884 <inflate_trees_free>
    inflate_trees_free(s->sub.decode.tl, z);
21f25518:	e51b3010 	ldr	r3, [fp, #-16]
21f2551c:	e5933004 	ldr	r3, [r3, #4]
21f25520:	e1a00003 	mov	r0, r3
21f25524:	e51b1014 	ldr	r1, [fp, #-20]
21f25528:	eb000cd5 	bl	21f28884 <inflate_trees_free>
  }
  s->mode = TYPE;
21f2552c:	e51b2010 	ldr	r2, [fp, #-16]
21f25530:	e3a03000 	mov	r3, #0	; 0x0
21f25534:	e5823000 	str	r3, [r2]
  s->bitk = 0;
21f25538:	e51b2010 	ldr	r2, [fp, #-16]
21f2553c:	e3a03000 	mov	r3, #0	; 0x0
21f25540:	e5823020 	str	r3, [r2, #32]
  s->bitb = 0;
21f25544:	e51b2010 	ldr	r2, [fp, #-16]
21f25548:	e3a03000 	mov	r3, #0	; 0x0
21f2554c:	e5823024 	str	r3, [r2, #36]
  s->read = s->write = s->window;
21f25550:	e51b3010 	ldr	r3, [fp, #-16]
21f25554:	e5932028 	ldr	r2, [r3, #40]
21f25558:	e51b3010 	ldr	r3, [fp, #-16]
21f2555c:	e5832034 	str	r2, [r3, #52]
21f25560:	e51b3010 	ldr	r3, [fp, #-16]
21f25564:	e5932034 	ldr	r2, [r3, #52]
21f25568:	e51b3010 	ldr	r3, [fp, #-16]
21f2556c:	e5832030 	str	r2, [r3, #48]
  if (s->checkfn != Z_NULL)
21f25570:	e51b3010 	ldr	r3, [fp, #-16]
21f25574:	e5933038 	ldr	r3, [r3, #56]
21f25578:	e3530000 	cmp	r3, #0	; 0x0
21f2557c:	0a000009 	beq	21f255a8 <inflate_blocks_reset+0x158>
    s->check = (*s->checkfn)(0L, Z_NULL, 0);
21f25580:	e51b3010 	ldr	r3, [fp, #-16]
21f25584:	e5933038 	ldr	r3, [r3, #56]
21f25588:	e3a00000 	mov	r0, #0	; 0x0
21f2558c:	e3a01000 	mov	r1, #0	; 0x0
21f25590:	e3a02000 	mov	r2, #0	; 0x0
21f25594:	e1a0e00f 	mov	lr, pc
21f25598:	e1a0f003 	mov	pc, r3
21f2559c:	e1a02000 	mov	r2, r0
21f255a0:	e51b3010 	ldr	r3, [fp, #-16]
21f255a4:	e583203c 	str	r2, [r3, #60]
  if (z->outcb != Z_NULL)
21f255a8:	e51b3014 	ldr	r3, [fp, #-20]
21f255ac:	e5933030 	ldr	r3, [r3, #48]
21f255b0:	e3530000 	cmp	r3, #0	; 0x0
21f255b4:	0a000005 	beq	21f255d0 <inflate_blocks_reset+0x180>
    (*z->outcb)(Z_NULL, 0);
21f255b8:	e51b3014 	ldr	r3, [fp, #-20]
21f255bc:	e5933030 	ldr	r3, [r3, #48]
21f255c0:	e3a00000 	mov	r0, #0	; 0x0
21f255c4:	e3a01000 	mov	r1, #0	; 0x0
21f255c8:	e1a0e00f 	mov	lr, pc
21f255cc:	e1a0f003 	mov	pc, r3
  Trace((stderr, "inflate:   blocks reset\n"));
}
21f255d0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f255d4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f255d8 <inflate_blocks_new>:


local inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_stream *z;
check_func c;
uInt w;
{
21f255d8:	e1a0c00d 	mov	ip, sp
21f255dc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f255e0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f255e4:	e24dd014 	sub	sp, sp, #20	; 0x14
21f255e8:	e50b0014 	str	r0, [fp, #-20]
21f255ec:	e50b1018 	str	r1, [fp, #-24]
21f255f0:	e50b201c 	str	r2, [fp, #-28]
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
21f255f4:	e51b3014 	ldr	r3, [fp, #-20]
21f255f8:	e593c020 	ldr	ip, [r3, #32]
21f255fc:	e51b3014 	ldr	r3, [fp, #-20]
21f25600:	e5933028 	ldr	r3, [r3, #40]
21f25604:	e1a00003 	mov	r0, r3
21f25608:	e3a01001 	mov	r1, #1	; 0x1
21f2560c:	e3a02040 	mov	r2, #64	; 0x40
21f25610:	e1a0e00f 	mov	lr, pc
21f25614:	e1a0f00c 	mov	pc, ip
21f25618:	e1a03000 	mov	r3, r0
21f2561c:	e50b3010 	str	r3, [fp, #-16]
21f25620:	e51b3010 	ldr	r3, [fp, #-16]
21f25624:	e3530000 	cmp	r3, #0	; 0x0
21f25628:	1a000002 	bne	21f25638 <inflate_blocks_new+0x60>
       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
    return s;
21f2562c:	e51b3010 	ldr	r3, [fp, #-16]
21f25630:	e50b3020 	str	r3, [fp, #-32]
21f25634:	ea000030 	b	21f256fc <inflate_blocks_new+0x124>
  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
21f25638:	e51b3014 	ldr	r3, [fp, #-20]
21f2563c:	e593c020 	ldr	ip, [r3, #32]
21f25640:	e51b3014 	ldr	r3, [fp, #-20]
21f25644:	e5933028 	ldr	r3, [r3, #40]
21f25648:	e1a00003 	mov	r0, r3
21f2564c:	e3a01001 	mov	r1, #1	; 0x1
21f25650:	e51b201c 	ldr	r2, [fp, #-28]
21f25654:	e1a0e00f 	mov	lr, pc
21f25658:	e1a0f00c 	mov	pc, ip
21f2565c:	e1a03000 	mov	r3, r0
21f25660:	e1a02003 	mov	r2, r3
21f25664:	e51b3010 	ldr	r3, [fp, #-16]
21f25668:	e5832028 	str	r2, [r3, #40]
21f2566c:	e51b3010 	ldr	r3, [fp, #-16]
21f25670:	e5933028 	ldr	r3, [r3, #40]
21f25674:	e3530000 	cmp	r3, #0	; 0x0
21f25678:	1a00000b 	bne	21f256ac <inflate_blocks_new+0xd4>
  {
    ZFREE(z, s, sizeof(struct inflate_blocks_state));
21f2567c:	e51b3014 	ldr	r3, [fp, #-20]
21f25680:	e593c024 	ldr	ip, [r3, #36]
21f25684:	e51b3014 	ldr	r3, [fp, #-20]
21f25688:	e5933028 	ldr	r3, [r3, #40]
21f2568c:	e1a00003 	mov	r0, r3
21f25690:	e51b1010 	ldr	r1, [fp, #-16]
21f25694:	e3a02040 	mov	r2, #64	; 0x40
21f25698:	e1a0e00f 	mov	lr, pc
21f2569c:	e1a0f00c 	mov	pc, ip
    return Z_NULL;
21f256a0:	e3a03000 	mov	r3, #0	; 0x0
21f256a4:	e50b3020 	str	r3, [fp, #-32]
21f256a8:	ea000013 	b	21f256fc <inflate_blocks_new+0x124>
  }
  s->end = s->window + w;
21f256ac:	e51b3010 	ldr	r3, [fp, #-16]
21f256b0:	e5932028 	ldr	r2, [r3, #40]
21f256b4:	e51b301c 	ldr	r3, [fp, #-28]
21f256b8:	e0822003 	add	r2, r2, r3
21f256bc:	e51b3010 	ldr	r3, [fp, #-16]
21f256c0:	e583202c 	str	r2, [r3, #44]
  s->checkfn = c;
21f256c4:	e51b2010 	ldr	r2, [fp, #-16]
21f256c8:	e51b3018 	ldr	r3, [fp, #-24]
21f256cc:	e5823038 	str	r3, [r2, #56]
  s->mode = TYPE;
21f256d0:	e51b2010 	ldr	r2, [fp, #-16]
21f256d4:	e3a03000 	mov	r3, #0	; 0x0
21f256d8:	e5823000 	str	r3, [r2]
  Trace((stderr, "inflate:   blocks allocated\n"));
  inflate_blocks_reset(s, z, &s->check);
21f256dc:	e51b3010 	ldr	r3, [fp, #-16]
21f256e0:	e283303c 	add	r3, r3, #60	; 0x3c
21f256e4:	e51b0010 	ldr	r0, [fp, #-16]
21f256e8:	e51b1014 	ldr	r1, [fp, #-20]
21f256ec:	e1a02003 	mov	r2, r3
21f256f0:	ebffff56 	bl	21f25450 <inflate_blocks_reset>
  return s;
21f256f4:	e51b3010 	ldr	r3, [fp, #-16]
21f256f8:	e50b3020 	str	r3, [fp, #-32]
21f256fc:	e51b3020 	ldr	r3, [fp, #-32]
}
21f25700:	e1a00003 	mov	r0, r3
21f25704:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f25708:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2570c <inflate_blocks>:


local int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
21f2570c:	e1a0c00d 	mov	ip, sp
21f25710:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f25714:	e24cb004 	sub	fp, ip, #4	; 0x4
21f25718:	e24dd09c 	sub	sp, sp, #156	; 0x9c
21f2571c:	e50b0060 	str	r0, [fp, #-96]
21f25720:	e50b1064 	str	r1, [fp, #-100]
21f25724:	e50b2068 	str	r2, [fp, #-104]
  uInt t;               /* temporary storage */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
21f25728:	e51b3064 	ldr	r3, [fp, #-100]
21f2572c:	e5933000 	ldr	r3, [r3]
21f25730:	e50b3030 	str	r3, [fp, #-48]
21f25734:	e51b3064 	ldr	r3, [fp, #-100]
21f25738:	e5933004 	ldr	r3, [r3, #4]
21f2573c:	e50b302c 	str	r3, [fp, #-44]
21f25740:	e51b3060 	ldr	r3, [fp, #-96]
21f25744:	e5933024 	ldr	r3, [r3, #36]
21f25748:	e50b3038 	str	r3, [fp, #-56]
21f2574c:	e51b3060 	ldr	r3, [fp, #-96]
21f25750:	e5933020 	ldr	r3, [r3, #32]
21f25754:	e50b3034 	str	r3, [fp, #-52]
21f25758:	e51b3060 	ldr	r3, [fp, #-96]
21f2575c:	e5933034 	ldr	r3, [r3, #52]
21f25760:	e50b3028 	str	r3, [fp, #-40]
21f25764:	e51b3060 	ldr	r3, [fp, #-96]
21f25768:	e5932030 	ldr	r2, [r3, #48]
21f2576c:	e51b3028 	ldr	r3, [fp, #-40]
21f25770:	e1520003 	cmp	r2, r3
21f25774:	9a000007 	bls	21f25798 <inflate_blocks+0x8c>
21f25778:	e51b3060 	ldr	r3, [fp, #-96]
21f2577c:	e5933030 	ldr	r3, [r3, #48]
21f25780:	e1a02003 	mov	r2, r3
21f25784:	e51b3028 	ldr	r3, [fp, #-40]
21f25788:	e0633002 	rsb	r3, r3, r2
21f2578c:	e2433001 	sub	r3, r3, #1	; 0x1
21f25790:	e50b3098 	str	r3, [fp, #-152]
21f25794:	ea000005 	b	21f257b0 <inflate_blocks+0xa4>
21f25798:	e51b3060 	ldr	r3, [fp, #-96]
21f2579c:	e593302c 	ldr	r3, [r3, #44]
21f257a0:	e1a02003 	mov	r2, r3
21f257a4:	e51b3028 	ldr	r3, [fp, #-40]
21f257a8:	e0633002 	rsb	r3, r3, r2
21f257ac:	e50b3098 	str	r3, [fp, #-152]
21f257b0:	e51b2098 	ldr	r2, [fp, #-152]
21f257b4:	e50b2024 	str	r2, [fp, #-36]
21f257b8:	eaffffff 	b	21f257bc <inflate_blocks+0xb0>

  /* process input based on current state */
  while (1) switch (s->mode)
21f257bc:	e51b3060 	ldr	r3, [fp, #-96]
21f257c0:	e5933000 	ldr	r3, [r3]
21f257c4:	e3530009 	cmp	r3, #9	; 0x9
21f257c8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f257cc:	ea0006a4 	b	21f27264 <.text+0x27264>
21f257d0:	21f258d0 	ldrcssb	r5, [r2, #128]!
21f257d4:	21f25c50 	mvncss	r5, r0, asr ip
21f257d8:	21f25d70 	mvncss	r5, r0, ror sp
21f257dc:	21f261fc 	ldrcssh	r6, [r2, #28]!
21f257e0:	21f26558 	mvncss	r6, r8, asr r5
21f257e4:	21f26ba0 	mvncss	r6, r0, lsr #23
21f257e8:	21f26e68 	mvncss	r6, r8, ror #28
21f257ec:	21f27038 	mvncss	r7, r8, lsr r0
21f257f0:	21f2715c 	mvncss	r7, ip, asr r1
21f257f4:	21f271e0 	mvncss	r7, r0, ror #3
  {
    case TYPE:
      NEEDBITS(3)
21f257f8:	e51b302c 	ldr	r3, [fp, #-44]
21f257fc:	e3530000 	cmp	r3, #0	; 0x0
21f25800:	0a000013 	beq	21f25854 <.text+0x25854>
21f25804:	e3a03000 	mov	r3, #0	; 0x0
21f25808:	e50b3068 	str	r3, [fp, #-104]
21f2580c:	e51b302c 	ldr	r3, [fp, #-44]
21f25810:	e2433001 	sub	r3, r3, #1	; 0x1
21f25814:	e50b302c 	str	r3, [fp, #-44]
21f25818:	e51b3030 	ldr	r3, [fp, #-48]
21f2581c:	e5d33000 	ldrb	r3, [r3]
21f25820:	e1a02003 	mov	r2, r3
21f25824:	e51b3034 	ldr	r3, [fp, #-52]
21f25828:	e1a02312 	mov	r2, r2, lsl r3
21f2582c:	e51b3038 	ldr	r3, [fp, #-56]
21f25830:	e1833002 	orr	r3, r3, r2
21f25834:	e50b3038 	str	r3, [fp, #-56]
21f25838:	e51b3030 	ldr	r3, [fp, #-48]
21f2583c:	e2833001 	add	r3, r3, #1	; 0x1
21f25840:	e50b3030 	str	r3, [fp, #-48]
21f25844:	e51b3034 	ldr	r3, [fp, #-52]
21f25848:	e2833008 	add	r3, r3, #8	; 0x8
21f2584c:	e50b3034 	str	r3, [fp, #-52]
21f25850:	ea00001e 	b	21f258d0 <.text+0x258d0>
21f25854:	e51b2060 	ldr	r2, [fp, #-96]
21f25858:	e51b3038 	ldr	r3, [fp, #-56]
21f2585c:	e5823024 	str	r3, [r2, #36]
21f25860:	e51b2060 	ldr	r2, [fp, #-96]
21f25864:	e51b3034 	ldr	r3, [fp, #-52]
21f25868:	e5823020 	str	r3, [r2, #32]
21f2586c:	e51b2064 	ldr	r2, [fp, #-100]
21f25870:	e51b302c 	ldr	r3, [fp, #-44]
21f25874:	e5823004 	str	r3, [r2, #4]
21f25878:	e51b3064 	ldr	r3, [fp, #-100]
21f2587c:	e5931008 	ldr	r1, [r3, #8]
21f25880:	e51b2030 	ldr	r2, [fp, #-48]
21f25884:	e51b3064 	ldr	r3, [fp, #-100]
21f25888:	e5933000 	ldr	r3, [r3]
21f2588c:	e0633002 	rsb	r3, r3, r2
21f25890:	e0812003 	add	r2, r1, r3
21f25894:	e51b3064 	ldr	r3, [fp, #-100]
21f25898:	e5832008 	str	r2, [r3, #8]
21f2589c:	e51b2064 	ldr	r2, [fp, #-100]
21f258a0:	e51b3030 	ldr	r3, [fp, #-48]
21f258a4:	e5823000 	str	r3, [r2]
21f258a8:	e51b2060 	ldr	r2, [fp, #-96]
21f258ac:	e51b3028 	ldr	r3, [fp, #-40]
21f258b0:	e5823034 	str	r3, [r2, #52]
21f258b4:	e51b0060 	ldr	r0, [fp, #-96]
21f258b8:	e51b1064 	ldr	r1, [fp, #-100]
21f258bc:	e51b2068 	ldr	r2, [fp, #-104]
21f258c0:	eb001124 	bl	21f29d58 <inflate_flush>
21f258c4:	e1a03000 	mov	r3, r0
21f258c8:	e50b3094 	str	r3, [fp, #-148]
21f258cc:	ea000684 	b	21f272e4 <.text+0x272e4>
21f258d0:	e51b3034 	ldr	r3, [fp, #-52]
21f258d4:	e3530002 	cmp	r3, #2	; 0x2
21f258d8:	9affffc6 	bls	21f257f8 <.text+0x257f8>
      t = (uInt)b & 7;
21f258dc:	e51b3038 	ldr	r3, [fp, #-56]
21f258e0:	e2033007 	and	r3, r3, #7	; 0x7
21f258e4:	e50b303c 	str	r3, [fp, #-60]
      s->last = t & 1;
21f258e8:	e51b303c 	ldr	r3, [fp, #-60]
21f258ec:	e2032001 	and	r2, r3, #1	; 0x1
21f258f0:	e51b3060 	ldr	r3, [fp, #-96]
21f258f4:	e583201c 	str	r2, [r3, #28]
      switch (t >> 1)
21f258f8:	e51b303c 	ldr	r3, [fp, #-60]
21f258fc:	e1a030a3 	mov	r3, r3, lsr #1
21f25900:	e3530003 	cmp	r3, #3	; 0x3
21f25904:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f25908:	eaffffab 	b	21f257bc <inflate_blocks+0xb0>
21f2590c:	21f2591c 	mvncss	r5, ip, lsl r9
21f25910:	21f25970 	mvncss	r5, r0, ror r9
21f25914:	21f25a9c 	ldrcsb	r5, [r2, #172]!
21f25918:	21f25ac4 	mvncss	r5, r4, asr #21
      {
	case 0:                         /* stored */
	  Trace((stderr, "inflate:     stored block%s\n",
		 s->last ? " (last)" : ""));
	  DUMPBITS(3)
21f2591c:	e51b3038 	ldr	r3, [fp, #-56]
21f25920:	e1a031a3 	mov	r3, r3, lsr #3
21f25924:	e50b3038 	str	r3, [fp, #-56]
21f25928:	e51b3034 	ldr	r3, [fp, #-52]
21f2592c:	e2433003 	sub	r3, r3, #3	; 0x3
21f25930:	e50b3034 	str	r3, [fp, #-52]
	  t = k & 7;                    /* go to byte boundary */
21f25934:	e51b3034 	ldr	r3, [fp, #-52]
21f25938:	e2033007 	and	r3, r3, #7	; 0x7
21f2593c:	e50b303c 	str	r3, [fp, #-60]
	  DUMPBITS(t)
21f25940:	e51b203c 	ldr	r2, [fp, #-60]
21f25944:	e51b3038 	ldr	r3, [fp, #-56]
21f25948:	e1a03233 	mov	r3, r3, lsr r2
21f2594c:	e50b3038 	str	r3, [fp, #-56]
21f25950:	e51b2034 	ldr	r2, [fp, #-52]
21f25954:	e51b303c 	ldr	r3, [fp, #-60]
21f25958:	e0633002 	rsb	r3, r3, r2
21f2595c:	e50b3034 	str	r3, [fp, #-52]
	  s->mode = LENS;               /* get length of stored block */
21f25960:	e51b2060 	ldr	r2, [fp, #-96]
21f25964:	e3a03001 	mov	r3, #1	; 0x1
21f25968:	e5823000 	str	r3, [r2]
	  break;
21f2596c:	eaffff92 	b	21f257bc <inflate_blocks+0xb0>
	case 1:                         /* fixed */
	  Trace((stderr, "inflate:     fixed codes block%s\n",
		 s->last ? " (last)" : ""));
	  {
	    uInt bl, bd;
	    inflate_huft *tl, *td;

	    inflate_trees_fixed(&bl, &bd, &tl, &td);
21f25970:	e24b3040 	sub	r3, fp, #64	; 0x40
21f25974:	e24b2044 	sub	r2, fp, #68	; 0x44
21f25978:	e24bc048 	sub	ip, fp, #72	; 0x48
21f2597c:	e24be04c 	sub	lr, fp, #76	; 0x4c
21f25980:	e1a00003 	mov	r0, r3
21f25984:	e1a01002 	mov	r1, r2
21f25988:	e1a0200c 	mov	r2, ip
21f2598c:	e1a0300e 	mov	r3, lr
21f25990:	eb000af2 	bl	21f28560 <inflate_trees_fixed>
	    s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
21f25994:	e51b2040 	ldr	r2, [fp, #-64]
21f25998:	e51b1044 	ldr	r1, [fp, #-68]
21f2599c:	e51bc048 	ldr	ip, [fp, #-72]
21f259a0:	e51be04c 	ldr	lr, [fp, #-76]
21f259a4:	e51b3064 	ldr	r3, [fp, #-100]
21f259a8:	e58d3000 	str	r3, [sp]
21f259ac:	e1a00002 	mov	r0, r2
21f259b0:	e1a0200c 	mov	r2, ip
21f259b4:	e1a0300e 	mov	r3, lr
21f259b8:	eb000bd3 	bl	21f2890c <inflate_codes_new>
21f259bc:	e1a02000 	mov	r2, r0
21f259c0:	e51b3060 	ldr	r3, [fp, #-96]
21f259c4:	e583200c 	str	r2, [r3, #12]
	    if (s->sub.decode.codes == Z_NULL)
21f259c8:	e51b3060 	ldr	r3, [fp, #-96]
21f259cc:	e593300c 	ldr	r3, [r3, #12]
21f259d0:	e3530000 	cmp	r3, #0	; 0x0
21f259d4:	1a000020 	bne	21f25a5c <.text+0x25a5c>
	    {
	      r = Z_MEM_ERROR;
21f259d8:	e3e03003 	mvn	r3, #3	; 0x3
21f259dc:	e50b3068 	str	r3, [fp, #-104]
	      LEAVE
21f259e0:	e51b2060 	ldr	r2, [fp, #-96]
21f259e4:	e51b3038 	ldr	r3, [fp, #-56]
21f259e8:	e5823024 	str	r3, [r2, #36]
21f259ec:	e51b2060 	ldr	r2, [fp, #-96]
21f259f0:	e51b3034 	ldr	r3, [fp, #-52]
21f259f4:	e5823020 	str	r3, [r2, #32]
21f259f8:	e51b2064 	ldr	r2, [fp, #-100]
21f259fc:	e51b302c 	ldr	r3, [fp, #-44]
21f25a00:	e5823004 	str	r3, [r2, #4]
21f25a04:	e51b3064 	ldr	r3, [fp, #-100]
21f25a08:	e5931008 	ldr	r1, [r3, #8]
21f25a0c:	e51b2030 	ldr	r2, [fp, #-48]
21f25a10:	e51b3064 	ldr	r3, [fp, #-100]
21f25a14:	e5933000 	ldr	r3, [r3]
21f25a18:	e0633002 	rsb	r3, r3, r2
21f25a1c:	e0812003 	add	r2, r1, r3
21f25a20:	e51b3064 	ldr	r3, [fp, #-100]
21f25a24:	e5832008 	str	r2, [r3, #8]
21f25a28:	e51b2064 	ldr	r2, [fp, #-100]
21f25a2c:	e51b3030 	ldr	r3, [fp, #-48]
21f25a30:	e5823000 	str	r3, [r2]
21f25a34:	e51b2060 	ldr	r2, [fp, #-96]
21f25a38:	e51b3028 	ldr	r3, [fp, #-40]
21f25a3c:	e5823034 	str	r3, [r2, #52]
21f25a40:	e51b0060 	ldr	r0, [fp, #-96]
21f25a44:	e51b1064 	ldr	r1, [fp, #-100]
21f25a48:	e51b2068 	ldr	r2, [fp, #-104]
21f25a4c:	eb0010c1 	bl	21f29d58 <inflate_flush>
21f25a50:	e1a03000 	mov	r3, r0
21f25a54:	e50b3094 	str	r3, [fp, #-148]
21f25a58:	ea000621 	b	21f272e4 <.text+0x272e4>
	    }
	    s->sub.decode.tl = Z_NULL;  /* don't try to free these */
21f25a5c:	e51b2060 	ldr	r2, [fp, #-96]
21f25a60:	e3a03000 	mov	r3, #0	; 0x0
21f25a64:	e5823004 	str	r3, [r2, #4]
	    s->sub.decode.td = Z_NULL;
21f25a68:	e51b2060 	ldr	r2, [fp, #-96]
21f25a6c:	e3a03000 	mov	r3, #0	; 0x0
21f25a70:	e5823008 	str	r3, [r2, #8]
	  }
	  DUMPBITS(3)
21f25a74:	e51b3038 	ldr	r3, [fp, #-56]
21f25a78:	e1a031a3 	mov	r3, r3, lsr #3
21f25a7c:	e50b3038 	str	r3, [fp, #-56]
21f25a80:	e51b3034 	ldr	r3, [fp, #-52]
21f25a84:	e2433003 	sub	r3, r3, #3	; 0x3
21f25a88:	e50b3034 	str	r3, [fp, #-52]
	  s->mode = CODES;
21f25a8c:	e51b2060 	ldr	r2, [fp, #-96]
21f25a90:	e3a03006 	mov	r3, #6	; 0x6
21f25a94:	e5823000 	str	r3, [r2]
	  break;
21f25a98:	eaffff47 	b	21f257bc <inflate_blocks+0xb0>
	case 2:                         /* dynamic */
	  Trace((stderr, "inflate:     dynamic codes block%s\n",
		 s->last ? " (last)" : ""));
	  DUMPBITS(3)
21f25a9c:	e51b3038 	ldr	r3, [fp, #-56]
21f25aa0:	e1a031a3 	mov	r3, r3, lsr #3
21f25aa4:	e50b3038 	str	r3, [fp, #-56]
21f25aa8:	e51b3034 	ldr	r3, [fp, #-52]
21f25aac:	e2433003 	sub	r3, r3, #3	; 0x3
21f25ab0:	e50b3034 	str	r3, [fp, #-52]
	  s->mode = TABLE;
21f25ab4:	e51b2060 	ldr	r2, [fp, #-96]
21f25ab8:	e3a03003 	mov	r3, #3	; 0x3
21f25abc:	e5823000 	str	r3, [r2]
	  break;
21f25ac0:	eaffff3d 	b	21f257bc <inflate_blocks+0xb0>
	case 3:                         /* illegal */
	  DUMPBITS(3)
21f25ac4:	e51b3038 	ldr	r3, [fp, #-56]
21f25ac8:	e1a031a3 	mov	r3, r3, lsr #3
21f25acc:	e50b3038 	str	r3, [fp, #-56]
21f25ad0:	e51b3034 	ldr	r3, [fp, #-52]
21f25ad4:	e2433003 	sub	r3, r3, #3	; 0x3
21f25ad8:	e50b3034 	str	r3, [fp, #-52]
	  s->mode = BADB;
21f25adc:	e51b2060 	ldr	r2, [fp, #-96]
21f25ae0:	e3a03009 	mov	r3, #9	; 0x9
21f25ae4:	e5823000 	str	r3, [r2]
	  z->msg = "invalid block type";
21f25ae8:	e51b2064 	ldr	r2, [fp, #-100]
21f25aec:	e59f3e90 	ldr	r3, [pc, #3728]	; 21f26984 <.text+0x26984>
21f25af0:	e5823018 	str	r3, [r2, #24]
	  r = Z_DATA_ERROR;
21f25af4:	e3e03002 	mvn	r3, #2	; 0x2
21f25af8:	e50b3068 	str	r3, [fp, #-104]
	  LEAVE
21f25afc:	e51b2060 	ldr	r2, [fp, #-96]
21f25b00:	e51b3038 	ldr	r3, [fp, #-56]
21f25b04:	e5823024 	str	r3, [r2, #36]
21f25b08:	e51b2060 	ldr	r2, [fp, #-96]
21f25b0c:	e51b3034 	ldr	r3, [fp, #-52]
21f25b10:	e5823020 	str	r3, [r2, #32]
21f25b14:	e51b2064 	ldr	r2, [fp, #-100]
21f25b18:	e51b302c 	ldr	r3, [fp, #-44]
21f25b1c:	e5823004 	str	r3, [r2, #4]
21f25b20:	e51b3064 	ldr	r3, [fp, #-100]
21f25b24:	e5931008 	ldr	r1, [r3, #8]
21f25b28:	e51b2030 	ldr	r2, [fp, #-48]
21f25b2c:	e51b3064 	ldr	r3, [fp, #-100]
21f25b30:	e5933000 	ldr	r3, [r3]
21f25b34:	e0633002 	rsb	r3, r3, r2
21f25b38:	e0812003 	add	r2, r1, r3
21f25b3c:	e51b3064 	ldr	r3, [fp, #-100]
21f25b40:	e5832008 	str	r2, [r3, #8]
21f25b44:	e51b2064 	ldr	r2, [fp, #-100]
21f25b48:	e51b3030 	ldr	r3, [fp, #-48]
21f25b4c:	e5823000 	str	r3, [r2]
21f25b50:	e51b2060 	ldr	r2, [fp, #-96]
21f25b54:	e51b3028 	ldr	r3, [fp, #-40]
21f25b58:	e5823034 	str	r3, [r2, #52]
21f25b5c:	e51b0060 	ldr	r0, [fp, #-96]
21f25b60:	e51b1064 	ldr	r1, [fp, #-100]
21f25b64:	e51b2068 	ldr	r2, [fp, #-104]
21f25b68:	eb00107a 	bl	21f29d58 <inflate_flush>
21f25b6c:	e1a03000 	mov	r3, r0
21f25b70:	e50b3094 	str	r3, [fp, #-148]
21f25b74:	ea0005da 	b	21f272e4 <.text+0x272e4>
      }
      break;
    case LENS:
      NEEDBITS(32)
21f25b78:	e51b302c 	ldr	r3, [fp, #-44]
21f25b7c:	e3530000 	cmp	r3, #0	; 0x0
21f25b80:	0a000013 	beq	21f25bd4 <.text+0x25bd4>
21f25b84:	e3a03000 	mov	r3, #0	; 0x0
21f25b88:	e50b3068 	str	r3, [fp, #-104]
21f25b8c:	e51b302c 	ldr	r3, [fp, #-44]
21f25b90:	e2433001 	sub	r3, r3, #1	; 0x1
21f25b94:	e50b302c 	str	r3, [fp, #-44]
21f25b98:	e51b3030 	ldr	r3, [fp, #-48]
21f25b9c:	e5d33000 	ldrb	r3, [r3]
21f25ba0:	e1a02003 	mov	r2, r3
21f25ba4:	e51b3034 	ldr	r3, [fp, #-52]
21f25ba8:	e1a02312 	mov	r2, r2, lsl r3
21f25bac:	e51b3038 	ldr	r3, [fp, #-56]
21f25bb0:	e1833002 	orr	r3, r3, r2
21f25bb4:	e50b3038 	str	r3, [fp, #-56]
21f25bb8:	e51b3030 	ldr	r3, [fp, #-48]
21f25bbc:	e2833001 	add	r3, r3, #1	; 0x1
21f25bc0:	e50b3030 	str	r3, [fp, #-48]
21f25bc4:	e51b3034 	ldr	r3, [fp, #-52]
21f25bc8:	e2833008 	add	r3, r3, #8	; 0x8
21f25bcc:	e50b3034 	str	r3, [fp, #-52]
21f25bd0:	ea00001e 	b	21f25c50 <.text+0x25c50>
21f25bd4:	e51b2060 	ldr	r2, [fp, #-96]
21f25bd8:	e51b3038 	ldr	r3, [fp, #-56]
21f25bdc:	e5823024 	str	r3, [r2, #36]
21f25be0:	e51b2060 	ldr	r2, [fp, #-96]
21f25be4:	e51b3034 	ldr	r3, [fp, #-52]
21f25be8:	e5823020 	str	r3, [r2, #32]
21f25bec:	e51b2064 	ldr	r2, [fp, #-100]
21f25bf0:	e51b302c 	ldr	r3, [fp, #-44]
21f25bf4:	e5823004 	str	r3, [r2, #4]
21f25bf8:	e51b3064 	ldr	r3, [fp, #-100]
21f25bfc:	e5931008 	ldr	r1, [r3, #8]
21f25c00:	e51b2030 	ldr	r2, [fp, #-48]
21f25c04:	e51b3064 	ldr	r3, [fp, #-100]
21f25c08:	e5933000 	ldr	r3, [r3]
21f25c0c:	e0633002 	rsb	r3, r3, r2
21f25c10:	e0812003 	add	r2, r1, r3
21f25c14:	e51b3064 	ldr	r3, [fp, #-100]
21f25c18:	e5832008 	str	r2, [r3, #8]
21f25c1c:	e51b2064 	ldr	r2, [fp, #-100]
21f25c20:	e51b3030 	ldr	r3, [fp, #-48]
21f25c24:	e5823000 	str	r3, [r2]
21f25c28:	e51b2060 	ldr	r2, [fp, #-96]
21f25c2c:	e51b3028 	ldr	r3, [fp, #-40]
21f25c30:	e5823034 	str	r3, [r2, #52]
21f25c34:	e51b0060 	ldr	r0, [fp, #-96]
21f25c38:	e51b1064 	ldr	r1, [fp, #-100]
21f25c3c:	e51b2068 	ldr	r2, [fp, #-104]
21f25c40:	eb001044 	bl	21f29d58 <inflate_flush>
21f25c44:	e1a03000 	mov	r3, r0
21f25c48:	e50b3094 	str	r3, [fp, #-148]
21f25c4c:	ea0005a4 	b	21f272e4 <.text+0x272e4>
21f25c50:	e51b3034 	ldr	r3, [fp, #-52]
21f25c54:	e353001f 	cmp	r3, #31	; 0x1f
21f25c58:	9affffc6 	bls	21f25b78 <.text+0x25b78>
      if (((~b) >> 16) != (b & 0xffff))
21f25c5c:	e51b3038 	ldr	r3, [fp, #-56]
21f25c60:	e1e03003 	mvn	r3, r3
21f25c64:	e1a02823 	mov	r2, r3, lsr #16
21f25c68:	e51b3038 	ldr	r3, [fp, #-56]
21f25c6c:	e1a03803 	mov	r3, r3, lsl #16
21f25c70:	e1a03823 	mov	r3, r3, lsr #16
21f25c74:	e1520003 	cmp	r2, r3
21f25c78:	0a000026 	beq	21f25d18 <.text+0x25d18>
      {
	s->mode = BADB;
21f25c7c:	e51b2060 	ldr	r2, [fp, #-96]
21f25c80:	e3a03009 	mov	r3, #9	; 0x9
21f25c84:	e5823000 	str	r3, [r2]
	z->msg = "invalid stored block lengths";
21f25c88:	e51b2064 	ldr	r2, [fp, #-100]
21f25c8c:	e59f3cf4 	ldr	r3, [pc, #3316]	; 21f26988 <.text+0x26988>
21f25c90:	e5823018 	str	r3, [r2, #24]
	r = Z_DATA_ERROR;
21f25c94:	e3e03002 	mvn	r3, #2	; 0x2
21f25c98:	e50b3068 	str	r3, [fp, #-104]
	LEAVE
21f25c9c:	e51b2060 	ldr	r2, [fp, #-96]
21f25ca0:	e51b3038 	ldr	r3, [fp, #-56]
21f25ca4:	e5823024 	str	r3, [r2, #36]
21f25ca8:	e51b2060 	ldr	r2, [fp, #-96]
21f25cac:	e51b3034 	ldr	r3, [fp, #-52]
21f25cb0:	e5823020 	str	r3, [r2, #32]
21f25cb4:	e51b2064 	ldr	r2, [fp, #-100]
21f25cb8:	e51b302c 	ldr	r3, [fp, #-44]
21f25cbc:	e5823004 	str	r3, [r2, #4]
21f25cc0:	e51b3064 	ldr	r3, [fp, #-100]
21f25cc4:	e5931008 	ldr	r1, [r3, #8]
21f25cc8:	e51b2030 	ldr	r2, [fp, #-48]
21f25ccc:	e51b3064 	ldr	r3, [fp, #-100]
21f25cd0:	e5933000 	ldr	r3, [r3]
21f25cd4:	e0633002 	rsb	r3, r3, r2
21f25cd8:	e0812003 	add	r2, r1, r3
21f25cdc:	e51b3064 	ldr	r3, [fp, #-100]
21f25ce0:	e5832008 	str	r2, [r3, #8]
21f25ce4:	e51b2064 	ldr	r2, [fp, #-100]
21f25ce8:	e51b3030 	ldr	r3, [fp, #-48]
21f25cec:	e5823000 	str	r3, [r2]
21f25cf0:	e51b2060 	ldr	r2, [fp, #-96]
21f25cf4:	e51b3028 	ldr	r3, [fp, #-40]
21f25cf8:	e5823034 	str	r3, [r2, #52]
21f25cfc:	e51b0060 	ldr	r0, [fp, #-96]
21f25d00:	e51b1064 	ldr	r1, [fp, #-100]
21f25d04:	e51b2068 	ldr	r2, [fp, #-104]
21f25d08:	eb001012 	bl	21f29d58 <inflate_flush>
21f25d0c:	e1a03000 	mov	r3, r0
21f25d10:	e50b3094 	str	r3, [fp, #-148]
21f25d14:	ea000572 	b	21f272e4 <.text+0x272e4>
      }
      s->sub.left = (uInt)b & 0xffff;
21f25d18:	e51b3038 	ldr	r3, [fp, #-56]
21f25d1c:	e1a03803 	mov	r3, r3, lsl #16
21f25d20:	e1a03823 	mov	r3, r3, lsr #16
21f25d24:	e51b2060 	ldr	r2, [fp, #-96]
21f25d28:	e5823004 	str	r3, [r2, #4]
      b = k = 0;                      /* dump bits */
21f25d2c:	e3a03000 	mov	r3, #0	; 0x0
21f25d30:	e50b3034 	str	r3, [fp, #-52]
21f25d34:	e3a03000 	mov	r3, #0	; 0x0
21f25d38:	e50b3038 	str	r3, [fp, #-56]
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : TYPE;
21f25d3c:	e51b3060 	ldr	r3, [fp, #-96]
21f25d40:	e5933004 	ldr	r3, [r3, #4]
21f25d44:	e3530000 	cmp	r3, #0	; 0x0
21f25d48:	0a000002 	beq	21f25d58 <.text+0x25d58>
21f25d4c:	e3a03002 	mov	r3, #2	; 0x2
21f25d50:	e50b3090 	str	r3, [fp, #-144]
21f25d54:	ea000001 	b	21f25d60 <.text+0x25d60>
21f25d58:	e3a02000 	mov	r2, #0	; 0x0
21f25d5c:	e50b2090 	str	r2, [fp, #-144]
21f25d60:	e51b3060 	ldr	r3, [fp, #-96]
21f25d64:	e51b2090 	ldr	r2, [fp, #-144]
21f25d68:	e5832000 	str	r2, [r3]
      break;
21f25d6c:	eafffe92 	b	21f257bc <inflate_blocks+0xb0>
    case STORED:
      if (n == 0)
21f25d70:	e51b302c 	ldr	r3, [fp, #-44]
21f25d74:	e3530000 	cmp	r3, #0	; 0x0
21f25d78:	1a00001e 	bne	21f25df8 <.text+0x25df8>
	LEAVE
21f25d7c:	e51b2060 	ldr	r2, [fp, #-96]
21f25d80:	e51b3038 	ldr	r3, [fp, #-56]
21f25d84:	e5823024 	str	r3, [r2, #36]
21f25d88:	e51b2060 	ldr	r2, [fp, #-96]
21f25d8c:	e51b3034 	ldr	r3, [fp, #-52]
21f25d90:	e5823020 	str	r3, [r2, #32]
21f25d94:	e51b2064 	ldr	r2, [fp, #-100]
21f25d98:	e51b302c 	ldr	r3, [fp, #-44]
21f25d9c:	e5823004 	str	r3, [r2, #4]
21f25da0:	e51b3064 	ldr	r3, [fp, #-100]
21f25da4:	e5931008 	ldr	r1, [r3, #8]
21f25da8:	e51b2030 	ldr	r2, [fp, #-48]
21f25dac:	e51b3064 	ldr	r3, [fp, #-100]
21f25db0:	e5933000 	ldr	r3, [r3]
21f25db4:	e0633002 	rsb	r3, r3, r2
21f25db8:	e0812003 	add	r2, r1, r3
21f25dbc:	e51b3064 	ldr	r3, [fp, #-100]
21f25dc0:	e5832008 	str	r2, [r3, #8]
21f25dc4:	e51b2064 	ldr	r2, [fp, #-100]
21f25dc8:	e51b3030 	ldr	r3, [fp, #-48]
21f25dcc:	e5823000 	str	r3, [r2]
21f25dd0:	e51b2060 	ldr	r2, [fp, #-96]
21f25dd4:	e51b3028 	ldr	r3, [fp, #-40]
21f25dd8:	e5823034 	str	r3, [r2, #52]
21f25ddc:	e51b0060 	ldr	r0, [fp, #-96]
21f25de0:	e51b1064 	ldr	r1, [fp, #-100]
21f25de4:	e51b2068 	ldr	r2, [fp, #-104]
21f25de8:	eb000fda 	bl	21f29d58 <inflate_flush>
21f25dec:	e1a03000 	mov	r3, r0
21f25df0:	e50b3094 	str	r3, [fp, #-148]
21f25df4:	ea00053a 	b	21f272e4 <.text+0x272e4>
      NEEDOUT
21f25df8:	e51b3024 	ldr	r3, [fp, #-36]
21f25dfc:	e3530000 	cmp	r3, #0	; 0x0
21f25e00:	1a00008b 	bne	21f26034 <.text+0x26034>
21f25e04:	e51b3060 	ldr	r3, [fp, #-96]
21f25e08:	e593202c 	ldr	r2, [r3, #44]
21f25e0c:	e51b3028 	ldr	r3, [fp, #-40]
21f25e10:	e1520003 	cmp	r2, r3
21f25e14:	1a00001d 	bne	21f25e90 <.text+0x25e90>
21f25e18:	e51b3060 	ldr	r3, [fp, #-96]
21f25e1c:	e5932030 	ldr	r2, [r3, #48]
21f25e20:	e51b3060 	ldr	r3, [fp, #-96]
21f25e24:	e5933028 	ldr	r3, [r3, #40]
21f25e28:	e1520003 	cmp	r2, r3
21f25e2c:	0a000017 	beq	21f25e90 <.text+0x25e90>
21f25e30:	e51b3060 	ldr	r3, [fp, #-96]
21f25e34:	e5933028 	ldr	r3, [r3, #40]
21f25e38:	e50b3028 	str	r3, [fp, #-40]
21f25e3c:	e51b3060 	ldr	r3, [fp, #-96]
21f25e40:	e5932030 	ldr	r2, [r3, #48]
21f25e44:	e51b3028 	ldr	r3, [fp, #-40]
21f25e48:	e1520003 	cmp	r2, r3
21f25e4c:	9a000007 	bls	21f25e70 <.text+0x25e70>
21f25e50:	e51b3060 	ldr	r3, [fp, #-96]
21f25e54:	e5933030 	ldr	r3, [r3, #48]
21f25e58:	e1a02003 	mov	r2, r3
21f25e5c:	e51b3028 	ldr	r3, [fp, #-40]
21f25e60:	e0633002 	rsb	r3, r3, r2
21f25e64:	e2433001 	sub	r3, r3, #1	; 0x1
21f25e68:	e50b308c 	str	r3, [fp, #-140]
21f25e6c:	ea000005 	b	21f25e88 <.text+0x25e88>
21f25e70:	e51b3060 	ldr	r3, [fp, #-96]
21f25e74:	e593302c 	ldr	r3, [r3, #44]
21f25e78:	e1a02003 	mov	r2, r3
21f25e7c:	e51b3028 	ldr	r3, [fp, #-40]
21f25e80:	e0633002 	rsb	r3, r3, r2
21f25e84:	e50b308c 	str	r3, [fp, #-140]
21f25e88:	e51b308c 	ldr	r3, [fp, #-140]
21f25e8c:	e50b3024 	str	r3, [fp, #-36]
21f25e90:	e51b3024 	ldr	r3, [fp, #-36]
21f25e94:	e3530000 	cmp	r3, #0	; 0x0
21f25e98:	1a000065 	bne	21f26034 <.text+0x26034>
21f25e9c:	e51b2060 	ldr	r2, [fp, #-96]
21f25ea0:	e51b3028 	ldr	r3, [fp, #-40]
21f25ea4:	e5823034 	str	r3, [r2, #52]
21f25ea8:	e51b0060 	ldr	r0, [fp, #-96]
21f25eac:	e51b1064 	ldr	r1, [fp, #-100]
21f25eb0:	e51b2068 	ldr	r2, [fp, #-104]
21f25eb4:	eb000fa7 	bl	21f29d58 <inflate_flush>
21f25eb8:	e1a03000 	mov	r3, r0
21f25ebc:	e50b3068 	str	r3, [fp, #-104]
21f25ec0:	e51b3060 	ldr	r3, [fp, #-96]
21f25ec4:	e5933034 	ldr	r3, [r3, #52]
21f25ec8:	e50b3028 	str	r3, [fp, #-40]
21f25ecc:	e51b3060 	ldr	r3, [fp, #-96]
21f25ed0:	e5932030 	ldr	r2, [r3, #48]
21f25ed4:	e51b3028 	ldr	r3, [fp, #-40]
21f25ed8:	e1520003 	cmp	r2, r3
21f25edc:	9a000007 	bls	21f25f00 <.text+0x25f00>
21f25ee0:	e51b3060 	ldr	r3, [fp, #-96]
21f25ee4:	e5933030 	ldr	r3, [r3, #48]
21f25ee8:	e1a02003 	mov	r2, r3
21f25eec:	e51b3028 	ldr	r3, [fp, #-40]
21f25ef0:	e0633002 	rsb	r3, r3, r2
21f25ef4:	e2433001 	sub	r3, r3, #1	; 0x1
21f25ef8:	e50b3088 	str	r3, [fp, #-136]
21f25efc:	ea000005 	b	21f25f18 <.text+0x25f18>
21f25f00:	e51b3060 	ldr	r3, [fp, #-96]
21f25f04:	e593302c 	ldr	r3, [r3, #44]
21f25f08:	e1a02003 	mov	r2, r3
21f25f0c:	e51b3028 	ldr	r3, [fp, #-40]
21f25f10:	e0633002 	rsb	r3, r3, r2
21f25f14:	e50b3088 	str	r3, [fp, #-136]
21f25f18:	e51b2088 	ldr	r2, [fp, #-136]
21f25f1c:	e50b2024 	str	r2, [fp, #-36]
21f25f20:	e51b3060 	ldr	r3, [fp, #-96]
21f25f24:	e593202c 	ldr	r2, [r3, #44]
21f25f28:	e51b3028 	ldr	r3, [fp, #-40]
21f25f2c:	e1520003 	cmp	r2, r3
21f25f30:	1a00001d 	bne	21f25fac <.text+0x25fac>
21f25f34:	e51b3060 	ldr	r3, [fp, #-96]
21f25f38:	e5932030 	ldr	r2, [r3, #48]
21f25f3c:	e51b3060 	ldr	r3, [fp, #-96]
21f25f40:	e5933028 	ldr	r3, [r3, #40]
21f25f44:	e1520003 	cmp	r2, r3
21f25f48:	0a000017 	beq	21f25fac <.text+0x25fac>
21f25f4c:	e51b3060 	ldr	r3, [fp, #-96]
21f25f50:	e5933028 	ldr	r3, [r3, #40]
21f25f54:	e50b3028 	str	r3, [fp, #-40]
21f25f58:	e51b3060 	ldr	r3, [fp, #-96]
21f25f5c:	e5932030 	ldr	r2, [r3, #48]
21f25f60:	e51b3028 	ldr	r3, [fp, #-40]
21f25f64:	e1520003 	cmp	r2, r3
21f25f68:	9a000007 	bls	21f25f8c <.text+0x25f8c>
21f25f6c:	e51b3060 	ldr	r3, [fp, #-96]
21f25f70:	e5933030 	ldr	r3, [r3, #48]
21f25f74:	e1a02003 	mov	r2, r3
21f25f78:	e51b3028 	ldr	r3, [fp, #-40]
21f25f7c:	e0633002 	rsb	r3, r3, r2
21f25f80:	e2433001 	sub	r3, r3, #1	; 0x1
21f25f84:	e50b3084 	str	r3, [fp, #-132]
21f25f88:	ea000005 	b	21f25fa4 <.text+0x25fa4>
21f25f8c:	e51b3060 	ldr	r3, [fp, #-96]
21f25f90:	e593302c 	ldr	r3, [r3, #44]
21f25f94:	e1a02003 	mov	r2, r3
21f25f98:	e51b3028 	ldr	r3, [fp, #-40]
21f25f9c:	e0633002 	rsb	r3, r3, r2
21f25fa0:	e50b3084 	str	r3, [fp, #-132]
21f25fa4:	e51b3084 	ldr	r3, [fp, #-132]
21f25fa8:	e50b3024 	str	r3, [fp, #-36]
21f25fac:	e51b3024 	ldr	r3, [fp, #-36]
21f25fb0:	e3530000 	cmp	r3, #0	; 0x0
21f25fb4:	1a00001e 	bne	21f26034 <.text+0x26034>
21f25fb8:	e51b2060 	ldr	r2, [fp, #-96]
21f25fbc:	e51b3038 	ldr	r3, [fp, #-56]
21f25fc0:	e5823024 	str	r3, [r2, #36]
21f25fc4:	e51b2060 	ldr	r2, [fp, #-96]
21f25fc8:	e51b3034 	ldr	r3, [fp, #-52]
21f25fcc:	e5823020 	str	r3, [r2, #32]
21f25fd0:	e51b2064 	ldr	r2, [fp, #-100]
21f25fd4:	e51b302c 	ldr	r3, [fp, #-44]
21f25fd8:	e5823004 	str	r3, [r2, #4]
21f25fdc:	e51b3064 	ldr	r3, [fp, #-100]
21f25fe0:	e5931008 	ldr	r1, [r3, #8]
21f25fe4:	e51b2030 	ldr	r2, [fp, #-48]
21f25fe8:	e51b3064 	ldr	r3, [fp, #-100]
21f25fec:	e5933000 	ldr	r3, [r3]
21f25ff0:	e0633002 	rsb	r3, r3, r2
21f25ff4:	e0812003 	add	r2, r1, r3
21f25ff8:	e51b3064 	ldr	r3, [fp, #-100]
21f25ffc:	e5832008 	str	r2, [r3, #8]
21f26000:	e51b2064 	ldr	r2, [fp, #-100]
21f26004:	e51b3030 	ldr	r3, [fp, #-48]
21f26008:	e5823000 	str	r3, [r2]
21f2600c:	e51b2060 	ldr	r2, [fp, #-96]
21f26010:	e51b3028 	ldr	r3, [fp, #-40]
21f26014:	e5823034 	str	r3, [r2, #52]
21f26018:	e51b0060 	ldr	r0, [fp, #-96]
21f2601c:	e51b1064 	ldr	r1, [fp, #-100]
21f26020:	e51b2068 	ldr	r2, [fp, #-104]
21f26024:	eb000f4b 	bl	21f29d58 <inflate_flush>
21f26028:	e1a03000 	mov	r3, r0
21f2602c:	e50b3094 	str	r3, [fp, #-148]
21f26030:	ea0004ab 	b	21f272e4 <.text+0x272e4>
21f26034:	e3a03000 	mov	r3, #0	; 0x0
21f26038:	e50b3068 	str	r3, [fp, #-104]
      t = s->sub.left;
21f2603c:	e51b3060 	ldr	r3, [fp, #-96]
21f26040:	e5933004 	ldr	r3, [r3, #4]
21f26044:	e50b303c 	str	r3, [fp, #-60]
      if (t > n) t = n;
21f26048:	e51b203c 	ldr	r2, [fp, #-60]
21f2604c:	e51b302c 	ldr	r3, [fp, #-44]
21f26050:	e1520003 	cmp	r2, r3
21f26054:	9a000001 	bls	21f26060 <.text+0x26060>
21f26058:	e51b302c 	ldr	r3, [fp, #-44]
21f2605c:	e50b303c 	str	r3, [fp, #-60]
      if (t > m) t = m;
21f26060:	e51b203c 	ldr	r2, [fp, #-60]
21f26064:	e51b3024 	ldr	r3, [fp, #-36]
21f26068:	e1520003 	cmp	r2, r3
21f2606c:	9a000001 	bls	21f26078 <.text+0x26078>
21f26070:	e51b3024 	ldr	r3, [fp, #-36]
21f26074:	e50b303c 	str	r3, [fp, #-60]
      zmemcpy(q, p, t);
21f26078:	e51b0028 	ldr	r0, [fp, #-40]
21f2607c:	e51b1030 	ldr	r1, [fp, #-48]
21f26080:	e51b203c 	ldr	r2, [fp, #-60]
21f26084:	ebfff450 	bl	21f231cc <memcpy>
      p += t;  n -= t;
21f26088:	e51b203c 	ldr	r2, [fp, #-60]
21f2608c:	e51b3030 	ldr	r3, [fp, #-48]
21f26090:	e0833002 	add	r3, r3, r2
21f26094:	e50b3030 	str	r3, [fp, #-48]
21f26098:	e51b202c 	ldr	r2, [fp, #-44]
21f2609c:	e51b303c 	ldr	r3, [fp, #-60]
21f260a0:	e0633002 	rsb	r3, r3, r2
21f260a4:	e50b302c 	str	r3, [fp, #-44]
      q += t;  m -= t;
21f260a8:	e51b203c 	ldr	r2, [fp, #-60]
21f260ac:	e51b3028 	ldr	r3, [fp, #-40]
21f260b0:	e0833002 	add	r3, r3, r2
21f260b4:	e50b3028 	str	r3, [fp, #-40]
21f260b8:	e51b2024 	ldr	r2, [fp, #-36]
21f260bc:	e51b303c 	ldr	r3, [fp, #-60]
21f260c0:	e0633002 	rsb	r3, r3, r2
21f260c4:	e50b3024 	str	r3, [fp, #-36]
      if ((s->sub.left -= t) != 0)
21f260c8:	e51b3060 	ldr	r3, [fp, #-96]
21f260cc:	e5932004 	ldr	r2, [r3, #4]
21f260d0:	e51b303c 	ldr	r3, [fp, #-60]
21f260d4:	e0632002 	rsb	r2, r3, r2
21f260d8:	e51b3060 	ldr	r3, [fp, #-96]
21f260dc:	e5832004 	str	r2, [r3, #4]
21f260e0:	e51b3060 	ldr	r3, [fp, #-96]
21f260e4:	e5933004 	ldr	r3, [r3, #4]
21f260e8:	e3530000 	cmp	r3, #0	; 0x0
21f260ec:	1afffdb2 	bne	21f257bc <inflate_blocks+0xb0>
	break;
      Tracev((stderr, "inflate:       stored end, %lu total out\n",
	      z->total_out + (q >= s->read ? q - s->read :
	      (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
21f260f0:	e51b3060 	ldr	r3, [fp, #-96]
21f260f4:	e593301c 	ldr	r3, [r3, #28]
21f260f8:	e3530000 	cmp	r3, #0	; 0x0
21f260fc:	0a000002 	beq	21f2610c <.text+0x2610c>
21f26100:	e3a02007 	mov	r2, #7	; 0x7
21f26104:	e50b2080 	str	r2, [fp, #-128]
21f26108:	ea000001 	b	21f26114 <.text+0x26114>
21f2610c:	e3a03000 	mov	r3, #0	; 0x0
21f26110:	e50b3080 	str	r3, [fp, #-128]
21f26114:	e51b3060 	ldr	r3, [fp, #-96]
21f26118:	e51b2080 	ldr	r2, [fp, #-128]
21f2611c:	e5832000 	str	r2, [r3]
      break;
21f26120:	eafffda5 	b	21f257bc <inflate_blocks+0xb0>
    case TABLE:
      NEEDBITS(14)
21f26124:	e51b302c 	ldr	r3, [fp, #-44]
21f26128:	e3530000 	cmp	r3, #0	; 0x0
21f2612c:	0a000013 	beq	21f26180 <.text+0x26180>
21f26130:	e3a03000 	mov	r3, #0	; 0x0
21f26134:	e50b3068 	str	r3, [fp, #-104]
21f26138:	e51b302c 	ldr	r3, [fp, #-44]
21f2613c:	e2433001 	sub	r3, r3, #1	; 0x1
21f26140:	e50b302c 	str	r3, [fp, #-44]
21f26144:	e51b3030 	ldr	r3, [fp, #-48]
21f26148:	e5d33000 	ldrb	r3, [r3]
21f2614c:	e1a02003 	mov	r2, r3
21f26150:	e51b3034 	ldr	r3, [fp, #-52]
21f26154:	e1a02312 	mov	r2, r2, lsl r3
21f26158:	e51b3038 	ldr	r3, [fp, #-56]
21f2615c:	e1833002 	orr	r3, r3, r2
21f26160:	e50b3038 	str	r3, [fp, #-56]
21f26164:	e51b3030 	ldr	r3, [fp, #-48]
21f26168:	e2833001 	add	r3, r3, #1	; 0x1
21f2616c:	e50b3030 	str	r3, [fp, #-48]
21f26170:	e51b3034 	ldr	r3, [fp, #-52]
21f26174:	e2833008 	add	r3, r3, #8	; 0x8
21f26178:	e50b3034 	str	r3, [fp, #-52]
21f2617c:	ea00001e 	b	21f261fc <.text+0x261fc>
21f26180:	e51b2060 	ldr	r2, [fp, #-96]
21f26184:	e51b3038 	ldr	r3, [fp, #-56]
21f26188:	e5823024 	str	r3, [r2, #36]
21f2618c:	e51b2060 	ldr	r2, [fp, #-96]
21f26190:	e51b3034 	ldr	r3, [fp, #-52]
21f26194:	e5823020 	str	r3, [r2, #32]
21f26198:	e51b2064 	ldr	r2, [fp, #-100]
21f2619c:	e51b302c 	ldr	r3, [fp, #-44]
21f261a0:	e5823004 	str	r3, [r2, #4]
21f261a4:	e51b3064 	ldr	r3, [fp, #-100]
21f261a8:	e5931008 	ldr	r1, [r3, #8]
21f261ac:	e51b2030 	ldr	r2, [fp, #-48]
21f261b0:	e51b3064 	ldr	r3, [fp, #-100]
21f261b4:	e5933000 	ldr	r3, [r3]
21f261b8:	e0633002 	rsb	r3, r3, r2
21f261bc:	e0812003 	add	r2, r1, r3
21f261c0:	e51b3064 	ldr	r3, [fp, #-100]
21f261c4:	e5832008 	str	r2, [r3, #8]
21f261c8:	e51b2064 	ldr	r2, [fp, #-100]
21f261cc:	e51b3030 	ldr	r3, [fp, #-48]
21f261d0:	e5823000 	str	r3, [r2]
21f261d4:	e51b2060 	ldr	r2, [fp, #-96]
21f261d8:	e51b3028 	ldr	r3, [fp, #-40]
21f261dc:	e5823034 	str	r3, [r2, #52]
21f261e0:	e51b0060 	ldr	r0, [fp, #-96]
21f261e4:	e51b1064 	ldr	r1, [fp, #-100]
21f261e8:	e51b2068 	ldr	r2, [fp, #-104]
21f261ec:	eb000ed9 	bl	21f29d58 <inflate_flush>
21f261f0:	e1a03000 	mov	r3, r0
21f261f4:	e50b3094 	str	r3, [fp, #-148]
21f261f8:	ea000439 	b	21f272e4 <.text+0x272e4>
21f261fc:	e51b3034 	ldr	r3, [fp, #-52]
21f26200:	e353000d 	cmp	r3, #13	; 0xd
21f26204:	9affffc6 	bls	21f26124 <.text+0x26124>
      s->sub.trees.table = t = (uInt)b & 0x3fff;
21f26208:	e51b3038 	ldr	r3, [fp, #-56]
21f2620c:	e1a03903 	mov	r3, r3, lsl #18
21f26210:	e1a03923 	mov	r3, r3, lsr #18
21f26214:	e50b303c 	str	r3, [fp, #-60]
21f26218:	e51b2060 	ldr	r2, [fp, #-96]
21f2621c:	e51b303c 	ldr	r3, [fp, #-60]
21f26220:	e5823004 	str	r3, [r2, #4]
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
21f26224:	e51b303c 	ldr	r3, [fp, #-60]
21f26228:	e203301f 	and	r3, r3, #31	; 0x1f
21f2622c:	e353001d 	cmp	r3, #29	; 0x1d
21f26230:	8a000004 	bhi	21f26248 <.text+0x26248>
21f26234:	e51b303c 	ldr	r3, [fp, #-60]
21f26238:	e1a032a3 	mov	r3, r3, lsr #5
21f2623c:	e203301f 	and	r3, r3, #31	; 0x1f
21f26240:	e353001d 	cmp	r3, #29	; 0x1d
21f26244:	9a000026 	bls	21f262e4 <.text+0x262e4>
      {
	s->mode = BADB;
21f26248:	e51b2060 	ldr	r2, [fp, #-96]
21f2624c:	e3a03009 	mov	r3, #9	; 0x9
21f26250:	e5823000 	str	r3, [r2]
	z->msg = "too many length or distance symbols";
21f26254:	e51b2064 	ldr	r2, [fp, #-100]
21f26258:	e59f372c 	ldr	r3, [pc, #1836]	; 21f2698c <.text+0x2698c>
21f2625c:	e5823018 	str	r3, [r2, #24]
	r = Z_DATA_ERROR;
21f26260:	e3e03002 	mvn	r3, #2	; 0x2
21f26264:	e50b3068 	str	r3, [fp, #-104]
	LEAVE
21f26268:	e51b2060 	ldr	r2, [fp, #-96]
21f2626c:	e51b3038 	ldr	r3, [fp, #-56]
21f26270:	e5823024 	str	r3, [r2, #36]
21f26274:	e51b2060 	ldr	r2, [fp, #-96]
21f26278:	e51b3034 	ldr	r3, [fp, #-52]
21f2627c:	e5823020 	str	r3, [r2, #32]
21f26280:	e51b2064 	ldr	r2, [fp, #-100]
21f26284:	e51b302c 	ldr	r3, [fp, #-44]
21f26288:	e5823004 	str	r3, [r2, #4]
21f2628c:	e51b3064 	ldr	r3, [fp, #-100]
21f26290:	e5931008 	ldr	r1, [r3, #8]
21f26294:	e51b2030 	ldr	r2, [fp, #-48]
21f26298:	e51b3064 	ldr	r3, [fp, #-100]
21f2629c:	e5933000 	ldr	r3, [r3]
21f262a0:	e0633002 	rsb	r3, r3, r2
21f262a4:	e0812003 	add	r2, r1, r3
21f262a8:	e51b3064 	ldr	r3, [fp, #-100]
21f262ac:	e5832008 	str	r2, [r3, #8]
21f262b0:	e51b2064 	ldr	r2, [fp, #-100]
21f262b4:	e51b3030 	ldr	r3, [fp, #-48]
21f262b8:	e5823000 	str	r3, [r2]
21f262bc:	e51b2060 	ldr	r2, [fp, #-96]
21f262c0:	e51b3028 	ldr	r3, [fp, #-40]
21f262c4:	e5823034 	str	r3, [r2, #52]
21f262c8:	e51b0060 	ldr	r0, [fp, #-96]
21f262cc:	e51b1064 	ldr	r1, [fp, #-100]
21f262d0:	e51b2068 	ldr	r2, [fp, #-104]
21f262d4:	eb000e9f 	bl	21f29d58 <inflate_flush>
21f262d8:	e1a03000 	mov	r3, r0
21f262dc:	e50b3094 	str	r3, [fp, #-148]
21f262e0:	ea0003ff 	b	21f272e4 <.text+0x272e4>
      }
#endif
      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
21f262e4:	e51b303c 	ldr	r3, [fp, #-60]
21f262e8:	e203201f 	and	r2, r3, #31	; 0x1f
21f262ec:	e51b303c 	ldr	r3, [fp, #-60]
21f262f0:	e1a032a3 	mov	r3, r3, lsr #5
21f262f4:	e203301f 	and	r3, r3, #31	; 0x1f
21f262f8:	e0823003 	add	r3, r2, r3
21f262fc:	e2833c01 	add	r3, r3, #256	; 0x100
21f26300:	e2833002 	add	r3, r3, #2	; 0x2
21f26304:	e50b303c 	str	r3, [fp, #-60]
      if (t < 19)
21f26308:	e51b303c 	ldr	r3, [fp, #-60]
21f2630c:	e3530012 	cmp	r3, #18	; 0x12
21f26310:	8a000001 	bhi	21f2631c <.text+0x2631c>
	t = 19;
21f26314:	e3a03013 	mov	r3, #19	; 0x13
21f26318:	e50b303c 	str	r3, [fp, #-60]
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
21f2631c:	e51b3064 	ldr	r3, [fp, #-100]
21f26320:	e593c020 	ldr	ip, [r3, #32]
21f26324:	e51b3064 	ldr	r3, [fp, #-100]
21f26328:	e5933028 	ldr	r3, [r3, #40]
21f2632c:	e1a00003 	mov	r0, r3
21f26330:	e51b103c 	ldr	r1, [fp, #-60]
21f26334:	e3a02004 	mov	r2, #4	; 0x4
21f26338:	e1a0e00f 	mov	lr, pc
21f2633c:	e1a0f00c 	mov	pc, ip
21f26340:	e1a03000 	mov	r3, r0
21f26344:	e1a02003 	mov	r2, r3
21f26348:	e51b3060 	ldr	r3, [fp, #-96]
21f2634c:	e583200c 	str	r2, [r3, #12]
21f26350:	e51b3060 	ldr	r3, [fp, #-96]
21f26354:	e593300c 	ldr	r3, [r3, #12]
21f26358:	e3530000 	cmp	r3, #0	; 0x0
21f2635c:	1a000020 	bne	21f263e4 <.text+0x263e4>
      {
	r = Z_MEM_ERROR;
21f26360:	e3e03003 	mvn	r3, #3	; 0x3
21f26364:	e50b3068 	str	r3, [fp, #-104]
	LEAVE
21f26368:	e51b2060 	ldr	r2, [fp, #-96]
21f2636c:	e51b3038 	ldr	r3, [fp, #-56]
21f26370:	e5823024 	str	r3, [r2, #36]
21f26374:	e51b2060 	ldr	r2, [fp, #-96]
21f26378:	e51b3034 	ldr	r3, [fp, #-52]
21f2637c:	e5823020 	str	r3, [r2, #32]
21f26380:	e51b2064 	ldr	r2, [fp, #-100]
21f26384:	e51b302c 	ldr	r3, [fp, #-44]
21f26388:	e5823004 	str	r3, [r2, #4]
21f2638c:	e51b3064 	ldr	r3, [fp, #-100]
21f26390:	e5931008 	ldr	r1, [r3, #8]
21f26394:	e51b2030 	ldr	r2, [fp, #-48]
21f26398:	e51b3064 	ldr	r3, [fp, #-100]
21f2639c:	e5933000 	ldr	r3, [r3]
21f263a0:	e0633002 	rsb	r3, r3, r2
21f263a4:	e0812003 	add	r2, r1, r3
21f263a8:	e51b3064 	ldr	r3, [fp, #-100]
21f263ac:	e5832008 	str	r2, [r3, #8]
21f263b0:	e51b2064 	ldr	r2, [fp, #-100]
21f263b4:	e51b3030 	ldr	r3, [fp, #-48]
21f263b8:	e5823000 	str	r3, [r2]
21f263bc:	e51b2060 	ldr	r2, [fp, #-96]
21f263c0:	e51b3028 	ldr	r3, [fp, #-40]
21f263c4:	e5823034 	str	r3, [r2, #52]
21f263c8:	e51b0060 	ldr	r0, [fp, #-96]
21f263cc:	e51b1064 	ldr	r1, [fp, #-100]
21f263d0:	e51b2068 	ldr	r2, [fp, #-104]
21f263d4:	eb000e5f 	bl	21f29d58 <inflate_flush>
21f263d8:	e1a03000 	mov	r3, r0
21f263dc:	e50b3094 	str	r3, [fp, #-148]
21f263e0:	ea0003bf 	b	21f272e4 <.text+0x272e4>
      }
      s->sub.trees.nblens = t;
21f263e4:	e51b203c 	ldr	r2, [fp, #-60]
21f263e8:	e51b3060 	ldr	r3, [fp, #-96]
21f263ec:	e5832018 	str	r2, [r3, #24]
      DUMPBITS(14)
21f263f0:	e51b3038 	ldr	r3, [fp, #-56]
21f263f4:	e1a03723 	mov	r3, r3, lsr #14
21f263f8:	e50b3038 	str	r3, [fp, #-56]
21f263fc:	e51b3034 	ldr	r3, [fp, #-52]
21f26400:	e243300e 	sub	r3, r3, #14	; 0xe
21f26404:	e50b3034 	str	r3, [fp, #-52]
      s->sub.trees.index = 0;
21f26408:	e51b2060 	ldr	r2, [fp, #-96]
21f2640c:	e3a03000 	mov	r3, #0	; 0x0
21f26410:	e5823008 	str	r3, [r2, #8]
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
21f26414:	e51b2060 	ldr	r2, [fp, #-96]
21f26418:	e3a03004 	mov	r3, #4	; 0x4
21f2641c:	e5823000 	str	r3, [r2]
21f26420:	ea00004c 	b	21f26558 <.text+0x26558>
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
	NEEDBITS(3)
21f26424:	e51b302c 	ldr	r3, [fp, #-44]
21f26428:	e3530000 	cmp	r3, #0	; 0x0
21f2642c:	0a000013 	beq	21f26480 <.text+0x26480>
21f26430:	e3a03000 	mov	r3, #0	; 0x0
21f26434:	e50b3068 	str	r3, [fp, #-104]
21f26438:	e51b302c 	ldr	r3, [fp, #-44]
21f2643c:	e2433001 	sub	r3, r3, #1	; 0x1
21f26440:	e50b302c 	str	r3, [fp, #-44]
21f26444:	e51b3030 	ldr	r3, [fp, #-48]
21f26448:	e5d33000 	ldrb	r3, [r3]
21f2644c:	e1a02003 	mov	r2, r3
21f26450:	e51b3034 	ldr	r3, [fp, #-52]
21f26454:	e1a02312 	mov	r2, r2, lsl r3
21f26458:	e51b3038 	ldr	r3, [fp, #-56]
21f2645c:	e1833002 	orr	r3, r3, r2
21f26460:	e50b3038 	str	r3, [fp, #-56]
21f26464:	e51b3030 	ldr	r3, [fp, #-48]
21f26468:	e2833001 	add	r3, r3, #1	; 0x1
21f2646c:	e50b3030 	str	r3, [fp, #-48]
21f26470:	e51b3034 	ldr	r3, [fp, #-52]
21f26474:	e2833008 	add	r3, r3, #8	; 0x8
21f26478:	e50b3034 	str	r3, [fp, #-52]
21f2647c:	ea00001e 	b	21f264fc <.text+0x264fc>
21f26480:	e51b2060 	ldr	r2, [fp, #-96]
21f26484:	e51b3038 	ldr	r3, [fp, #-56]
21f26488:	e5823024 	str	r3, [r2, #36]
21f2648c:	e51b2060 	ldr	r2, [fp, #-96]
21f26490:	e51b3034 	ldr	r3, [fp, #-52]
21f26494:	e5823020 	str	r3, [r2, #32]
21f26498:	e51b2064 	ldr	r2, [fp, #-100]
21f2649c:	e51b302c 	ldr	r3, [fp, #-44]
21f264a0:	e5823004 	str	r3, [r2, #4]
21f264a4:	e51b3064 	ldr	r3, [fp, #-100]
21f264a8:	e5931008 	ldr	r1, [r3, #8]
21f264ac:	e51b2030 	ldr	r2, [fp, #-48]
21f264b0:	e51b3064 	ldr	r3, [fp, #-100]
21f264b4:	e5933000 	ldr	r3, [r3]
21f264b8:	e0633002 	rsb	r3, r3, r2
21f264bc:	e0812003 	add	r2, r1, r3
21f264c0:	e51b3064 	ldr	r3, [fp, #-100]
21f264c4:	e5832008 	str	r2, [r3, #8]
21f264c8:	e51b2064 	ldr	r2, [fp, #-100]
21f264cc:	e51b3030 	ldr	r3, [fp, #-48]
21f264d0:	e5823000 	str	r3, [r2]
21f264d4:	e51b2060 	ldr	r2, [fp, #-96]
21f264d8:	e51b3028 	ldr	r3, [fp, #-40]
21f264dc:	e5823034 	str	r3, [r2, #52]
21f264e0:	e51b0060 	ldr	r0, [fp, #-96]
21f264e4:	e51b1064 	ldr	r1, [fp, #-100]
21f264e8:	e51b2068 	ldr	r2, [fp, #-104]
21f264ec:	eb000e19 	bl	21f29d58 <inflate_flush>
21f264f0:	e1a03000 	mov	r3, r0
21f264f4:	e50b3094 	str	r3, [fp, #-148]
21f264f8:	ea000379 	b	21f272e4 <.text+0x272e4>
21f264fc:	e51b3034 	ldr	r3, [fp, #-52]
21f26500:	e3530002 	cmp	r3, #2	; 0x2
21f26504:	9affffc6 	bls	21f26424 <.text+0x26424>
	s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
21f26508:	e51b3060 	ldr	r3, [fp, #-96]
21f2650c:	e593200c 	ldr	r2, [r3, #12]
21f26510:	e51b3060 	ldr	r3, [fp, #-96]
21f26514:	e5931008 	ldr	r1, [r3, #8]
21f26518:	e59f3470 	ldr	r3, [pc, #1136]	; 21f26990 <.text+0x26990>
21f2651c:	e7933101 	ldr	r3, [r3, r1, lsl #2]
21f26520:	e1a03103 	mov	r3, r3, lsl #2
21f26524:	e0822003 	add	r2, r2, r3
21f26528:	e51b3038 	ldr	r3, [fp, #-56]
21f2652c:	e2033007 	and	r3, r3, #7	; 0x7
21f26530:	e5823000 	str	r3, [r2]
21f26534:	e2812001 	add	r2, r1, #1	; 0x1
21f26538:	e51b3060 	ldr	r3, [fp, #-96]
21f2653c:	e5832008 	str	r2, [r3, #8]
	DUMPBITS(3)
21f26540:	e51b3038 	ldr	r3, [fp, #-56]
21f26544:	e1a031a3 	mov	r3, r3, lsr #3
21f26548:	e50b3038 	str	r3, [fp, #-56]
21f2654c:	e51b3034 	ldr	r3, [fp, #-52]
21f26550:	e2433003 	sub	r3, r3, #3	; 0x3
21f26554:	e50b3034 	str	r3, [fp, #-52]
21f26558:	e51b3060 	ldr	r3, [fp, #-96]
21f2655c:	e5932008 	ldr	r2, [r3, #8]
21f26560:	e51b3060 	ldr	r3, [fp, #-96]
21f26564:	e5933004 	ldr	r3, [r3, #4]
21f26568:	e1a03523 	mov	r3, r3, lsr #10
21f2656c:	e2833004 	add	r3, r3, #4	; 0x4
21f26570:	e1520003 	cmp	r2, r3
21f26574:	3affffe0 	bcc	21f264fc <.text+0x264fc>
21f26578:	ea00000c 	b	21f265b0 <.text+0x265b0>
      }
      while (s->sub.trees.index < 19)
	s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
21f2657c:	e51b3060 	ldr	r3, [fp, #-96]
21f26580:	e593200c 	ldr	r2, [r3, #12]
21f26584:	e51b3060 	ldr	r3, [fp, #-96]
21f26588:	e5931008 	ldr	r1, [r3, #8]
21f2658c:	e59f33fc 	ldr	r3, [pc, #1020]	; 21f26990 <.text+0x26990>
21f26590:	e7933101 	ldr	r3, [r3, r1, lsl #2]
21f26594:	e1a03103 	mov	r3, r3, lsl #2
21f26598:	e0822003 	add	r2, r2, r3
21f2659c:	e3a03000 	mov	r3, #0	; 0x0
21f265a0:	e5823000 	str	r3, [r2]
21f265a4:	e2812001 	add	r2, r1, #1	; 0x1
21f265a8:	e51b3060 	ldr	r3, [fp, #-96]
21f265ac:	e5832008 	str	r2, [r3, #8]
21f265b0:	e51b3060 	ldr	r3, [fp, #-96]
21f265b4:	e5933008 	ldr	r3, [r3, #8]
21f265b8:	e3530012 	cmp	r3, #18	; 0x12
21f265bc:	9affffee 	bls	21f2657c <.text+0x2657c>
      s->sub.trees.bb = 7;
21f265c0:	e51b2060 	ldr	r2, [fp, #-96]
21f265c4:	e3a03007 	mov	r3, #7	; 0x7
21f265c8:	e5823010 	str	r3, [r2, #16]
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
21f265cc:	e51b3060 	ldr	r3, [fp, #-96]
21f265d0:	e593200c 	ldr	r2, [r3, #12]
21f265d4:	e51b3060 	ldr	r3, [fp, #-96]
21f265d8:	e2831010 	add	r1, r3, #16	; 0x10
21f265dc:	e51b3060 	ldr	r3, [fp, #-96]
21f265e0:	e2833014 	add	r3, r3, #20	; 0x14
21f265e4:	e1a00002 	mov	r0, r2
21f265e8:	e1a02003 	mov	r2, r3
21f265ec:	e51b3064 	ldr	r3, [fp, #-100]
21f265f0:	eb00070c 	bl	21f28228 <inflate_trees_bits>
21f265f4:	e1a03000 	mov	r3, r0
21f265f8:	e50b303c 	str	r3, [fp, #-60]
			     &s->sub.trees.tb, z);
      if (t != Z_OK)
21f265fc:	e51b303c 	ldr	r3, [fp, #-60]
21f26600:	e3530000 	cmp	r3, #0	; 0x0
21f26604:	0a000026 	beq	21f266a4 <.text+0x266a4>
      {
	r = t;
21f26608:	e51b303c 	ldr	r3, [fp, #-60]
21f2660c:	e50b3068 	str	r3, [fp, #-104]
	if (r == Z_DATA_ERROR)
21f26610:	e51b3068 	ldr	r3, [fp, #-104]
21f26614:	e3730003 	cmn	r3, #3	; 0x3
21f26618:	1a000002 	bne	21f26628 <.text+0x26628>
	  s->mode = BADB;
21f2661c:	e51b2060 	ldr	r2, [fp, #-96]
21f26620:	e3a03009 	mov	r3, #9	; 0x9
21f26624:	e5823000 	str	r3, [r2]
	LEAVE
21f26628:	e51b2060 	ldr	r2, [fp, #-96]
21f2662c:	e51b3038 	ldr	r3, [fp, #-56]
21f26630:	e5823024 	str	r3, [r2, #36]
21f26634:	e51b2060 	ldr	r2, [fp, #-96]
21f26638:	e51b3034 	ldr	r3, [fp, #-52]
21f2663c:	e5823020 	str	r3, [r2, #32]
21f26640:	e51b2064 	ldr	r2, [fp, #-100]
21f26644:	e51b302c 	ldr	r3, [fp, #-44]
21f26648:	e5823004 	str	r3, [r2, #4]
21f2664c:	e51b3064 	ldr	r3, [fp, #-100]
21f26650:	e5931008 	ldr	r1, [r3, #8]
21f26654:	e51b2030 	ldr	r2, [fp, #-48]
21f26658:	e51b3064 	ldr	r3, [fp, #-100]
21f2665c:	e5933000 	ldr	r3, [r3]
21f26660:	e0633002 	rsb	r3, r3, r2
21f26664:	e0812003 	add	r2, r1, r3
21f26668:	e51b3064 	ldr	r3, [fp, #-100]
21f2666c:	e5832008 	str	r2, [r3, #8]
21f26670:	e51b2064 	ldr	r2, [fp, #-100]
21f26674:	e51b3030 	ldr	r3, [fp, #-48]
21f26678:	e5823000 	str	r3, [r2]
21f2667c:	e51b2060 	ldr	r2, [fp, #-96]
21f26680:	e51b3028 	ldr	r3, [fp, #-40]
21f26684:	e5823034 	str	r3, [r2, #52]
21f26688:	e51b0060 	ldr	r0, [fp, #-96]
21f2668c:	e51b1064 	ldr	r1, [fp, #-100]
21f26690:	e51b2068 	ldr	r2, [fp, #-104]
21f26694:	eb000daf 	bl	21f29d58 <inflate_flush>
21f26698:	e1a03000 	mov	r3, r0
21f2669c:	e50b3094 	str	r3, [fp, #-148]
21f266a0:	ea00030f 	b	21f272e4 <.text+0x272e4>
      }
      s->sub.trees.index = 0;
21f266a4:	e51b2060 	ldr	r2, [fp, #-96]
21f266a8:	e3a03000 	mov	r3, #0	; 0x0
21f266ac:	e5823008 	str	r3, [r2, #8]
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
21f266b0:	e51b2060 	ldr	r2, [fp, #-96]
21f266b4:	e3a03005 	mov	r3, #5	; 0x5
21f266b8:	e5823000 	str	r3, [r2]
21f266bc:	ea000137 	b	21f26ba0 <.text+0x26ba0>
    case DTREE:
      while (t = s->sub.trees.table,
	     s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
      {
	inflate_huft *h;
	uInt i, j, c;

	t = s->sub.trees.bb;
21f266c0:	e51b3060 	ldr	r3, [fp, #-96]
21f266c4:	e5933010 	ldr	r3, [r3, #16]
21f266c8:	e50b303c 	str	r3, [fp, #-60]
	NEEDBITS(t)
21f266cc:	ea000035 	b	21f267a8 <.text+0x267a8>
21f266d0:	e51b302c 	ldr	r3, [fp, #-44]
21f266d4:	e3530000 	cmp	r3, #0	; 0x0
21f266d8:	0a000013 	beq	21f2672c <.text+0x2672c>
21f266dc:	e3a03000 	mov	r3, #0	; 0x0
21f266e0:	e50b3068 	str	r3, [fp, #-104]
21f266e4:	e51b302c 	ldr	r3, [fp, #-44]
21f266e8:	e2433001 	sub	r3, r3, #1	; 0x1
21f266ec:	e50b302c 	str	r3, [fp, #-44]
21f266f0:	e51b3030 	ldr	r3, [fp, #-48]
21f266f4:	e5d33000 	ldrb	r3, [r3]
21f266f8:	e1a02003 	mov	r2, r3
21f266fc:	e51b3034 	ldr	r3, [fp, #-52]
21f26700:	e1a02312 	mov	r2, r2, lsl r3
21f26704:	e51b3038 	ldr	r3, [fp, #-56]
21f26708:	e1833002 	orr	r3, r3, r2
21f2670c:	e50b3038 	str	r3, [fp, #-56]
21f26710:	e51b3030 	ldr	r3, [fp, #-48]
21f26714:	e2833001 	add	r3, r3, #1	; 0x1
21f26718:	e50b3030 	str	r3, [fp, #-48]
21f2671c:	e51b3034 	ldr	r3, [fp, #-52]
21f26720:	e2833008 	add	r3, r3, #8	; 0x8
21f26724:	e50b3034 	str	r3, [fp, #-52]
21f26728:	ea00001e 	b	21f267a8 <.text+0x267a8>
21f2672c:	e51b2060 	ldr	r2, [fp, #-96]
21f26730:	e51b3038 	ldr	r3, [fp, #-56]
21f26734:	e5823024 	str	r3, [r2, #36]
21f26738:	e51b2060 	ldr	r2, [fp, #-96]
21f2673c:	e51b3034 	ldr	r3, [fp, #-52]
21f26740:	e5823020 	str	r3, [r2, #32]
21f26744:	e51b2064 	ldr	r2, [fp, #-100]
21f26748:	e51b302c 	ldr	r3, [fp, #-44]
21f2674c:	e5823004 	str	r3, [r2, #4]
21f26750:	e51b3064 	ldr	r3, [fp, #-100]
21f26754:	e5931008 	ldr	r1, [r3, #8]
21f26758:	e51b2030 	ldr	r2, [fp, #-48]
21f2675c:	e51b3064 	ldr	r3, [fp, #-100]
21f26760:	e5933000 	ldr	r3, [r3]
21f26764:	e0633002 	rsb	r3, r3, r2
21f26768:	e0812003 	add	r2, r1, r3
21f2676c:	e51b3064 	ldr	r3, [fp, #-100]
21f26770:	e5832008 	str	r2, [r3, #8]
21f26774:	e51b2064 	ldr	r2, [fp, #-100]
21f26778:	e51b3030 	ldr	r3, [fp, #-48]
21f2677c:	e5823000 	str	r3, [r2]
21f26780:	e51b2060 	ldr	r2, [fp, #-96]
21f26784:	e51b3028 	ldr	r3, [fp, #-40]
21f26788:	e5823034 	str	r3, [r2, #52]
21f2678c:	e51b0060 	ldr	r0, [fp, #-96]
21f26790:	e51b1064 	ldr	r1, [fp, #-100]
21f26794:	e51b2068 	ldr	r2, [fp, #-104]
21f26798:	eb000d6e 	bl	21f29d58 <inflate_flush>
21f2679c:	e1a03000 	mov	r3, r0
21f267a0:	e50b3094 	str	r3, [fp, #-148]
21f267a4:	ea0002ce 	b	21f272e4 <.text+0x272e4>
21f267a8:	e51b2034 	ldr	r2, [fp, #-52]
21f267ac:	e51b303c 	ldr	r3, [fp, #-60]
21f267b0:	e1520003 	cmp	r2, r3
21f267b4:	3affffc5 	bcc	21f266d0 <.text+0x266d0>
	h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
21f267b8:	e51b3060 	ldr	r3, [fp, #-96]
21f267bc:	e5931014 	ldr	r1, [r3, #20]
21f267c0:	e51b203c 	ldr	r2, [fp, #-60]
21f267c4:	e59f31c8 	ldr	r3, [pc, #456]	; 21f26994 <.text+0x26994>
21f267c8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f267cc:	e51b3038 	ldr	r3, [fp, #-56]
21f267d0:	e0023003 	and	r3, r2, r3
21f267d4:	e1a03183 	mov	r3, r3, lsl #3
21f267d8:	e0813003 	add	r3, r1, r3
21f267dc:	e50b3020 	str	r3, [fp, #-32]
	t = h->word.what.Bits;
21f267e0:	e51b3020 	ldr	r3, [fp, #-32]
21f267e4:	e5d33001 	ldrb	r3, [r3, #1]
21f267e8:	e50b303c 	str	r3, [fp, #-60]
	c = h->more.Base;
21f267ec:	e51b3020 	ldr	r3, [fp, #-32]
21f267f0:	e5933004 	ldr	r3, [r3, #4]
21f267f4:	e50b3014 	str	r3, [fp, #-20]
	if (c < 16)
21f267f8:	e51b3014 	ldr	r3, [fp, #-20]
21f267fc:	e353000f 	cmp	r3, #15	; 0xf
21f26800:	8a000013 	bhi	21f26854 <.text+0x26854>
	{
	  DUMPBITS(t)
21f26804:	e51b203c 	ldr	r2, [fp, #-60]
21f26808:	e51b3038 	ldr	r3, [fp, #-56]
21f2680c:	e1a03233 	mov	r3, r3, lsr r2
21f26810:	e50b3038 	str	r3, [fp, #-56]
21f26814:	e51b2034 	ldr	r2, [fp, #-52]
21f26818:	e51b303c 	ldr	r3, [fp, #-60]
21f2681c:	e0633002 	rsb	r3, r3, r2
21f26820:	e50b3034 	str	r3, [fp, #-52]
	  s->sub.trees.blens[s->sub.trees.index++] = c;
21f26824:	e51b3060 	ldr	r3, [fp, #-96]
21f26828:	e593200c 	ldr	r2, [r3, #12]
21f2682c:	e51b3060 	ldr	r3, [fp, #-96]
21f26830:	e5931008 	ldr	r1, [r3, #8]
21f26834:	e1a03101 	mov	r3, r1, lsl #2
21f26838:	e0822003 	add	r2, r2, r3
21f2683c:	e51b3014 	ldr	r3, [fp, #-20]
21f26840:	e5823000 	str	r3, [r2]
21f26844:	e2812001 	add	r2, r1, #1	; 0x1
21f26848:	e51b3060 	ldr	r3, [fp, #-96]
21f2684c:	e5832008 	str	r2, [r3, #8]
21f26850:	ea0000d2 	b	21f26ba0 <.text+0x26ba0>
	}
	else /* c == 16..18 */
	{
	  i = c == 18 ? 7 : c - 14;
21f26854:	e51b3014 	ldr	r3, [fp, #-20]
21f26858:	e3530012 	cmp	r3, #18	; 0x12
21f2685c:	0a000003 	beq	21f26870 <.text+0x26870>
21f26860:	e51b3014 	ldr	r3, [fp, #-20]
21f26864:	e243300e 	sub	r3, r3, #14	; 0xe
21f26868:	e50b307c 	str	r3, [fp, #-124]
21f2686c:	ea000001 	b	21f26878 <.text+0x26878>
21f26870:	e3a03007 	mov	r3, #7	; 0x7
21f26874:	e50b307c 	str	r3, [fp, #-124]
21f26878:	e51b207c 	ldr	r2, [fp, #-124]
21f2687c:	e50b201c 	str	r2, [fp, #-28]
	  j = c == 18 ? 11 : 3;
21f26880:	e51b3014 	ldr	r3, [fp, #-20]
21f26884:	e3530012 	cmp	r3, #18	; 0x12
21f26888:	1a000002 	bne	21f26898 <.text+0x26898>
21f2688c:	e3a0300b 	mov	r3, #11	; 0xb
21f26890:	e50b3078 	str	r3, [fp, #-120]
21f26894:	ea000001 	b	21f268a0 <.text+0x268a0>
21f26898:	e3a02003 	mov	r2, #3	; 0x3
21f2689c:	e50b2078 	str	r2, [fp, #-120]
21f268a0:	e51b3078 	ldr	r3, [fp, #-120]
21f268a4:	e50b3018 	str	r3, [fp, #-24]
	  NEEDBITS(t + i)
21f268a8:	ea00003b 	b	21f2699c <.text+0x2699c>
21f268ac:	e51b302c 	ldr	r3, [fp, #-44]
21f268b0:	e3530000 	cmp	r3, #0	; 0x0
21f268b4:	0a000013 	beq	21f26908 <.text+0x26908>
21f268b8:	e3a03000 	mov	r3, #0	; 0x0
21f268bc:	e50b3068 	str	r3, [fp, #-104]
21f268c0:	e51b302c 	ldr	r3, [fp, #-44]
21f268c4:	e2433001 	sub	r3, r3, #1	; 0x1
21f268c8:	e50b302c 	str	r3, [fp, #-44]
21f268cc:	e51b3030 	ldr	r3, [fp, #-48]
21f268d0:	e5d33000 	ldrb	r3, [r3]
21f268d4:	e1a02003 	mov	r2, r3
21f268d8:	e51b3034 	ldr	r3, [fp, #-52]
21f268dc:	e1a02312 	mov	r2, r2, lsl r3
21f268e0:	e51b3038 	ldr	r3, [fp, #-56]
21f268e4:	e1833002 	orr	r3, r3, r2
21f268e8:	e50b3038 	str	r3, [fp, #-56]
21f268ec:	e51b3030 	ldr	r3, [fp, #-48]
21f268f0:	e2833001 	add	r3, r3, #1	; 0x1
21f268f4:	e50b3030 	str	r3, [fp, #-48]
21f268f8:	e51b3034 	ldr	r3, [fp, #-52]
21f268fc:	e2833008 	add	r3, r3, #8	; 0x8
21f26900:	e50b3034 	str	r3, [fp, #-52]
21f26904:	ea000024 	b	21f2699c <.text+0x2699c>
21f26908:	e51b2060 	ldr	r2, [fp, #-96]
21f2690c:	e51b3038 	ldr	r3, [fp, #-56]
21f26910:	e5823024 	str	r3, [r2, #36]
21f26914:	e51b2060 	ldr	r2, [fp, #-96]
21f26918:	e51b3034 	ldr	r3, [fp, #-52]
21f2691c:	e5823020 	str	r3, [r2, #32]
21f26920:	e51b2064 	ldr	r2, [fp, #-100]
21f26924:	e51b302c 	ldr	r3, [fp, #-44]
21f26928:	e5823004 	str	r3, [r2, #4]
21f2692c:	e51b3064 	ldr	r3, [fp, #-100]
21f26930:	e5931008 	ldr	r1, [r3, #8]
21f26934:	e51b2030 	ldr	r2, [fp, #-48]
21f26938:	e51b3064 	ldr	r3, [fp, #-100]
21f2693c:	e5933000 	ldr	r3, [r3]
21f26940:	e0633002 	rsb	r3, r3, r2
21f26944:	e0812003 	add	r2, r1, r3
21f26948:	e51b3064 	ldr	r3, [fp, #-100]
21f2694c:	e5832008 	str	r2, [r3, #8]
21f26950:	e51b2064 	ldr	r2, [fp, #-100]
21f26954:	e51b3030 	ldr	r3, [fp, #-48]
21f26958:	e5823000 	str	r3, [r2]
21f2695c:	e51b2060 	ldr	r2, [fp, #-96]
21f26960:	e51b3028 	ldr	r3, [fp, #-40]
21f26964:	e5823034 	str	r3, [r2, #52]
21f26968:	e51b0060 	ldr	r0, [fp, #-96]
21f2696c:	e51b1064 	ldr	r1, [fp, #-100]
21f26970:	e51b2068 	ldr	r2, [fp, #-104]
21f26974:	eb000cf7 	bl	21f29d58 <inflate_flush>
21f26978:	e1a03000 	mov	r3, r0
21f2697c:	e50b3094 	str	r3, [fp, #-148]
21f26980:	ea000257 	b	21f272e4 <.text+0x272e4>
21f26984:	21f32d4c 	mvncss	r2, ip, asr #26
21f26988:	21f32d60 	mvncss	r2, r0, ror #26
21f2698c:	21f32d80 	mvncss	r2, r0, lsl #27
21f26990:	21f33a18 	mvncss	r3, r8, lsl sl
21f26994:	21f339d4 	ldrcssb	r3, [r3, #148]!
21f26998:	21f32da4 	mvncss	r2, r4, lsr #27
21f2699c:	e51b203c 	ldr	r2, [fp, #-60]
21f269a0:	e51b301c 	ldr	r3, [fp, #-28]
21f269a4:	e0822003 	add	r2, r2, r3
21f269a8:	e51b3034 	ldr	r3, [fp, #-52]
21f269ac:	e1520003 	cmp	r2, r3
21f269b0:	8affffbd 	bhi	21f268ac <.text+0x268ac>
	  DUMPBITS(t)
21f269b4:	e51b203c 	ldr	r2, [fp, #-60]
21f269b8:	e51b3038 	ldr	r3, [fp, #-56]
21f269bc:	e1a03233 	mov	r3, r3, lsr r2
21f269c0:	e50b3038 	str	r3, [fp, #-56]
21f269c4:	e51b2034 	ldr	r2, [fp, #-52]
21f269c8:	e51b303c 	ldr	r3, [fp, #-60]
21f269cc:	e0633002 	rsb	r3, r3, r2
21f269d0:	e50b3034 	str	r3, [fp, #-52]
	  j += (uInt)b & inflate_mask[i];
21f269d4:	e51b201c 	ldr	r2, [fp, #-28]
21f269d8:	e51f304c 	ldr	r3, [pc, #-76]	; 21f26994 <.text+0x26994>
21f269dc:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f269e0:	e51b3038 	ldr	r3, [fp, #-56]
21f269e4:	e0022003 	and	r2, r2, r3
21f269e8:	e51b3018 	ldr	r3, [fp, #-24]
21f269ec:	e0833002 	add	r3, r3, r2
21f269f0:	e50b3018 	str	r3, [fp, #-24]
	  DUMPBITS(i)
21f269f4:	e51b201c 	ldr	r2, [fp, #-28]
21f269f8:	e51b3038 	ldr	r3, [fp, #-56]
21f269fc:	e1a03233 	mov	r3, r3, lsr r2
21f26a00:	e50b3038 	str	r3, [fp, #-56]
21f26a04:	e51b2034 	ldr	r2, [fp, #-52]
21f26a08:	e51b301c 	ldr	r3, [fp, #-28]
21f26a0c:	e0633002 	rsb	r3, r3, r2
21f26a10:	e50b3034 	str	r3, [fp, #-52]
	  i = s->sub.trees.index;
21f26a14:	e51b3060 	ldr	r3, [fp, #-96]
21f26a18:	e5933008 	ldr	r3, [r3, #8]
21f26a1c:	e50b301c 	str	r3, [fp, #-28]
	  t = s->sub.trees.table;
21f26a20:	e51b3060 	ldr	r3, [fp, #-96]
21f26a24:	e5933004 	ldr	r3, [r3, #4]
21f26a28:	e50b303c 	str	r3, [fp, #-60]
	  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
21f26a2c:	e51b201c 	ldr	r2, [fp, #-28]
21f26a30:	e51b3018 	ldr	r3, [fp, #-24]
21f26a34:	e0821003 	add	r1, r2, r3
21f26a38:	e51b303c 	ldr	r3, [fp, #-60]
21f26a3c:	e203201f 	and	r2, r3, #31	; 0x1f
21f26a40:	e51b303c 	ldr	r3, [fp, #-60]
21f26a44:	e1a032a3 	mov	r3, r3, lsr #5
21f26a48:	e203301f 	and	r3, r3, #31	; 0x1f
21f26a4c:	e0823003 	add	r3, r2, r3
21f26a50:	e2833c01 	add	r3, r3, #256	; 0x100
21f26a54:	e2833002 	add	r3, r3, #2	; 0x2
21f26a58:	e1510003 	cmp	r1, r3
21f26a5c:	8a000005 	bhi	21f26a78 <.text+0x26a78>
21f26a60:	e51b3014 	ldr	r3, [fp, #-20]
21f26a64:	e3530010 	cmp	r3, #16	; 0x10
21f26a68:	1a000029 	bne	21f26b14 <.text+0x26b14>
21f26a6c:	e51b301c 	ldr	r3, [fp, #-28]
21f26a70:	e3530000 	cmp	r3, #0	; 0x0
21f26a74:	1a000026 	bne	21f26b14 <.text+0x26b14>
	      (c == 16 && i < 1))
	  {
	    s->mode = BADB;
21f26a78:	e51b2060 	ldr	r2, [fp, #-96]
21f26a7c:	e3a03009 	mov	r3, #9	; 0x9
21f26a80:	e5823000 	str	r3, [r2]
	    z->msg = "invalid bit length repeat";
21f26a84:	e51b2064 	ldr	r2, [fp, #-100]
21f26a88:	e51f30f8 	ldr	r3, [pc, #-248]	; 21f26998 <.text+0x26998>
21f26a8c:	e5823018 	str	r3, [r2, #24]
	    r = Z_DATA_ERROR;
21f26a90:	e3e03002 	mvn	r3, #2	; 0x2
21f26a94:	e50b3068 	str	r3, [fp, #-104]
	    LEAVE
21f26a98:	e51b2060 	ldr	r2, [fp, #-96]
21f26a9c:	e51b3038 	ldr	r3, [fp, #-56]
21f26aa0:	e5823024 	str	r3, [r2, #36]
21f26aa4:	e51b2060 	ldr	r2, [fp, #-96]
21f26aa8:	e51b3034 	ldr	r3, [fp, #-52]
21f26aac:	e5823020 	str	r3, [r2, #32]
21f26ab0:	e51b2064 	ldr	r2, [fp, #-100]
21f26ab4:	e51b302c 	ldr	r3, [fp, #-44]
21f26ab8:	e5823004 	str	r3, [r2, #4]
21f26abc:	e51b3064 	ldr	r3, [fp, #-100]
21f26ac0:	e5931008 	ldr	r1, [r3, #8]
21f26ac4:	e51b2030 	ldr	r2, [fp, #-48]
21f26ac8:	e51b3064 	ldr	r3, [fp, #-100]
21f26acc:	e5933000 	ldr	r3, [r3]
21f26ad0:	e0633002 	rsb	r3, r3, r2
21f26ad4:	e0812003 	add	r2, r1, r3
21f26ad8:	e51b3064 	ldr	r3, [fp, #-100]
21f26adc:	e5832008 	str	r2, [r3, #8]
21f26ae0:	e51b2064 	ldr	r2, [fp, #-100]
21f26ae4:	e51b3030 	ldr	r3, [fp, #-48]
21f26ae8:	e5823000 	str	r3, [r2]
21f26aec:	e51b2060 	ldr	r2, [fp, #-96]
21f26af0:	e51b3028 	ldr	r3, [fp, #-40]
21f26af4:	e5823034 	str	r3, [r2, #52]
21f26af8:	e51b0060 	ldr	r0, [fp, #-96]
21f26afc:	e51b1064 	ldr	r1, [fp, #-100]
21f26b00:	e51b2068 	ldr	r2, [fp, #-104]
21f26b04:	eb000c93 	bl	21f29d58 <inflate_flush>
21f26b08:	e1a03000 	mov	r3, r0
21f26b0c:	e50b3094 	str	r3, [fp, #-148]
21f26b10:	ea0001f3 	b	21f272e4 <.text+0x272e4>
	  }
	  c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
21f26b14:	e51b3014 	ldr	r3, [fp, #-20]
21f26b18:	e3530010 	cmp	r3, #16	; 0x10
21f26b1c:	1a000008 	bne	21f26b44 <.text+0x26b44>
21f26b20:	e51b3060 	ldr	r3, [fp, #-96]
21f26b24:	e593200c 	ldr	r2, [r3, #12]
21f26b28:	e51b301c 	ldr	r3, [fp, #-28]
21f26b2c:	e1a03103 	mov	r3, r3, lsl #2
21f26b30:	e0823003 	add	r3, r2, r3
21f26b34:	e2433004 	sub	r3, r3, #4	; 0x4
21f26b38:	e5933000 	ldr	r3, [r3]
21f26b3c:	e50b3074 	str	r3, [fp, #-116]
21f26b40:	ea000001 	b	21f26b4c <.text+0x26b4c>
21f26b44:	e3a02000 	mov	r2, #0	; 0x0
21f26b48:	e50b2074 	str	r2, [fp, #-116]
21f26b4c:	e51b3074 	ldr	r3, [fp, #-116]
21f26b50:	e50b3014 	str	r3, [fp, #-20]
	  do {
	    s->sub.trees.blens[i++] = c;
21f26b54:	e51b3060 	ldr	r3, [fp, #-96]
21f26b58:	e593200c 	ldr	r2, [r3, #12]
21f26b5c:	e51b301c 	ldr	r3, [fp, #-28]
21f26b60:	e1a03103 	mov	r3, r3, lsl #2
21f26b64:	e0822003 	add	r2, r2, r3
21f26b68:	e51b3014 	ldr	r3, [fp, #-20]
21f26b6c:	e5823000 	str	r3, [r2]
21f26b70:	e51b301c 	ldr	r3, [fp, #-28]
21f26b74:	e2833001 	add	r3, r3, #1	; 0x1
21f26b78:	e50b301c 	str	r3, [fp, #-28]
	  } while (--j);
21f26b7c:	e51b3018 	ldr	r3, [fp, #-24]
21f26b80:	e2433001 	sub	r3, r3, #1	; 0x1
21f26b84:	e50b3018 	str	r3, [fp, #-24]
21f26b88:	e51b3018 	ldr	r3, [fp, #-24]
21f26b8c:	e3530000 	cmp	r3, #0	; 0x0
21f26b90:	1affffef 	bne	21f26b54 <.text+0x26b54>
	  s->sub.trees.index = i;
21f26b94:	e51b2060 	ldr	r2, [fp, #-96]
21f26b98:	e51b301c 	ldr	r3, [fp, #-28]
21f26b9c:	e5823008 	str	r3, [r2, #8]
21f26ba0:	e51b3060 	ldr	r3, [fp, #-96]
21f26ba4:	e5933004 	ldr	r3, [r3, #4]
21f26ba8:	e50b303c 	str	r3, [fp, #-60]
21f26bac:	e51b3060 	ldr	r3, [fp, #-96]
21f26bb0:	e5931008 	ldr	r1, [r3, #8]
21f26bb4:	e51b303c 	ldr	r3, [fp, #-60]
21f26bb8:	e203201f 	and	r2, r3, #31	; 0x1f
21f26bbc:	e51b303c 	ldr	r3, [fp, #-60]
21f26bc0:	e1a032a3 	mov	r3, r3, lsr #5
21f26bc4:	e203301f 	and	r3, r3, #31	; 0x1f
21f26bc8:	e0823003 	add	r3, r2, r3
21f26bcc:	e2833c01 	add	r3, r3, #256	; 0x100
21f26bd0:	e2833002 	add	r3, r3, #2	; 0x2
21f26bd4:	e1510003 	cmp	r1, r3
21f26bd8:	3afffeb8 	bcc	21f266c0 <.text+0x266c0>
	}
      }
      inflate_trees_free(s->sub.trees.tb, z);
21f26bdc:	e51b3060 	ldr	r3, [fp, #-96]
21f26be0:	e5933014 	ldr	r3, [r3, #20]
21f26be4:	e1a00003 	mov	r0, r3
21f26be8:	e51b1064 	ldr	r1, [fp, #-100]
21f26bec:	eb000724 	bl	21f28884 <inflate_trees_free>
      s->sub.trees.tb = Z_NULL;
21f26bf0:	e51b2060 	ldr	r2, [fp, #-96]
21f26bf4:	e3a03000 	mov	r3, #0	; 0x0
21f26bf8:	e5823014 	str	r3, [r2, #20]
      {
	uInt bl, bd;
	inflate_huft *tl, *td;
	inflate_codes_statef *c;

	bl = 9;         /* must be <= 9 for lookahead assumptions */
21f26bfc:	e3a03009 	mov	r3, #9	; 0x9
21f26c00:	e50b3050 	str	r3, [fp, #-80]
	bd = 6;         /* must be <= 9 for lookahead assumptions */
21f26c04:	e3a03006 	mov	r3, #6	; 0x6
21f26c08:	e50b3054 	str	r3, [fp, #-84]
	t = s->sub.trees.table;
21f26c0c:	e51b3060 	ldr	r3, [fp, #-96]
21f26c10:	e5933004 	ldr	r3, [r3, #4]
21f26c14:	e50b303c 	str	r3, [fp, #-60]
	t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
21f26c18:	e51b303c 	ldr	r3, [fp, #-60]
21f26c1c:	e203301f 	and	r3, r3, #31	; 0x1f
21f26c20:	e2832c01 	add	r2, r3, #256	; 0x100
21f26c24:	e2822001 	add	r2, r2, #1	; 0x1
21f26c28:	e51b303c 	ldr	r3, [fp, #-60]
21f26c2c:	e1a032a3 	mov	r3, r3, lsr #5
21f26c30:	e203301f 	and	r3, r3, #31	; 0x1f
21f26c34:	e2831001 	add	r1, r3, #1	; 0x1
21f26c38:	e51b3060 	ldr	r3, [fp, #-96]
21f26c3c:	e593c00c 	ldr	ip, [r3, #12]
21f26c40:	e24be050 	sub	lr, fp, #80	; 0x50
21f26c44:	e24b3054 	sub	r3, fp, #84	; 0x54
21f26c48:	e58d3000 	str	r3, [sp]
21f26c4c:	e24b3058 	sub	r3, fp, #88	; 0x58
21f26c50:	e58d3004 	str	r3, [sp, #4]
21f26c54:	e24b305c 	sub	r3, fp, #92	; 0x5c
21f26c58:	e58d3008 	str	r3, [sp, #8]
21f26c5c:	e51b3064 	ldr	r3, [fp, #-100]
21f26c60:	e58d300c 	str	r3, [sp, #12]
21f26c64:	e1a00002 	mov	r0, r2
21f26c68:	e1a0200c 	mov	r2, ip
21f26c6c:	e1a0300e 	mov	r3, lr
21f26c70:	eb00059d 	bl	21f282ec <inflate_trees_dynamic>
21f26c74:	e1a03000 	mov	r3, r0
21f26c78:	e50b303c 	str	r3, [fp, #-60]
				  s->sub.trees.blens, &bl, &bd, &tl, &td, z);
	if (t != Z_OK)
21f26c7c:	e51b303c 	ldr	r3, [fp, #-60]
21f26c80:	e3530000 	cmp	r3, #0	; 0x0
21f26c84:	0a000026 	beq	21f26d24 <.text+0x26d24>
	{
	  if (t == (uInt)Z_DATA_ERROR)
21f26c88:	e51b303c 	ldr	r3, [fp, #-60]
21f26c8c:	e3730003 	cmn	r3, #3	; 0x3
21f26c90:	1a000002 	bne	21f26ca0 <.text+0x26ca0>
	    s->mode = BADB;
21f26c94:	e51b2060 	ldr	r2, [fp, #-96]
21f26c98:	e3a03009 	mov	r3, #9	; 0x9
21f26c9c:	e5823000 	str	r3, [r2]
	  r = t;
21f26ca0:	e51b303c 	ldr	r3, [fp, #-60]
21f26ca4:	e50b3068 	str	r3, [fp, #-104]
	  LEAVE
21f26ca8:	e51b2060 	ldr	r2, [fp, #-96]
21f26cac:	e51b3038 	ldr	r3, [fp, #-56]
21f26cb0:	e5823024 	str	r3, [r2, #36]
21f26cb4:	e51b2060 	ldr	r2, [fp, #-96]
21f26cb8:	e51b3034 	ldr	r3, [fp, #-52]
21f26cbc:	e5823020 	str	r3, [r2, #32]
21f26cc0:	e51b2064 	ldr	r2, [fp, #-100]
21f26cc4:	e51b302c 	ldr	r3, [fp, #-44]
21f26cc8:	e5823004 	str	r3, [r2, #4]
21f26ccc:	e51b3064 	ldr	r3, [fp, #-100]
21f26cd0:	e5931008 	ldr	r1, [r3, #8]
21f26cd4:	e51b2030 	ldr	r2, [fp, #-48]
21f26cd8:	e51b3064 	ldr	r3, [fp, #-100]
21f26cdc:	e5933000 	ldr	r3, [r3]
21f26ce0:	e0633002 	rsb	r3, r3, r2
21f26ce4:	e0812003 	add	r2, r1, r3
21f26ce8:	e51b3064 	ldr	r3, [fp, #-100]
21f26cec:	e5832008 	str	r2, [r3, #8]
21f26cf0:	e51b2064 	ldr	r2, [fp, #-100]
21f26cf4:	e51b3030 	ldr	r3, [fp, #-48]
21f26cf8:	e5823000 	str	r3, [r2]
21f26cfc:	e51b2060 	ldr	r2, [fp, #-96]
21f26d00:	e51b3028 	ldr	r3, [fp, #-40]
21f26d04:	e5823034 	str	r3, [r2, #52]
21f26d08:	e51b0060 	ldr	r0, [fp, #-96]
21f26d0c:	e51b1064 	ldr	r1, [fp, #-100]
21f26d10:	e51b2068 	ldr	r2, [fp, #-104]
21f26d14:	eb000c0f 	bl	21f29d58 <inflate_flush>
21f26d18:	e1a03000 	mov	r3, r0
21f26d1c:	e50b3094 	str	r3, [fp, #-148]
21f26d20:	ea00016f 	b	21f272e4 <.text+0x272e4>
	}
	Tracev((stderr, "inflate:       trees ok\n"));
	if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
21f26d24:	e51b2050 	ldr	r2, [fp, #-80]
21f26d28:	e51b1054 	ldr	r1, [fp, #-84]
21f26d2c:	e51bc058 	ldr	ip, [fp, #-88]
21f26d30:	e51be05c 	ldr	lr, [fp, #-92]
21f26d34:	e51b3064 	ldr	r3, [fp, #-100]
21f26d38:	e58d3000 	str	r3, [sp]
21f26d3c:	e1a00002 	mov	r0, r2
21f26d40:	e1a0200c 	mov	r2, ip
21f26d44:	e1a0300e 	mov	r3, lr
21f26d48:	eb0006ef 	bl	21f2890c <inflate_codes_new>
21f26d4c:	e1a03000 	mov	r3, r0
21f26d50:	e50b3010 	str	r3, [fp, #-16]
21f26d54:	e51b3010 	ldr	r3, [fp, #-16]
21f26d58:	e3530000 	cmp	r3, #0	; 0x0
21f26d5c:	1a000028 	bne	21f26e04 <.text+0x26e04>
	{
	  inflate_trees_free(td, z);
21f26d60:	e51b305c 	ldr	r3, [fp, #-92]
21f26d64:	e1a00003 	mov	r0, r3
21f26d68:	e51b1064 	ldr	r1, [fp, #-100]
21f26d6c:	eb0006c4 	bl	21f28884 <inflate_trees_free>
	  inflate_trees_free(tl, z);
21f26d70:	e51b3058 	ldr	r3, [fp, #-88]
21f26d74:	e1a00003 	mov	r0, r3
21f26d78:	e51b1064 	ldr	r1, [fp, #-100]
21f26d7c:	eb0006c0 	bl	21f28884 <inflate_trees_free>
	  r = Z_MEM_ERROR;
21f26d80:	e3e03003 	mvn	r3, #3	; 0x3
21f26d84:	e50b3068 	str	r3, [fp, #-104]
	  LEAVE
21f26d88:	e51b2060 	ldr	r2, [fp, #-96]
21f26d8c:	e51b3038 	ldr	r3, [fp, #-56]
21f26d90:	e5823024 	str	r3, [r2, #36]
21f26d94:	e51b2060 	ldr	r2, [fp, #-96]
21f26d98:	e51b3034 	ldr	r3, [fp, #-52]
21f26d9c:	e5823020 	str	r3, [r2, #32]
21f26da0:	e51b2064 	ldr	r2, [fp, #-100]
21f26da4:	e51b302c 	ldr	r3, [fp, #-44]
21f26da8:	e5823004 	str	r3, [r2, #4]
21f26dac:	e51b3064 	ldr	r3, [fp, #-100]
21f26db0:	e5931008 	ldr	r1, [r3, #8]
21f26db4:	e51b2030 	ldr	r2, [fp, #-48]
21f26db8:	e51b3064 	ldr	r3, [fp, #-100]
21f26dbc:	e5933000 	ldr	r3, [r3]
21f26dc0:	e0633002 	rsb	r3, r3, r2
21f26dc4:	e0812003 	add	r2, r1, r3
21f26dc8:	e51b3064 	ldr	r3, [fp, #-100]
21f26dcc:	e5832008 	str	r2, [r3, #8]
21f26dd0:	e51b2064 	ldr	r2, [fp, #-100]
21f26dd4:	e51b3030 	ldr	r3, [fp, #-48]
21f26dd8:	e5823000 	str	r3, [r2]
21f26ddc:	e51b2060 	ldr	r2, [fp, #-96]
21f26de0:	e51b3028 	ldr	r3, [fp, #-40]
21f26de4:	e5823034 	str	r3, [r2, #52]
21f26de8:	e51b0060 	ldr	r0, [fp, #-96]
21f26dec:	e51b1064 	ldr	r1, [fp, #-100]
21f26df0:	e51b2068 	ldr	r2, [fp, #-104]
21f26df4:	eb000bd7 	bl	21f29d58 <inflate_flush>
21f26df8:	e1a03000 	mov	r3, r0
21f26dfc:	e50b3094 	str	r3, [fp, #-148]
21f26e00:	ea000137 	b	21f272e4 <.text+0x272e4>
	}
	ZFREE(z, s->sub.trees.blens, s->sub.trees.nblens * sizeof(uInt));
21f26e04:	e51b3064 	ldr	r3, [fp, #-100]
21f26e08:	e593c024 	ldr	ip, [r3, #36]
21f26e0c:	e51b3064 	ldr	r3, [fp, #-100]
21f26e10:	e5932028 	ldr	r2, [r3, #40]
21f26e14:	e51b3060 	ldr	r3, [fp, #-96]
21f26e18:	e593100c 	ldr	r1, [r3, #12]
21f26e1c:	e51b3060 	ldr	r3, [fp, #-96]
21f26e20:	e5933018 	ldr	r3, [r3, #24]
21f26e24:	e1a03103 	mov	r3, r3, lsl #2
21f26e28:	e1a00002 	mov	r0, r2
21f26e2c:	e1a02003 	mov	r2, r3
21f26e30:	e1a0e00f 	mov	lr, pc
21f26e34:	e1a0f00c 	mov	pc, ip
	s->sub.decode.codes = c;
21f26e38:	e51b2060 	ldr	r2, [fp, #-96]
21f26e3c:	e51b3010 	ldr	r3, [fp, #-16]
21f26e40:	e582300c 	str	r3, [r2, #12]
	s->sub.decode.tl = tl;
21f26e44:	e51b2058 	ldr	r2, [fp, #-88]
21f26e48:	e51b3060 	ldr	r3, [fp, #-96]
21f26e4c:	e5832004 	str	r2, [r3, #4]
	s->sub.decode.td = td;
21f26e50:	e51b205c 	ldr	r2, [fp, #-92]
21f26e54:	e51b3060 	ldr	r3, [fp, #-96]
21f26e58:	e5832008 	str	r2, [r3, #8]
      }
      s->mode = CODES;
21f26e5c:	e51b2060 	ldr	r2, [fp, #-96]
21f26e60:	e3a03006 	mov	r3, #6	; 0x6
21f26e64:	e5823000 	str	r3, [r2]
    case CODES:
      UPDATE
21f26e68:	e51b2060 	ldr	r2, [fp, #-96]
21f26e6c:	e51b3038 	ldr	r3, [fp, #-56]
21f26e70:	e5823024 	str	r3, [r2, #36]
21f26e74:	e51b2060 	ldr	r2, [fp, #-96]
21f26e78:	e51b3034 	ldr	r3, [fp, #-52]
21f26e7c:	e5823020 	str	r3, [r2, #32]
21f26e80:	e51b2064 	ldr	r2, [fp, #-100]
21f26e84:	e51b302c 	ldr	r3, [fp, #-44]
21f26e88:	e5823004 	str	r3, [r2, #4]
21f26e8c:	e51b3064 	ldr	r3, [fp, #-100]
21f26e90:	e5931008 	ldr	r1, [r3, #8]
21f26e94:	e51b2030 	ldr	r2, [fp, #-48]
21f26e98:	e51b3064 	ldr	r3, [fp, #-100]
21f26e9c:	e5933000 	ldr	r3, [r3]
21f26ea0:	e0633002 	rsb	r3, r3, r2
21f26ea4:	e0812003 	add	r2, r1, r3
21f26ea8:	e51b3064 	ldr	r3, [fp, #-100]
21f26eac:	e5832008 	str	r2, [r3, #8]
21f26eb0:	e51b2064 	ldr	r2, [fp, #-100]
21f26eb4:	e51b3030 	ldr	r3, [fp, #-48]
21f26eb8:	e5823000 	str	r3, [r2]
21f26ebc:	e51b2060 	ldr	r2, [fp, #-96]
21f26ec0:	e51b3028 	ldr	r3, [fp, #-40]
21f26ec4:	e5823034 	str	r3, [r2, #52]
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
21f26ec8:	e51b0060 	ldr	r0, [fp, #-96]
21f26ecc:	e51b1064 	ldr	r1, [fp, #-100]
21f26ed0:	e51b2068 	ldr	r2, [fp, #-104]
21f26ed4:	eb0006b7 	bl	21f289b8 <inflate_codes>
21f26ed8:	e1a03000 	mov	r3, r0
21f26edc:	e50b3068 	str	r3, [fp, #-104]
21f26ee0:	e51b3068 	ldr	r3, [fp, #-104]
21f26ee4:	e3530001 	cmp	r3, #1	; 0x1
21f26ee8:	0a000006 	beq	21f26f08 <.text+0x26f08>
	return inflate_flush(s, z, r);
21f26eec:	e51b0060 	ldr	r0, [fp, #-96]
21f26ef0:	e51b1064 	ldr	r1, [fp, #-100]
21f26ef4:	e51b2068 	ldr	r2, [fp, #-104]
21f26ef8:	eb000b96 	bl	21f29d58 <inflate_flush>
21f26efc:	e1a03000 	mov	r3, r0
21f26f00:	e50b3094 	str	r3, [fp, #-148]
21f26f04:	ea0000f6 	b	21f272e4 <.text+0x272e4>
      r = Z_OK;
21f26f08:	e3a03000 	mov	r3, #0	; 0x0
21f26f0c:	e50b3068 	str	r3, [fp, #-104]
      inflate_codes_free(s->sub.decode.codes, z);
21f26f10:	e51b3060 	ldr	r3, [fp, #-96]
21f26f14:	e593300c 	ldr	r3, [r3, #12]
21f26f18:	e1a00003 	mov	r0, r3
21f26f1c:	e51b1064 	ldr	r1, [fp, #-100]
21f26f20:	eb000b7b 	bl	21f29d14 <inflate_codes_free>
      inflate_trees_free(s->sub.decode.td, z);
21f26f24:	e51b3060 	ldr	r3, [fp, #-96]
21f26f28:	e5933008 	ldr	r3, [r3, #8]
21f26f2c:	e1a00003 	mov	r0, r3
21f26f30:	e51b1064 	ldr	r1, [fp, #-100]
21f26f34:	eb000652 	bl	21f28884 <inflate_trees_free>
      inflate_trees_free(s->sub.decode.tl, z);
21f26f38:	e51b3060 	ldr	r3, [fp, #-96]
21f26f3c:	e5933004 	ldr	r3, [r3, #4]
21f26f40:	e1a00003 	mov	r0, r3
21f26f44:	e51b1064 	ldr	r1, [fp, #-100]
21f26f48:	eb00064d 	bl	21f28884 <inflate_trees_free>
      LOAD
21f26f4c:	e51b3064 	ldr	r3, [fp, #-100]
21f26f50:	e5933000 	ldr	r3, [r3]
21f26f54:	e50b3030 	str	r3, [fp, #-48]
21f26f58:	e51b3064 	ldr	r3, [fp, #-100]
21f26f5c:	e5933004 	ldr	r3, [r3, #4]
21f26f60:	e50b302c 	str	r3, [fp, #-44]
21f26f64:	e51b3060 	ldr	r3, [fp, #-96]
21f26f68:	e5933024 	ldr	r3, [r3, #36]
21f26f6c:	e50b3038 	str	r3, [fp, #-56]
21f26f70:	e51b3060 	ldr	r3, [fp, #-96]
21f26f74:	e5933020 	ldr	r3, [r3, #32]
21f26f78:	e50b3034 	str	r3, [fp, #-52]
21f26f7c:	e51b3060 	ldr	r3, [fp, #-96]
21f26f80:	e5933034 	ldr	r3, [r3, #52]
21f26f84:	e50b3028 	str	r3, [fp, #-40]
21f26f88:	e51b3060 	ldr	r3, [fp, #-96]
21f26f8c:	e5932030 	ldr	r2, [r3, #48]
21f26f90:	e51b3028 	ldr	r3, [fp, #-40]
21f26f94:	e1520003 	cmp	r2, r3
21f26f98:	9a000007 	bls	21f26fbc <.text+0x26fbc>
21f26f9c:	e51b3060 	ldr	r3, [fp, #-96]
21f26fa0:	e5933030 	ldr	r3, [r3, #48]
21f26fa4:	e1a02003 	mov	r2, r3
21f26fa8:	e51b3028 	ldr	r3, [fp, #-40]
21f26fac:	e0633002 	rsb	r3, r3, r2
21f26fb0:	e2433001 	sub	r3, r3, #1	; 0x1
21f26fb4:	e50b3070 	str	r3, [fp, #-112]
21f26fb8:	ea000005 	b	21f26fd4 <.text+0x26fd4>
21f26fbc:	e51b3060 	ldr	r3, [fp, #-96]
21f26fc0:	e593302c 	ldr	r3, [r3, #44]
21f26fc4:	e1a02003 	mov	r2, r3
21f26fc8:	e51b3028 	ldr	r3, [fp, #-40]
21f26fcc:	e0633002 	rsb	r3, r3, r2
21f26fd0:	e50b3070 	str	r3, [fp, #-112]
21f26fd4:	e51b2070 	ldr	r2, [fp, #-112]
21f26fd8:	e50b2024 	str	r2, [fp, #-36]
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
	      z->total_out + (q >= s->read ? q - s->read :
	      (s->end - s->read) + (q - s->window))));
      if (!s->last)
21f26fdc:	e51b3060 	ldr	r3, [fp, #-96]
21f26fe0:	e593301c 	ldr	r3, [r3, #28]
21f26fe4:	e3530000 	cmp	r3, #0	; 0x0
21f26fe8:	1a000003 	bne	21f26ffc <.text+0x26ffc>
      {
	s->mode = TYPE;
21f26fec:	e51b2060 	ldr	r2, [fp, #-96]
21f26ff0:	e3a03000 	mov	r3, #0	; 0x0
21f26ff4:	e5823000 	str	r3, [r2]
	break;
21f26ff8:	eafff9ef 	b	21f257bc <inflate_blocks+0xb0>
      }
      if (k > 7)              /* return unused byte, if any */
21f26ffc:	e51b3034 	ldr	r3, [fp, #-52]
21f27000:	e3530007 	cmp	r3, #7	; 0x7
21f27004:	9a000008 	bls	21f2702c <.text+0x2702c>
      {
	Assert(k < 16, "inflate_codes grabbed too many bytes")
	k -= 8;
21f27008:	e51b3034 	ldr	r3, [fp, #-52]
21f2700c:	e2433008 	sub	r3, r3, #8	; 0x8
21f27010:	e50b3034 	str	r3, [fp, #-52]
	n++;
21f27014:	e51b302c 	ldr	r3, [fp, #-44]
21f27018:	e2833001 	add	r3, r3, #1	; 0x1
21f2701c:	e50b302c 	str	r3, [fp, #-44]
	p--;                    /* can always return one */
21f27020:	e51b3030 	ldr	r3, [fp, #-48]
21f27024:	e2433001 	sub	r3, r3, #1	; 0x1
21f27028:	e50b3030 	str	r3, [fp, #-48]
      }
      s->mode = DRY;
21f2702c:	e51b2060 	ldr	r2, [fp, #-96]
21f27030:	e3a03007 	mov	r3, #7	; 0x7
21f27034:	e5823000 	str	r3, [r2]
    case DRY:
      FLUSH
21f27038:	e51b2060 	ldr	r2, [fp, #-96]
21f2703c:	e51b3028 	ldr	r3, [fp, #-40]
21f27040:	e5823034 	str	r3, [r2, #52]
21f27044:	e51b0060 	ldr	r0, [fp, #-96]
21f27048:	e51b1064 	ldr	r1, [fp, #-100]
21f2704c:	e51b2068 	ldr	r2, [fp, #-104]
21f27050:	eb000b40 	bl	21f29d58 <inflate_flush>
21f27054:	e1a03000 	mov	r3, r0
21f27058:	e50b3068 	str	r3, [fp, #-104]
21f2705c:	e51b3060 	ldr	r3, [fp, #-96]
21f27060:	e5933034 	ldr	r3, [r3, #52]
21f27064:	e50b3028 	str	r3, [fp, #-40]
21f27068:	e51b3060 	ldr	r3, [fp, #-96]
21f2706c:	e5932030 	ldr	r2, [r3, #48]
21f27070:	e51b3028 	ldr	r3, [fp, #-40]
21f27074:	e1520003 	cmp	r2, r3
21f27078:	9a000007 	bls	21f2709c <.text+0x2709c>
21f2707c:	e51b3060 	ldr	r3, [fp, #-96]
21f27080:	e5933030 	ldr	r3, [r3, #48]
21f27084:	e1a02003 	mov	r2, r3
21f27088:	e51b3028 	ldr	r3, [fp, #-40]
21f2708c:	e0633002 	rsb	r3, r3, r2
21f27090:	e2433001 	sub	r3, r3, #1	; 0x1
21f27094:	e50b306c 	str	r3, [fp, #-108]
21f27098:	ea000005 	b	21f270b4 <.text+0x270b4>
21f2709c:	e51b3060 	ldr	r3, [fp, #-96]
21f270a0:	e593302c 	ldr	r3, [r3, #44]
21f270a4:	e1a02003 	mov	r2, r3
21f270a8:	e51b3028 	ldr	r3, [fp, #-40]
21f270ac:	e0633002 	rsb	r3, r3, r2
21f270b0:	e50b306c 	str	r3, [fp, #-108]
21f270b4:	e51b306c 	ldr	r3, [fp, #-108]
21f270b8:	e50b3024 	str	r3, [fp, #-36]
      if (s->read != s->write)
21f270bc:	e51b3060 	ldr	r3, [fp, #-96]
21f270c0:	e5932030 	ldr	r2, [r3, #48]
21f270c4:	e51b3060 	ldr	r3, [fp, #-96]
21f270c8:	e5933034 	ldr	r3, [r3, #52]
21f270cc:	e1520003 	cmp	r2, r3
21f270d0:	0a00001e 	beq	21f27150 <.text+0x27150>
	LEAVE
21f270d4:	e51b2060 	ldr	r2, [fp, #-96]
21f270d8:	e51b3038 	ldr	r3, [fp, #-56]
21f270dc:	e5823024 	str	r3, [r2, #36]
21f270e0:	e51b2060 	ldr	r2, [fp, #-96]
21f270e4:	e51b3034 	ldr	r3, [fp, #-52]
21f270e8:	e5823020 	str	r3, [r2, #32]
21f270ec:	e51b2064 	ldr	r2, [fp, #-100]
21f270f0:	e51b302c 	ldr	r3, [fp, #-44]
21f270f4:	e5823004 	str	r3, [r2, #4]
21f270f8:	e51b3064 	ldr	r3, [fp, #-100]
21f270fc:	e5931008 	ldr	r1, [r3, #8]
21f27100:	e51b2030 	ldr	r2, [fp, #-48]
21f27104:	e51b3064 	ldr	r3, [fp, #-100]
21f27108:	e5933000 	ldr	r3, [r3]
21f2710c:	e0633002 	rsb	r3, r3, r2
21f27110:	e0812003 	add	r2, r1, r3
21f27114:	e51b3064 	ldr	r3, [fp, #-100]
21f27118:	e5832008 	str	r2, [r3, #8]
21f2711c:	e51b2064 	ldr	r2, [fp, #-100]
21f27120:	e51b3030 	ldr	r3, [fp, #-48]
21f27124:	e5823000 	str	r3, [r2]
21f27128:	e51b2060 	ldr	r2, [fp, #-96]
21f2712c:	e51b3028 	ldr	r3, [fp, #-40]
21f27130:	e5823034 	str	r3, [r2, #52]
21f27134:	e51b0060 	ldr	r0, [fp, #-96]
21f27138:	e51b1064 	ldr	r1, [fp, #-100]
21f2713c:	e51b2068 	ldr	r2, [fp, #-104]
21f27140:	eb000b04 	bl	21f29d58 <inflate_flush>
21f27144:	e1a03000 	mov	r3, r0
21f27148:	e50b3094 	str	r3, [fp, #-148]
21f2714c:	ea000064 	b	21f272e4 <.text+0x272e4>
      s->mode = DONEB;
21f27150:	e51b2060 	ldr	r2, [fp, #-96]
21f27154:	e3a03008 	mov	r3, #8	; 0x8
21f27158:	e5823000 	str	r3, [r2]
    case DONEB:
      r = Z_STREAM_END;
21f2715c:	e3a03001 	mov	r3, #1	; 0x1
21f27160:	e50b3068 	str	r3, [fp, #-104]
      LEAVE
21f27164:	e51b2060 	ldr	r2, [fp, #-96]
21f27168:	e51b3038 	ldr	r3, [fp, #-56]
21f2716c:	e5823024 	str	r3, [r2, #36]
21f27170:	e51b2060 	ldr	r2, [fp, #-96]
21f27174:	e51b3034 	ldr	r3, [fp, #-52]
21f27178:	e5823020 	str	r3, [r2, #32]
21f2717c:	e51b2064 	ldr	r2, [fp, #-100]
21f27180:	e51b302c 	ldr	r3, [fp, #-44]
21f27184:	e5823004 	str	r3, [r2, #4]
21f27188:	e51b3064 	ldr	r3, [fp, #-100]
21f2718c:	e5931008 	ldr	r1, [r3, #8]
21f27190:	e51b2030 	ldr	r2, [fp, #-48]
21f27194:	e51b3064 	ldr	r3, [fp, #-100]
21f27198:	e5933000 	ldr	r3, [r3]
21f2719c:	e0633002 	rsb	r3, r3, r2
21f271a0:	e0812003 	add	r2, r1, r3
21f271a4:	e51b3064 	ldr	r3, [fp, #-100]
21f271a8:	e5832008 	str	r2, [r3, #8]
21f271ac:	e51b2064 	ldr	r2, [fp, #-100]
21f271b0:	e51b3030 	ldr	r3, [fp, #-48]
21f271b4:	e5823000 	str	r3, [r2]
21f271b8:	e51b2060 	ldr	r2, [fp, #-96]
21f271bc:	e51b3028 	ldr	r3, [fp, #-40]
21f271c0:	e5823034 	str	r3, [r2, #52]
21f271c4:	e51b0060 	ldr	r0, [fp, #-96]
21f271c8:	e51b1064 	ldr	r1, [fp, #-100]
21f271cc:	e51b2068 	ldr	r2, [fp, #-104]
21f271d0:	eb000ae0 	bl	21f29d58 <inflate_flush>
21f271d4:	e1a03000 	mov	r3, r0
21f271d8:	e50b3094 	str	r3, [fp, #-148]
21f271dc:	ea000040 	b	21f272e4 <.text+0x272e4>
    case BADB:
      r = Z_DATA_ERROR;
21f271e0:	e3e03002 	mvn	r3, #2	; 0x2
21f271e4:	e50b3068 	str	r3, [fp, #-104]
      LEAVE
21f271e8:	e51b2060 	ldr	r2, [fp, #-96]
21f271ec:	e51b3038 	ldr	r3, [fp, #-56]
21f271f0:	e5823024 	str	r3, [r2, #36]
21f271f4:	e51b2060 	ldr	r2, [fp, #-96]
21f271f8:	e51b3034 	ldr	r3, [fp, #-52]
21f271fc:	e5823020 	str	r3, [r2, #32]
21f27200:	e51b2064 	ldr	r2, [fp, #-100]
21f27204:	e51b302c 	ldr	r3, [fp, #-44]
21f27208:	e5823004 	str	r3, [r2, #4]
21f2720c:	e51b3064 	ldr	r3, [fp, #-100]
21f27210:	e5931008 	ldr	r1, [r3, #8]
21f27214:	e51b2030 	ldr	r2, [fp, #-48]
21f27218:	e51b3064 	ldr	r3, [fp, #-100]
21f2721c:	e5933000 	ldr	r3, [r3]
21f27220:	e0633002 	rsb	r3, r3, r2
21f27224:	e0812003 	add	r2, r1, r3
21f27228:	e51b3064 	ldr	r3, [fp, #-100]
21f2722c:	e5832008 	str	r2, [r3, #8]
21f27230:	e51b2064 	ldr	r2, [fp, #-100]
21f27234:	e51b3030 	ldr	r3, [fp, #-48]
21f27238:	e5823000 	str	r3, [r2]
21f2723c:	e51b2060 	ldr	r2, [fp, #-96]
21f27240:	e51b3028 	ldr	r3, [fp, #-40]
21f27244:	e5823034 	str	r3, [r2, #52]
21f27248:	e51b0060 	ldr	r0, [fp, #-96]
21f2724c:	e51b1064 	ldr	r1, [fp, #-100]
21f27250:	e51b2068 	ldr	r2, [fp, #-104]
21f27254:	eb000abf 	bl	21f29d58 <inflate_flush>
21f27258:	e1a03000 	mov	r3, r0
21f2725c:	e50b3094 	str	r3, [fp, #-148]
21f27260:	ea00001f 	b	21f272e4 <.text+0x272e4>
    default:
      r = Z_STREAM_ERROR;
21f27264:	e3e03001 	mvn	r3, #1	; 0x1
21f27268:	e50b3068 	str	r3, [fp, #-104]
      LEAVE
21f2726c:	e51b2060 	ldr	r2, [fp, #-96]
21f27270:	e51b3038 	ldr	r3, [fp, #-56]
21f27274:	e5823024 	str	r3, [r2, #36]
21f27278:	e51b2060 	ldr	r2, [fp, #-96]
21f2727c:	e51b3034 	ldr	r3, [fp, #-52]
21f27280:	e5823020 	str	r3, [r2, #32]
21f27284:	e51b2064 	ldr	r2, [fp, #-100]
21f27288:	e51b302c 	ldr	r3, [fp, #-44]
21f2728c:	e5823004 	str	r3, [r2, #4]
21f27290:	e51b3064 	ldr	r3, [fp, #-100]
21f27294:	e5931008 	ldr	r1, [r3, #8]
21f27298:	e51b2030 	ldr	r2, [fp, #-48]
21f2729c:	e51b3064 	ldr	r3, [fp, #-100]
21f272a0:	e5933000 	ldr	r3, [r3]
21f272a4:	e0633002 	rsb	r3, r3, r2
21f272a8:	e0812003 	add	r2, r1, r3
21f272ac:	e51b3064 	ldr	r3, [fp, #-100]
21f272b0:	e5832008 	str	r2, [r3, #8]
21f272b4:	e51b2064 	ldr	r2, [fp, #-100]
21f272b8:	e51b3030 	ldr	r3, [fp, #-48]
21f272bc:	e5823000 	str	r3, [r2]
21f272c0:	e51b2060 	ldr	r2, [fp, #-96]
21f272c4:	e51b3028 	ldr	r3, [fp, #-40]
21f272c8:	e5823034 	str	r3, [r2, #52]
21f272cc:	e51b0060 	ldr	r0, [fp, #-96]
21f272d0:	e51b1064 	ldr	r1, [fp, #-100]
21f272d4:	e51b2068 	ldr	r2, [fp, #-104]
21f272d8:	eb000a9e 	bl	21f29d58 <inflate_flush>
21f272dc:	e1a03000 	mov	r3, r0
21f272e0:	e50b3094 	str	r3, [fp, #-148]
21f272e4:	e51b3094 	ldr	r3, [fp, #-148]
  }
}
21f272e8:	e1a00003 	mov	r0, r3
21f272ec:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f272f0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f272f4 <inflate_blocks_free>:


local int inflate_blocks_free(s, z, c)
inflate_blocks_statef *s;
z_stream *z;
uLongf *c;
{
21f272f4:	e1a0c00d 	mov	ip, sp
21f272f8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f272fc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f27300:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f27304:	e50b0010 	str	r0, [fp, #-16]
21f27308:	e50b1014 	str	r1, [fp, #-20]
21f2730c:	e50b2018 	str	r2, [fp, #-24]
  inflate_blocks_reset(s, z, c);
21f27310:	e51b0010 	ldr	r0, [fp, #-16]
21f27314:	e51b1014 	ldr	r1, [fp, #-20]
21f27318:	e51b2018 	ldr	r2, [fp, #-24]
21f2731c:	ebfff84b 	bl	21f25450 <inflate_blocks_reset>
  ZFREE(z, s->window, s->end - s->window);
21f27320:	e51b3014 	ldr	r3, [fp, #-20]
21f27324:	e593c024 	ldr	ip, [r3, #36]
21f27328:	e51b3014 	ldr	r3, [fp, #-20]
21f2732c:	e5930028 	ldr	r0, [r3, #40]
21f27330:	e51b3010 	ldr	r3, [fp, #-16]
21f27334:	e5931028 	ldr	r1, [r3, #40]
21f27338:	e51b3010 	ldr	r3, [fp, #-16]
21f2733c:	e593302c 	ldr	r3, [r3, #44]
21f27340:	e1a02003 	mov	r2, r3
21f27344:	e51b3010 	ldr	r3, [fp, #-16]
21f27348:	e5933028 	ldr	r3, [r3, #40]
21f2734c:	e0633002 	rsb	r3, r3, r2
21f27350:	e1a02003 	mov	r2, r3
21f27354:	e1a0e00f 	mov	lr, pc
21f27358:	e1a0f00c 	mov	pc, ip
  ZFREE(z, s, sizeof(struct inflate_blocks_state));
21f2735c:	e51b3014 	ldr	r3, [fp, #-20]
21f27360:	e593c024 	ldr	ip, [r3, #36]
21f27364:	e51b3014 	ldr	r3, [fp, #-20]
21f27368:	e5933028 	ldr	r3, [r3, #40]
21f2736c:	e1a00003 	mov	r0, r3
21f27370:	e51b1010 	ldr	r1, [fp, #-16]
21f27374:	e3a02040 	mov	r2, #64	; 0x40
21f27378:	e1a0e00f 	mov	lr, pc
21f2737c:	e1a0f00c 	mov	pc, ip
  Trace((stderr, "inflate:   blocks freed\n"));
  return Z_OK;
21f27380:	e3a03000 	mov	r3, #0	; 0x0
}
21f27384:	e1a00003 	mov	r0, r3
21f27388:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2738c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f27390 <inflate_addhistory>:

/*
 * This subroutine adds the data at next_in/avail_in to the output history
 * without performing any output.  The output buffer must be "caught up";
 * i.e. no pending output (hence s->read equals s->write), and the state must
 * be BLOCKS (i.e. we should be willing to see the start of a series of
 * BLOCKS).  On exit, the output will also be caught up, and the checksum
 * will have been updated if need be.
 */
local int inflate_addhistory(s, z)
inflate_blocks_statef *s;
z_stream *z;
{
21f27390:	e1a0c00d 	mov	ip, sp
21f27394:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f27398:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2739c:	e24dd030 	sub	sp, sp, #48	; 0x30
21f273a0:	e50b002c 	str	r0, [fp, #-44]
21f273a4:	e50b1030 	str	r1, [fp, #-48]
    uLong b;              /* bit buffer */  /* NOT USED HERE */
    uInt k;               /* bits in bit buffer */ /* NOT USED HERE */
    uInt t;               /* temporary storage */
    Bytef *p;             /* input data pointer */
    uInt n;               /* bytes available there */
    Bytef *q;             /* output window write pointer */
    uInt m;               /* bytes to end of window or read pointer */

    if (s->read != s->write)
21f273a8:	e51b302c 	ldr	r3, [fp, #-44]
21f273ac:	e5932030 	ldr	r2, [r3, #48]
21f273b0:	e51b302c 	ldr	r3, [fp, #-44]
21f273b4:	e5933034 	ldr	r3, [r3, #52]
21f273b8:	e1520003 	cmp	r2, r3
21f273bc:	0a000002 	beq	21f273cc <inflate_addhistory+0x3c>
	return Z_STREAM_ERROR;
21f273c0:	e3e03001 	mvn	r3, #1	; 0x1
21f273c4:	e50b303c 	str	r3, [fp, #-60]
21f273c8:	ea0000a3 	b	21f2765c <inflate_addhistory+0x2cc>
    if (s->mode != TYPE)
21f273cc:	e51b302c 	ldr	r3, [fp, #-44]
21f273d0:	e5933000 	ldr	r3, [r3]
21f273d4:	e3530000 	cmp	r3, #0	; 0x0
21f273d8:	0a000002 	beq	21f273e8 <inflate_addhistory+0x58>
	return Z_DATA_ERROR;
21f273dc:	e3e03002 	mvn	r3, #2	; 0x2
21f273e0:	e50b303c 	str	r3, [fp, #-60]
21f273e4:	ea00009c 	b	21f2765c <inflate_addhistory+0x2cc>

    /* we're ready to rock */
    LOAD
21f273e8:	e51b3030 	ldr	r3, [fp, #-48]
21f273ec:	e5933000 	ldr	r3, [r3]
21f273f0:	e50b301c 	str	r3, [fp, #-28]
21f273f4:	e51b3030 	ldr	r3, [fp, #-48]
21f273f8:	e5933004 	ldr	r3, [r3, #4]
21f273fc:	e50b3018 	str	r3, [fp, #-24]
21f27400:	e51b302c 	ldr	r3, [fp, #-44]
21f27404:	e5933024 	ldr	r3, [r3, #36]
21f27408:	e50b3028 	str	r3, [fp, #-40]
21f2740c:	e51b302c 	ldr	r3, [fp, #-44]
21f27410:	e5933020 	ldr	r3, [r3, #32]
21f27414:	e50b3024 	str	r3, [fp, #-36]
21f27418:	e51b302c 	ldr	r3, [fp, #-44]
21f2741c:	e5933034 	ldr	r3, [r3, #52]
21f27420:	e50b3014 	str	r3, [fp, #-20]
21f27424:	e51b302c 	ldr	r3, [fp, #-44]
21f27428:	e5932030 	ldr	r2, [r3, #48]
21f2742c:	e51b3014 	ldr	r3, [fp, #-20]
21f27430:	e1520003 	cmp	r2, r3
21f27434:	9a000007 	bls	21f27458 <inflate_addhistory+0xc8>
21f27438:	e51b302c 	ldr	r3, [fp, #-44]
21f2743c:	e5933030 	ldr	r3, [r3, #48]
21f27440:	e1a02003 	mov	r2, r3
21f27444:	e51b3014 	ldr	r3, [fp, #-20]
21f27448:	e0633002 	rsb	r3, r3, r2
21f2744c:	e2433001 	sub	r3, r3, #1	; 0x1
21f27450:	e50b3038 	str	r3, [fp, #-56]
21f27454:	ea000005 	b	21f27470 <inflate_addhistory+0xe0>
21f27458:	e51b302c 	ldr	r3, [fp, #-44]
21f2745c:	e593302c 	ldr	r3, [r3, #44]
21f27460:	e1a02003 	mov	r2, r3
21f27464:	e51b3014 	ldr	r3, [fp, #-20]
21f27468:	e0633002 	rsb	r3, r3, r2
21f2746c:	e50b3038 	str	r3, [fp, #-56]
21f27470:	e51b3038 	ldr	r3, [fp, #-56]
21f27474:	e50b3010 	str	r3, [fp, #-16]
    /* while there is input ready, copy to output buffer, moving
     * pointers as needed.
     */
    while (n) {
21f27478:	ea00005a 	b	21f275e8 <inflate_addhistory+0x258>
	t = n;  /* how many to do */
21f2747c:	e51b3018 	ldr	r3, [fp, #-24]
21f27480:	e50b3020 	str	r3, [fp, #-32]
	/* is there room until end of buffer? */
	if (t > m) t = m;
21f27484:	e51b2020 	ldr	r2, [fp, #-32]
21f27488:	e51b3010 	ldr	r3, [fp, #-16]
21f2748c:	e1520003 	cmp	r2, r3
21f27490:	9a000001 	bls	21f2749c <inflate_addhistory+0x10c>
21f27494:	e51b3010 	ldr	r3, [fp, #-16]
21f27498:	e50b3020 	str	r3, [fp, #-32]
	/* update check information */
	if (s->checkfn != Z_NULL)
21f2749c:	e51b302c 	ldr	r3, [fp, #-44]
21f274a0:	e5933038 	ldr	r3, [r3, #56]
21f274a4:	e3530000 	cmp	r3, #0	; 0x0
21f274a8:	0a00000b 	beq	21f274dc <inflate_addhistory+0x14c>
	    s->check = (*s->checkfn)(s->check, q, t);
21f274ac:	e51b302c 	ldr	r3, [fp, #-44]
21f274b0:	e593c038 	ldr	ip, [r3, #56]
21f274b4:	e51b302c 	ldr	r3, [fp, #-44]
21f274b8:	e593303c 	ldr	r3, [r3, #60]
21f274bc:	e1a00003 	mov	r0, r3
21f274c0:	e51b1014 	ldr	r1, [fp, #-20]
21f274c4:	e51b2020 	ldr	r2, [fp, #-32]
21f274c8:	e1a0e00f 	mov	lr, pc
21f274cc:	e1a0f00c 	mov	pc, ip
21f274d0:	e1a02000 	mov	r2, r0
21f274d4:	e51b302c 	ldr	r3, [fp, #-44]
21f274d8:	e583203c 	str	r2, [r3, #60]
	/* output callback */
	if (z->outcb != Z_NULL)
21f274dc:	e51b3030 	ldr	r3, [fp, #-48]
21f274e0:	e5933030 	ldr	r3, [r3, #48]
21f274e4:	e3530000 	cmp	r3, #0	; 0x0
21f274e8:	0a000005 	beq	21f27504 <inflate_addhistory+0x174>
	    (*z->outcb)(q, t);
21f274ec:	e51b3030 	ldr	r3, [fp, #-48]
21f274f0:	e5933030 	ldr	r3, [r3, #48]
21f274f4:	e51b0014 	ldr	r0, [fp, #-20]
21f274f8:	e51b1020 	ldr	r1, [fp, #-32]
21f274fc:	e1a0e00f 	mov	lr, pc
21f27500:	e1a0f003 	mov	pc, r3
	zmemcpy(q, p, t);
21f27504:	e51b0014 	ldr	r0, [fp, #-20]
21f27508:	e51b101c 	ldr	r1, [fp, #-28]
21f2750c:	e51b2020 	ldr	r2, [fp, #-32]
21f27510:	ebffef2d 	bl	21f231cc <memcpy>
	q += t;
21f27514:	e51b2020 	ldr	r2, [fp, #-32]
21f27518:	e51b3014 	ldr	r3, [fp, #-20]
21f2751c:	e0833002 	add	r3, r3, r2
21f27520:	e50b3014 	str	r3, [fp, #-20]
	p += t;
21f27524:	e51b2020 	ldr	r2, [fp, #-32]
21f27528:	e51b301c 	ldr	r3, [fp, #-28]
21f2752c:	e0833002 	add	r3, r3, r2
21f27530:	e50b301c 	str	r3, [fp, #-28]
	n -= t;
21f27534:	e51b2018 	ldr	r2, [fp, #-24]
21f27538:	e51b3020 	ldr	r3, [fp, #-32]
21f2753c:	e0633002 	rsb	r3, r3, r2
21f27540:	e50b3018 	str	r3, [fp, #-24]
	z->total_out += t;
21f27544:	e51b3030 	ldr	r3, [fp, #-48]
21f27548:	e5932014 	ldr	r2, [r3, #20]
21f2754c:	e51b3020 	ldr	r3, [fp, #-32]
21f27550:	e0822003 	add	r2, r2, r3
21f27554:	e51b3030 	ldr	r3, [fp, #-48]
21f27558:	e5832014 	str	r2, [r3, #20]
	s->read = q;    /* drag read pointer forward */
21f2755c:	e51b202c 	ldr	r2, [fp, #-44]
21f27560:	e51b3014 	ldr	r3, [fp, #-20]
21f27564:	e5823030 	str	r3, [r2, #48]
/*      WRAP  */ 	/* expand WRAP macro by hand to handle s->read */
	if (q == s->end) {
21f27568:	e51b302c 	ldr	r3, [fp, #-44]
21f2756c:	e593202c 	ldr	r2, [r3, #44]
21f27570:	e51b3014 	ldr	r3, [fp, #-20]
21f27574:	e1520003 	cmp	r2, r3
21f27578:	1a00001a 	bne	21f275e8 <inflate_addhistory+0x258>
	    s->read = q = s->window;
21f2757c:	e51b302c 	ldr	r3, [fp, #-44]
21f27580:	e5933028 	ldr	r3, [r3, #40]
21f27584:	e50b3014 	str	r3, [fp, #-20]
21f27588:	e51b202c 	ldr	r2, [fp, #-44]
21f2758c:	e51b3014 	ldr	r3, [fp, #-20]
21f27590:	e5823030 	str	r3, [r2, #48]
	    m = WAVAIL;
21f27594:	e51b302c 	ldr	r3, [fp, #-44]
21f27598:	e5932030 	ldr	r2, [r3, #48]
21f2759c:	e51b3014 	ldr	r3, [fp, #-20]
21f275a0:	e1520003 	cmp	r2, r3
21f275a4:	9a000007 	bls	21f275c8 <inflate_addhistory+0x238>
21f275a8:	e51b302c 	ldr	r3, [fp, #-44]
21f275ac:	e5933030 	ldr	r3, [r3, #48]
21f275b0:	e1a02003 	mov	r2, r3
21f275b4:	e51b3014 	ldr	r3, [fp, #-20]
21f275b8:	e0633002 	rsb	r3, r3, r2
21f275bc:	e2433001 	sub	r3, r3, #1	; 0x1
21f275c0:	e50b3034 	str	r3, [fp, #-52]
21f275c4:	ea000005 	b	21f275e0 <inflate_addhistory+0x250>
21f275c8:	e51b302c 	ldr	r3, [fp, #-44]
21f275cc:	e593302c 	ldr	r3, [r3, #44]
21f275d0:	e1a02003 	mov	r2, r3
21f275d4:	e51b3014 	ldr	r3, [fp, #-20]
21f275d8:	e0633002 	rsb	r3, r3, r2
21f275dc:	e50b3034 	str	r3, [fp, #-52]
21f275e0:	e51b3034 	ldr	r3, [fp, #-52]
21f275e4:	e50b3010 	str	r3, [fp, #-16]
21f275e8:	e51b3018 	ldr	r3, [fp, #-24]
21f275ec:	e3530000 	cmp	r3, #0	; 0x0
21f275f0:	1affffa1 	bne	21f2747c <inflate_addhistory+0xec>
	}
    }
    UPDATE
21f275f4:	e51b202c 	ldr	r2, [fp, #-44]
21f275f8:	e51b3028 	ldr	r3, [fp, #-40]
21f275fc:	e5823024 	str	r3, [r2, #36]
21f27600:	e51b202c 	ldr	r2, [fp, #-44]
21f27604:	e51b3024 	ldr	r3, [fp, #-36]
21f27608:	e5823020 	str	r3, [r2, #32]
21f2760c:	e51b2030 	ldr	r2, [fp, #-48]
21f27610:	e51b3018 	ldr	r3, [fp, #-24]
21f27614:	e5823004 	str	r3, [r2, #4]
21f27618:	e51b3030 	ldr	r3, [fp, #-48]
21f2761c:	e5931008 	ldr	r1, [r3, #8]
21f27620:	e51b201c 	ldr	r2, [fp, #-28]
21f27624:	e51b3030 	ldr	r3, [fp, #-48]
21f27628:	e5933000 	ldr	r3, [r3]
21f2762c:	e0633002 	rsb	r3, r3, r2
21f27630:	e0812003 	add	r2, r1, r3
21f27634:	e51b3030 	ldr	r3, [fp, #-48]
21f27638:	e5832008 	str	r2, [r3, #8]
21f2763c:	e51b2030 	ldr	r2, [fp, #-48]
21f27640:	e51b301c 	ldr	r3, [fp, #-28]
21f27644:	e5823000 	str	r3, [r2]
21f27648:	e51b202c 	ldr	r2, [fp, #-44]
21f2764c:	e51b3014 	ldr	r3, [fp, #-20]
21f27650:	e5823034 	str	r3, [r2, #52]
    return Z_OK;
21f27654:	e3a03000 	mov	r3, #0	; 0x0
21f27658:	e50b303c 	str	r3, [fp, #-60]
21f2765c:	e51b303c 	ldr	r3, [fp, #-60]
}
21f27660:	e1a00003 	mov	r0, r3
21f27664:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f27668:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2766c <inflate_packet_flush>:


/*
 * At the end of a Deflate-compressed PPP packet, we expect to have seen
 * a `stored' block type value but not the (zero) length bytes.
 */
local int inflate_packet_flush(s)
    inflate_blocks_statef *s;
{
21f2766c:	e1a0c00d 	mov	ip, sp
21f27670:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f27674:	e24cb004 	sub	fp, ip, #4	; 0x4
21f27678:	e24dd008 	sub	sp, sp, #8	; 0x8
21f2767c:	e50b0010 	str	r0, [fp, #-16]
    if (s->mode != LENS)
21f27680:	e51b3010 	ldr	r3, [fp, #-16]
21f27684:	e5933000 	ldr	r3, [r3]
21f27688:	e3530001 	cmp	r3, #1	; 0x1
21f2768c:	0a000002 	beq	21f2769c <inflate_packet_flush+0x30>
	return Z_DATA_ERROR;
21f27690:	e3e03002 	mvn	r3, #2	; 0x2
21f27694:	e50b3014 	str	r3, [fp, #-20]
21f27698:	ea000004 	b	21f276b0 <inflate_packet_flush+0x44>
    s->mode = TYPE;
21f2769c:	e51b2010 	ldr	r2, [fp, #-16]
21f276a0:	e3a03000 	mov	r3, #0	; 0x0
21f276a4:	e5823000 	str	r3, [r2]
    return Z_OK;
21f276a8:	e3a03000 	mov	r3, #0	; 0x0
21f276ac:	e50b3014 	str	r3, [fp, #-20]
21f276b0:	e51b3014 	ldr	r3, [fp, #-20]
}
21f276b4:	e1a00003 	mov	r0, r3
21f276b8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f276bc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f276c0 <huft_build>:


/*+++++*/
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* simplify the use of the inflate_huft type with some defines */
#define base more.Base
#define next more.Next
#define exop word.what.Exop
#define bits word.what.Bits


local int huft_build OF((
    uIntf *,            /* code lengths in bits */
    uInt,               /* number of codes */
    uInt,               /* number of "simple" codes */
    uIntf *,            /* list of base values for non-simple codes */
    uIntf *,            /* list of extra bits for non-simple codes */
    inflate_huft * FAR*,/* result: starting table */
    uIntf *,            /* maximum lookup bits (returns actual) */
    z_stream *));       /* for zalloc function */

local voidpf falloc OF((
    voidpf,             /* opaque pointer (not used) */
    uInt,               /* number of items */
    uInt));             /* size of item */

local void ffree OF((
    voidpf q,           /* opaque pointer (not used) */
    voidpf p,           /* what to free (not used) */
    uInt n));		/* number of bytes (not used) */

/* Tables for deflate from PKZIP's appnote.txt. */
local uInt cplens[] = { /* Copy lengths for literal codes 257..285 */
	3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
	35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
	/* actually lengths - 2; also see note #13 above about 258 */
local uInt cplext[] = { /* Extra bits for literal codes 257..285 */
	0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
	3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 192, 192}; /* 192==invalid */
local uInt cpdist[] = { /* Copy offsets for distance codes 0..29 */
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
	257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
	8193, 12289, 16385, 24577};
local uInt cpdext[] = { /* Extra bits for distance codes */
	0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
	7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
	12, 12, 13, 13};

/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
#define BMAX 15         /* maximum bit length of any code */
#define N_MAX 288       /* maximum number of codes in any set */

#ifdef DEBUG_ZLIB
  uInt inflate_hufts;
#endif

local int huft_build(b, n, s, d, e, t, m, zs)
uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
uInt n;                 /* number of codes (assumed <= N_MAX) */
uInt s;                 /* number of simple-valued codes (0..s-1) */
uIntf *d;               /* list of base values for non-simple codes */
uIntf *e;               /* list of extra bits for non-simple codes */
inflate_huft * FAR *t;  /* result: starting table */
uIntf *m;               /* maximum lookup bits, returns actual */
z_stream *zs;           /* for zalloc function */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), Z_DATA_ERROR if the input is invalid (all zero length codes or an
   over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
{
21f276c0:	e1a0c00d 	mov	ip, sp
21f276c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f276c8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f276cc:	e24dde59 	sub	sp, sp, #1424	; 0x590
21f276d0:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f276d4:	e50b0578 	str	r0, [fp, #-1400]
21f276d8:	e50b157c 	str	r1, [fp, #-1404]
21f276dc:	e50b2580 	str	r2, [fp, #-1408]
21f276e0:	e50b3584 	str	r3, [fp, #-1412]

  uInt a;                       /* counter for codes of length k */
  uInt c[BMAX+1];               /* bit length count table */
  uInt f;                       /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  register uInt i;              /* counter, current code */
  register uInt j;              /* counter */
  register int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  register uIntf *p;            /* pointer into c[], b[], or v[] */
  inflate_huft *q;              /* points to current table */
  struct inflate_huft_s r;      /* table entry for structure assignment */
  inflate_huft *u[BMAX];        /* table stack */
  uInt v[N_MAX];                /* values in order of bit length */
  register int w;               /* bits before this table == (l * h) */
  uInt x[BMAX+1];               /* bit offsets, then code stack */
  uIntf *xp;                    /* pointer into x */
  int y;                        /* number of dummy codes added */
  uInt z;                       /* number of entries in current table */


  /* Generate counts for each bit length */
  p = c;
21f276e4:	e24b0070 	sub	r0, fp, #112	; 0x70
21f276e8:	e50b058c 	str	r0, [fp, #-1420]
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
21f276ec:	e3a03000 	mov	r3, #0	; 0x0
21f276f0:	e51b158c 	ldr	r1, [fp, #-1420]
21f276f4:	e5813000 	str	r3, [r1]
21f276f8:	e51b258c 	ldr	r2, [fp, #-1420]
21f276fc:	e2822004 	add	r2, r2, #4	; 0x4
21f27700:	e50b258c 	str	r2, [fp, #-1420]
21f27704:	e3a03000 	mov	r3, #0	; 0x0
21f27708:	e51bc58c 	ldr	ip, [fp, #-1420]
21f2770c:	e58c3000 	str	r3, [ip]
21f27710:	e51b058c 	ldr	r0, [fp, #-1420]
21f27714:	e2800004 	add	r0, r0, #4	; 0x4
21f27718:	e50b058c 	str	r0, [fp, #-1420]
21f2771c:	e3a03000 	mov	r3, #0	; 0x0
21f27720:	e51b158c 	ldr	r1, [fp, #-1420]
21f27724:	e5813000 	str	r3, [r1]
21f27728:	e51b258c 	ldr	r2, [fp, #-1420]
21f2772c:	e2822004 	add	r2, r2, #4	; 0x4
21f27730:	e50b258c 	str	r2, [fp, #-1420]
21f27734:	e3a03000 	mov	r3, #0	; 0x0
21f27738:	e51bc58c 	ldr	ip, [fp, #-1420]
21f2773c:	e58c3000 	str	r3, [ip]
21f27740:	e51b058c 	ldr	r0, [fp, #-1420]
21f27744:	e2800004 	add	r0, r0, #4	; 0x4
21f27748:	e50b058c 	str	r0, [fp, #-1420]
21f2774c:	e3a03000 	mov	r3, #0	; 0x0
21f27750:	e51b158c 	ldr	r1, [fp, #-1420]
21f27754:	e5813000 	str	r3, [r1]
21f27758:	e51b258c 	ldr	r2, [fp, #-1420]
21f2775c:	e2822004 	add	r2, r2, #4	; 0x4
21f27760:	e50b258c 	str	r2, [fp, #-1420]
21f27764:	e3a03000 	mov	r3, #0	; 0x0
21f27768:	e51bc58c 	ldr	ip, [fp, #-1420]
21f2776c:	e58c3000 	str	r3, [ip]
21f27770:	e51b058c 	ldr	r0, [fp, #-1420]
21f27774:	e2800004 	add	r0, r0, #4	; 0x4
21f27778:	e50b058c 	str	r0, [fp, #-1420]
21f2777c:	e3a03000 	mov	r3, #0	; 0x0
21f27780:	e51b158c 	ldr	r1, [fp, #-1420]
21f27784:	e5813000 	str	r3, [r1]
21f27788:	e51b258c 	ldr	r2, [fp, #-1420]
21f2778c:	e2822004 	add	r2, r2, #4	; 0x4
21f27790:	e50b258c 	str	r2, [fp, #-1420]
21f27794:	e3a03000 	mov	r3, #0	; 0x0
21f27798:	e51bc58c 	ldr	ip, [fp, #-1420]
21f2779c:	e58c3000 	str	r3, [ip]
21f277a0:	e51b058c 	ldr	r0, [fp, #-1420]
21f277a4:	e2800004 	add	r0, r0, #4	; 0x4
21f277a8:	e50b058c 	str	r0, [fp, #-1420]
21f277ac:	e3a03000 	mov	r3, #0	; 0x0
21f277b0:	e51b158c 	ldr	r1, [fp, #-1420]
21f277b4:	e5813000 	str	r3, [r1]
21f277b8:	e51b258c 	ldr	r2, [fp, #-1420]
21f277bc:	e2822004 	add	r2, r2, #4	; 0x4
21f277c0:	e50b258c 	str	r2, [fp, #-1420]
21f277c4:	e3a03000 	mov	r3, #0	; 0x0
21f277c8:	e51bc58c 	ldr	ip, [fp, #-1420]
21f277cc:	e58c3000 	str	r3, [ip]
21f277d0:	e51b058c 	ldr	r0, [fp, #-1420]
21f277d4:	e2800004 	add	r0, r0, #4	; 0x4
21f277d8:	e50b058c 	str	r0, [fp, #-1420]
21f277dc:	e3a03000 	mov	r3, #0	; 0x0
21f277e0:	e51b158c 	ldr	r1, [fp, #-1420]
21f277e4:	e5813000 	str	r3, [r1]
21f277e8:	e51b258c 	ldr	r2, [fp, #-1420]
21f277ec:	e2822004 	add	r2, r2, #4	; 0x4
21f277f0:	e50b258c 	str	r2, [fp, #-1420]
21f277f4:	e3a03000 	mov	r3, #0	; 0x0
21f277f8:	e51bc58c 	ldr	ip, [fp, #-1420]
21f277fc:	e58c3000 	str	r3, [ip]
21f27800:	e51b058c 	ldr	r0, [fp, #-1420]
21f27804:	e2800004 	add	r0, r0, #4	; 0x4
21f27808:	e50b058c 	str	r0, [fp, #-1420]
21f2780c:	e3a03000 	mov	r3, #0	; 0x0
21f27810:	e51b158c 	ldr	r1, [fp, #-1420]
21f27814:	e5813000 	str	r3, [r1]
21f27818:	e51b258c 	ldr	r2, [fp, #-1420]
21f2781c:	e2822004 	add	r2, r2, #4	; 0x4
21f27820:	e50b258c 	str	r2, [fp, #-1420]
21f27824:	e3a03000 	mov	r3, #0	; 0x0
21f27828:	e51bc58c 	ldr	ip, [fp, #-1420]
21f2782c:	e58c3000 	str	r3, [ip]
21f27830:	e51b058c 	ldr	r0, [fp, #-1420]
21f27834:	e2800004 	add	r0, r0, #4	; 0x4
21f27838:	e50b058c 	str	r0, [fp, #-1420]
21f2783c:	e3a03000 	mov	r3, #0	; 0x0
21f27840:	e51b158c 	ldr	r1, [fp, #-1420]
21f27844:	e5813000 	str	r3, [r1]
21f27848:	e51b258c 	ldr	r2, [fp, #-1420]
21f2784c:	e2822004 	add	r2, r2, #4	; 0x4
21f27850:	e50b258c 	str	r2, [fp, #-1420]
21f27854:	e3a03000 	mov	r3, #0	; 0x0
21f27858:	e51bc58c 	ldr	ip, [fp, #-1420]
21f2785c:	e58c3000 	str	r3, [ip]
  p = b;  i = n;
21f27860:	e51b0578 	ldr	r0, [fp, #-1400]
21f27864:	e50b058c 	str	r0, [fp, #-1420]
21f27868:	e51b157c 	ldr	r1, [fp, #-1404]
21f2786c:	e50b1598 	str	r1, [fp, #-1432]
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
21f27870:	e51b258c 	ldr	r2, [fp, #-1420]
21f27874:	e5920000 	ldr	r0, [r2]
21f27878:	e3e02063 	mvn	r2, #99	; 0x63
21f2787c:	e1a03100 	mov	r3, r0, lsl #2
21f27880:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27884:	e083300c 	add	r3, r3, ip
21f27888:	e0833002 	add	r3, r3, r2
21f2788c:	e5933000 	ldr	r3, [r3]
21f27890:	e2831001 	add	r1, r3, #1	; 0x1
21f27894:	e3e02063 	mvn	r2, #99	; 0x63
21f27898:	e1a03100 	mov	r3, r0, lsl #2
21f2789c:	e24b000c 	sub	r0, fp, #12	; 0xc
21f278a0:	e0833000 	add	r3, r3, r0
21f278a4:	e0833002 	add	r3, r3, r2
21f278a8:	e5831000 	str	r1, [r3]
21f278ac:	e51b158c 	ldr	r1, [fp, #-1420]
21f278b0:	e2811004 	add	r1, r1, #4	; 0x4
21f278b4:	e50b158c 	str	r1, [fp, #-1420]
  } while (--i);
21f278b8:	e51b2598 	ldr	r2, [fp, #-1432]
21f278bc:	e2422001 	sub	r2, r2, #1	; 0x1
21f278c0:	e50b2598 	str	r2, [fp, #-1432]
21f278c4:	e51b3598 	ldr	r3, [fp, #-1432]
21f278c8:	e3530000 	cmp	r3, #0	; 0x0
21f278cc:	1affffe7 	bne	21f27870 <huft_build+0x1b0>
  if (c[0] == n)                /* null input--all zero length codes */
21f278d0:	e51b2070 	ldr	r2, [fp, #-112]
21f278d4:	e51b357c 	ldr	r3, [fp, #-1404]
21f278d8:	e1520003 	cmp	r2, r3
21f278dc:	1a000008 	bne	21f27904 <huft_build+0x244>
  {
    *t = (inflate_huft *)Z_NULL;
21f278e0:	e59b2008 	ldr	r2, [fp, #8]
21f278e4:	e3a03000 	mov	r3, #0	; 0x0
21f278e8:	e5823000 	str	r3, [r2]
    *m = 0;
21f278ec:	e59b200c 	ldr	r2, [fp, #12]
21f278f0:	e3a03000 	mov	r3, #0	; 0x0
21f278f4:	e5823000 	str	r3, [r2]
    return Z_OK;
21f278f8:	e3a0c000 	mov	ip, #0	; 0x0
21f278fc:	e50bc5a8 	str	ip, [fp, #-1448]
21f27900:	ea000244 	b	21f28218 <huft_build+0xb58>
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
21f27904:	e59b300c 	ldr	r3, [fp, #12]
21f27908:	e5933000 	ldr	r3, [r3]
21f2790c:	e50b3020 	str	r3, [fp, #-32]
  for (j = 1; j <= BMAX; j++)
21f27910:	e3a00001 	mov	r0, #1	; 0x1
21f27914:	e50b0594 	str	r0, [fp, #-1428]
21f27918:	ea00000b 	b	21f2794c <huft_build+0x28c>
    if (c[j])
21f2791c:	e51b3594 	ldr	r3, [fp, #-1428]
21f27920:	e3e02063 	mvn	r2, #99	; 0x63
21f27924:	e1a03103 	mov	r3, r3, lsl #2
21f27928:	e24b100c 	sub	r1, fp, #12	; 0xc
21f2792c:	e0833001 	add	r3, r3, r1
21f27930:	e0833002 	add	r3, r3, r2
21f27934:	e5933000 	ldr	r3, [r3]
21f27938:	e3530000 	cmp	r3, #0	; 0x0
21f2793c:	1a000005 	bne	21f27958 <huft_build+0x298>
21f27940:	e51b2594 	ldr	r2, [fp, #-1428]
21f27944:	e2822001 	add	r2, r2, #1	; 0x1
21f27948:	e50b2594 	str	r2, [fp, #-1428]
21f2794c:	e51b3594 	ldr	r3, [fp, #-1428]
21f27950:	e353000f 	cmp	r3, #15	; 0xf
21f27954:	9afffff0 	bls	21f2791c <huft_build+0x25c>
      break;
  k = j;                        /* minimum code length */
21f27958:	e51bc594 	ldr	ip, [fp, #-1428]
21f2795c:	e50bc590 	str	ip, [fp, #-1424]
  if ((uInt)l < j)
21f27960:	e51b3020 	ldr	r3, [fp, #-32]
21f27964:	e51b0594 	ldr	r0, [fp, #-1428]
21f27968:	e1530000 	cmp	r3, r0
21f2796c:	2a000001 	bcs	21f27978 <huft_build+0x2b8>
    l = j;
21f27970:	e51b1594 	ldr	r1, [fp, #-1428]
21f27974:	e50b1020 	str	r1, [fp, #-32]
  for (i = BMAX; i; i--)
21f27978:	e3a0200f 	mov	r2, #15	; 0xf
21f2797c:	e50b2598 	str	r2, [fp, #-1432]
21f27980:	ea00000b 	b	21f279b4 <huft_build+0x2f4>
    if (c[i])
21f27984:	e51b3598 	ldr	r3, [fp, #-1432]
21f27988:	e3e02063 	mvn	r2, #99	; 0x63
21f2798c:	e1a03103 	mov	r3, r3, lsl #2
21f27990:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27994:	e083300c 	add	r3, r3, ip
21f27998:	e0833002 	add	r3, r3, r2
21f2799c:	e5933000 	ldr	r3, [r3]
21f279a0:	e3530000 	cmp	r3, #0	; 0x0
21f279a4:	1a000005 	bne	21f279c0 <huft_build+0x300>
21f279a8:	e51b0598 	ldr	r0, [fp, #-1432]
21f279ac:	e2400001 	sub	r0, r0, #1	; 0x1
21f279b0:	e50b0598 	str	r0, [fp, #-1432]
21f279b4:	e51b1598 	ldr	r1, [fp, #-1432]
21f279b8:	e3510000 	cmp	r1, #0	; 0x0
21f279bc:	1afffff0 	bne	21f27984 <huft_build+0x2c4>
      break;
  g = i;                        /* maximum code length */
21f279c0:	e51b2598 	ldr	r2, [fp, #-1432]
21f279c4:	e50b2028 	str	r2, [fp, #-40]
  if ((uInt)l > i)
21f279c8:	e51b3020 	ldr	r3, [fp, #-32]
21f279cc:	e51bc598 	ldr	ip, [fp, #-1432]
21f279d0:	e153000c 	cmp	r3, ip
21f279d4:	9a000001 	bls	21f279e0 <huft_build+0x320>
    l = i;
21f279d8:	e51b0598 	ldr	r0, [fp, #-1432]
21f279dc:	e50b0020 	str	r0, [fp, #-32]
  *m = l;
21f279e0:	e51b2020 	ldr	r2, [fp, #-32]
21f279e4:	e59b300c 	ldr	r3, [fp, #12]
21f279e8:	e5832000 	str	r2, [r3]


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
21f279ec:	e51b2594 	ldr	r2, [fp, #-1428]
21f279f0:	e3a03001 	mov	r3, #1	; 0x1
21f279f4:	e1a03213 	mov	r3, r3, lsl r2
21f279f8:	e50b3014 	str	r3, [fp, #-20]
21f279fc:	ea000015 	b	21f27a58 <huft_build+0x398>
    if ((y -= c[j]) < 0)
21f27a00:	e51b1014 	ldr	r1, [fp, #-20]
21f27a04:	e51b3594 	ldr	r3, [fp, #-1428]
21f27a08:	e3e02063 	mvn	r2, #99	; 0x63
21f27a0c:	e1a03103 	mov	r3, r3, lsl #2
21f27a10:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27a14:	e083300c 	add	r3, r3, ip
21f27a18:	e0833002 	add	r3, r3, r2
21f27a1c:	e5933000 	ldr	r3, [r3]
21f27a20:	e0633001 	rsb	r3, r3, r1
21f27a24:	e50b3014 	str	r3, [fp, #-20]
21f27a28:	e51b3014 	ldr	r3, [fp, #-20]
21f27a2c:	e3530000 	cmp	r3, #0	; 0x0
21f27a30:	aa000002 	bge	21f27a40 <huft_build+0x380>
      return Z_DATA_ERROR;
21f27a34:	e3e00002 	mvn	r0, #2	; 0x2
21f27a38:	e50b05a8 	str	r0, [fp, #-1448]
21f27a3c:	ea0001f5 	b	21f28218 <huft_build+0xb58>
21f27a40:	e51b1594 	ldr	r1, [fp, #-1428]
21f27a44:	e2811001 	add	r1, r1, #1	; 0x1
21f27a48:	e50b1594 	str	r1, [fp, #-1428]
21f27a4c:	e51b3014 	ldr	r3, [fp, #-20]
21f27a50:	e1a03083 	mov	r3, r3, lsl #1
21f27a54:	e50b3014 	str	r3, [fp, #-20]
21f27a58:	e51b2594 	ldr	r2, [fp, #-1428]
21f27a5c:	e51b3598 	ldr	r3, [fp, #-1432]
21f27a60:	e1520003 	cmp	r2, r3
21f27a64:	3affffe5 	bcc	21f27a00 <huft_build+0x340>
  if ((y -= c[i]) < 0)
21f27a68:	e51b1014 	ldr	r1, [fp, #-20]
21f27a6c:	e51b3598 	ldr	r3, [fp, #-1432]
21f27a70:	e3e02063 	mvn	r2, #99	; 0x63
21f27a74:	e1a03103 	mov	r3, r3, lsl #2
21f27a78:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27a7c:	e083300c 	add	r3, r3, ip
21f27a80:	e0833002 	add	r3, r3, r2
21f27a84:	e5933000 	ldr	r3, [r3]
21f27a88:	e0633001 	rsb	r3, r3, r1
21f27a8c:	e50b3014 	str	r3, [fp, #-20]
21f27a90:	e51b3014 	ldr	r3, [fp, #-20]
21f27a94:	e3530000 	cmp	r3, #0	; 0x0
21f27a98:	aa000002 	bge	21f27aa8 <huft_build+0x3e8>
    return Z_DATA_ERROR;
21f27a9c:	e3e00002 	mvn	r0, #2	; 0x2
21f27aa0:	e50b05a8 	str	r0, [fp, #-1448]
21f27aa4:	ea0001db 	b	21f28218 <huft_build+0xb58>
  c[i] += y;
21f27aa8:	e51b0598 	ldr	r0, [fp, #-1432]
21f27aac:	e51b3598 	ldr	r3, [fp, #-1432]
21f27ab0:	e3e02063 	mvn	r2, #99	; 0x63
21f27ab4:	e1a03103 	mov	r3, r3, lsl #2
21f27ab8:	e24b100c 	sub	r1, fp, #12	; 0xc
21f27abc:	e0833001 	add	r3, r3, r1
21f27ac0:	e0833002 	add	r3, r3, r2
21f27ac4:	e5932000 	ldr	r2, [r3]
21f27ac8:	e51b3014 	ldr	r3, [fp, #-20]
21f27acc:	e0821003 	add	r1, r2, r3
21f27ad0:	e3e02063 	mvn	r2, #99	; 0x63
21f27ad4:	e1a03100 	mov	r3, r0, lsl #2
21f27ad8:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27adc:	e083300c 	add	r3, r3, ip
21f27ae0:	e0833002 	add	r3, r3, r2
21f27ae4:	e5831000 	str	r1, [r3]


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
21f27ae8:	e3a00000 	mov	r0, #0	; 0x0
21f27aec:	e50b0594 	str	r0, [fp, #-1428]
21f27af0:	e51b1594 	ldr	r1, [fp, #-1428]
21f27af4:	e50b1570 	str	r1, [fp, #-1392]
  p = c + 1;  xp = x + 2;
21f27af8:	e24b3070 	sub	r3, fp, #112	; 0x70
21f27afc:	e2833004 	add	r3, r3, #4	; 0x4
21f27b00:	e50b358c 	str	r3, [fp, #-1420]
21f27b04:	e24b3e56 	sub	r3, fp, #1376	; 0x560
21f27b08:	e243300c 	sub	r3, r3, #12	; 0xc
21f27b0c:	e2433008 	sub	r3, r3, #8	; 0x8
21f27b10:	e2833008 	add	r3, r3, #8	; 0x8
21f27b14:	e50b3018 	str	r3, [fp, #-24]
  while (--i) {                 /* note that i == g from above */
21f27b18:	ea00000d 	b	21f27b54 <huft_build+0x494>
    *xp++ = (j += *p++);
21f27b1c:	e51b258c 	ldr	r2, [fp, #-1420]
21f27b20:	e5923000 	ldr	r3, [r2]
21f27b24:	e51bc594 	ldr	ip, [fp, #-1428]
21f27b28:	e08cc003 	add	ip, ip, r3
21f27b2c:	e50bc594 	str	ip, [fp, #-1428]
21f27b30:	e51b3018 	ldr	r3, [fp, #-24]
21f27b34:	e51b0594 	ldr	r0, [fp, #-1428]
21f27b38:	e5830000 	str	r0, [r3]
21f27b3c:	e51b3018 	ldr	r3, [fp, #-24]
21f27b40:	e2833004 	add	r3, r3, #4	; 0x4
21f27b44:	e50b3018 	str	r3, [fp, #-24]
21f27b48:	e51b158c 	ldr	r1, [fp, #-1420]
21f27b4c:	e2811004 	add	r1, r1, #4	; 0x4
21f27b50:	e50b158c 	str	r1, [fp, #-1420]
21f27b54:	e51b2598 	ldr	r2, [fp, #-1432]
21f27b58:	e2422001 	sub	r2, r2, #1	; 0x1
21f27b5c:	e50b2598 	str	r2, [fp, #-1432]
21f27b60:	e51b3598 	ldr	r3, [fp, #-1432]
21f27b64:	e3530000 	cmp	r3, #0	; 0x0
21f27b68:	1affffeb 	bne	21f27b1c <huft_build+0x45c>
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
21f27b6c:	e51bc578 	ldr	ip, [fp, #-1400]
21f27b70:	e50bc58c 	str	ip, [fp, #-1420]
21f27b74:	e3a00000 	mov	r0, #0	; 0x0
21f27b78:	e50b0598 	str	r0, [fp, #-1432]
  do {
    if ((j = *p++) != 0)
21f27b7c:	e51b158c 	ldr	r1, [fp, #-1420]
21f27b80:	e5911000 	ldr	r1, [r1]
21f27b84:	e50b1594 	str	r1, [fp, #-1428]
21f27b88:	e51b2594 	ldr	r2, [fp, #-1428]
21f27b8c:	e3520000 	cmp	r2, #0	; 0x0
21f27b90:	03a03000 	moveq	r3, #0	; 0x0
21f27b94:	13a03001 	movne	r3, #1	; 0x1
21f27b98:	e20330ff 	and	r3, r3, #255	; 0xff
21f27b9c:	e51bc58c 	ldr	ip, [fp, #-1420]
21f27ba0:	e28cc004 	add	ip, ip, #4	; 0x4
21f27ba4:	e50bc58c 	str	ip, [fp, #-1420]
21f27ba8:	e3530000 	cmp	r3, #0	; 0x0
21f27bac:	0a000017 	beq	21f27c10 <huft_build+0x550>
      v[x[j]++] = i;
21f27bb0:	e51b0594 	ldr	r0, [fp, #-1428]
21f27bb4:	e3e03e56 	mvn	r3, #1376	; 0x560
21f27bb8:	e2433007 	sub	r3, r3, #7	; 0x7
21f27bbc:	e1a02100 	mov	r2, r0, lsl #2
21f27bc0:	e24b100c 	sub	r1, fp, #12	; 0xc
21f27bc4:	e0822001 	add	r2, r2, r1
21f27bc8:	e0823003 	add	r3, r2, r3
21f27bcc:	e5931000 	ldr	r1, [r3]
21f27bd0:	e3e03e52 	mvn	r3, #1312	; 0x520
21f27bd4:	e2433007 	sub	r3, r3, #7	; 0x7
21f27bd8:	e1a02101 	mov	r2, r1, lsl #2
21f27bdc:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27be0:	e082200c 	add	r2, r2, ip
21f27be4:	e0823003 	add	r3, r2, r3
21f27be8:	e51b2598 	ldr	r2, [fp, #-1432]
21f27bec:	e5832000 	str	r2, [r3]
21f27bf0:	e2811001 	add	r1, r1, #1	; 0x1
21f27bf4:	e3e03e56 	mvn	r3, #1376	; 0x560
21f27bf8:	e2433007 	sub	r3, r3, #7	; 0x7
21f27bfc:	e1a02100 	mov	r2, r0, lsl #2
21f27c00:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27c04:	e082200c 	add	r2, r2, ip
21f27c08:	e0823003 	add	r3, r2, r3
21f27c0c:	e5831000 	str	r1, [r3]
  } while (++i < n);
21f27c10:	e51b0598 	ldr	r0, [fp, #-1432]
21f27c14:	e2800001 	add	r0, r0, #1	; 0x1
21f27c18:	e50b0598 	str	r0, [fp, #-1432]
21f27c1c:	e51b357c 	ldr	r3, [fp, #-1404]
21f27c20:	e51b1598 	ldr	r1, [fp, #-1432]
21f27c24:	e1510003 	cmp	r1, r3
21f27c28:	3affffd3 	bcc	21f27b7c <huft_build+0x4bc>


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
21f27c2c:	e3a02000 	mov	r2, #0	; 0x0
21f27c30:	e50b2598 	str	r2, [fp, #-1432]
21f27c34:	e51b3598 	ldr	r3, [fp, #-1432]
21f27c38:	e50b3574 	str	r3, [fp, #-1396]
  p = v;                        /* grab values in bit order */
21f27c3c:	e24bce52 	sub	ip, fp, #1312	; 0x520
21f27c40:	e24cc00c 	sub	ip, ip, #12	; 0xc
21f27c44:	e50bc58c 	str	ip, [fp, #-1420]
21f27c48:	e51b058c 	ldr	r0, [fp, #-1420]
21f27c4c:	e2400008 	sub	r0, r0, #8	; 0x8
21f27c50:	e50b058c 	str	r0, [fp, #-1420]
  h = -1;                       /* no tables yet--level -1 */
21f27c54:	e3e03000 	mvn	r3, #0	; 0x0
21f27c58:	e50b3024 	str	r3, [fp, #-36]
  w = -l;                       /* bits decoded == (l * h) */
21f27c5c:	e51b3020 	ldr	r3, [fp, #-32]
21f27c60:	e2633000 	rsb	r3, r3, #0	; 0x0
21f27c64:	e50b3588 	str	r3, [fp, #-1416]
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
21f27c68:	e3a03000 	mov	r3, #0	; 0x0
21f27c6c:	e50b30b4 	str	r3, [fp, #-180]
  q = (inflate_huft *)Z_NULL;   /* ditto */
21f27c70:	e3a03000 	mov	r3, #0	; 0x0
21f27c74:	e50b301c 	str	r3, [fp, #-28]
  z = 0;                        /* ditto */
21f27c78:	e3a03000 	mov	r3, #0	; 0x0
21f27c7c:	e50b3010 	str	r3, [fp, #-16]

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
21f27c80:	ea000153 	b	21f281d4 <huft_build+0xb14>
  {
    a = c[k];
21f27c84:	e51b3590 	ldr	r3, [fp, #-1424]
21f27c88:	e3e02063 	mvn	r2, #99	; 0x63
21f27c8c:	e1a03103 	mov	r3, r3, lsl #2
21f27c90:	e24b100c 	sub	r1, fp, #12	; 0xc
21f27c94:	e0833001 	add	r3, r3, r1
21f27c98:	e0833002 	add	r3, r3, r2
21f27c9c:	e5933000 	ldr	r3, [r3]
21f27ca0:	e50b3030 	str	r3, [fp, #-48]
    while (a--)
21f27ca4:	ea000141 	b	21f281b0 <huft_build+0xaf0>
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
	h++;
21f27ca8:	e51b3024 	ldr	r3, [fp, #-36]
21f27cac:	e2833001 	add	r3, r3, #1	; 0x1
21f27cb0:	e50b3024 	str	r3, [fp, #-36]
	w += l;                 /* previous table always l bits */
21f27cb4:	e51b3020 	ldr	r3, [fp, #-32]
21f27cb8:	e51b2588 	ldr	r2, [fp, #-1416]
21f27cbc:	e0822003 	add	r2, r2, r3
21f27cc0:	e50b2588 	str	r2, [fp, #-1416]

	/* compute minimum size table less than or equal to l bits */
	z = (z = g - w) > (uInt)l ? l : z;      /* table size upper limit */
21f27cc4:	e51b3028 	ldr	r3, [fp, #-40]
21f27cc8:	e51bc588 	ldr	ip, [fp, #-1416]
21f27ccc:	e06c3003 	rsb	r3, ip, r3
21f27cd0:	e50b3010 	str	r3, [fp, #-16]
21f27cd4:	e51b2020 	ldr	r2, [fp, #-32]
21f27cd8:	e51b3010 	ldr	r3, [fp, #-16]
21f27cdc:	e1530002 	cmp	r3, r2
21f27ce0:	9a000002 	bls	21f27cf0 <huft_build+0x630>
21f27ce4:	e51b0020 	ldr	r0, [fp, #-32]
21f27ce8:	e50b05a4 	str	r0, [fp, #-1444]
21f27cec:	ea000001 	b	21f27cf8 <huft_build+0x638>
21f27cf0:	e51b1010 	ldr	r1, [fp, #-16]
21f27cf4:	e50b15a4 	str	r1, [fp, #-1444]
21f27cf8:	e51b25a4 	ldr	r2, [fp, #-1444]
21f27cfc:	e50b2010 	str	r2, [fp, #-16]
	if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
21f27d00:	e51bc590 	ldr	ip, [fp, #-1424]
21f27d04:	e51b0588 	ldr	r0, [fp, #-1416]
21f27d08:	e060300c 	rsb	r3, r0, ip
21f27d0c:	e50b3594 	str	r3, [fp, #-1428]
21f27d10:	e51b2594 	ldr	r2, [fp, #-1428]
21f27d14:	e3a03001 	mov	r3, #1	; 0x1
21f27d18:	e1a03213 	mov	r3, r3, lsl r2
21f27d1c:	e50b302c 	str	r3, [fp, #-44]
21f27d20:	e51b3030 	ldr	r3, [fp, #-48]
21f27d24:	e2832001 	add	r2, r3, #1	; 0x1
21f27d28:	e51b302c 	ldr	r3, [fp, #-44]
21f27d2c:	e1530002 	cmp	r3, r2
21f27d30:	9a000026 	bls	21f27dd0 <huft_build+0x710>
	{                       /* too few codes for k-w bit table */
	  f -= a + 1;           /* deduct codes from patterns left */
21f27d34:	e51b202c 	ldr	r2, [fp, #-44]
21f27d38:	e51b3030 	ldr	r3, [fp, #-48]
21f27d3c:	e0633002 	rsb	r3, r3, r2
21f27d40:	e2433001 	sub	r3, r3, #1	; 0x1
21f27d44:	e50b302c 	str	r3, [fp, #-44]
	  xp = c + k;
21f27d48:	e51b3590 	ldr	r3, [fp, #-1424]
21f27d4c:	e1a03103 	mov	r3, r3, lsl #2
21f27d50:	e1a02003 	mov	r2, r3
21f27d54:	e24b3070 	sub	r3, fp, #112	; 0x70
21f27d58:	e0833002 	add	r3, r3, r2
21f27d5c:	e50b3018 	str	r3, [fp, #-24]
	  if (j < z)
21f27d60:	e51b3010 	ldr	r3, [fp, #-16]
21f27d64:	e51b1594 	ldr	r1, [fp, #-1428]
21f27d68:	e1510003 	cmp	r1, r3
21f27d6c:	3a000010 	bcc	21f27db4 <huft_build+0x6f4>
21f27d70:	ea000016 	b	21f27dd0 <huft_build+0x710>
	    while (++j < z)     /* try smaller tables up to z bits */
	    {
	      if ((f <<= 1) <= *++xp)
21f27d74:	e51b302c 	ldr	r3, [fp, #-44]
21f27d78:	e1a03083 	mov	r3, r3, lsl #1
21f27d7c:	e50b302c 	str	r3, [fp, #-44]
21f27d80:	e51b3018 	ldr	r3, [fp, #-24]
21f27d84:	e2833004 	add	r3, r3, #4	; 0x4
21f27d88:	e50b3018 	str	r3, [fp, #-24]
21f27d8c:	e51b3018 	ldr	r3, [fp, #-24]
21f27d90:	e5932000 	ldr	r2, [r3]
21f27d94:	e51b302c 	ldr	r3, [fp, #-44]
21f27d98:	e1530002 	cmp	r3, r2
21f27d9c:	9a00000b 	bls	21f27dd0 <huft_build+0x710>
		break;          /* enough codes to use up j bits */
	      f -= *xp;         /* else deduct codes from patterns */
21f27da0:	e51b3018 	ldr	r3, [fp, #-24]
21f27da4:	e5932000 	ldr	r2, [r3]
21f27da8:	e51b302c 	ldr	r3, [fp, #-44]
21f27dac:	e0623003 	rsb	r3, r2, r3
21f27db0:	e50b302c 	str	r3, [fp, #-44]
21f27db4:	e51b2594 	ldr	r2, [fp, #-1428]
21f27db8:	e2822001 	add	r2, r2, #1	; 0x1
21f27dbc:	e50b2594 	str	r2, [fp, #-1428]
21f27dc0:	e51b3010 	ldr	r3, [fp, #-16]
21f27dc4:	e51bc594 	ldr	ip, [fp, #-1428]
21f27dc8:	e15c0003 	cmp	ip, r3
21f27dcc:	3affffe8 	bcc	21f27d74 <huft_build+0x6b4>
	    }
	}
	z = 1 << j;             /* table entries for j-bit table */
21f27dd0:	e51b2594 	ldr	r2, [fp, #-1428]
21f27dd4:	e3a03001 	mov	r3, #1	; 0x1
21f27dd8:	e1a03213 	mov	r3, r3, lsl r2
21f27ddc:	e50b3010 	str	r3, [fp, #-16]

	/* allocate and link in new table */
	if ((q = (inflate_huft *)ZALLOC
21f27de0:	e59b3010 	ldr	r3, [fp, #16]
21f27de4:	e593c020 	ldr	ip, [r3, #32]
21f27de8:	e59b3010 	ldr	r3, [fp, #16]
21f27dec:	e5932028 	ldr	r2, [r3, #40]
21f27df0:	e51b3010 	ldr	r3, [fp, #-16]
21f27df4:	e2833001 	add	r3, r3, #1	; 0x1
21f27df8:	e1a00002 	mov	r0, r2
21f27dfc:	e1a01003 	mov	r1, r3
21f27e00:	e3a02008 	mov	r2, #8	; 0x8
21f27e04:	e1a0e00f 	mov	lr, pc
21f27e08:	e1a0f00c 	mov	pc, ip
21f27e0c:	e1a03000 	mov	r3, r0
21f27e10:	e50b301c 	str	r3, [fp, #-28]
21f27e14:	e51b301c 	ldr	r3, [fp, #-28]
21f27e18:	e3530000 	cmp	r3, #0	; 0x0
21f27e1c:	1a000009 	bne	21f27e48 <huft_build+0x788>
	     (zs,z + 1,sizeof(inflate_huft))) == Z_NULL)
	{
	  if (h)
21f27e20:	e51b3024 	ldr	r3, [fp, #-36]
21f27e24:	e3530000 	cmp	r3, #0	; 0x0
21f27e28:	0a000003 	beq	21f27e3c <huft_build+0x77c>
	    inflate_trees_free(u[0], zs);
21f27e2c:	e51b30b4 	ldr	r3, [fp, #-180]
21f27e30:	e1a00003 	mov	r0, r3
21f27e34:	e59b1010 	ldr	r1, [fp, #16]
21f27e38:	eb000291 	bl	21f28884 <inflate_trees_free>
	  return Z_MEM_ERROR;   /* not enough memory */
21f27e3c:	e3e00003 	mvn	r0, #3	; 0x3
21f27e40:	e50b05a8 	str	r0, [fp, #-1448]
21f27e44:	ea0000f3 	b	21f28218 <huft_build+0xb58>
	}
	q->word.Nalloc = z + 1;
21f27e48:	e51b3010 	ldr	r3, [fp, #-16]
21f27e4c:	e2832001 	add	r2, r3, #1	; 0x1
21f27e50:	e51b301c 	ldr	r3, [fp, #-28]
21f27e54:	e5832000 	str	r2, [r3]
#ifdef DEBUG_ZLIB
	inflate_hufts += z + 1;
#endif
	*t = q + 1;             /* link to list for huft_free() */
21f27e58:	e51b301c 	ldr	r3, [fp, #-28]
21f27e5c:	e2832008 	add	r2, r3, #8	; 0x8
21f27e60:	e59b3008 	ldr	r3, [fp, #8]
21f27e64:	e5832000 	str	r2, [r3]
	*(t = &(q->next)) = Z_NULL;
21f27e68:	e51b301c 	ldr	r3, [fp, #-28]
21f27e6c:	e2833004 	add	r3, r3, #4	; 0x4
21f27e70:	e58b3008 	str	r3, [fp, #8]
21f27e74:	e59b2008 	ldr	r2, [fp, #8]
21f27e78:	e3a03000 	mov	r3, #0	; 0x0
21f27e7c:	e5823000 	str	r3, [r2]
	u[h] = ++q;             /* table starts after link */
21f27e80:	e51b1024 	ldr	r1, [fp, #-36]
21f27e84:	e51b301c 	ldr	r3, [fp, #-28]
21f27e88:	e2833008 	add	r3, r3, #8	; 0x8
21f27e8c:	e50b301c 	str	r3, [fp, #-28]
21f27e90:	e3e020a7 	mvn	r2, #167	; 0xa7
21f27e94:	e1a03101 	mov	r3, r1, lsl #2
21f27e98:	e24b100c 	sub	r1, fp, #12	; 0xc
21f27e9c:	e0833001 	add	r3, r3, r1
21f27ea0:	e0832002 	add	r2, r3, r2
21f27ea4:	e51b301c 	ldr	r3, [fp, #-28]
21f27ea8:	e5823000 	str	r3, [r2]

	/* connect to last table, if there is one */
	if (h)
21f27eac:	e51b3024 	ldr	r3, [fp, #-36]
21f27eb0:	e3530000 	cmp	r3, #0	; 0x0
21f27eb4:	0a000024 	beq	21f27f4c <huft_build+0x88c>
	{
	  x[h] = i;             /* save pattern for backing up */
21f27eb8:	e51b2024 	ldr	r2, [fp, #-36]
21f27ebc:	e3e03e56 	mvn	r3, #1376	; 0x560
21f27ec0:	e2433007 	sub	r3, r3, #7	; 0x7
21f27ec4:	e1a02102 	mov	r2, r2, lsl #2
21f27ec8:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f27ecc:	e082200c 	add	r2, r2, ip
21f27ed0:	e0823003 	add	r3, r2, r3
21f27ed4:	e51b0598 	ldr	r0, [fp, #-1432]
21f27ed8:	e5830000 	str	r0, [r3]
	  r.bits = (Byte)l;     /* bits to dump before this table */
21f27edc:	e51b3020 	ldr	r3, [fp, #-32]
21f27ee0:	e20330ff 	and	r3, r3, #255	; 0xff
21f27ee4:	e54b3077 	strb	r3, [fp, #-119]
	  r.exop = (Byte)j;     /* bits in this table */
21f27ee8:	e51b1594 	ldr	r1, [fp, #-1428]
21f27eec:	e20130ff 	and	r3, r1, #255	; 0xff
21f27ef0:	e54b3078 	strb	r3, [fp, #-120]
	  r.next = q;           /* pointer to this table */
21f27ef4:	e51b301c 	ldr	r3, [fp, #-28]
21f27ef8:	e50b3074 	str	r3, [fp, #-116]
	  j = i >> (w - l);     /* (get around Turbo C bug) */
21f27efc:	e51b3020 	ldr	r3, [fp, #-32]
21f27f00:	e51b2588 	ldr	r2, [fp, #-1416]
21f27f04:	e0633002 	rsb	r3, r3, r2
21f27f08:	e51bc598 	ldr	ip, [fp, #-1432]
21f27f0c:	e1a0333c 	mov	r3, ip, lsr r3
21f27f10:	e50b3594 	str	r3, [fp, #-1428]
	  u[h-1][j] = r;        /* connect to last table */
21f27f14:	e51b3024 	ldr	r3, [fp, #-36]
21f27f18:	e2433001 	sub	r3, r3, #1	; 0x1
21f27f1c:	e3e020a7 	mvn	r2, #167	; 0xa7
21f27f20:	e1a03103 	mov	r3, r3, lsl #2
21f27f24:	e24b000c 	sub	r0, fp, #12	; 0xc
21f27f28:	e0833000 	add	r3, r3, r0
21f27f2c:	e0833002 	add	r3, r3, r2
21f27f30:	e5932000 	ldr	r2, [r3]
21f27f34:	e51b1594 	ldr	r1, [fp, #-1428]
21f27f38:	e1a03181 	mov	r3, r1, lsl #3
21f27f3c:	e0823003 	add	r3, r2, r3
21f27f40:	e24b0078 	sub	r0, fp, #120	; 0x78
21f27f44:	e8900003 	ldmia	r0, {r0, r1}
21f27f48:	e8830003 	stmia	r3, {r0, r1}
21f27f4c:	e51b3020 	ldr	r3, [fp, #-32]
21f27f50:	e51b1588 	ldr	r1, [fp, #-1416]
21f27f54:	e0813003 	add	r3, r1, r3
21f27f58:	e51b2590 	ldr	r2, [fp, #-1424]
21f27f5c:	e1530002 	cmp	r3, r2
21f27f60:	baffff50 	blt	21f27ca8 <huft_build+0x5e8>
	}
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
21f27f64:	e51bc590 	ldr	ip, [fp, #-1424]
21f27f68:	e20c30ff 	and	r3, ip, #255	; 0xff
21f27f6c:	e51b0588 	ldr	r0, [fp, #-1416]
21f27f70:	e20020ff 	and	r2, r0, #255	; 0xff
21f27f74:	e1a01003 	mov	r1, r3
21f27f78:	e1a03002 	mov	r3, r2
21f27f7c:	e0633001 	rsb	r3, r3, r1
21f27f80:	e20330ff 	and	r3, r3, #255	; 0xff
21f27f84:	e20330ff 	and	r3, r3, #255	; 0xff
21f27f88:	e54b3077 	strb	r3, [fp, #-119]
      if (p >= v + n)
21f27f8c:	e51b357c 	ldr	r3, [fp, #-1404]
21f27f90:	e1a03103 	mov	r3, r3, lsl #2
21f27f94:	e1a02003 	mov	r2, r3
21f27f98:	e24b3e52 	sub	r3, fp, #1312	; 0x520
21f27f9c:	e243300c 	sub	r3, r3, #12	; 0xc
21f27fa0:	e2433008 	sub	r3, r3, #8	; 0x8
21f27fa4:	e0833002 	add	r3, r3, r2
21f27fa8:	e51b158c 	ldr	r1, [fp, #-1420]
21f27fac:	e1530001 	cmp	r3, r1
21f27fb0:	8a000002 	bhi	21f27fc0 <huft_build+0x900>
	r.exop = 128 + 64;      /* out of values--invalid code */
21f27fb4:	e3e0303f 	mvn	r3, #63	; 0x3f
21f27fb8:	e54b3078 	strb	r3, [fp, #-120]
21f27fbc:	ea000032 	b	21f2808c <huft_build+0x9cc>
      else if (*p < s)
21f27fc0:	e51b358c 	ldr	r3, [fp, #-1420]
21f27fc4:	e5932000 	ldr	r2, [r3]
21f27fc8:	e51b3580 	ldr	r3, [fp, #-1408]
21f27fcc:	e1520003 	cmp	r2, r3
21f27fd0:	2a000012 	bcs	21f28020 <huft_build+0x960>
      {
	r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
21f27fd4:	e51bc58c 	ldr	ip, [fp, #-1420]
21f27fd8:	e59c3000 	ldr	r3, [ip]
21f27fdc:	e35300ff 	cmp	r3, #255	; 0xff
21f27fe0:	8a000002 	bhi	21f27ff0 <huft_build+0x930>
21f27fe4:	e3a00000 	mov	r0, #0	; 0x0
21f27fe8:	e50b05a0 	str	r0, [fp, #-1440]
21f27fec:	ea000001 	b	21f27ff8 <huft_build+0x938>
21f27ff0:	e3a01060 	mov	r1, #96	; 0x60
21f27ff4:	e50b15a0 	str	r1, [fp, #-1440]
21f27ff8:	e51b25a0 	ldr	r2, [fp, #-1440]
21f27ffc:	e1a03002 	mov	r3, r2
21f28000:	e54b3078 	strb	r3, [fp, #-120]
	r.base = *p++;          /* simple code is just the value */
21f28004:	e51bc58c 	ldr	ip, [fp, #-1420]
21f28008:	e59c3000 	ldr	r3, [ip]
21f2800c:	e50b3074 	str	r3, [fp, #-116]
21f28010:	e51b058c 	ldr	r0, [fp, #-1420]
21f28014:	e2800004 	add	r0, r0, #4	; 0x4
21f28018:	e50b058c 	str	r0, [fp, #-1420]
21f2801c:	ea00001a 	b	21f2808c <huft_build+0x9cc>
      }
      else
      {
	r.exop = (Byte)e[*p - s] + 16 + 64; /* non-simple--look up in lists */
21f28020:	e51b158c 	ldr	r1, [fp, #-1420]
21f28024:	e5912000 	ldr	r2, [r1]
21f28028:	e51b3580 	ldr	r3, [fp, #-1408]
21f2802c:	e0633002 	rsb	r3, r3, r2
21f28030:	e1a03103 	mov	r3, r3, lsl #2
21f28034:	e1a02003 	mov	r2, r3
21f28038:	e59b3004 	ldr	r3, [fp, #4]
21f2803c:	e0823003 	add	r3, r2, r3
21f28040:	e5933000 	ldr	r3, [r3]
21f28044:	e20330ff 	and	r3, r3, #255	; 0xff
21f28048:	e2833050 	add	r3, r3, #80	; 0x50
21f2804c:	e20330ff 	and	r3, r3, #255	; 0xff
21f28050:	e20330ff 	and	r3, r3, #255	; 0xff
21f28054:	e54b3078 	strb	r3, [fp, #-120]
	r.base = d[*p++ - s];
21f28058:	e51b358c 	ldr	r3, [fp, #-1420]
21f2805c:	e5932000 	ldr	r2, [r3]
21f28060:	e51b3580 	ldr	r3, [fp, #-1408]
21f28064:	e0633002 	rsb	r3, r3, r2
21f28068:	e1a03103 	mov	r3, r3, lsl #2
21f2806c:	e1a02003 	mov	r2, r3
21f28070:	e51b3584 	ldr	r3, [fp, #-1412]
21f28074:	e0823003 	add	r3, r2, r3
21f28078:	e5933000 	ldr	r3, [r3]
21f2807c:	e50b3074 	str	r3, [fp, #-116]
21f28080:	e51bc58c 	ldr	ip, [fp, #-1420]
21f28084:	e28cc004 	add	ip, ip, #4	; 0x4
21f28088:	e50bc58c 	str	ip, [fp, #-1420]
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
21f2808c:	e51b0590 	ldr	r0, [fp, #-1424]
21f28090:	e51b1588 	ldr	r1, [fp, #-1416]
21f28094:	e0613000 	rsb	r3, r1, r0
21f28098:	e3a02001 	mov	r2, #1	; 0x1
21f2809c:	e1a03312 	mov	r3, r2, lsl r3
21f280a0:	e50b302c 	str	r3, [fp, #-44]
      for (j = i >> w; j < z; j += f)
21f280a4:	e51b2598 	ldr	r2, [fp, #-1432]
21f280a8:	e51b3588 	ldr	r3, [fp, #-1416]
21f280ac:	e1a02332 	mov	r2, r2, lsr r3
21f280b0:	e50b2594 	str	r2, [fp, #-1428]
21f280b4:	ea00000b 	b	21f280e8 <huft_build+0xa28>
	q[j] = r;
21f280b8:	e51bc594 	ldr	ip, [fp, #-1428]
21f280bc:	e1a0318c 	mov	r3, ip, lsl #3
21f280c0:	e1a02003 	mov	r2, r3
21f280c4:	e51b301c 	ldr	r3, [fp, #-28]
21f280c8:	e0823003 	add	r3, r2, r3
21f280cc:	e24b0078 	sub	r0, fp, #120	; 0x78
21f280d0:	e8900003 	ldmia	r0, {r0, r1}
21f280d4:	e8830003 	stmia	r3, {r0, r1}
21f280d8:	e51b302c 	ldr	r3, [fp, #-44]
21f280dc:	e51b1594 	ldr	r1, [fp, #-1428]
21f280e0:	e0811003 	add	r1, r1, r3
21f280e4:	e50b1594 	str	r1, [fp, #-1428]
21f280e8:	e51b3010 	ldr	r3, [fp, #-16]
21f280ec:	e51b2594 	ldr	r2, [fp, #-1428]
21f280f0:	e1520003 	cmp	r2, r3
21f280f4:	3affffef 	bcc	21f280b8 <huft_build+0x9f8>

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
21f280f8:	e51bc590 	ldr	ip, [fp, #-1424]
21f280fc:	e24c3001 	sub	r3, ip, #1	; 0x1
21f28100:	e3a02001 	mov	r2, #1	; 0x1
21f28104:	e1a03312 	mov	r3, r2, lsl r3
21f28108:	e50b3594 	str	r3, [fp, #-1428]
21f2810c:	ea000006 	b	21f2812c <huft_build+0xa6c>
	i ^= j;
21f28110:	e51b0598 	ldr	r0, [fp, #-1432]
21f28114:	e51b1594 	ldr	r1, [fp, #-1428]
21f28118:	e0200001 	eor	r0, r0, r1
21f2811c:	e50b0598 	str	r0, [fp, #-1432]
21f28120:	e51b2594 	ldr	r2, [fp, #-1428]
21f28124:	e1a020a2 	mov	r2, r2, lsr #1
21f28128:	e50b2594 	str	r2, [fp, #-1428]
21f2812c:	e51bc598 	ldr	ip, [fp, #-1432]
21f28130:	e51b0594 	ldr	r0, [fp, #-1428]
21f28134:	e00c3000 	and	r3, ip, r0
21f28138:	e3530000 	cmp	r3, #0	; 0x0
21f2813c:	1afffff3 	bne	21f28110 <huft_build+0xa50>
      i ^= j;
21f28140:	e51b1598 	ldr	r1, [fp, #-1432]
21f28144:	e51b2594 	ldr	r2, [fp, #-1428]
21f28148:	e0211002 	eor	r1, r1, r2
21f2814c:	e50b1598 	str	r1, [fp, #-1432]

      /* backup over finished tables */
      while ((i & ((1 << w) - 1)) != x[h])
21f28150:	ea000006 	b	21f28170 <huft_build+0xab0>
      {
	h--;                    /* don't need to update q */
21f28154:	e51b3024 	ldr	r3, [fp, #-36]
21f28158:	e2433001 	sub	r3, r3, #1	; 0x1
21f2815c:	e50b3024 	str	r3, [fp, #-36]
	w -= l;
21f28160:	e51b3020 	ldr	r3, [fp, #-32]
21f28164:	e51bc588 	ldr	ip, [fp, #-1416]
21f28168:	e063c00c 	rsb	ip, r3, ip
21f2816c:	e50bc588 	str	ip, [fp, #-1416]
21f28170:	e3a03001 	mov	r3, #1	; 0x1
21f28174:	e51b0588 	ldr	r0, [fp, #-1416]
21f28178:	e1a03013 	mov	r3, r3, lsl r0
21f2817c:	e2433001 	sub	r3, r3, #1	; 0x1
21f28180:	e51b2598 	ldr	r2, [fp, #-1432]
21f28184:	e0031002 	and	r1, r3, r2
21f28188:	e51b2024 	ldr	r2, [fp, #-36]
21f2818c:	e3e03e56 	mvn	r3, #1376	; 0x560
21f28190:	e2433007 	sub	r3, r3, #7	; 0x7
21f28194:	e1a02102 	mov	r2, r2, lsl #2
21f28198:	e24bc00c 	sub	ip, fp, #12	; 0xc
21f2819c:	e082200c 	add	r2, r2, ip
21f281a0:	e0823003 	add	r3, r2, r3
21f281a4:	e5933000 	ldr	r3, [r3]
21f281a8:	e1510003 	cmp	r1, r3
21f281ac:	1affffe8 	bne	21f28154 <huft_build+0xa94>
21f281b0:	e51b3030 	ldr	r3, [fp, #-48]
21f281b4:	e2433001 	sub	r3, r3, #1	; 0x1
21f281b8:	e50b3030 	str	r3, [fp, #-48]
21f281bc:	e51b3030 	ldr	r3, [fp, #-48]
21f281c0:	e3730001 	cmn	r3, #1	; 0x1
21f281c4:	1affff60 	bne	21f27f4c <huft_build+0x88c>
21f281c8:	e51b0590 	ldr	r0, [fp, #-1424]
21f281cc:	e2800001 	add	r0, r0, #1	; 0x1
21f281d0:	e50b0590 	str	r0, [fp, #-1424]
21f281d4:	e51b3028 	ldr	r3, [fp, #-40]
21f281d8:	e51b1590 	ldr	r1, [fp, #-1424]
21f281dc:	e1510003 	cmp	r1, r3
21f281e0:	dafffea7 	ble	21f27c84 <huft_build+0x5c4>
      }
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
21f281e4:	e51b3014 	ldr	r3, [fp, #-20]
21f281e8:	e3530000 	cmp	r3, #0	; 0x0
21f281ec:	0a000005 	beq	21f28208 <huft_build+0xb48>
21f281f0:	e51b3028 	ldr	r3, [fp, #-40]
21f281f4:	e3530001 	cmp	r3, #1	; 0x1
21f281f8:	0a000002 	beq	21f28208 <huft_build+0xb48>
21f281fc:	e3e02004 	mvn	r2, #4	; 0x4
21f28200:	e50b259c 	str	r2, [fp, #-1436]
21f28204:	ea000001 	b	21f28210 <huft_build+0xb50>
21f28208:	e3a03000 	mov	r3, #0	; 0x0
21f2820c:	e50b359c 	str	r3, [fp, #-1436]
21f28210:	e51bc59c 	ldr	ip, [fp, #-1436]
21f28214:	e50bc5a8 	str	ip, [fp, #-1448]
21f28218:	e51b35a8 	ldr	r3, [fp, #-1448]
}
21f2821c:	e1a00003 	mov	r0, r3
21f28220:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f28224:	e89da800 	ldmia	sp, {fp, sp, pc}

21f28228 <inflate_trees_bits>:


local int inflate_trees_bits(c, bb, tb, z)
uIntf *c;               /* 19 code lengths */
uIntf *bb;              /* bits tree desired/actual depth */
inflate_huft * FAR *tb; /* bits tree result */
z_stream *z;            /* for zfree function */
{
21f28228:	e1a0c00d 	mov	ip, sp
21f2822c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f28230:	e24cb004 	sub	fp, ip, #4	; 0x4
21f28234:	e24dd024 	sub	sp, sp, #36	; 0x24
21f28238:	e50b0014 	str	r0, [fp, #-20]
21f2823c:	e50b1018 	str	r1, [fp, #-24]
21f28240:	e50b201c 	str	r2, [fp, #-28]
21f28244:	e50b3020 	str	r3, [fp, #-32]
  int r;

  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL, tb, bb, z);
21f28248:	e3a03000 	mov	r3, #0	; 0x0
21f2824c:	e58d3000 	str	r3, [sp]
21f28250:	e51b301c 	ldr	r3, [fp, #-28]
21f28254:	e58d3004 	str	r3, [sp, #4]
21f28258:	e51b3018 	ldr	r3, [fp, #-24]
21f2825c:	e58d3008 	str	r3, [sp, #8]
21f28260:	e51b3020 	ldr	r3, [fp, #-32]
21f28264:	e58d300c 	str	r3, [sp, #12]
21f28268:	e51b0014 	ldr	r0, [fp, #-20]
21f2826c:	e3a01013 	mov	r1, #19	; 0x13
21f28270:	e3a02013 	mov	r2, #19	; 0x13
21f28274:	e3a03000 	mov	r3, #0	; 0x0
21f28278:	ebfffd10 	bl	21f276c0 <huft_build>
21f2827c:	e1a03000 	mov	r3, r0
21f28280:	e50b3010 	str	r3, [fp, #-16]
  if (r == Z_DATA_ERROR)
21f28284:	e51b3010 	ldr	r3, [fp, #-16]
21f28288:	e3730003 	cmn	r3, #3	; 0x3
21f2828c:	1a000003 	bne	21f282a0 <inflate_trees_bits+0x78>
    z->msg = "oversubscribed dynamic bit lengths tree";
21f28290:	e51b2020 	ldr	r2, [fp, #-32]
21f28294:	e59f3048 	ldr	r3, [pc, #72]	; 21f282e4 <.text+0x282e4>
21f28298:	e5823018 	str	r3, [r2, #24]
21f2829c:	ea00000c 	b	21f282d4 <inflate_trees_bits+0xac>
  else if (r == Z_BUF_ERROR)
21f282a0:	e51b3010 	ldr	r3, [fp, #-16]
21f282a4:	e3730005 	cmn	r3, #5	; 0x5
21f282a8:	1a000009 	bne	21f282d4 <inflate_trees_bits+0xac>
  {
    inflate_trees_free(*tb, z);
21f282ac:	e51b301c 	ldr	r3, [fp, #-28]
21f282b0:	e5933000 	ldr	r3, [r3]
21f282b4:	e1a00003 	mov	r0, r3
21f282b8:	e51b1020 	ldr	r1, [fp, #-32]
21f282bc:	eb000170 	bl	21f28884 <inflate_trees_free>
    z->msg = "incomplete dynamic bit lengths tree";
21f282c0:	e51b2020 	ldr	r2, [fp, #-32]
21f282c4:	e59f301c 	ldr	r3, [pc, #28]	; 21f282e8 <.text+0x282e8>
21f282c8:	e5823018 	str	r3, [r2, #24]
    r = Z_DATA_ERROR;
21f282cc:	e3e03002 	mvn	r3, #2	; 0x2
21f282d0:	e50b3010 	str	r3, [fp, #-16]
  }
  return r;
21f282d4:	e51b3010 	ldr	r3, [fp, #-16]
}
21f282d8:	e1a00003 	mov	r0, r3
21f282dc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f282e0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f282e4:	21f32dc0 	mvncss	r2, r0, asr #27
21f282e8:	21f32de8 	mvncss	r2, r8, ror #27

21f282ec <inflate_trees_dynamic>:


local int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, z)
uInt nl;                /* number of literal/length codes */
uInt nd;                /* number of distance codes */
uIntf *c;               /* that many (total) code lengths */
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
z_stream *z;            /* for zfree function */
{
21f282ec:	e1a0c00d 	mov	ip, sp
21f282f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f282f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f282f8:	e24dd028 	sub	sp, sp, #40	; 0x28
21f282fc:	e50b0014 	str	r0, [fp, #-20]
21f28300:	e50b1018 	str	r1, [fp, #-24]
21f28304:	e50b201c 	str	r2, [fp, #-28]
21f28308:	e50b3020 	str	r3, [fp, #-32]
  int r;

  /* build literal/length tree */
  if ((r = huft_build(c, nl, 257, cplens, cplext, tl, bl, z)) != Z_OK)
21f2830c:	e59f3184 	ldr	r3, [pc, #388]	; 21f28498 <.text+0x28498>
21f28310:	e58d3000 	str	r3, [sp]
21f28314:	e59b3008 	ldr	r3, [fp, #8]
21f28318:	e58d3004 	str	r3, [sp, #4]
21f2831c:	e51b3020 	ldr	r3, [fp, #-32]
21f28320:	e58d3008 	str	r3, [sp, #8]
21f28324:	e59b3010 	ldr	r3, [fp, #16]
21f28328:	e58d300c 	str	r3, [sp, #12]
21f2832c:	e51b001c 	ldr	r0, [fp, #-28]
21f28330:	e51b1014 	ldr	r1, [fp, #-20]
21f28334:	e3a02c01 	mov	r2, #256	; 0x100
21f28338:	e2822001 	add	r2, r2, #1	; 0x1
21f2833c:	e59f3158 	ldr	r3, [pc, #344]	; 21f2849c <.text+0x2849c>
21f28340:	ebfffcde 	bl	21f276c0 <huft_build>
21f28344:	e1a03000 	mov	r3, r0
21f28348:	e50b3010 	str	r3, [fp, #-16]
21f2834c:	e51b3010 	ldr	r3, [fp, #-16]
21f28350:	e3530000 	cmp	r3, #0	; 0x0
21f28354:	0a000016 	beq	21f283b4 <inflate_trees_dynamic+0xc8>
  {
    if (r == Z_DATA_ERROR)
21f28358:	e51b3010 	ldr	r3, [fp, #-16]
21f2835c:	e3730003 	cmn	r3, #3	; 0x3
21f28360:	1a000003 	bne	21f28374 <inflate_trees_dynamic+0x88>
      z->msg = "oversubscribed literal/length tree";
21f28364:	e59b2010 	ldr	r2, [fp, #16]
21f28368:	e59f3130 	ldr	r3, [pc, #304]	; 21f284a0 <.text+0x284a0>
21f2836c:	e5823018 	str	r3, [r2, #24]
21f28370:	ea00000c 	b	21f283a8 <inflate_trees_dynamic+0xbc>
    else if (r == Z_BUF_ERROR)
21f28374:	e51b3010 	ldr	r3, [fp, #-16]
21f28378:	e3730005 	cmn	r3, #5	; 0x5
21f2837c:	1a000009 	bne	21f283a8 <inflate_trees_dynamic+0xbc>
    {
      inflate_trees_free(*tl, z);
21f28380:	e59b3008 	ldr	r3, [fp, #8]
21f28384:	e5933000 	ldr	r3, [r3]
21f28388:	e1a00003 	mov	r0, r3
21f2838c:	e59b1010 	ldr	r1, [fp, #16]
21f28390:	eb00013b 	bl	21f28884 <inflate_trees_free>
      z->msg = "incomplete literal/length tree";
21f28394:	e59b2010 	ldr	r2, [fp, #16]
21f28398:	e59f3104 	ldr	r3, [pc, #260]	; 21f284a4 <.text+0x284a4>
21f2839c:	e5823018 	str	r3, [r2, #24]
      r = Z_DATA_ERROR;
21f283a0:	e3e03002 	mvn	r3, #2	; 0x2
21f283a4:	e50b3010 	str	r3, [fp, #-16]
    }
    return r;
21f283a8:	e51b3010 	ldr	r3, [fp, #-16]
21f283ac:	e50b3024 	str	r3, [fp, #-36]
21f283b0:	ea000034 	b	21f28488 <inflate_trees_dynamic+0x19c>
  }

  /* build distance tree */
  if ((r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, z)) != Z_OK)
21f283b4:	e51b3014 	ldr	r3, [fp, #-20]
21f283b8:	e1a03103 	mov	r3, r3, lsl #2
21f283bc:	e1a02003 	mov	r2, r3
21f283c0:	e51b301c 	ldr	r3, [fp, #-28]
21f283c4:	e0822003 	add	r2, r2, r3
21f283c8:	e59f30d8 	ldr	r3, [pc, #216]	; 21f284a8 <.text+0x284a8>
21f283cc:	e58d3000 	str	r3, [sp]
21f283d0:	e59b300c 	ldr	r3, [fp, #12]
21f283d4:	e58d3004 	str	r3, [sp, #4]
21f283d8:	e59b3004 	ldr	r3, [fp, #4]
21f283dc:	e58d3008 	str	r3, [sp, #8]
21f283e0:	e59b3010 	ldr	r3, [fp, #16]
21f283e4:	e58d300c 	str	r3, [sp, #12]
21f283e8:	e1a00002 	mov	r0, r2
21f283ec:	e51b1018 	ldr	r1, [fp, #-24]
21f283f0:	e3a02000 	mov	r2, #0	; 0x0
21f283f4:	e59f30b0 	ldr	r3, [pc, #176]	; 21f284ac <.text+0x284ac>
21f283f8:	ebfffcb0 	bl	21f276c0 <huft_build>
21f283fc:	e1a03000 	mov	r3, r0
21f28400:	e50b3010 	str	r3, [fp, #-16]
21f28404:	e51b3010 	ldr	r3, [fp, #-16]
21f28408:	e3530000 	cmp	r3, #0	; 0x0
21f2840c:	0a00001b 	beq	21f28480 <inflate_trees_dynamic+0x194>
  {
    if (r == Z_DATA_ERROR)
21f28410:	e51b3010 	ldr	r3, [fp, #-16]
21f28414:	e3730003 	cmn	r3, #3	; 0x3
21f28418:	1a000003 	bne	21f2842c <inflate_trees_dynamic+0x140>
      z->msg = "oversubscribed literal/length tree";
21f2841c:	e59b2010 	ldr	r2, [fp, #16]
21f28420:	e59f3078 	ldr	r3, [pc, #120]	; 21f284a0 <.text+0x284a0>
21f28424:	e5823018 	str	r3, [r2, #24]
21f28428:	ea00000c 	b	21f28460 <inflate_trees_dynamic+0x174>
    else if (r == Z_BUF_ERROR) {
21f2842c:	e51b3010 	ldr	r3, [fp, #-16]
21f28430:	e3730005 	cmn	r3, #5	; 0x5
21f28434:	1a000009 	bne	21f28460 <inflate_trees_dynamic+0x174>
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      inflate_trees_free(*td, z);
21f28438:	e59b300c 	ldr	r3, [fp, #12]
21f2843c:	e5933000 	ldr	r3, [r3]
21f28440:	e1a00003 	mov	r0, r3
21f28444:	e59b1010 	ldr	r1, [fp, #16]
21f28448:	eb00010d 	bl	21f28884 <inflate_trees_free>
      z->msg = "incomplete literal/length tree";
21f2844c:	e59b2010 	ldr	r2, [fp, #16]
21f28450:	e59f304c 	ldr	r3, [pc, #76]	; 21f284a4 <.text+0x284a4>
21f28454:	e5823018 	str	r3, [r2, #24]
      r = Z_DATA_ERROR;
21f28458:	e3e03002 	mvn	r3, #2	; 0x2
21f2845c:	e50b3010 	str	r3, [fp, #-16]
    }
    inflate_trees_free(*tl, z);
21f28460:	e59b3008 	ldr	r3, [fp, #8]
21f28464:	e5933000 	ldr	r3, [r3]
21f28468:	e1a00003 	mov	r0, r3
21f2846c:	e59b1010 	ldr	r1, [fp, #16]
21f28470:	eb000103 	bl	21f28884 <inflate_trees_free>
    return r;
21f28474:	e51b3010 	ldr	r3, [fp, #-16]
21f28478:	e50b3024 	str	r3, [fp, #-36]
21f2847c:	ea000001 	b	21f28488 <inflate_trees_dynamic+0x19c>
#endif
  }

  /* done */
  return Z_OK;
21f28480:	e3a03000 	mov	r3, #0	; 0x0
21f28484:	e50b3024 	str	r3, [fp, #-36]
21f28488:	e51b3024 	ldr	r3, [fp, #-36]
}
21f2848c:	e1a00003 	mov	r0, r3
21f28490:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f28494:	e89da800 	ldmia	sp, {fp, sp, pc}
21f28498:	21f33ae0 	mvncss	r3, r0, ror #21
21f2849c:	21f33a64 	mvncss	r3, r4, ror #20
21f284a0:	21f32e0c 	mvncss	r2, ip, lsl #28
21f284a4:	21f32e30 	mvncss	r2, r0, lsr lr
21f284a8:	21f33bd4 	ldrcssb	r3, [r3, #180]!
21f284ac:	21f33b5c 	mvncss	r3, ip, asr fp

21f284b0 <falloc>:


/* build fixed tables only once--keep them here */
local int fixed_lock = 0;
local int fixed_built = 0;
#define FIXEDH 530      /* number of hufts used by fixed tables */
local uInt fixed_left = FIXEDH;
local inflate_huft fixed_mem[FIXEDH];
local uInt fixed_bl;
local uInt fixed_bd;
local inflate_huft *fixed_tl;
local inflate_huft *fixed_td;


local voidpf falloc(q, n, s)
voidpf q;        /* opaque pointer (not used) */
uInt n;         /* number of items */
uInt s;         /* size of item */
{
21f284b0:	e1a0c00d 	mov	ip, sp
21f284b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f284b8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f284bc:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f284c0:	e50b0010 	str	r0, [fp, #-16]
21f284c4:	e50b1014 	str	r1, [fp, #-20]
21f284c8:	e50b2018 	str	r2, [fp, #-24]
  Assert(s == sizeof(inflate_huft) && n <= fixed_left,
	 "inflate_trees falloc overflow");
  if (q) s++; /* to make some compilers happy */
21f284cc:	e51b3010 	ldr	r3, [fp, #-16]
21f284d0:	e3530000 	cmp	r3, #0	; 0x0
21f284d4:	0a000002 	beq	21f284e4 <falloc+0x34>
21f284d8:	e51b3018 	ldr	r3, [fp, #-24]
21f284dc:	e2833001 	add	r3, r3, #1	; 0x1
21f284e0:	e50b3018 	str	r3, [fp, #-24]
  fixed_left -= n;
21f284e4:	e59f3034 	ldr	r3, [pc, #52]	; 21f28520 <.text+0x28520>
21f284e8:	e5932000 	ldr	r2, [r3]
21f284ec:	e51b3014 	ldr	r3, [fp, #-20]
21f284f0:	e0632002 	rsb	r2, r3, r2
21f284f4:	e59f3024 	ldr	r3, [pc, #36]	; 21f28520 <.text+0x28520>
21f284f8:	e5832000 	str	r2, [r3]
  return (voidpf)(fixed_mem + fixed_left);
21f284fc:	e59f301c 	ldr	r3, [pc, #28]	; 21f28520 <.text+0x28520>
21f28500:	e5933000 	ldr	r3, [r3]
21f28504:	e1a03183 	mov	r3, r3, lsl #3
21f28508:	e1a02003 	mov	r2, r3
21f2850c:	e59f3010 	ldr	r3, [pc, #16]	; 21f28524 <.text+0x28524>
21f28510:	e0823003 	add	r3, r2, r3
}
21f28514:	e1a00003 	mov	r0, r3
21f28518:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2851c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f28520:	21f33c4c 	mvncss	r3, ip, asr #24
21f28524:	21f67c00 	mvncss	r7, r0, lsl #24

21f28528 <ffree>:


local void ffree(q, p, n)
voidpf q;
voidpf p;
uInt n;
{
21f28528:	e1a0c00d 	mov	ip, sp
21f2852c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f28530:	e24cb004 	sub	fp, ip, #4	; 0x4
21f28534:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f28538:	e50b0010 	str	r0, [fp, #-16]
21f2853c:	e50b1014 	str	r1, [fp, #-20]
21f28540:	e50b2018 	str	r2, [fp, #-24]
  Assert(0, "inflate_trees ffree called!");
  if (q) q = p; /* to make some compilers happy */
21f28544:	e51b3010 	ldr	r3, [fp, #-16]
21f28548:	e3530000 	cmp	r3, #0	; 0x0
21f2854c:	0a000001 	beq	21f28558 <ffree+0x30>
21f28550:	e51b3014 	ldr	r3, [fp, #-20]
21f28554:	e50b3010 	str	r3, [fp, #-16]
}
21f28558:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2855c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f28560 <inflate_trees_fixed>:


local int inflate_trees_fixed(bl, bd, tl, td)
uIntf *bl;               /* literal desired/actual bit depth */
uIntf *bd;               /* distance desired/actual bit depth */
inflate_huft * FAR *tl;  /* literal/length tree result */
inflate_huft * FAR *td;  /* distance tree result */
{
21f28560:	e1a0c00d 	mov	ip, sp
21f28564:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f28568:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2856c:	e24dde4d 	sub	sp, sp, #1232	; 0x4d0
21f28570:	e24dd008 	sub	sp, sp, #8	; 0x8
21f28574:	e50b04c8 	str	r0, [fp, #-1224]
21f28578:	e50b14cc 	str	r1, [fp, #-1228]
21f2857c:	e50b24d0 	str	r2, [fp, #-1232]
21f28580:	e50b34d4 	str	r3, [fp, #-1236]
  /* build fixed tables if not built already--lock out other instances */
  while (++fixed_lock > 1)
21f28584:	ea000004 	b	21f2859c <inflate_trees_fixed+0x3c>
    fixed_lock--;
21f28588:	e59f32c4 	ldr	r3, [pc, #708]	; 21f28854 <.text+0x28854>
21f2858c:	e5933000 	ldr	r3, [r3]
21f28590:	e2432001 	sub	r2, r3, #1	; 0x1
21f28594:	e59f32b8 	ldr	r3, [pc, #696]	; 21f28854 <.text+0x28854>
21f28598:	e5832000 	str	r2, [r3]
21f2859c:	e59f32b0 	ldr	r3, [pc, #688]	; 21f28854 <.text+0x28854>
21f285a0:	e5933000 	ldr	r3, [r3]
21f285a4:	e2832001 	add	r2, r3, #1	; 0x1
21f285a8:	e59f32a4 	ldr	r3, [pc, #676]	; 21f28854 <.text+0x28854>
21f285ac:	e5832000 	str	r2, [r3]
21f285b0:	e59f329c 	ldr	r3, [pc, #668]	; 21f28854 <.text+0x28854>
21f285b4:	e5933000 	ldr	r3, [r3]
21f285b8:	e3530001 	cmp	r3, #1	; 0x1
21f285bc:	cafffff1 	bgt	21f28588 <inflate_trees_fixed+0x28>
  if (!fixed_built)
21f285c0:	e59f3290 	ldr	r3, [pc, #656]	; 21f28858 <.text+0x28858>
21f285c4:	e5933000 	ldr	r3, [r3]
21f285c8:	e3530000 	cmp	r3, #0	; 0x0
21f285cc:	1a000087 	bne	21f287f0 <inflate_trees_fixed+0x290>
  {
    int k;              /* temporary variable */
    unsigned c[288];    /* length list for huft_build */
    z_stream z;         /* for falloc function */

    /* set up fake z_stream for memory routines */
    z.zalloc = falloc;
21f285d0:	e59f3284 	ldr	r3, [pc, #644]	; 21f2885c <.text+0x2885c>
21f285d4:	e50b3024 	str	r3, [fp, #-36]
    z.zfree = ffree;
21f285d8:	e59f3280 	ldr	r3, [pc, #640]	; 21f28860 <.text+0x28860>
21f285dc:	e50b3020 	str	r3, [fp, #-32]
    z.opaque = Z_NULL;
21f285e0:	e3a03000 	mov	r3, #0	; 0x0
21f285e4:	e50b301c 	str	r3, [fp, #-28]

    /* literal table */
    for (k = 0; k < 144; k++)
21f285e8:	e3a03000 	mov	r3, #0	; 0x0
21f285ec:	e50b3010 	str	r3, [fp, #-16]
21f285f0:	ea00000b 	b	21f28624 <inflate_trees_fixed+0xc4>
      c[k] = 8;
21f285f4:	e51b2010 	ldr	r2, [fp, #-16]
21f285f8:	e3e03e4b 	mvn	r3, #1200	; 0x4b0
21f285fc:	e2433007 	sub	r3, r3, #7	; 0x7
21f28600:	e1a02102 	mov	r2, r2, lsl #2
21f28604:	e24b100c 	sub	r1, fp, #12	; 0xc
21f28608:	e0822001 	add	r2, r2, r1
21f2860c:	e0822003 	add	r2, r2, r3
21f28610:	e3a03008 	mov	r3, #8	; 0x8
21f28614:	e5823000 	str	r3, [r2]
21f28618:	e51b3010 	ldr	r3, [fp, #-16]
21f2861c:	e2833001 	add	r3, r3, #1	; 0x1
21f28620:	e50b3010 	str	r3, [fp, #-16]
21f28624:	e51b3010 	ldr	r3, [fp, #-16]
21f28628:	e353008f 	cmp	r3, #143	; 0x8f
21f2862c:	dafffff0 	ble	21f285f4 <inflate_trees_fixed+0x94>
21f28630:	ea00000b 	b	21f28664 <inflate_trees_fixed+0x104>
    for (; k < 256; k++)
      c[k] = 9;
21f28634:	e51b2010 	ldr	r2, [fp, #-16]
21f28638:	e3e03e4b 	mvn	r3, #1200	; 0x4b0
21f2863c:	e2433007 	sub	r3, r3, #7	; 0x7
21f28640:	e1a02102 	mov	r2, r2, lsl #2
21f28644:	e24b100c 	sub	r1, fp, #12	; 0xc
21f28648:	e0822001 	add	r2, r2, r1
21f2864c:	e0822003 	add	r2, r2, r3
21f28650:	e3a03009 	mov	r3, #9	; 0x9
21f28654:	e5823000 	str	r3, [r2]
21f28658:	e51b3010 	ldr	r3, [fp, #-16]
21f2865c:	e2833001 	add	r3, r3, #1	; 0x1
21f28660:	e50b3010 	str	r3, [fp, #-16]
21f28664:	e51b3010 	ldr	r3, [fp, #-16]
21f28668:	e35300ff 	cmp	r3, #255	; 0xff
21f2866c:	dafffff0 	ble	21f28634 <inflate_trees_fixed+0xd4>
21f28670:	ea00000b 	b	21f286a4 <inflate_trees_fixed+0x144>
    for (; k < 280; k++)
      c[k] = 7;
21f28674:	e51b2010 	ldr	r2, [fp, #-16]
21f28678:	e3e03e4b 	mvn	r3, #1200	; 0x4b0
21f2867c:	e2433007 	sub	r3, r3, #7	; 0x7
21f28680:	e1a02102 	mov	r2, r2, lsl #2
21f28684:	e24b100c 	sub	r1, fp, #12	; 0xc
21f28688:	e0822001 	add	r2, r2, r1
21f2868c:	e0822003 	add	r2, r2, r3
21f28690:	e3a03007 	mov	r3, #7	; 0x7
21f28694:	e5823000 	str	r3, [r2]
21f28698:	e51b3010 	ldr	r3, [fp, #-16]
21f2869c:	e2833001 	add	r3, r3, #1	; 0x1
21f286a0:	e50b3010 	str	r3, [fp, #-16]
21f286a4:	e51b2010 	ldr	r2, [fp, #-16]
21f286a8:	e3a03f45 	mov	r3, #276	; 0x114
21f286ac:	e2833003 	add	r3, r3, #3	; 0x3
21f286b0:	e1520003 	cmp	r2, r3
21f286b4:	daffffee 	ble	21f28674 <inflate_trees_fixed+0x114>
21f286b8:	ea00000b 	b	21f286ec <inflate_trees_fixed+0x18c>
    for (; k < 288; k++)
      c[k] = 8;
21f286bc:	e51b2010 	ldr	r2, [fp, #-16]
21f286c0:	e3e03e4b 	mvn	r3, #1200	; 0x4b0
21f286c4:	e2433007 	sub	r3, r3, #7	; 0x7
21f286c8:	e1a02102 	mov	r2, r2, lsl #2
21f286cc:	e24b100c 	sub	r1, fp, #12	; 0xc
21f286d0:	e0822001 	add	r2, r2, r1
21f286d4:	e0822003 	add	r2, r2, r3
21f286d8:	e3a03008 	mov	r3, #8	; 0x8
21f286dc:	e5823000 	str	r3, [r2]
21f286e0:	e51b3010 	ldr	r3, [fp, #-16]
21f286e4:	e2833001 	add	r3, r3, #1	; 0x1
21f286e8:	e50b3010 	str	r3, [fp, #-16]
21f286ec:	e51b2010 	ldr	r2, [fp, #-16]
21f286f0:	e3a03f47 	mov	r3, #284	; 0x11c
21f286f4:	e2833003 	add	r3, r3, #3	; 0x3
21f286f8:	e1520003 	cmp	r2, r3
21f286fc:	daffffee 	ble	21f286bc <inflate_trees_fixed+0x15c>
    fixed_bl = 7;
21f28700:	e59f215c 	ldr	r2, [pc, #348]	; 21f28864 <.text+0x28864>
21f28704:	e3a03007 	mov	r3, #7	; 0x7
21f28708:	e5823000 	str	r3, [r2]
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl, &z);
21f2870c:	e24b2e4b 	sub	r2, fp, #1200	; 0x4b0
21f28710:	e242200c 	sub	r2, r2, #12	; 0xc
21f28714:	e2422008 	sub	r2, r2, #8	; 0x8
21f28718:	e59f3148 	ldr	r3, [pc, #328]	; 21f28868 <.text+0x28868>
21f2871c:	e58d3000 	str	r3, [sp]
21f28720:	e59f3144 	ldr	r3, [pc, #324]	; 21f2886c <.text+0x2886c>
21f28724:	e58d3004 	str	r3, [sp, #4]
21f28728:	e59f3134 	ldr	r3, [pc, #308]	; 21f28864 <.text+0x28864>
21f2872c:	e58d3008 	str	r3, [sp, #8]
21f28730:	e24b3044 	sub	r3, fp, #68	; 0x44
21f28734:	e58d300c 	str	r3, [sp, #12]
21f28738:	e1a00002 	mov	r0, r2
21f2873c:	e3a01e12 	mov	r1, #288	; 0x120
21f28740:	e3a02c01 	mov	r2, #256	; 0x100
21f28744:	e2822001 	add	r2, r2, #1	; 0x1
21f28748:	e59f3120 	ldr	r3, [pc, #288]	; 21f28870 <.text+0x28870>
21f2874c:	ebfffbdb 	bl	21f276c0 <huft_build>

    /* distance table */
    for (k = 0; k < 30; k++)
21f28750:	e3a03000 	mov	r3, #0	; 0x0
21f28754:	e50b3010 	str	r3, [fp, #-16]
21f28758:	ea00000b 	b	21f2878c <inflate_trees_fixed+0x22c>
      c[k] = 5;
21f2875c:	e51b2010 	ldr	r2, [fp, #-16]
21f28760:	e3e03e4b 	mvn	r3, #1200	; 0x4b0
21f28764:	e2433007 	sub	r3, r3, #7	; 0x7
21f28768:	e1a02102 	mov	r2, r2, lsl #2
21f2876c:	e24b100c 	sub	r1, fp, #12	; 0xc
21f28770:	e0822001 	add	r2, r2, r1
21f28774:	e0822003 	add	r2, r2, r3
21f28778:	e3a03005 	mov	r3, #5	; 0x5
21f2877c:	e5823000 	str	r3, [r2]
21f28780:	e51b3010 	ldr	r3, [fp, #-16]
21f28784:	e2833001 	add	r3, r3, #1	; 0x1
21f28788:	e50b3010 	str	r3, [fp, #-16]
21f2878c:	e51b3010 	ldr	r3, [fp, #-16]
21f28790:	e353001d 	cmp	r3, #29	; 0x1d
21f28794:	dafffff0 	ble	21f2875c <inflate_trees_fixed+0x1fc>
    fixed_bd = 5;
21f28798:	e59f20d4 	ldr	r2, [pc, #212]	; 21f28874 <.text+0x28874>
21f2879c:	e3a03005 	mov	r3, #5	; 0x5
21f287a0:	e5823000 	str	r3, [r2]
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd, &z);
21f287a4:	e24b2e4b 	sub	r2, fp, #1200	; 0x4b0
21f287a8:	e242200c 	sub	r2, r2, #12	; 0xc
21f287ac:	e2422008 	sub	r2, r2, #8	; 0x8
21f287b0:	e59f30c0 	ldr	r3, [pc, #192]	; 21f28878 <.text+0x28878>
21f287b4:	e58d3000 	str	r3, [sp]
21f287b8:	e59f30bc 	ldr	r3, [pc, #188]	; 21f2887c <.text+0x2887c>
21f287bc:	e58d3004 	str	r3, [sp, #4]
21f287c0:	e59f30ac 	ldr	r3, [pc, #172]	; 21f28874 <.text+0x28874>
21f287c4:	e58d3008 	str	r3, [sp, #8]
21f287c8:	e24b3044 	sub	r3, fp, #68	; 0x44
21f287cc:	e58d300c 	str	r3, [sp, #12]
21f287d0:	e1a00002 	mov	r0, r2
21f287d4:	e3a0101e 	mov	r1, #30	; 0x1e
21f287d8:	e3a02000 	mov	r2, #0	; 0x0
21f287dc:	e59f309c 	ldr	r3, [pc, #156]	; 21f28880 <.text+0x28880>
21f287e0:	ebfffbb6 	bl	21f276c0 <huft_build>

    /* done */
    fixed_built = 1;
21f287e4:	e59f206c 	ldr	r2, [pc, #108]	; 21f28858 <.text+0x28858>
21f287e8:	e3a03001 	mov	r3, #1	; 0x1
21f287ec:	e5823000 	str	r3, [r2]
  }
  fixed_lock--;
21f287f0:	e59f305c 	ldr	r3, [pc, #92]	; 21f28854 <.text+0x28854>
21f287f4:	e5933000 	ldr	r3, [r3]
21f287f8:	e2432001 	sub	r2, r3, #1	; 0x1
21f287fc:	e59f3050 	ldr	r3, [pc, #80]	; 21f28854 <.text+0x28854>
21f28800:	e5832000 	str	r2, [r3]
  *bl = fixed_bl;
21f28804:	e59f3058 	ldr	r3, [pc, #88]	; 21f28864 <.text+0x28864>
21f28808:	e5932000 	ldr	r2, [r3]
21f2880c:	e51b34c8 	ldr	r3, [fp, #-1224]
21f28810:	e5832000 	str	r2, [r3]
  *bd = fixed_bd;
21f28814:	e59f3058 	ldr	r3, [pc, #88]	; 21f28874 <.text+0x28874>
21f28818:	e5932000 	ldr	r2, [r3]
21f2881c:	e51b34cc 	ldr	r3, [fp, #-1228]
21f28820:	e5832000 	str	r2, [r3]
  *tl = fixed_tl;
21f28824:	e59f3040 	ldr	r3, [pc, #64]	; 21f2886c <.text+0x2886c>
21f28828:	e5932000 	ldr	r2, [r3]
21f2882c:	e51b34d0 	ldr	r3, [fp, #-1232]
21f28830:	e5832000 	str	r2, [r3]
  *td = fixed_td;
21f28834:	e59f3040 	ldr	r3, [pc, #64]	; 21f2887c <.text+0x2887c>
21f28838:	e5932000 	ldr	r2, [r3]
21f2883c:	e51b34d4 	ldr	r3, [fp, #-1236]
21f28840:	e5832000 	str	r2, [r3]
  return Z_OK;
21f28844:	e3a03000 	mov	r3, #0	; 0x0
}
21f28848:	e1a00003 	mov	r0, r3
21f2884c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f28850:	e89da800 	ldmia	sp, {fp, sp, pc}
21f28854:	21f67bf8 	ldrcssh	r7, [r6, #184]!
21f28858:	21f67bfc 	ldrcssh	r7, [r6, #188]!
21f2885c:	21f284b0 	ldrcsh	r8, [r2, #64]!
21f28860:	21f28528 	mvncss	r8, r8, lsr #10
21f28864:	21f68c90 	ldrcsb	r8, [r6, #192]!
21f28868:	21f33ae0 	mvncss	r3, r0, ror #21
21f2886c:	21f68c98 	ldrcsb	r8, [r6, #200]!
21f28870:	21f33a64 	mvncss	r3, r4, ror #20
21f28874:	21f68c94 	ldrcsb	r8, [r6, #196]!
21f28878:	21f33bd4 	ldrcssb	r3, [r3, #180]!
21f2887c:	21f68c9c 	ldrcsb	r8, [r6, #204]!
21f28880:	21f33b5c 	mvncss	r3, ip, asr fp

21f28884 <inflate_trees_free>:


local int inflate_trees_free(t, z)
inflate_huft *t;        /* table to free */
z_stream *z;            /* for zfree function */
/* Free the malloc'ed tables built by huft_build(), which makes a linked
   list of the tables it made, with the links in a dummy first entry of
   each table. */
{
21f28884:	e1a0c00d 	mov	ip, sp
21f28888:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f2888c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f28890:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f28894:	e50b0014 	str	r0, [fp, #-20]
21f28898:	e50b1018 	str	r1, [fp, #-24]
  register inflate_huft *p, *q;

  /* Go through linked list, freeing from the malloced (t[-1]) address. */
  p = t;
21f2889c:	e51b1014 	ldr	r1, [fp, #-20]
21f288a0:	e50b101c 	str	r1, [fp, #-28]
  while (p != Z_NULL)
21f288a4:	ea000011 	b	21f288f0 <inflate_trees_free+0x6c>
  {
    q = (--p)->next;
21f288a8:	e51b301c 	ldr	r3, [fp, #-28]
21f288ac:	e2433008 	sub	r3, r3, #8	; 0x8
21f288b0:	e50b301c 	str	r3, [fp, #-28]
21f288b4:	e51b101c 	ldr	r1, [fp, #-28]
21f288b8:	e5914004 	ldr	r4, [r1, #4]
    ZFREE(z, p, p->word.Nalloc * sizeof(inflate_huft));
21f288bc:	e51b3018 	ldr	r3, [fp, #-24]
21f288c0:	e593c024 	ldr	ip, [r3, #36]
21f288c4:	e51b3018 	ldr	r3, [fp, #-24]
21f288c8:	e5932028 	ldr	r2, [r3, #40]
21f288cc:	e51b101c 	ldr	r1, [fp, #-28]
21f288d0:	e5913000 	ldr	r3, [r1]
21f288d4:	e1a03183 	mov	r3, r3, lsl #3
21f288d8:	e1a00002 	mov	r0, r2
21f288dc:	e51b101c 	ldr	r1, [fp, #-28]
21f288e0:	e1a02003 	mov	r2, r3
21f288e4:	e1a0e00f 	mov	lr, pc
21f288e8:	e1a0f00c 	mov	pc, ip
    p = q;
21f288ec:	e50b401c 	str	r4, [fp, #-28]
21f288f0:	e51b301c 	ldr	r3, [fp, #-28]
21f288f4:	e3530000 	cmp	r3, #0	; 0x0
21f288f8:	1affffea 	bne	21f288a8 <inflate_trees_free+0x24>
  }
  return Z_OK;
21f288fc:	e3a03000 	mov	r3, #0	; 0x0
}
21f28900:	e1a00003 	mov	r0, r3
21f28904:	e24bd010 	sub	sp, fp, #16	; 0x10
21f28908:	e89da810 	ldmia	sp, {r4, fp, sp, pc}

21f2890c <inflate_codes_new>:

/*+++++*/
/* infcodes.c -- process literals and length/distance pairs
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* simplify the use of the inflate_huft type with some defines */
#define base more.Base
#define next more.Next
#define exop word.what.Exop
#define bits word.what.Bits

/* inflate codes private state */
struct inflate_codes_state {

  /* mode */
  enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
      START,    /* x: set up for LEN */
      LEN,      /* i: get length/literal/eob next */
      LENEXT,   /* i: getting length extra (have base) */
      DIST,     /* i: get distance next */
      DISTEXT,  /* i: getting distance extra */
      COPY,     /* o: copying bytes in window, waiting for space */
      LIT,      /* o: got literal, waiting for output space */
      WASH,     /* o: got eob, possibly still output waiting */
      END,      /* x: got eob and all data flushed */
      BADCODE}  /* x: got error */
    mode;               /* current inflate_codes mode */

  /* mode dependent information */
  uInt len;
  union {
    struct {
      inflate_huft *tree;       /* pointer into tree */
      uInt need;                /* bits needed */
    } code;             /* if LEN or DIST, where in tree */
    uInt lit;           /* if LIT, literal */
    struct {
      uInt get;                 /* bits to get for extra */
      uInt dist;                /* distance back to copy from */
    } copy;             /* if EXT or COPY, where and how much */
  } sub;                /* submode */

  /* mode independent information */
  Byte lbits;           /* ltree bits decoded per branch */
  Byte dbits;           /* dtree bits decoder per branch */
  inflate_huft *ltree;          /* literal/length/eob tree */
  inflate_huft *dtree;          /* distance tree */

};


local inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
uInt bl, bd;
inflate_huft *tl, *td;
z_stream *z;
{
21f2890c:	e1a0c00d 	mov	ip, sp
21f28910:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f28914:	e24cb004 	sub	fp, ip, #4	; 0x4
21f28918:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2891c:	e50b0014 	str	r0, [fp, #-20]
21f28920:	e50b1018 	str	r1, [fp, #-24]
21f28924:	e50b201c 	str	r2, [fp, #-28]
21f28928:	e50b3020 	str	r3, [fp, #-32]
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
21f2892c:	e59b3004 	ldr	r3, [fp, #4]
21f28930:	e593c020 	ldr	ip, [r3, #32]
21f28934:	e59b3004 	ldr	r3, [fp, #4]
21f28938:	e5933028 	ldr	r3, [r3, #40]
21f2893c:	e1a00003 	mov	r0, r3
21f28940:	e3a01001 	mov	r1, #1	; 0x1
21f28944:	e3a0201c 	mov	r2, #28	; 0x1c
21f28948:	e1a0e00f 	mov	lr, pc
21f2894c:	e1a0f00c 	mov	pc, ip
21f28950:	e1a03000 	mov	r3, r0
21f28954:	e50b3010 	str	r3, [fp, #-16]
21f28958:	e51b3010 	ldr	r3, [fp, #-16]
21f2895c:	e3530000 	cmp	r3, #0	; 0x0
21f28960:	0a000010 	beq	21f289a8 <inflate_codes_new+0x9c>
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
21f28964:	e51b2010 	ldr	r2, [fp, #-16]
21f28968:	e3a03000 	mov	r3, #0	; 0x0
21f2896c:	e5823000 	str	r3, [r2]
    c->lbits = (Byte)bl;
21f28970:	e51b3014 	ldr	r3, [fp, #-20]
21f28974:	e20330ff 	and	r3, r3, #255	; 0xff
21f28978:	e51b2010 	ldr	r2, [fp, #-16]
21f2897c:	e5c23010 	strb	r3, [r2, #16]
    c->dbits = (Byte)bd;
21f28980:	e51b3018 	ldr	r3, [fp, #-24]
21f28984:	e20330ff 	and	r3, r3, #255	; 0xff
21f28988:	e51b2010 	ldr	r2, [fp, #-16]
21f2898c:	e5c23011 	strb	r3, [r2, #17]
    c->ltree = tl;
21f28990:	e51b2010 	ldr	r2, [fp, #-16]
21f28994:	e51b301c 	ldr	r3, [fp, #-28]
21f28998:	e5823014 	str	r3, [r2, #20]
    c->dtree = td;
21f2899c:	e51b2010 	ldr	r2, [fp, #-16]
21f289a0:	e51b3020 	ldr	r3, [fp, #-32]
21f289a4:	e5823018 	str	r3, [r2, #24]
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
21f289a8:	e51b3010 	ldr	r3, [fp, #-16]
}
21f289ac:	e1a00003 	mov	r0, r3
21f289b0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f289b4:	e89da800 	ldmia	sp, {fp, sp, pc}

21f289b8 <inflate_codes>:


local int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
21f289b8:	e1a0c00d 	mov	ip, sp
21f289bc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f289c0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f289c4:	e24dd070 	sub	sp, sp, #112	; 0x70
21f289c8:	e50b003c 	str	r0, [fp, #-60]
21f289cc:	e50b1040 	str	r1, [fp, #-64]
21f289d0:	e50b2044 	str	r2, [fp, #-68]
  uInt j;               /* temporary storage */
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
21f289d4:	e51b303c 	ldr	r3, [fp, #-60]
21f289d8:	e593300c 	ldr	r3, [r3, #12]
21f289dc:	e50b3010 	str	r3, [fp, #-16]

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD
21f289e0:	e51b3040 	ldr	r3, [fp, #-64]
21f289e4:	e5933000 	ldr	r3, [r3]
21f289e8:	e50b3024 	str	r3, [fp, #-36]
21f289ec:	e51b3040 	ldr	r3, [fp, #-64]
21f289f0:	e5933004 	ldr	r3, [r3, #4]
21f289f4:	e50b3020 	str	r3, [fp, #-32]
21f289f8:	e51b303c 	ldr	r3, [fp, #-60]
21f289fc:	e5933024 	ldr	r3, [r3, #36]
21f28a00:	e50b302c 	str	r3, [fp, #-44]
21f28a04:	e51b303c 	ldr	r3, [fp, #-60]
21f28a08:	e5933020 	ldr	r3, [r3, #32]
21f28a0c:	e50b3028 	str	r3, [fp, #-40]
21f28a10:	e51b303c 	ldr	r3, [fp, #-60]
21f28a14:	e5933034 	ldr	r3, [r3, #52]
21f28a18:	e50b301c 	str	r3, [fp, #-28]
21f28a1c:	e51b303c 	ldr	r3, [fp, #-60]
21f28a20:	e5932030 	ldr	r2, [r3, #48]
21f28a24:	e51b301c 	ldr	r3, [fp, #-28]
21f28a28:	e1520003 	cmp	r2, r3
21f28a2c:	9a000007 	bls	21f28a50 <inflate_codes+0x98>
21f28a30:	e51b303c 	ldr	r3, [fp, #-60]
21f28a34:	e5933030 	ldr	r3, [r3, #48]
21f28a38:	e1a02003 	mov	r2, r3
21f28a3c:	e51b301c 	ldr	r3, [fp, #-28]
21f28a40:	e0633002 	rsb	r3, r3, r2
21f28a44:	e2433001 	sub	r3, r3, #1	; 0x1
21f28a48:	e50b3074 	str	r3, [fp, #-116]
21f28a4c:	ea000005 	b	21f28a68 <inflate_codes+0xb0>
21f28a50:	e51b303c 	ldr	r3, [fp, #-60]
21f28a54:	e593302c 	ldr	r3, [r3, #44]
21f28a58:	e1a02003 	mov	r2, r3
21f28a5c:	e51b301c 	ldr	r3, [fp, #-28]
21f28a60:	e0633002 	rsb	r3, r3, r2
21f28a64:	e50b3074 	str	r3, [fp, #-116]
21f28a68:	e51b2074 	ldr	r2, [fp, #-116]
21f28a6c:	e50b2018 	str	r2, [fp, #-24]
21f28a70:	eaffffff 	b	21f28a74 <inflate_codes+0xbc>

  /* process input and output based on current state */
  while (1) switch (c->mode)
21f28a74:	e51b3010 	ldr	r3, [fp, #-16]
21f28a78:	e5933000 	ldr	r3, [r3]
21f28a7c:	e3530009 	cmp	r3, #9	; 0x9
21f28a80:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
21f28a84:	ea00047e 	b	21f29c84 <.text+0x29c84>
21f28a88:	21f28ab0 	ldrcsh	r8, [r2, #160]!
21f28a8c:	21f28c80 	mvncss	r8, r0, lsl #25
21f28a90:	21f28f50 	mvncss	r8, r0, asr pc
21f28a94:	21f290c0 	mvncss	r9, r0, asr #1
21f28a98:	21f2933c 	mvncss	r9, ip, lsr r3
21f28a9c:	21f29488 	mvncss	r9, r8, lsl #9
21f28aa0:	21f297cc 	mvncss	r9, ip, asr #15
21f28aa4:	21f29a4c 	mvncss	r9, ip, asr #20
21f28aa8:	21f29b70 	mvncss	r9, r0, ror fp
21f28aac:	21f29bf4 	ldrcssh	r9, [r2, #180]!
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
21f28ab0:	e51b2018 	ldr	r2, [fp, #-24]
21f28ab4:	e3a03c01 	mov	r3, #256	; 0x100
21f28ab8:	e2833001 	add	r3, r3, #1	; 0x1
21f28abc:	e1520003 	cmp	r2, r3
21f28ac0:	9a000062 	bls	21f28c50 <.text+0x28c50>
21f28ac4:	e51b3020 	ldr	r3, [fp, #-32]
21f28ac8:	e3530009 	cmp	r3, #9	; 0x9
21f28acc:	9a00005f 	bls	21f28c50 <.text+0x28c50>
      {
	UPDATE
21f28ad0:	e51b203c 	ldr	r2, [fp, #-60]
21f28ad4:	e51b302c 	ldr	r3, [fp, #-44]
21f28ad8:	e5823024 	str	r3, [r2, #36]
21f28adc:	e51b203c 	ldr	r2, [fp, #-60]
21f28ae0:	e51b3028 	ldr	r3, [fp, #-40]
21f28ae4:	e5823020 	str	r3, [r2, #32]
21f28ae8:	e51b2040 	ldr	r2, [fp, #-64]
21f28aec:	e51b3020 	ldr	r3, [fp, #-32]
21f28af0:	e5823004 	str	r3, [r2, #4]
21f28af4:	e51b3040 	ldr	r3, [fp, #-64]
21f28af8:	e5931008 	ldr	r1, [r3, #8]
21f28afc:	e51b2024 	ldr	r2, [fp, #-36]
21f28b00:	e51b3040 	ldr	r3, [fp, #-64]
21f28b04:	e5933000 	ldr	r3, [r3]
21f28b08:	e0633002 	rsb	r3, r3, r2
21f28b0c:	e0812003 	add	r2, r1, r3
21f28b10:	e51b3040 	ldr	r3, [fp, #-64]
21f28b14:	e5832008 	str	r2, [r3, #8]
21f28b18:	e51b2040 	ldr	r2, [fp, #-64]
21f28b1c:	e51b3024 	ldr	r3, [fp, #-36]
21f28b20:	e5823000 	str	r3, [r2]
21f28b24:	e51b203c 	ldr	r2, [fp, #-60]
21f28b28:	e51b301c 	ldr	r3, [fp, #-28]
21f28b2c:	e5823034 	str	r3, [r2, #52]
	r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
21f28b30:	e51b3010 	ldr	r3, [fp, #-16]
21f28b34:	e5d33010 	ldrb	r3, [r3, #16]
21f28b38:	e1a01003 	mov	r1, r3
21f28b3c:	e51b3010 	ldr	r3, [fp, #-16]
21f28b40:	e5d33011 	ldrb	r3, [r3, #17]
21f28b44:	e1a02003 	mov	r2, r3
21f28b48:	e51b3010 	ldr	r3, [fp, #-16]
21f28b4c:	e593c014 	ldr	ip, [r3, #20]
21f28b50:	e51b3010 	ldr	r3, [fp, #-16]
21f28b54:	e593e018 	ldr	lr, [r3, #24]
21f28b58:	e51b303c 	ldr	r3, [fp, #-60]
21f28b5c:	e58d3000 	str	r3, [sp]
21f28b60:	e51b3040 	ldr	r3, [fp, #-64]
21f28b64:	e58d3004 	str	r3, [sp, #4]
21f28b68:	e1a00001 	mov	r0, r1
21f28b6c:	e1a01002 	mov	r1, r2
21f28b70:	e1a0200c 	mov	r2, ip
21f28b74:	e1a0300e 	mov	r3, lr
21f28b78:	eb000539 	bl	21f2a064 <inflate_fast>
21f28b7c:	e1a03000 	mov	r3, r0
21f28b80:	e50b3044 	str	r3, [fp, #-68]
	LOAD
21f28b84:	e51b3040 	ldr	r3, [fp, #-64]
21f28b88:	e5933000 	ldr	r3, [r3]
21f28b8c:	e50b3024 	str	r3, [fp, #-36]
21f28b90:	e51b3040 	ldr	r3, [fp, #-64]
21f28b94:	e5933004 	ldr	r3, [r3, #4]
21f28b98:	e50b3020 	str	r3, [fp, #-32]
21f28b9c:	e51b303c 	ldr	r3, [fp, #-60]
21f28ba0:	e5933024 	ldr	r3, [r3, #36]
21f28ba4:	e50b302c 	str	r3, [fp, #-44]
21f28ba8:	e51b303c 	ldr	r3, [fp, #-60]
21f28bac:	e5933020 	ldr	r3, [r3, #32]
21f28bb0:	e50b3028 	str	r3, [fp, #-40]
21f28bb4:	e51b303c 	ldr	r3, [fp, #-60]
21f28bb8:	e5933034 	ldr	r3, [r3, #52]
21f28bbc:	e50b301c 	str	r3, [fp, #-28]
21f28bc0:	e51b303c 	ldr	r3, [fp, #-60]
21f28bc4:	e5932030 	ldr	r2, [r3, #48]
21f28bc8:	e51b301c 	ldr	r3, [fp, #-28]
21f28bcc:	e1520003 	cmp	r2, r3
21f28bd0:	9a000007 	bls	21f28bf4 <.text+0x28bf4>
21f28bd4:	e51b303c 	ldr	r3, [fp, #-60]
21f28bd8:	e5933030 	ldr	r3, [r3, #48]
21f28bdc:	e1a02003 	mov	r2, r3
21f28be0:	e51b301c 	ldr	r3, [fp, #-28]
21f28be4:	e0633002 	rsb	r3, r3, r2
21f28be8:	e2433001 	sub	r3, r3, #1	; 0x1
21f28bec:	e50b3070 	str	r3, [fp, #-112]
21f28bf0:	ea000005 	b	21f28c0c <.text+0x28c0c>
21f28bf4:	e51b303c 	ldr	r3, [fp, #-60]
21f28bf8:	e593302c 	ldr	r3, [r3, #44]
21f28bfc:	e1a02003 	mov	r2, r3
21f28c00:	e51b301c 	ldr	r3, [fp, #-28]
21f28c04:	e0633002 	rsb	r3, r3, r2
21f28c08:	e50b3070 	str	r3, [fp, #-112]
21f28c0c:	e51b3070 	ldr	r3, [fp, #-112]
21f28c10:	e50b3018 	str	r3, [fp, #-24]
	if (r != Z_OK)
21f28c14:	e51b3044 	ldr	r3, [fp, #-68]
21f28c18:	e3530000 	cmp	r3, #0	; 0x0
21f28c1c:	0a00000b 	beq	21f28c50 <.text+0x28c50>
	{
	  c->mode = r == Z_STREAM_END ? WASH : BADCODE;
21f28c20:	e51b3044 	ldr	r3, [fp, #-68]
21f28c24:	e3530001 	cmp	r3, #1	; 0x1
21f28c28:	1a000002 	bne	21f28c38 <.text+0x28c38>
21f28c2c:	e3a02007 	mov	r2, #7	; 0x7
21f28c30:	e50b206c 	str	r2, [fp, #-108]
21f28c34:	ea000001 	b	21f28c40 <.text+0x28c40>
21f28c38:	e3a03009 	mov	r3, #9	; 0x9
21f28c3c:	e50b306c 	str	r3, [fp, #-108]
21f28c40:	e51b3010 	ldr	r3, [fp, #-16]
21f28c44:	e51b206c 	ldr	r2, [fp, #-108]
21f28c48:	e5832000 	str	r2, [r3]
	  break;
21f28c4c:	eaffff88 	b	21f28a74 <inflate_codes+0xbc>
	}
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
21f28c50:	e51b3010 	ldr	r3, [fp, #-16]
21f28c54:	e5d33010 	ldrb	r3, [r3, #16]
21f28c58:	e1a02003 	mov	r2, r3
21f28c5c:	e51b3010 	ldr	r3, [fp, #-16]
21f28c60:	e583200c 	str	r2, [r3, #12]
      c->sub.code.tree = c->ltree;
21f28c64:	e51b3010 	ldr	r3, [fp, #-16]
21f28c68:	e5932014 	ldr	r2, [r3, #20]
21f28c6c:	e51b3010 	ldr	r3, [fp, #-16]
21f28c70:	e5832008 	str	r2, [r3, #8]
      c->mode = LEN;
21f28c74:	e51b2010 	ldr	r2, [fp, #-16]
21f28c78:	e3a03001 	mov	r3, #1	; 0x1
21f28c7c:	e5823000 	str	r3, [r2]
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
21f28c80:	e51b3010 	ldr	r3, [fp, #-16]
21f28c84:	e593300c 	ldr	r3, [r3, #12]
21f28c88:	e50b3038 	str	r3, [fp, #-56]
      NEEDBITS(j)
21f28c8c:	ea000035 	b	21f28d68 <.text+0x28d68>
21f28c90:	e51b3020 	ldr	r3, [fp, #-32]
21f28c94:	e3530000 	cmp	r3, #0	; 0x0
21f28c98:	0a000013 	beq	21f28cec <.text+0x28cec>
21f28c9c:	e3a03000 	mov	r3, #0	; 0x0
21f28ca0:	e50b3044 	str	r3, [fp, #-68]
21f28ca4:	e51b3020 	ldr	r3, [fp, #-32]
21f28ca8:	e2433001 	sub	r3, r3, #1	; 0x1
21f28cac:	e50b3020 	str	r3, [fp, #-32]
21f28cb0:	e51b3024 	ldr	r3, [fp, #-36]
21f28cb4:	e5d33000 	ldrb	r3, [r3]
21f28cb8:	e1a02003 	mov	r2, r3
21f28cbc:	e51b3028 	ldr	r3, [fp, #-40]
21f28cc0:	e1a02312 	mov	r2, r2, lsl r3
21f28cc4:	e51b302c 	ldr	r3, [fp, #-44]
21f28cc8:	e1833002 	orr	r3, r3, r2
21f28ccc:	e50b302c 	str	r3, [fp, #-44]
21f28cd0:	e51b3024 	ldr	r3, [fp, #-36]
21f28cd4:	e2833001 	add	r3, r3, #1	; 0x1
21f28cd8:	e50b3024 	str	r3, [fp, #-36]
21f28cdc:	e51b3028 	ldr	r3, [fp, #-40]
21f28ce0:	e2833008 	add	r3, r3, #8	; 0x8
21f28ce4:	e50b3028 	str	r3, [fp, #-40]
21f28ce8:	ea00001e 	b	21f28d68 <.text+0x28d68>
21f28cec:	e51b203c 	ldr	r2, [fp, #-60]
21f28cf0:	e51b302c 	ldr	r3, [fp, #-44]
21f28cf4:	e5823024 	str	r3, [r2, #36]
21f28cf8:	e51b203c 	ldr	r2, [fp, #-60]
21f28cfc:	e51b3028 	ldr	r3, [fp, #-40]
21f28d00:	e5823020 	str	r3, [r2, #32]
21f28d04:	e51b2040 	ldr	r2, [fp, #-64]
21f28d08:	e51b3020 	ldr	r3, [fp, #-32]
21f28d0c:	e5823004 	str	r3, [r2, #4]
21f28d10:	e51b3040 	ldr	r3, [fp, #-64]
21f28d14:	e5931008 	ldr	r1, [r3, #8]
21f28d18:	e51b2024 	ldr	r2, [fp, #-36]
21f28d1c:	e51b3040 	ldr	r3, [fp, #-64]
21f28d20:	e5933000 	ldr	r3, [r3]
21f28d24:	e0633002 	rsb	r3, r3, r2
21f28d28:	e0812003 	add	r2, r1, r3
21f28d2c:	e51b3040 	ldr	r3, [fp, #-64]
21f28d30:	e5832008 	str	r2, [r3, #8]
21f28d34:	e51b2040 	ldr	r2, [fp, #-64]
21f28d38:	e51b3024 	ldr	r3, [fp, #-36]
21f28d3c:	e5823000 	str	r3, [r2]
21f28d40:	e51b203c 	ldr	r2, [fp, #-60]
21f28d44:	e51b301c 	ldr	r3, [fp, #-28]
21f28d48:	e5823034 	str	r3, [r2, #52]
21f28d4c:	e51b003c 	ldr	r0, [fp, #-60]
21f28d50:	e51b1040 	ldr	r1, [fp, #-64]
21f28d54:	e51b2044 	ldr	r2, [fp, #-68]
21f28d58:	eb0003fe 	bl	21f29d58 <inflate_flush>
21f28d5c:	e1a03000 	mov	r3, r0
21f28d60:	e50b3068 	str	r3, [fp, #-104]
21f28d64:	ea0003e6 	b	21f29d04 <.text+0x29d04>
21f28d68:	e51b2028 	ldr	r2, [fp, #-40]
21f28d6c:	e51b3038 	ldr	r3, [fp, #-56]
21f28d70:	e1520003 	cmp	r2, r3
21f28d74:	3affffc5 	bcc	21f28c90 <.text+0x28c90>
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
21f28d78:	e51b3010 	ldr	r3, [fp, #-16]
21f28d7c:	e5931008 	ldr	r1, [r3, #8]
21f28d80:	e51b2038 	ldr	r2, [fp, #-56]
21f28d84:	e59f3eec 	ldr	r3, [pc, #3820]	; 21f29c78 <.text+0x29c78>
21f28d88:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f28d8c:	e51b302c 	ldr	r3, [fp, #-44]
21f28d90:	e0023003 	and	r3, r2, r3
21f28d94:	e1a03183 	mov	r3, r3, lsl #3
21f28d98:	e0813003 	add	r3, r1, r3
21f28d9c:	e50b3034 	str	r3, [fp, #-52]
      DUMPBITS(t->bits)
21f28da0:	e51b3034 	ldr	r3, [fp, #-52]
21f28da4:	e5d33001 	ldrb	r3, [r3, #1]
21f28da8:	e1a02003 	mov	r2, r3
21f28dac:	e51b302c 	ldr	r3, [fp, #-44]
21f28db0:	e1a03233 	mov	r3, r3, lsr r2
21f28db4:	e50b302c 	str	r3, [fp, #-44]
21f28db8:	e51b3034 	ldr	r3, [fp, #-52]
21f28dbc:	e5d33001 	ldrb	r3, [r3, #1]
21f28dc0:	e1a02003 	mov	r2, r3
21f28dc4:	e51b3028 	ldr	r3, [fp, #-40]
21f28dc8:	e0623003 	rsb	r3, r2, r3
21f28dcc:	e50b3028 	str	r3, [fp, #-40]
      e = (uInt)(t->exop);
21f28dd0:	e51b3034 	ldr	r3, [fp, #-52]
21f28dd4:	e5d33000 	ldrb	r3, [r3]
21f28dd8:	e50b3030 	str	r3, [fp, #-48]
      if (e == 0)               /* literal */
21f28ddc:	e51b3030 	ldr	r3, [fp, #-48]
21f28de0:	e3530000 	cmp	r3, #0	; 0x0
21f28de4:	1a000007 	bne	21f28e08 <.text+0x28e08>
      {
	c->sub.lit = t->base;
21f28de8:	e51b3034 	ldr	r3, [fp, #-52]
21f28dec:	e5932004 	ldr	r2, [r3, #4]
21f28df0:	e51b3010 	ldr	r3, [fp, #-16]
21f28df4:	e5832008 	str	r2, [r3, #8]
	Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
		 "inflate:         literal '%c'\n" :
		 "inflate:         literal 0x%02x\n", t->base));
	c->mode = LIT;
21f28df8:	e51b2010 	ldr	r2, [fp, #-16]
21f28dfc:	e3a03006 	mov	r3, #6	; 0x6
21f28e00:	e5823000 	str	r3, [r2]
	break;
21f28e04:	eaffff1a 	b	21f28a74 <inflate_codes+0xbc>
      }
      if (e & 16)               /* length */
21f28e08:	e51b3030 	ldr	r3, [fp, #-48]
21f28e0c:	e1a03223 	mov	r3, r3, lsr #4
21f28e10:	e2033001 	and	r3, r3, #1	; 0x1
21f28e14:	e20330ff 	and	r3, r3, #255	; 0xff
21f28e18:	e3530000 	cmp	r3, #0	; 0x0
21f28e1c:	0a00000b 	beq	21f28e50 <.text+0x28e50>
      {
	c->sub.copy.get = e & 15;
21f28e20:	e51b3030 	ldr	r3, [fp, #-48]
21f28e24:	e203200f 	and	r2, r3, #15	; 0xf
21f28e28:	e51b3010 	ldr	r3, [fp, #-16]
21f28e2c:	e5832008 	str	r2, [r3, #8]
	c->len = t->base;
21f28e30:	e51b3034 	ldr	r3, [fp, #-52]
21f28e34:	e5932004 	ldr	r2, [r3, #4]
21f28e38:	e51b3010 	ldr	r3, [fp, #-16]
21f28e3c:	e5832004 	str	r2, [r3, #4]
	c->mode = LENEXT;
21f28e40:	e51b2010 	ldr	r2, [fp, #-16]
21f28e44:	e3a03002 	mov	r3, #2	; 0x2
21f28e48:	e5823000 	str	r3, [r2]
	break;
21f28e4c:	eaffff08 	b	21f28a74 <inflate_codes+0xbc>
      }
      if ((e & 64) == 0)        /* next table */
21f28e50:	e51b3030 	ldr	r3, [fp, #-48]
21f28e54:	e1a03323 	mov	r3, r3, lsr #6
21f28e58:	e2233001 	eor	r3, r3, #1	; 0x1
21f28e5c:	e2033001 	and	r3, r3, #1	; 0x1
21f28e60:	e20330ff 	and	r3, r3, #255	; 0xff
21f28e64:	e3530000 	cmp	r3, #0	; 0x0
21f28e68:	0a000007 	beq	21f28e8c <.text+0x28e8c>
      {
	c->sub.code.need = e;
21f28e6c:	e51b2010 	ldr	r2, [fp, #-16]
21f28e70:	e51b3030 	ldr	r3, [fp, #-48]
21f28e74:	e582300c 	str	r3, [r2, #12]
	c->sub.code.tree = t->next;
21f28e78:	e51b3034 	ldr	r3, [fp, #-52]
21f28e7c:	e5932004 	ldr	r2, [r3, #4]
21f28e80:	e51b3010 	ldr	r3, [fp, #-16]
21f28e84:	e5832008 	str	r2, [r3, #8]
	break;
21f28e88:	eafffef9 	b	21f28a74 <inflate_codes+0xbc>
      }
      if (e & 32)               /* end of block */
21f28e8c:	e51b3030 	ldr	r3, [fp, #-48]
21f28e90:	e1a032a3 	mov	r3, r3, lsr #5
21f28e94:	e2033001 	and	r3, r3, #1	; 0x1
21f28e98:	e20330ff 	and	r3, r3, #255	; 0xff
21f28e9c:	e3530000 	cmp	r3, #0	; 0x0
21f28ea0:	0a000003 	beq	21f28eb4 <.text+0x28eb4>
      {
	Tracevv((stderr, "inflate:         end of block\n"));
	c->mode = WASH;
21f28ea4:	e51b2010 	ldr	r2, [fp, #-16]
21f28ea8:	e3a03007 	mov	r3, #7	; 0x7
21f28eac:	e5823000 	str	r3, [r2]
	break;
21f28eb0:	eafffeef 	b	21f28a74 <inflate_codes+0xbc>
      }
      c->mode = BADCODE;        /* invalid code */
21f28eb4:	e51b2010 	ldr	r2, [fp, #-16]
21f28eb8:	e3a03009 	mov	r3, #9	; 0x9
21f28ebc:	e5823000 	str	r3, [r2]
      z->msg = "invalid literal/length code";
21f28ec0:	e51b2040 	ldr	r2, [fp, #-64]
21f28ec4:	e59f3db0 	ldr	r3, [pc, #3504]	; 21f29c7c <.text+0x29c7c>
21f28ec8:	e5823018 	str	r3, [r2, #24]
      r = Z_DATA_ERROR;
21f28ecc:	e3e03002 	mvn	r3, #2	; 0x2
21f28ed0:	e50b3044 	str	r3, [fp, #-68]
      LEAVE
21f28ed4:	e51b203c 	ldr	r2, [fp, #-60]
21f28ed8:	e51b302c 	ldr	r3, [fp, #-44]
21f28edc:	e5823024 	str	r3, [r2, #36]
21f28ee0:	e51b203c 	ldr	r2, [fp, #-60]
21f28ee4:	e51b3028 	ldr	r3, [fp, #-40]
21f28ee8:	e5823020 	str	r3, [r2, #32]
21f28eec:	e51b2040 	ldr	r2, [fp, #-64]
21f28ef0:	e51b3020 	ldr	r3, [fp, #-32]
21f28ef4:	e5823004 	str	r3, [r2, #4]
21f28ef8:	e51b3040 	ldr	r3, [fp, #-64]
21f28efc:	e5931008 	ldr	r1, [r3, #8]
21f28f00:	e51b2024 	ldr	r2, [fp, #-36]
21f28f04:	e51b3040 	ldr	r3, [fp, #-64]
21f28f08:	e5933000 	ldr	r3, [r3]
21f28f0c:	e0633002 	rsb	r3, r3, r2
21f28f10:	e0812003 	add	r2, r1, r3
21f28f14:	e51b3040 	ldr	r3, [fp, #-64]
21f28f18:	e5832008 	str	r2, [r3, #8]
21f28f1c:	e51b2040 	ldr	r2, [fp, #-64]
21f28f20:	e51b3024 	ldr	r3, [fp, #-36]
21f28f24:	e5823000 	str	r3, [r2]
21f28f28:	e51b203c 	ldr	r2, [fp, #-60]
21f28f2c:	e51b301c 	ldr	r3, [fp, #-28]
21f28f30:	e5823034 	str	r3, [r2, #52]
21f28f34:	e51b003c 	ldr	r0, [fp, #-60]
21f28f38:	e51b1040 	ldr	r1, [fp, #-64]
21f28f3c:	e51b2044 	ldr	r2, [fp, #-68]
21f28f40:	eb000384 	bl	21f29d58 <inflate_flush>
21f28f44:	e1a03000 	mov	r3, r0
21f28f48:	e50b3068 	str	r3, [fp, #-104]
21f28f4c:	ea00036c 	b	21f29d04 <.text+0x29d04>
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
21f28f50:	e51b3010 	ldr	r3, [fp, #-16]
21f28f54:	e5933008 	ldr	r3, [r3, #8]
21f28f58:	e50b3038 	str	r3, [fp, #-56]
      NEEDBITS(j)
21f28f5c:	ea000035 	b	21f29038 <.text+0x29038>
21f28f60:	e51b3020 	ldr	r3, [fp, #-32]
21f28f64:	e3530000 	cmp	r3, #0	; 0x0
21f28f68:	0a000013 	beq	21f28fbc <.text+0x28fbc>
21f28f6c:	e3a03000 	mov	r3, #0	; 0x0
21f28f70:	e50b3044 	str	r3, [fp, #-68]
21f28f74:	e51b3020 	ldr	r3, [fp, #-32]
21f28f78:	e2433001 	sub	r3, r3, #1	; 0x1
21f28f7c:	e50b3020 	str	r3, [fp, #-32]
21f28f80:	e51b3024 	ldr	r3, [fp, #-36]
21f28f84:	e5d33000 	ldrb	r3, [r3]
21f28f88:	e1a02003 	mov	r2, r3
21f28f8c:	e51b3028 	ldr	r3, [fp, #-40]
21f28f90:	e1a02312 	mov	r2, r2, lsl r3
21f28f94:	e51b302c 	ldr	r3, [fp, #-44]
21f28f98:	e1833002 	orr	r3, r3, r2
21f28f9c:	e50b302c 	str	r3, [fp, #-44]
21f28fa0:	e51b3024 	ldr	r3, [fp, #-36]
21f28fa4:	e2833001 	add	r3, r3, #1	; 0x1
21f28fa8:	e50b3024 	str	r3, [fp, #-36]
21f28fac:	e51b3028 	ldr	r3, [fp, #-40]
21f28fb0:	e2833008 	add	r3, r3, #8	; 0x8
21f28fb4:	e50b3028 	str	r3, [fp, #-40]
21f28fb8:	ea00001e 	b	21f29038 <.text+0x29038>
21f28fbc:	e51b203c 	ldr	r2, [fp, #-60]
21f28fc0:	e51b302c 	ldr	r3, [fp, #-44]
21f28fc4:	e5823024 	str	r3, [r2, #36]
21f28fc8:	e51b203c 	ldr	r2, [fp, #-60]
21f28fcc:	e51b3028 	ldr	r3, [fp, #-40]
21f28fd0:	e5823020 	str	r3, [r2, #32]
21f28fd4:	e51b2040 	ldr	r2, [fp, #-64]
21f28fd8:	e51b3020 	ldr	r3, [fp, #-32]
21f28fdc:	e5823004 	str	r3, [r2, #4]
21f28fe0:	e51b3040 	ldr	r3, [fp, #-64]
21f28fe4:	e5931008 	ldr	r1, [r3, #8]
21f28fe8:	e51b2024 	ldr	r2, [fp, #-36]
21f28fec:	e51b3040 	ldr	r3, [fp, #-64]
21f28ff0:	e5933000 	ldr	r3, [r3]
21f28ff4:	e0633002 	rsb	r3, r3, r2
21f28ff8:	e0812003 	add	r2, r1, r3
21f28ffc:	e51b3040 	ldr	r3, [fp, #-64]
21f29000:	e5832008 	str	r2, [r3, #8]
21f29004:	e51b2040 	ldr	r2, [fp, #-64]
21f29008:	e51b3024 	ldr	r3, [fp, #-36]
21f2900c:	e5823000 	str	r3, [r2]
21f29010:	e51b203c 	ldr	r2, [fp, #-60]
21f29014:	e51b301c 	ldr	r3, [fp, #-28]
21f29018:	e5823034 	str	r3, [r2, #52]
21f2901c:	e51b003c 	ldr	r0, [fp, #-60]
21f29020:	e51b1040 	ldr	r1, [fp, #-64]
21f29024:	e51b2044 	ldr	r2, [fp, #-68]
21f29028:	eb00034a 	bl	21f29d58 <inflate_flush>
21f2902c:	e1a03000 	mov	r3, r0
21f29030:	e50b3068 	str	r3, [fp, #-104]
21f29034:	ea000332 	b	21f29d04 <.text+0x29d04>
21f29038:	e51b2028 	ldr	r2, [fp, #-40]
21f2903c:	e51b3038 	ldr	r3, [fp, #-56]
21f29040:	e1520003 	cmp	r2, r3
21f29044:	3affffc5 	bcc	21f28f60 <.text+0x28f60>
      c->len += (uInt)b & inflate_mask[j];
21f29048:	e51b3010 	ldr	r3, [fp, #-16]
21f2904c:	e5931004 	ldr	r1, [r3, #4]
21f29050:	e51b2038 	ldr	r2, [fp, #-56]
21f29054:	e59f3c1c 	ldr	r3, [pc, #3100]	; 21f29c78 <.text+0x29c78>
21f29058:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f2905c:	e51b302c 	ldr	r3, [fp, #-44]
21f29060:	e0023003 	and	r3, r2, r3
21f29064:	e0812003 	add	r2, r1, r3
21f29068:	e51b3010 	ldr	r3, [fp, #-16]
21f2906c:	e5832004 	str	r2, [r3, #4]
      DUMPBITS(j)
21f29070:	e51b2038 	ldr	r2, [fp, #-56]
21f29074:	e51b302c 	ldr	r3, [fp, #-44]
21f29078:	e1a03233 	mov	r3, r3, lsr r2
21f2907c:	e50b302c 	str	r3, [fp, #-44]
21f29080:	e51b2028 	ldr	r2, [fp, #-40]
21f29084:	e51b3038 	ldr	r3, [fp, #-56]
21f29088:	e0633002 	rsb	r3, r3, r2
21f2908c:	e50b3028 	str	r3, [fp, #-40]
      c->sub.code.need = c->dbits;
21f29090:	e51b3010 	ldr	r3, [fp, #-16]
21f29094:	e5d33011 	ldrb	r3, [r3, #17]
21f29098:	e1a02003 	mov	r2, r3
21f2909c:	e51b3010 	ldr	r3, [fp, #-16]
21f290a0:	e583200c 	str	r2, [r3, #12]
      c->sub.code.tree = c->dtree;
21f290a4:	e51b3010 	ldr	r3, [fp, #-16]
21f290a8:	e5932018 	ldr	r2, [r3, #24]
21f290ac:	e51b3010 	ldr	r3, [fp, #-16]
21f290b0:	e5832008 	str	r2, [r3, #8]
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
21f290b4:	e51b2010 	ldr	r2, [fp, #-16]
21f290b8:	e3a03003 	mov	r3, #3	; 0x3
21f290bc:	e5823000 	str	r3, [r2]
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
21f290c0:	e51b3010 	ldr	r3, [fp, #-16]
21f290c4:	e593300c 	ldr	r3, [r3, #12]
21f290c8:	e50b3038 	str	r3, [fp, #-56]
      NEEDBITS(j)
21f290cc:	ea000035 	b	21f291a8 <.text+0x291a8>
21f290d0:	e51b3020 	ldr	r3, [fp, #-32]
21f290d4:	e3530000 	cmp	r3, #0	; 0x0
21f290d8:	0a000013 	beq	21f2912c <.text+0x2912c>
21f290dc:	e3a03000 	mov	r3, #0	; 0x0
21f290e0:	e50b3044 	str	r3, [fp, #-68]
21f290e4:	e51b3020 	ldr	r3, [fp, #-32]
21f290e8:	e2433001 	sub	r3, r3, #1	; 0x1
21f290ec:	e50b3020 	str	r3, [fp, #-32]
21f290f0:	e51b3024 	ldr	r3, [fp, #-36]
21f290f4:	e5d33000 	ldrb	r3, [r3]
21f290f8:	e1a02003 	mov	r2, r3
21f290fc:	e51b3028 	ldr	r3, [fp, #-40]
21f29100:	e1a02312 	mov	r2, r2, lsl r3
21f29104:	e51b302c 	ldr	r3, [fp, #-44]
21f29108:	e1833002 	orr	r3, r3, r2
21f2910c:	e50b302c 	str	r3, [fp, #-44]
21f29110:	e51b3024 	ldr	r3, [fp, #-36]
21f29114:	e2833001 	add	r3, r3, #1	; 0x1
21f29118:	e50b3024 	str	r3, [fp, #-36]
21f2911c:	e51b3028 	ldr	r3, [fp, #-40]
21f29120:	e2833008 	add	r3, r3, #8	; 0x8
21f29124:	e50b3028 	str	r3, [fp, #-40]
21f29128:	ea00001e 	b	21f291a8 <.text+0x291a8>
21f2912c:	e51b203c 	ldr	r2, [fp, #-60]
21f29130:	e51b302c 	ldr	r3, [fp, #-44]
21f29134:	e5823024 	str	r3, [r2, #36]
21f29138:	e51b203c 	ldr	r2, [fp, #-60]
21f2913c:	e51b3028 	ldr	r3, [fp, #-40]
21f29140:	e5823020 	str	r3, [r2, #32]
21f29144:	e51b2040 	ldr	r2, [fp, #-64]
21f29148:	e51b3020 	ldr	r3, [fp, #-32]
21f2914c:	e5823004 	str	r3, [r2, #4]
21f29150:	e51b3040 	ldr	r3, [fp, #-64]
21f29154:	e5931008 	ldr	r1, [r3, #8]
21f29158:	e51b2024 	ldr	r2, [fp, #-36]
21f2915c:	e51b3040 	ldr	r3, [fp, #-64]
21f29160:	e5933000 	ldr	r3, [r3]
21f29164:	e0633002 	rsb	r3, r3, r2
21f29168:	e0812003 	add	r2, r1, r3
21f2916c:	e51b3040 	ldr	r3, [fp, #-64]
21f29170:	e5832008 	str	r2, [r3, #8]
21f29174:	e51b2040 	ldr	r2, [fp, #-64]
21f29178:	e51b3024 	ldr	r3, [fp, #-36]
21f2917c:	e5823000 	str	r3, [r2]
21f29180:	e51b203c 	ldr	r2, [fp, #-60]
21f29184:	e51b301c 	ldr	r3, [fp, #-28]
21f29188:	e5823034 	str	r3, [r2, #52]
21f2918c:	e51b003c 	ldr	r0, [fp, #-60]
21f29190:	e51b1040 	ldr	r1, [fp, #-64]
21f29194:	e51b2044 	ldr	r2, [fp, #-68]
21f29198:	eb0002ee 	bl	21f29d58 <inflate_flush>
21f2919c:	e1a03000 	mov	r3, r0
21f291a0:	e50b3068 	str	r3, [fp, #-104]
21f291a4:	ea0002d6 	b	21f29d04 <.text+0x29d04>
21f291a8:	e51b2028 	ldr	r2, [fp, #-40]
21f291ac:	e51b3038 	ldr	r3, [fp, #-56]
21f291b0:	e1520003 	cmp	r2, r3
21f291b4:	3affffc5 	bcc	21f290d0 <.text+0x290d0>
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
21f291b8:	e51b3010 	ldr	r3, [fp, #-16]
21f291bc:	e5931008 	ldr	r1, [r3, #8]
21f291c0:	e51b2038 	ldr	r2, [fp, #-56]
21f291c4:	e59f3aac 	ldr	r3, [pc, #2732]	; 21f29c78 <.text+0x29c78>
21f291c8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f291cc:	e51b302c 	ldr	r3, [fp, #-44]
21f291d0:	e0023003 	and	r3, r2, r3
21f291d4:	e1a03183 	mov	r3, r3, lsl #3
21f291d8:	e0813003 	add	r3, r1, r3
21f291dc:	e50b3034 	str	r3, [fp, #-52]
      DUMPBITS(t->bits)
21f291e0:	e51b3034 	ldr	r3, [fp, #-52]
21f291e4:	e5d33001 	ldrb	r3, [r3, #1]
21f291e8:	e1a02003 	mov	r2, r3
21f291ec:	e51b302c 	ldr	r3, [fp, #-44]
21f291f0:	e1a03233 	mov	r3, r3, lsr r2
21f291f4:	e50b302c 	str	r3, [fp, #-44]
21f291f8:	e51b3034 	ldr	r3, [fp, #-52]
21f291fc:	e5d33001 	ldrb	r3, [r3, #1]
21f29200:	e1a02003 	mov	r2, r3
21f29204:	e51b3028 	ldr	r3, [fp, #-40]
21f29208:	e0623003 	rsb	r3, r2, r3
21f2920c:	e50b3028 	str	r3, [fp, #-40]
      e = (uInt)(t->exop);
21f29210:	e51b3034 	ldr	r3, [fp, #-52]
21f29214:	e5d33000 	ldrb	r3, [r3]
21f29218:	e50b3030 	str	r3, [fp, #-48]
      if (e & 16)               /* distance */
21f2921c:	e51b3030 	ldr	r3, [fp, #-48]
21f29220:	e1a03223 	mov	r3, r3, lsr #4
21f29224:	e2033001 	and	r3, r3, #1	; 0x1
21f29228:	e20330ff 	and	r3, r3, #255	; 0xff
21f2922c:	e3530000 	cmp	r3, #0	; 0x0
21f29230:	0a00000b 	beq	21f29264 <.text+0x29264>
      {
	c->sub.copy.get = e & 15;
21f29234:	e51b3030 	ldr	r3, [fp, #-48]
21f29238:	e203200f 	and	r2, r3, #15	; 0xf
21f2923c:	e51b3010 	ldr	r3, [fp, #-16]
21f29240:	e5832008 	str	r2, [r3, #8]
	c->sub.copy.dist = t->base;
21f29244:	e51b3034 	ldr	r3, [fp, #-52]
21f29248:	e5932004 	ldr	r2, [r3, #4]
21f2924c:	e51b3010 	ldr	r3, [fp, #-16]
21f29250:	e583200c 	str	r2, [r3, #12]
	c->mode = DISTEXT;
21f29254:	e51b2010 	ldr	r2, [fp, #-16]
21f29258:	e3a03004 	mov	r3, #4	; 0x4
21f2925c:	e5823000 	str	r3, [r2]
	break;
21f29260:	eafffe03 	b	21f28a74 <inflate_codes+0xbc>
      }
      if ((e & 64) == 0)        /* next table */
21f29264:	e51b3030 	ldr	r3, [fp, #-48]
21f29268:	e1a03323 	mov	r3, r3, lsr #6
21f2926c:	e2233001 	eor	r3, r3, #1	; 0x1
21f29270:	e2033001 	and	r3, r3, #1	; 0x1
21f29274:	e20330ff 	and	r3, r3, #255	; 0xff
21f29278:	e3530000 	cmp	r3, #0	; 0x0
21f2927c:	0a000007 	beq	21f292a0 <.text+0x292a0>
      {
	c->sub.code.need = e;
21f29280:	e51b2010 	ldr	r2, [fp, #-16]
21f29284:	e51b3030 	ldr	r3, [fp, #-48]
21f29288:	e582300c 	str	r3, [r2, #12]
	c->sub.code.tree = t->next;
21f2928c:	e51b3034 	ldr	r3, [fp, #-52]
21f29290:	e5932004 	ldr	r2, [r3, #4]
21f29294:	e51b3010 	ldr	r3, [fp, #-16]
21f29298:	e5832008 	str	r2, [r3, #8]
	break;
21f2929c:	eafffdf4 	b	21f28a74 <inflate_codes+0xbc>
      }
      c->mode = BADCODE;        /* invalid code */
21f292a0:	e51b2010 	ldr	r2, [fp, #-16]
21f292a4:	e3a03009 	mov	r3, #9	; 0x9
21f292a8:	e5823000 	str	r3, [r2]
      z->msg = "invalid distance code";
21f292ac:	e51b2040 	ldr	r2, [fp, #-64]
21f292b0:	e59f39c8 	ldr	r3, [pc, #2504]	; 21f29c80 <.text+0x29c80>
21f292b4:	e5823018 	str	r3, [r2, #24]
      r = Z_DATA_ERROR;
21f292b8:	e3e03002 	mvn	r3, #2	; 0x2
21f292bc:	e50b3044 	str	r3, [fp, #-68]
      LEAVE
21f292c0:	e51b203c 	ldr	r2, [fp, #-60]
21f292c4:	e51b302c 	ldr	r3, [fp, #-44]
21f292c8:	e5823024 	str	r3, [r2, #36]
21f292cc:	e51b203c 	ldr	r2, [fp, #-60]
21f292d0:	e51b3028 	ldr	r3, [fp, #-40]
21f292d4:	e5823020 	str	r3, [r2, #32]
21f292d8:	e51b2040 	ldr	r2, [fp, #-64]
21f292dc:	e51b3020 	ldr	r3, [fp, #-32]
21f292e0:	e5823004 	str	r3, [r2, #4]
21f292e4:	e51b3040 	ldr	r3, [fp, #-64]
21f292e8:	e5931008 	ldr	r1, [r3, #8]
21f292ec:	e51b2024 	ldr	r2, [fp, #-36]
21f292f0:	e51b3040 	ldr	r3, [fp, #-64]
21f292f4:	e5933000 	ldr	r3, [r3]
21f292f8:	e0633002 	rsb	r3, r3, r2
21f292fc:	e0812003 	add	r2, r1, r3
21f29300:	e51b3040 	ldr	r3, [fp, #-64]
21f29304:	e5832008 	str	r2, [r3, #8]
21f29308:	e51b2040 	ldr	r2, [fp, #-64]
21f2930c:	e51b3024 	ldr	r3, [fp, #-36]
21f29310:	e5823000 	str	r3, [r2]
21f29314:	e51b203c 	ldr	r2, [fp, #-60]
21f29318:	e51b301c 	ldr	r3, [fp, #-28]
21f2931c:	e5823034 	str	r3, [r2, #52]
21f29320:	e51b003c 	ldr	r0, [fp, #-60]
21f29324:	e51b1040 	ldr	r1, [fp, #-64]
21f29328:	e51b2044 	ldr	r2, [fp, #-68]
21f2932c:	eb000289 	bl	21f29d58 <inflate_flush>
21f29330:	e1a03000 	mov	r3, r0
21f29334:	e50b3068 	str	r3, [fp, #-104]
21f29338:	ea000271 	b	21f29d04 <.text+0x29d04>
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
21f2933c:	e51b3010 	ldr	r3, [fp, #-16]
21f29340:	e5933008 	ldr	r3, [r3, #8]
21f29344:	e50b3038 	str	r3, [fp, #-56]
      NEEDBITS(j)
21f29348:	ea000035 	b	21f29424 <.text+0x29424>
21f2934c:	e51b3020 	ldr	r3, [fp, #-32]
21f29350:	e3530000 	cmp	r3, #0	; 0x0
21f29354:	0a000013 	beq	21f293a8 <.text+0x293a8>
21f29358:	e3a03000 	mov	r3, #0	; 0x0
21f2935c:	e50b3044 	str	r3, [fp, #-68]
21f29360:	e51b3020 	ldr	r3, [fp, #-32]
21f29364:	e2433001 	sub	r3, r3, #1	; 0x1
21f29368:	e50b3020 	str	r3, [fp, #-32]
21f2936c:	e51b3024 	ldr	r3, [fp, #-36]
21f29370:	e5d33000 	ldrb	r3, [r3]
21f29374:	e1a02003 	mov	r2, r3
21f29378:	e51b3028 	ldr	r3, [fp, #-40]
21f2937c:	e1a02312 	mov	r2, r2, lsl r3
21f29380:	e51b302c 	ldr	r3, [fp, #-44]
21f29384:	e1833002 	orr	r3, r3, r2
21f29388:	e50b302c 	str	r3, [fp, #-44]
21f2938c:	e51b3024 	ldr	r3, [fp, #-36]
21f29390:	e2833001 	add	r3, r3, #1	; 0x1
21f29394:	e50b3024 	str	r3, [fp, #-36]
21f29398:	e51b3028 	ldr	r3, [fp, #-40]
21f2939c:	e2833008 	add	r3, r3, #8	; 0x8
21f293a0:	e50b3028 	str	r3, [fp, #-40]
21f293a4:	ea00001e 	b	21f29424 <.text+0x29424>
21f293a8:	e51b203c 	ldr	r2, [fp, #-60]
21f293ac:	e51b302c 	ldr	r3, [fp, #-44]
21f293b0:	e5823024 	str	r3, [r2, #36]
21f293b4:	e51b203c 	ldr	r2, [fp, #-60]
21f293b8:	e51b3028 	ldr	r3, [fp, #-40]
21f293bc:	e5823020 	str	r3, [r2, #32]
21f293c0:	e51b2040 	ldr	r2, [fp, #-64]
21f293c4:	e51b3020 	ldr	r3, [fp, #-32]
21f293c8:	e5823004 	str	r3, [r2, #4]
21f293cc:	e51b3040 	ldr	r3, [fp, #-64]
21f293d0:	e5931008 	ldr	r1, [r3, #8]
21f293d4:	e51b2024 	ldr	r2, [fp, #-36]
21f293d8:	e51b3040 	ldr	r3, [fp, #-64]
21f293dc:	e5933000 	ldr	r3, [r3]
21f293e0:	e0633002 	rsb	r3, r3, r2
21f293e4:	e0812003 	add	r2, r1, r3
21f293e8:	e51b3040 	ldr	r3, [fp, #-64]
21f293ec:	e5832008 	str	r2, [r3, #8]
21f293f0:	e51b2040 	ldr	r2, [fp, #-64]
21f293f4:	e51b3024 	ldr	r3, [fp, #-36]
21f293f8:	e5823000 	str	r3, [r2]
21f293fc:	e51b203c 	ldr	r2, [fp, #-60]
21f29400:	e51b301c 	ldr	r3, [fp, #-28]
21f29404:	e5823034 	str	r3, [r2, #52]
21f29408:	e51b003c 	ldr	r0, [fp, #-60]
21f2940c:	e51b1040 	ldr	r1, [fp, #-64]
21f29410:	e51b2044 	ldr	r2, [fp, #-68]
21f29414:	eb00024f 	bl	21f29d58 <inflate_flush>
21f29418:	e1a03000 	mov	r3, r0
21f2941c:	e50b3068 	str	r3, [fp, #-104]
21f29420:	ea000237 	b	21f29d04 <.text+0x29d04>
21f29424:	e51b2028 	ldr	r2, [fp, #-40]
21f29428:	e51b3038 	ldr	r3, [fp, #-56]
21f2942c:	e1520003 	cmp	r2, r3
21f29430:	3affffc5 	bcc	21f2934c <.text+0x2934c>
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
21f29434:	e51b3010 	ldr	r3, [fp, #-16]
21f29438:	e593100c 	ldr	r1, [r3, #12]
21f2943c:	e51b2038 	ldr	r2, [fp, #-56]
21f29440:	e59f3830 	ldr	r3, [pc, #2096]	; 21f29c78 <.text+0x29c78>
21f29444:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f29448:	e51b302c 	ldr	r3, [fp, #-44]
21f2944c:	e0023003 	and	r3, r2, r3
21f29450:	e0812003 	add	r2, r1, r3
21f29454:	e51b3010 	ldr	r3, [fp, #-16]
21f29458:	e583200c 	str	r2, [r3, #12]
      DUMPBITS(j)
21f2945c:	e51b2038 	ldr	r2, [fp, #-56]
21f29460:	e51b302c 	ldr	r3, [fp, #-44]
21f29464:	e1a03233 	mov	r3, r3, lsr r2
21f29468:	e50b302c 	str	r3, [fp, #-44]
21f2946c:	e51b2028 	ldr	r2, [fp, #-40]
21f29470:	e51b3038 	ldr	r3, [fp, #-56]
21f29474:	e0633002 	rsb	r3, r3, r2
21f29478:	e50b3028 	str	r3, [fp, #-40]
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
21f2947c:	e51b2010 	ldr	r2, [fp, #-16]
21f29480:	e3a03005 	mov	r3, #5	; 0x5
21f29484:	e5823000 	str	r3, [r2]
    case COPY:          /* o: copying bytes in window, waiting for space */
#ifndef __TURBOC__ /* Turbo C bug for following expression */
      f = (uInt)(q - s->window) < c->sub.copy.dist ?
21f29488:	e51b201c 	ldr	r2, [fp, #-28]
21f2948c:	e51b303c 	ldr	r3, [fp, #-60]
21f29490:	e5933028 	ldr	r3, [r3, #40]
21f29494:	e0633002 	rsb	r3, r3, r2
21f29498:	e1a02003 	mov	r2, r3
21f2949c:	e51b3010 	ldr	r3, [fp, #-16]
21f294a0:	e593300c 	ldr	r3, [r3, #12]
21f294a4:	e1520003 	cmp	r2, r3
21f294a8:	2a00000b 	bcs	21f294dc <.text+0x294dc>
21f294ac:	e51b303c 	ldr	r3, [fp, #-60]
21f294b0:	e593002c 	ldr	r0, [r3, #44]
21f294b4:	e51b3010 	ldr	r3, [fp, #-16]
21f294b8:	e593100c 	ldr	r1, [r3, #12]
21f294bc:	e51b201c 	ldr	r2, [fp, #-28]
21f294c0:	e51b303c 	ldr	r3, [fp, #-60]
21f294c4:	e5933028 	ldr	r3, [r3, #40]
21f294c8:	e0633002 	rsb	r3, r3, r2
21f294cc:	e0633001 	rsb	r3, r3, r1
21f294d0:	e0630000 	rsb	r0, r3, r0
21f294d4:	e50b0064 	str	r0, [fp, #-100]
21f294d8:	ea000005 	b	21f294f4 <.text+0x294f4>
21f294dc:	e51b3010 	ldr	r3, [fp, #-16]
21f294e0:	e593300c 	ldr	r3, [r3, #12]
21f294e4:	e1a02003 	mov	r2, r3
21f294e8:	e51b301c 	ldr	r3, [fp, #-28]
21f294ec:	e0623003 	rsb	r3, r2, r3
21f294f0:	e50b3064 	str	r3, [fp, #-100]
21f294f4:	e51b3064 	ldr	r3, [fp, #-100]
21f294f8:	e50b3014 	str	r3, [fp, #-20]
	  s->end - (c->sub.copy.dist - (q - s->window)) :
	  q - c->sub.copy.dist;
#else
      f = q - c->sub.copy.dist;
      if ((uInt)(q - s->window) < c->sub.copy.dist)
	f = s->end - (c->sub.copy.dist - (q - s->window));
#endif
      while (c->len)
21f294fc:	ea0000aa 	b	21f297ac <.text+0x297ac>
      {
	NEEDOUT
21f29500:	e51b3018 	ldr	r3, [fp, #-24]
21f29504:	e3530000 	cmp	r3, #0	; 0x0
21f29508:	1a00008b 	bne	21f2973c <.text+0x2973c>
21f2950c:	e51b303c 	ldr	r3, [fp, #-60]
21f29510:	e593202c 	ldr	r2, [r3, #44]
21f29514:	e51b301c 	ldr	r3, [fp, #-28]
21f29518:	e1520003 	cmp	r2, r3
21f2951c:	1a00001d 	bne	21f29598 <.text+0x29598>
21f29520:	e51b303c 	ldr	r3, [fp, #-60]
21f29524:	e5932030 	ldr	r2, [r3, #48]
21f29528:	e51b303c 	ldr	r3, [fp, #-60]
21f2952c:	e5933028 	ldr	r3, [r3, #40]
21f29530:	e1520003 	cmp	r2, r3
21f29534:	0a000017 	beq	21f29598 <.text+0x29598>
21f29538:	e51b303c 	ldr	r3, [fp, #-60]
21f2953c:	e5933028 	ldr	r3, [r3, #40]
21f29540:	e50b301c 	str	r3, [fp, #-28]
21f29544:	e51b303c 	ldr	r3, [fp, #-60]
21f29548:	e5932030 	ldr	r2, [r3, #48]
21f2954c:	e51b301c 	ldr	r3, [fp, #-28]
21f29550:	e1520003 	cmp	r2, r3
21f29554:	9a000007 	bls	21f29578 <.text+0x29578>
21f29558:	e51b303c 	ldr	r3, [fp, #-60]
21f2955c:	e5933030 	ldr	r3, [r3, #48]
21f29560:	e1a02003 	mov	r2, r3
21f29564:	e51b301c 	ldr	r3, [fp, #-28]
21f29568:	e0633002 	rsb	r3, r3, r2
21f2956c:	e2433001 	sub	r3, r3, #1	; 0x1
21f29570:	e50b3060 	str	r3, [fp, #-96]
21f29574:	ea000005 	b	21f29590 <.text+0x29590>
21f29578:	e51b303c 	ldr	r3, [fp, #-60]
21f2957c:	e593302c 	ldr	r3, [r3, #44]
21f29580:	e1a02003 	mov	r2, r3
21f29584:	e51b301c 	ldr	r3, [fp, #-28]
21f29588:	e0633002 	rsb	r3, r3, r2
21f2958c:	e50b3060 	str	r3, [fp, #-96]
21f29590:	e51b2060 	ldr	r2, [fp, #-96]
21f29594:	e50b2018 	str	r2, [fp, #-24]
21f29598:	e51b3018 	ldr	r3, [fp, #-24]
21f2959c:	e3530000 	cmp	r3, #0	; 0x0
21f295a0:	1a000065 	bne	21f2973c <.text+0x2973c>
21f295a4:	e51b203c 	ldr	r2, [fp, #-60]
21f295a8:	e51b301c 	ldr	r3, [fp, #-28]
21f295ac:	e5823034 	str	r3, [r2, #52]
21f295b0:	e51b003c 	ldr	r0, [fp, #-60]
21f295b4:	e51b1040 	ldr	r1, [fp, #-64]
21f295b8:	e51b2044 	ldr	r2, [fp, #-68]
21f295bc:	eb0001e5 	bl	21f29d58 <inflate_flush>
21f295c0:	e1a03000 	mov	r3, r0
21f295c4:	e50b3044 	str	r3, [fp, #-68]
21f295c8:	e51b303c 	ldr	r3, [fp, #-60]
21f295cc:	e5933034 	ldr	r3, [r3, #52]
21f295d0:	e50b301c 	str	r3, [fp, #-28]
21f295d4:	e51b303c 	ldr	r3, [fp, #-60]
21f295d8:	e5932030 	ldr	r2, [r3, #48]
21f295dc:	e51b301c 	ldr	r3, [fp, #-28]
21f295e0:	e1520003 	cmp	r2, r3
21f295e4:	9a000007 	bls	21f29608 <.text+0x29608>
21f295e8:	e51b303c 	ldr	r3, [fp, #-60]
21f295ec:	e5933030 	ldr	r3, [r3, #48]
21f295f0:	e1a02003 	mov	r2, r3
21f295f4:	e51b301c 	ldr	r3, [fp, #-28]
21f295f8:	e0633002 	rsb	r3, r3, r2
21f295fc:	e2433001 	sub	r3, r3, #1	; 0x1
21f29600:	e50b305c 	str	r3, [fp, #-92]
21f29604:	ea000005 	b	21f29620 <.text+0x29620>
21f29608:	e51b303c 	ldr	r3, [fp, #-60]
21f2960c:	e593302c 	ldr	r3, [r3, #44]
21f29610:	e1a02003 	mov	r2, r3
21f29614:	e51b301c 	ldr	r3, [fp, #-28]
21f29618:	e0633002 	rsb	r3, r3, r2
21f2961c:	e50b305c 	str	r3, [fp, #-92]
21f29620:	e51b305c 	ldr	r3, [fp, #-92]
21f29624:	e50b3018 	str	r3, [fp, #-24]
21f29628:	e51b303c 	ldr	r3, [fp, #-60]
21f2962c:	e593202c 	ldr	r2, [r3, #44]
21f29630:	e51b301c 	ldr	r3, [fp, #-28]
21f29634:	e1520003 	cmp	r2, r3
21f29638:	1a00001d 	bne	21f296b4 <.text+0x296b4>
21f2963c:	e51b303c 	ldr	r3, [fp, #-60]
21f29640:	e5932030 	ldr	r2, [r3, #48]
21f29644:	e51b303c 	ldr	r3, [fp, #-60]
21f29648:	e5933028 	ldr	r3, [r3, #40]
21f2964c:	e1520003 	cmp	r2, r3
21f29650:	0a000017 	beq	21f296b4 <.text+0x296b4>
21f29654:	e51b303c 	ldr	r3, [fp, #-60]
21f29658:	e5933028 	ldr	r3, [r3, #40]
21f2965c:	e50b301c 	str	r3, [fp, #-28]
21f29660:	e51b303c 	ldr	r3, [fp, #-60]
21f29664:	e5932030 	ldr	r2, [r3, #48]
21f29668:	e51b301c 	ldr	r3, [fp, #-28]
21f2966c:	e1520003 	cmp	r2, r3
21f29670:	9a000007 	bls	21f29694 <.text+0x29694>
21f29674:	e51b303c 	ldr	r3, [fp, #-60]
21f29678:	e5933030 	ldr	r3, [r3, #48]
21f2967c:	e1a02003 	mov	r2, r3
21f29680:	e51b301c 	ldr	r3, [fp, #-28]
21f29684:	e0633002 	rsb	r3, r3, r2
21f29688:	e2433001 	sub	r3, r3, #1	; 0x1
21f2968c:	e50b3058 	str	r3, [fp, #-88]
21f29690:	ea000005 	b	21f296ac <.text+0x296ac>
21f29694:	e51b303c 	ldr	r3, [fp, #-60]
21f29698:	e593302c 	ldr	r3, [r3, #44]
21f2969c:	e1a02003 	mov	r2, r3
21f296a0:	e51b301c 	ldr	r3, [fp, #-28]
21f296a4:	e0633002 	rsb	r3, r3, r2
21f296a8:	e50b3058 	str	r3, [fp, #-88]
21f296ac:	e51b2058 	ldr	r2, [fp, #-88]
21f296b0:	e50b2018 	str	r2, [fp, #-24]
21f296b4:	e51b3018 	ldr	r3, [fp, #-24]
21f296b8:	e3530000 	cmp	r3, #0	; 0x0
21f296bc:	1a00001e 	bne	21f2973c <.text+0x2973c>
21f296c0:	e51b203c 	ldr	r2, [fp, #-60]
21f296c4:	e51b302c 	ldr	r3, [fp, #-44]
21f296c8:	e5823024 	str	r3, [r2, #36]
21f296cc:	e51b203c 	ldr	r2, [fp, #-60]
21f296d0:	e51b3028 	ldr	r3, [fp, #-40]
21f296d4:	e5823020 	str	r3, [r2, #32]
21f296d8:	e51b2040 	ldr	r2, [fp, #-64]
21f296dc:	e51b3020 	ldr	r3, [fp, #-32]
21f296e0:	e5823004 	str	r3, [r2, #4]
21f296e4:	e51b3040 	ldr	r3, [fp, #-64]
21f296e8:	e5931008 	ldr	r1, [r3, #8]
21f296ec:	e51b2024 	ldr	r2, [fp, #-36]
21f296f0:	e51b3040 	ldr	r3, [fp, #-64]
21f296f4:	e5933000 	ldr	r3, [r3]
21f296f8:	e0633002 	rsb	r3, r3, r2
21f296fc:	e0812003 	add	r2, r1, r3
21f29700:	e51b3040 	ldr	r3, [fp, #-64]
21f29704:	e5832008 	str	r2, [r3, #8]
21f29708:	e51b2040 	ldr	r2, [fp, #-64]
21f2970c:	e51b3024 	ldr	r3, [fp, #-36]
21f29710:	e5823000 	str	r3, [r2]
21f29714:	e51b203c 	ldr	r2, [fp, #-60]
21f29718:	e51b301c 	ldr	r3, [fp, #-28]
21f2971c:	e5823034 	str	r3, [r2, #52]
21f29720:	e51b003c 	ldr	r0, [fp, #-60]
21f29724:	e51b1040 	ldr	r1, [fp, #-64]
21f29728:	e51b2044 	ldr	r2, [fp, #-68]
21f2972c:	eb000189 	bl	21f29d58 <inflate_flush>
21f29730:	e1a03000 	mov	r3, r0
21f29734:	e50b3068 	str	r3, [fp, #-104]
21f29738:	ea000171 	b	21f29d04 <.text+0x29d04>
21f2973c:	e3a03000 	mov	r3, #0	; 0x0
21f29740:	e50b3044 	str	r3, [fp, #-68]
	OUTBYTE(*f++)
21f29744:	e51b3014 	ldr	r3, [fp, #-20]
21f29748:	e5d33000 	ldrb	r3, [r3]
21f2974c:	e51b201c 	ldr	r2, [fp, #-28]
21f29750:	e5c23000 	strb	r3, [r2]
21f29754:	e51b301c 	ldr	r3, [fp, #-28]
21f29758:	e2833001 	add	r3, r3, #1	; 0x1
21f2975c:	e50b301c 	str	r3, [fp, #-28]
21f29760:	e51b3014 	ldr	r3, [fp, #-20]
21f29764:	e2833001 	add	r3, r3, #1	; 0x1
21f29768:	e50b3014 	str	r3, [fp, #-20]
21f2976c:	e51b3018 	ldr	r3, [fp, #-24]
21f29770:	e2433001 	sub	r3, r3, #1	; 0x1
21f29774:	e50b3018 	str	r3, [fp, #-24]
	if (f == s->end)
21f29778:	e51b303c 	ldr	r3, [fp, #-60]
21f2977c:	e593202c 	ldr	r2, [r3, #44]
21f29780:	e51b3014 	ldr	r3, [fp, #-20]
21f29784:	e1520003 	cmp	r2, r3
21f29788:	1a000002 	bne	21f29798 <.text+0x29798>
	  f = s->window;
21f2978c:	e51b303c 	ldr	r3, [fp, #-60]
21f29790:	e5933028 	ldr	r3, [r3, #40]
21f29794:	e50b3014 	str	r3, [fp, #-20]
	c->len--;
21f29798:	e51b3010 	ldr	r3, [fp, #-16]
21f2979c:	e5933004 	ldr	r3, [r3, #4]
21f297a0:	e2432001 	sub	r2, r3, #1	; 0x1
21f297a4:	e51b3010 	ldr	r3, [fp, #-16]
21f297a8:	e5832004 	str	r2, [r3, #4]
21f297ac:	e51b3010 	ldr	r3, [fp, #-16]
21f297b0:	e5933004 	ldr	r3, [r3, #4]
21f297b4:	e3530000 	cmp	r3, #0	; 0x0
21f297b8:	1affff50 	bne	21f29500 <.text+0x29500>
      }
      c->mode = START;
21f297bc:	e51b2010 	ldr	r2, [fp, #-16]
21f297c0:	e3a03000 	mov	r3, #0	; 0x0
21f297c4:	e5823000 	str	r3, [r2]
      break;
21f297c8:	eafffca9 	b	21f28a74 <inflate_codes+0xbc>
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
21f297cc:	e51b3018 	ldr	r3, [fp, #-24]
21f297d0:	e3530000 	cmp	r3, #0	; 0x0
21f297d4:	1a00008b 	bne	21f29a08 <.text+0x29a08>
21f297d8:	e51b303c 	ldr	r3, [fp, #-60]
21f297dc:	e593202c 	ldr	r2, [r3, #44]
21f297e0:	e51b301c 	ldr	r3, [fp, #-28]
21f297e4:	e1520003 	cmp	r2, r3
21f297e8:	1a00001d 	bne	21f29864 <.text+0x29864>
21f297ec:	e51b303c 	ldr	r3, [fp, #-60]
21f297f0:	e5932030 	ldr	r2, [r3, #48]
21f297f4:	e51b303c 	ldr	r3, [fp, #-60]
21f297f8:	e5933028 	ldr	r3, [r3, #40]
21f297fc:	e1520003 	cmp	r2, r3
21f29800:	0a000017 	beq	21f29864 <.text+0x29864>
21f29804:	e51b303c 	ldr	r3, [fp, #-60]
21f29808:	e5933028 	ldr	r3, [r3, #40]
21f2980c:	e50b301c 	str	r3, [fp, #-28]
21f29810:	e51b303c 	ldr	r3, [fp, #-60]
21f29814:	e5932030 	ldr	r2, [r3, #48]
21f29818:	e51b301c 	ldr	r3, [fp, #-28]
21f2981c:	e1520003 	cmp	r2, r3
21f29820:	9a000007 	bls	21f29844 <.text+0x29844>
21f29824:	e51b303c 	ldr	r3, [fp, #-60]
21f29828:	e5933030 	ldr	r3, [r3, #48]
21f2982c:	e1a02003 	mov	r2, r3
21f29830:	e51b301c 	ldr	r3, [fp, #-28]
21f29834:	e0633002 	rsb	r3, r3, r2
21f29838:	e2433001 	sub	r3, r3, #1	; 0x1
21f2983c:	e50b3054 	str	r3, [fp, #-84]
21f29840:	ea000005 	b	21f2985c <.text+0x2985c>
21f29844:	e51b303c 	ldr	r3, [fp, #-60]
21f29848:	e593302c 	ldr	r3, [r3, #44]
21f2984c:	e1a02003 	mov	r2, r3
21f29850:	e51b301c 	ldr	r3, [fp, #-28]
21f29854:	e0633002 	rsb	r3, r3, r2
21f29858:	e50b3054 	str	r3, [fp, #-84]
21f2985c:	e51b3054 	ldr	r3, [fp, #-84]
21f29860:	e50b3018 	str	r3, [fp, #-24]
21f29864:	e51b3018 	ldr	r3, [fp, #-24]
21f29868:	e3530000 	cmp	r3, #0	; 0x0
21f2986c:	1a000065 	bne	21f29a08 <.text+0x29a08>
21f29870:	e51b203c 	ldr	r2, [fp, #-60]
21f29874:	e51b301c 	ldr	r3, [fp, #-28]
21f29878:	e5823034 	str	r3, [r2, #52]
21f2987c:	e51b003c 	ldr	r0, [fp, #-60]
21f29880:	e51b1040 	ldr	r1, [fp, #-64]
21f29884:	e51b2044 	ldr	r2, [fp, #-68]
21f29888:	eb000132 	bl	21f29d58 <inflate_flush>
21f2988c:	e1a03000 	mov	r3, r0
21f29890:	e50b3044 	str	r3, [fp, #-68]
21f29894:	e51b303c 	ldr	r3, [fp, #-60]
21f29898:	e5933034 	ldr	r3, [r3, #52]
21f2989c:	e50b301c 	str	r3, [fp, #-28]
21f298a0:	e51b303c 	ldr	r3, [fp, #-60]
21f298a4:	e5932030 	ldr	r2, [r3, #48]
21f298a8:	e51b301c 	ldr	r3, [fp, #-28]
21f298ac:	e1520003 	cmp	r2, r3
21f298b0:	9a000007 	bls	21f298d4 <.text+0x298d4>
21f298b4:	e51b303c 	ldr	r3, [fp, #-60]
21f298b8:	e5933030 	ldr	r3, [r3, #48]
21f298bc:	e1a02003 	mov	r2, r3
21f298c0:	e51b301c 	ldr	r3, [fp, #-28]
21f298c4:	e0633002 	rsb	r3, r3, r2
21f298c8:	e2433001 	sub	r3, r3, #1	; 0x1
21f298cc:	e50b3050 	str	r3, [fp, #-80]
21f298d0:	ea000005 	b	21f298ec <.text+0x298ec>
21f298d4:	e51b303c 	ldr	r3, [fp, #-60]
21f298d8:	e593302c 	ldr	r3, [r3, #44]
21f298dc:	e1a02003 	mov	r2, r3
21f298e0:	e51b301c 	ldr	r3, [fp, #-28]
21f298e4:	e0633002 	rsb	r3, r3, r2
21f298e8:	e50b3050 	str	r3, [fp, #-80]
21f298ec:	e51b2050 	ldr	r2, [fp, #-80]
21f298f0:	e50b2018 	str	r2, [fp, #-24]
21f298f4:	e51b303c 	ldr	r3, [fp, #-60]
21f298f8:	e593202c 	ldr	r2, [r3, #44]
21f298fc:	e51b301c 	ldr	r3, [fp, #-28]
21f29900:	e1520003 	cmp	r2, r3
21f29904:	1a00001d 	bne	21f29980 <.text+0x29980>
21f29908:	e51b303c 	ldr	r3, [fp, #-60]
21f2990c:	e5932030 	ldr	r2, [r3, #48]
21f29910:	e51b303c 	ldr	r3, [fp, #-60]
21f29914:	e5933028 	ldr	r3, [r3, #40]
21f29918:	e1520003 	cmp	r2, r3
21f2991c:	0a000017 	beq	21f29980 <.text+0x29980>
21f29920:	e51b303c 	ldr	r3, [fp, #-60]
21f29924:	e5933028 	ldr	r3, [r3, #40]
21f29928:	e50b301c 	str	r3, [fp, #-28]
21f2992c:	e51b303c 	ldr	r3, [fp, #-60]
21f29930:	e5932030 	ldr	r2, [r3, #48]
21f29934:	e51b301c 	ldr	r3, [fp, #-28]
21f29938:	e1520003 	cmp	r2, r3
21f2993c:	9a000007 	bls	21f29960 <.text+0x29960>
21f29940:	e51b303c 	ldr	r3, [fp, #-60]
21f29944:	e5933030 	ldr	r3, [r3, #48]
21f29948:	e1a02003 	mov	r2, r3
21f2994c:	e51b301c 	ldr	r3, [fp, #-28]
21f29950:	e0633002 	rsb	r3, r3, r2
21f29954:	e2433001 	sub	r3, r3, #1	; 0x1
21f29958:	e50b304c 	str	r3, [fp, #-76]
21f2995c:	ea000005 	b	21f29978 <.text+0x29978>
21f29960:	e51b303c 	ldr	r3, [fp, #-60]
21f29964:	e593302c 	ldr	r3, [r3, #44]
21f29968:	e1a02003 	mov	r2, r3
21f2996c:	e51b301c 	ldr	r3, [fp, #-28]
21f29970:	e0633002 	rsb	r3, r3, r2
21f29974:	e50b304c 	str	r3, [fp, #-76]
21f29978:	e51b304c 	ldr	r3, [fp, #-76]
21f2997c:	e50b3018 	str	r3, [fp, #-24]
21f29980:	e51b3018 	ldr	r3, [fp, #-24]
21f29984:	e3530000 	cmp	r3, #0	; 0x0
21f29988:	1a00001e 	bne	21f29a08 <.text+0x29a08>
21f2998c:	e51b203c 	ldr	r2, [fp, #-60]
21f29990:	e51b302c 	ldr	r3, [fp, #-44]
21f29994:	e5823024 	str	r3, [r2, #36]
21f29998:	e51b203c 	ldr	r2, [fp, #-60]
21f2999c:	e51b3028 	ldr	r3, [fp, #-40]
21f299a0:	e5823020 	str	r3, [r2, #32]
21f299a4:	e51b2040 	ldr	r2, [fp, #-64]
21f299a8:	e51b3020 	ldr	r3, [fp, #-32]
21f299ac:	e5823004 	str	r3, [r2, #4]
21f299b0:	e51b3040 	ldr	r3, [fp, #-64]
21f299b4:	e5931008 	ldr	r1, [r3, #8]
21f299b8:	e51b2024 	ldr	r2, [fp, #-36]
21f299bc:	e51b3040 	ldr	r3, [fp, #-64]
21f299c0:	e5933000 	ldr	r3, [r3]
21f299c4:	e0633002 	rsb	r3, r3, r2
21f299c8:	e0812003 	add	r2, r1, r3
21f299cc:	e51b3040 	ldr	r3, [fp, #-64]
21f299d0:	e5832008 	str	r2, [r3, #8]
21f299d4:	e51b2040 	ldr	r2, [fp, #-64]
21f299d8:	e51b3024 	ldr	r3, [fp, #-36]
21f299dc:	e5823000 	str	r3, [r2]
21f299e0:	e51b203c 	ldr	r2, [fp, #-60]
21f299e4:	e51b301c 	ldr	r3, [fp, #-28]
21f299e8:	e5823034 	str	r3, [r2, #52]
21f299ec:	e51b003c 	ldr	r0, [fp, #-60]
21f299f0:	e51b1040 	ldr	r1, [fp, #-64]
21f299f4:	e51b2044 	ldr	r2, [fp, #-68]
21f299f8:	eb0000d6 	bl	21f29d58 <inflate_flush>
21f299fc:	e1a03000 	mov	r3, r0
21f29a00:	e50b3068 	str	r3, [fp, #-104]
21f29a04:	ea0000be 	b	21f29d04 <.text+0x29d04>
21f29a08:	e3a03000 	mov	r3, #0	; 0x0
21f29a0c:	e50b3044 	str	r3, [fp, #-68]
      OUTBYTE(c->sub.lit)
21f29a10:	e51b3010 	ldr	r3, [fp, #-16]
21f29a14:	e5933008 	ldr	r3, [r3, #8]
21f29a18:	e20330ff 	and	r3, r3, #255	; 0xff
21f29a1c:	e51b201c 	ldr	r2, [fp, #-28]
21f29a20:	e5c23000 	strb	r3, [r2]
21f29a24:	e51b301c 	ldr	r3, [fp, #-28]
21f29a28:	e2833001 	add	r3, r3, #1	; 0x1
21f29a2c:	e50b301c 	str	r3, [fp, #-28]
21f29a30:	e51b3018 	ldr	r3, [fp, #-24]
21f29a34:	e2433001 	sub	r3, r3, #1	; 0x1
21f29a38:	e50b3018 	str	r3, [fp, #-24]
      c->mode = START;
21f29a3c:	e51b2010 	ldr	r2, [fp, #-16]
21f29a40:	e3a03000 	mov	r3, #0	; 0x0
21f29a44:	e5823000 	str	r3, [r2]
      break;
21f29a48:	eafffc09 	b	21f28a74 <inflate_codes+0xbc>
    case WASH:          /* o: got eob, possibly more output */
      FLUSH
21f29a4c:	e51b203c 	ldr	r2, [fp, #-60]
21f29a50:	e51b301c 	ldr	r3, [fp, #-28]
21f29a54:	e5823034 	str	r3, [r2, #52]
21f29a58:	e51b003c 	ldr	r0, [fp, #-60]
21f29a5c:	e51b1040 	ldr	r1, [fp, #-64]
21f29a60:	e51b2044 	ldr	r2, [fp, #-68]
21f29a64:	eb0000bb 	bl	21f29d58 <inflate_flush>
21f29a68:	e1a03000 	mov	r3, r0
21f29a6c:	e50b3044 	str	r3, [fp, #-68]
21f29a70:	e51b303c 	ldr	r3, [fp, #-60]
21f29a74:	e5933034 	ldr	r3, [r3, #52]
21f29a78:	e50b301c 	str	r3, [fp, #-28]
21f29a7c:	e51b303c 	ldr	r3, [fp, #-60]
21f29a80:	e5932030 	ldr	r2, [r3, #48]
21f29a84:	e51b301c 	ldr	r3, [fp, #-28]
21f29a88:	e1520003 	cmp	r2, r3
21f29a8c:	9a000007 	bls	21f29ab0 <.text+0x29ab0>
21f29a90:	e51b303c 	ldr	r3, [fp, #-60]
21f29a94:	e5933030 	ldr	r3, [r3, #48]
21f29a98:	e1a02003 	mov	r2, r3
21f29a9c:	e51b301c 	ldr	r3, [fp, #-28]
21f29aa0:	e0633002 	rsb	r3, r3, r2
21f29aa4:	e2433001 	sub	r3, r3, #1	; 0x1
21f29aa8:	e50b3048 	str	r3, [fp, #-72]
21f29aac:	ea000005 	b	21f29ac8 <.text+0x29ac8>
21f29ab0:	e51b303c 	ldr	r3, [fp, #-60]
21f29ab4:	e593302c 	ldr	r3, [r3, #44]
21f29ab8:	e1a02003 	mov	r2, r3
21f29abc:	e51b301c 	ldr	r3, [fp, #-28]
21f29ac0:	e0633002 	rsb	r3, r3, r2
21f29ac4:	e50b3048 	str	r3, [fp, #-72]
21f29ac8:	e51b2048 	ldr	r2, [fp, #-72]
21f29acc:	e50b2018 	str	r2, [fp, #-24]
      if (s->read != s->write)
21f29ad0:	e51b303c 	ldr	r3, [fp, #-60]
21f29ad4:	e5932030 	ldr	r2, [r3, #48]
21f29ad8:	e51b303c 	ldr	r3, [fp, #-60]
21f29adc:	e5933034 	ldr	r3, [r3, #52]
21f29ae0:	e1520003 	cmp	r2, r3
21f29ae4:	0a00001e 	beq	21f29b64 <.text+0x29b64>
	LEAVE
21f29ae8:	e51b203c 	ldr	r2, [fp, #-60]
21f29aec:	e51b302c 	ldr	r3, [fp, #-44]
21f29af0:	e5823024 	str	r3, [r2, #36]
21f29af4:	e51b203c 	ldr	r2, [fp, #-60]
21f29af8:	e51b3028 	ldr	r3, [fp, #-40]
21f29afc:	e5823020 	str	r3, [r2, #32]
21f29b00:	e51b2040 	ldr	r2, [fp, #-64]
21f29b04:	e51b3020 	ldr	r3, [fp, #-32]
21f29b08:	e5823004 	str	r3, [r2, #4]
21f29b0c:	e51b3040 	ldr	r3, [fp, #-64]
21f29b10:	e5931008 	ldr	r1, [r3, #8]
21f29b14:	e51b2024 	ldr	r2, [fp, #-36]
21f29b18:	e51b3040 	ldr	r3, [fp, #-64]
21f29b1c:	e5933000 	ldr	r3, [r3]
21f29b20:	e0633002 	rsb	r3, r3, r2
21f29b24:	e0812003 	add	r2, r1, r3
21f29b28:	e51b3040 	ldr	r3, [fp, #-64]
21f29b2c:	e5832008 	str	r2, [r3, #8]
21f29b30:	e51b2040 	ldr	r2, [fp, #-64]
21f29b34:	e51b3024 	ldr	r3, [fp, #-36]
21f29b38:	e5823000 	str	r3, [r2]
21f29b3c:	e51b203c 	ldr	r2, [fp, #-60]
21f29b40:	e51b301c 	ldr	r3, [fp, #-28]
21f29b44:	e5823034 	str	r3, [r2, #52]
21f29b48:	e51b003c 	ldr	r0, [fp, #-60]
21f29b4c:	e51b1040 	ldr	r1, [fp, #-64]
21f29b50:	e51b2044 	ldr	r2, [fp, #-68]
21f29b54:	eb00007f 	bl	21f29d58 <inflate_flush>
21f29b58:	e1a03000 	mov	r3, r0
21f29b5c:	e50b3068 	str	r3, [fp, #-104]
21f29b60:	ea000067 	b	21f29d04 <.text+0x29d04>
      c->mode = END;
21f29b64:	e51b2010 	ldr	r2, [fp, #-16]
21f29b68:	e3a03008 	mov	r3, #8	; 0x8
21f29b6c:	e5823000 	str	r3, [r2]
    case END:
      r = Z_STREAM_END;
21f29b70:	e3a03001 	mov	r3, #1	; 0x1
21f29b74:	e50b3044 	str	r3, [fp, #-68]
      LEAVE
21f29b78:	e51b203c 	ldr	r2, [fp, #-60]
21f29b7c:	e51b302c 	ldr	r3, [fp, #-44]
21f29b80:	e5823024 	str	r3, [r2, #36]
21f29b84:	e51b203c 	ldr	r2, [fp, #-60]
21f29b88:	e51b3028 	ldr	r3, [fp, #-40]
21f29b8c:	e5823020 	str	r3, [r2, #32]
21f29b90:	e51b2040 	ldr	r2, [fp, #-64]
21f29b94:	e51b3020 	ldr	r3, [fp, #-32]
21f29b98:	e5823004 	str	r3, [r2, #4]
21f29b9c:	e51b3040 	ldr	r3, [fp, #-64]
21f29ba0:	e5931008 	ldr	r1, [r3, #8]
21f29ba4:	e51b2024 	ldr	r2, [fp, #-36]
21f29ba8:	e51b3040 	ldr	r3, [fp, #-64]
21f29bac:	e5933000 	ldr	r3, [r3]
21f29bb0:	e0633002 	rsb	r3, r3, r2
21f29bb4:	e0812003 	add	r2, r1, r3
21f29bb8:	e51b3040 	ldr	r3, [fp, #-64]
21f29bbc:	e5832008 	str	r2, [r3, #8]
21f29bc0:	e51b2040 	ldr	r2, [fp, #-64]
21f29bc4:	e51b3024 	ldr	r3, [fp, #-36]
21f29bc8:	e5823000 	str	r3, [r2]
21f29bcc:	e51b203c 	ldr	r2, [fp, #-60]
21f29bd0:	e51b301c 	ldr	r3, [fp, #-28]
21f29bd4:	e5823034 	str	r3, [r2, #52]
21f29bd8:	e51b003c 	ldr	r0, [fp, #-60]
21f29bdc:	e51b1040 	ldr	r1, [fp, #-64]
21f29be0:	e51b2044 	ldr	r2, [fp, #-68]
21f29be4:	eb00005b 	bl	21f29d58 <inflate_flush>
21f29be8:	e1a03000 	mov	r3, r0
21f29bec:	e50b3068 	str	r3, [fp, #-104]
21f29bf0:	ea000043 	b	21f29d04 <.text+0x29d04>
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
21f29bf4:	e3e03002 	mvn	r3, #2	; 0x2
21f29bf8:	e50b3044 	str	r3, [fp, #-68]
      LEAVE
21f29bfc:	e51b203c 	ldr	r2, [fp, #-60]
21f29c00:	e51b302c 	ldr	r3, [fp, #-44]
21f29c04:	e5823024 	str	r3, [r2, #36]
21f29c08:	e51b203c 	ldr	r2, [fp, #-60]
21f29c0c:	e51b3028 	ldr	r3, [fp, #-40]
21f29c10:	e5823020 	str	r3, [r2, #32]
21f29c14:	e51b2040 	ldr	r2, [fp, #-64]
21f29c18:	e51b3020 	ldr	r3, [fp, #-32]
21f29c1c:	e5823004 	str	r3, [r2, #4]
21f29c20:	e51b3040 	ldr	r3, [fp, #-64]
21f29c24:	e5931008 	ldr	r1, [r3, #8]
21f29c28:	e51b2024 	ldr	r2, [fp, #-36]
21f29c2c:	e51b3040 	ldr	r3, [fp, #-64]
21f29c30:	e5933000 	ldr	r3, [r3]
21f29c34:	e0633002 	rsb	r3, r3, r2
21f29c38:	e0812003 	add	r2, r1, r3
21f29c3c:	e51b3040 	ldr	r3, [fp, #-64]
21f29c40:	e5832008 	str	r2, [r3, #8]
21f29c44:	e51b2040 	ldr	r2, [fp, #-64]
21f29c48:	e51b3024 	ldr	r3, [fp, #-36]
21f29c4c:	e5823000 	str	r3, [r2]
21f29c50:	e51b203c 	ldr	r2, [fp, #-60]
21f29c54:	e51b301c 	ldr	r3, [fp, #-28]
21f29c58:	e5823034 	str	r3, [r2, #52]
21f29c5c:	e51b003c 	ldr	r0, [fp, #-60]
21f29c60:	e51b1040 	ldr	r1, [fp, #-64]
21f29c64:	e51b2044 	ldr	r2, [fp, #-68]
21f29c68:	eb00003a 	bl	21f29d58 <inflate_flush>
21f29c6c:	e1a03000 	mov	r3, r0
21f29c70:	e50b3068 	str	r3, [fp, #-104]
21f29c74:	ea000022 	b	21f29d04 <.text+0x29d04>
21f29c78:	21f339d4 	ldrcssb	r3, [r3, #148]!
21f29c7c:	21f32e50 	mvncss	r2, r0, asr lr
21f29c80:	21f32e6c 	mvncss	r2, ip, ror #28
    default:
      r = Z_STREAM_ERROR;
21f29c84:	e3e03001 	mvn	r3, #1	; 0x1
21f29c88:	e50b3044 	str	r3, [fp, #-68]
      LEAVE
21f29c8c:	e51b203c 	ldr	r2, [fp, #-60]
21f29c90:	e51b302c 	ldr	r3, [fp, #-44]
21f29c94:	e5823024 	str	r3, [r2, #36]
21f29c98:	e51b203c 	ldr	r2, [fp, #-60]
21f29c9c:	e51b3028 	ldr	r3, [fp, #-40]
21f29ca0:	e5823020 	str	r3, [r2, #32]
21f29ca4:	e51b2040 	ldr	r2, [fp, #-64]
21f29ca8:	e51b3020 	ldr	r3, [fp, #-32]
21f29cac:	e5823004 	str	r3, [r2, #4]
21f29cb0:	e51b3040 	ldr	r3, [fp, #-64]
21f29cb4:	e5931008 	ldr	r1, [r3, #8]
21f29cb8:	e51b2024 	ldr	r2, [fp, #-36]
21f29cbc:	e51b3040 	ldr	r3, [fp, #-64]
21f29cc0:	e5933000 	ldr	r3, [r3]
21f29cc4:	e0633002 	rsb	r3, r3, r2
21f29cc8:	e0812003 	add	r2, r1, r3
21f29ccc:	e51b3040 	ldr	r3, [fp, #-64]
21f29cd0:	e5832008 	str	r2, [r3, #8]
21f29cd4:	e51b2040 	ldr	r2, [fp, #-64]
21f29cd8:	e51b3024 	ldr	r3, [fp, #-36]
21f29cdc:	e5823000 	str	r3, [r2]
21f29ce0:	e51b203c 	ldr	r2, [fp, #-60]
21f29ce4:	e51b301c 	ldr	r3, [fp, #-28]
21f29ce8:	e5823034 	str	r3, [r2, #52]
21f29cec:	e51b003c 	ldr	r0, [fp, #-60]
21f29cf0:	e51b1040 	ldr	r1, [fp, #-64]
21f29cf4:	e51b2044 	ldr	r2, [fp, #-68]
21f29cf8:	eb000016 	bl	21f29d58 <inflate_flush>
21f29cfc:	e1a03000 	mov	r3, r0
21f29d00:	e50b3068 	str	r3, [fp, #-104]
21f29d04:	e51b3068 	ldr	r3, [fp, #-104]
  }
}
21f29d08:	e1a00003 	mov	r0, r3
21f29d0c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f29d10:	e89da800 	ldmia	sp, {fp, sp, pc}

21f29d14 <inflate_codes_free>:


local void inflate_codes_free(c, z)
inflate_codes_statef *c;
z_stream *z;
{
21f29d14:	e1a0c00d 	mov	ip, sp
21f29d18:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f29d1c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f29d20:	e24dd008 	sub	sp, sp, #8	; 0x8
21f29d24:	e50b0010 	str	r0, [fp, #-16]
21f29d28:	e50b1014 	str	r1, [fp, #-20]
  ZFREE(z, c, sizeof(struct inflate_codes_state));
21f29d2c:	e51b3014 	ldr	r3, [fp, #-20]
21f29d30:	e593c024 	ldr	ip, [r3, #36]
21f29d34:	e51b3014 	ldr	r3, [fp, #-20]
21f29d38:	e5933028 	ldr	r3, [r3, #40]
21f29d3c:	e1a00003 	mov	r0, r3
21f29d40:	e51b1010 	ldr	r1, [fp, #-16]
21f29d44:	e3a0201c 	mov	r2, #28	; 0x1c
21f29d48:	e1a0e00f 	mov	lr, pc
21f29d4c:	e1a0f00c 	mov	pc, ip
  Tracev((stderr, "inflate:       codes free\n"));
}
21f29d50:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f29d54:	e89da800 	ldmia	sp, {fp, sp, pc}

21f29d58 <inflate_flush>:

/*+++++*/
/* inflate_util.c -- data and routines common to blocks and codes
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* copy as much as possible from the sliding window to the output area */
local int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_stream *z;
int r;
{
21f29d58:	e1a0c00d 	mov	ip, sp
21f29d5c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f29d60:	e24cb004 	sub	fp, ip, #4	; 0x4
21f29d64:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f29d68:	e50b001c 	str	r0, [fp, #-28]
21f29d6c:	e50b1020 	str	r1, [fp, #-32]
21f29d70:	e50b2024 	str	r2, [fp, #-36]
  uInt n;
  Bytef *p, *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
21f29d74:	e51b3020 	ldr	r3, [fp, #-32]
21f29d78:	e593300c 	ldr	r3, [r3, #12]
21f29d7c:	e50b3014 	str	r3, [fp, #-20]
  q = s->read;
21f29d80:	e51b301c 	ldr	r3, [fp, #-28]
21f29d84:	e5933030 	ldr	r3, [r3, #48]
21f29d88:	e50b3010 	str	r3, [fp, #-16]

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
21f29d8c:	e51b301c 	ldr	r3, [fp, #-28]
21f29d90:	e5932034 	ldr	r2, [r3, #52]
21f29d94:	e51b3010 	ldr	r3, [fp, #-16]
21f29d98:	e1520003 	cmp	r2, r3
21f29d9c:	3a000003 	bcc	21f29db0 <inflate_flush+0x58>
21f29da0:	e51b301c 	ldr	r3, [fp, #-28]
21f29da4:	e5933034 	ldr	r3, [r3, #52]
21f29da8:	e50b3028 	str	r3, [fp, #-40]
21f29dac:	ea000002 	b	21f29dbc <inflate_flush+0x64>
21f29db0:	e51b301c 	ldr	r3, [fp, #-28]
21f29db4:	e593302c 	ldr	r3, [r3, #44]
21f29db8:	e50b3028 	str	r3, [fp, #-40]
21f29dbc:	e51b2028 	ldr	r2, [fp, #-40]
21f29dc0:	e51b3010 	ldr	r3, [fp, #-16]
21f29dc4:	e0633002 	rsb	r3, r3, r2
21f29dc8:	e50b3018 	str	r3, [fp, #-24]
  if (n > z->avail_out) n = z->avail_out;
21f29dcc:	e51b3020 	ldr	r3, [fp, #-32]
21f29dd0:	e5932010 	ldr	r2, [r3, #16]
21f29dd4:	e51b3018 	ldr	r3, [fp, #-24]
21f29dd8:	e1520003 	cmp	r2, r3
21f29ddc:	2a000002 	bcs	21f29dec <inflate_flush+0x94>
21f29de0:	e51b3020 	ldr	r3, [fp, #-32]
21f29de4:	e5933010 	ldr	r3, [r3, #16]
21f29de8:	e50b3018 	str	r3, [fp, #-24]
  if (n && r == Z_BUF_ERROR) r = Z_OK;
21f29dec:	e51b3018 	ldr	r3, [fp, #-24]
21f29df0:	e3530000 	cmp	r3, #0	; 0x0
21f29df4:	0a000004 	beq	21f29e0c <inflate_flush+0xb4>
21f29df8:	e51b3024 	ldr	r3, [fp, #-36]
21f29dfc:	e3730005 	cmn	r3, #5	; 0x5
21f29e00:	1a000001 	bne	21f29e0c <inflate_flush+0xb4>
21f29e04:	e3a03000 	mov	r3, #0	; 0x0
21f29e08:	e50b3024 	str	r3, [fp, #-36]

  /* update counters */
  z->avail_out -= n;
21f29e0c:	e51b3020 	ldr	r3, [fp, #-32]
21f29e10:	e5932010 	ldr	r2, [r3, #16]
21f29e14:	e51b3018 	ldr	r3, [fp, #-24]
21f29e18:	e0632002 	rsb	r2, r3, r2
21f29e1c:	e51b3020 	ldr	r3, [fp, #-32]
21f29e20:	e5832010 	str	r2, [r3, #16]
  z->total_out += n;
21f29e24:	e51b3020 	ldr	r3, [fp, #-32]
21f29e28:	e5932014 	ldr	r2, [r3, #20]
21f29e2c:	e51b3018 	ldr	r3, [fp, #-24]
21f29e30:	e0822003 	add	r2, r2, r3
21f29e34:	e51b3020 	ldr	r3, [fp, #-32]
21f29e38:	e5832014 	str	r2, [r3, #20]

  /* update check information */
  if (s->checkfn != Z_NULL)
21f29e3c:	e51b301c 	ldr	r3, [fp, #-28]
21f29e40:	e5933038 	ldr	r3, [r3, #56]
21f29e44:	e3530000 	cmp	r3, #0	; 0x0
21f29e48:	0a00000b 	beq	21f29e7c <inflate_flush+0x124>
    s->check = (*s->checkfn)(s->check, q, n);
21f29e4c:	e51b301c 	ldr	r3, [fp, #-28]
21f29e50:	e593c038 	ldr	ip, [r3, #56]
21f29e54:	e51b301c 	ldr	r3, [fp, #-28]
21f29e58:	e593303c 	ldr	r3, [r3, #60]
21f29e5c:	e1a00003 	mov	r0, r3
21f29e60:	e51b1010 	ldr	r1, [fp, #-16]
21f29e64:	e51b2018 	ldr	r2, [fp, #-24]
21f29e68:	e1a0e00f 	mov	lr, pc
21f29e6c:	e1a0f00c 	mov	pc, ip
21f29e70:	e1a02000 	mov	r2, r0
21f29e74:	e51b301c 	ldr	r3, [fp, #-28]
21f29e78:	e583203c 	str	r2, [r3, #60]

  /* output callback */
  if (z->outcb != Z_NULL)
21f29e7c:	e51b3020 	ldr	r3, [fp, #-32]
21f29e80:	e5933030 	ldr	r3, [r3, #48]
21f29e84:	e3530000 	cmp	r3, #0	; 0x0
21f29e88:	0a000005 	beq	21f29ea4 <inflate_flush+0x14c>
    (*z->outcb)(q, n);
21f29e8c:	e51b3020 	ldr	r3, [fp, #-32]
21f29e90:	e5933030 	ldr	r3, [r3, #48]
21f29e94:	e51b0010 	ldr	r0, [fp, #-16]
21f29e98:	e51b1018 	ldr	r1, [fp, #-24]
21f29e9c:	e1a0e00f 	mov	lr, pc
21f29ea0:	e1a0f003 	mov	pc, r3

  /* copy as far as end of window */
  zmemcpy(p, q, n);
21f29ea4:	e51b0014 	ldr	r0, [fp, #-20]
21f29ea8:	e51b1010 	ldr	r1, [fp, #-16]
21f29eac:	e51b2018 	ldr	r2, [fp, #-24]
21f29eb0:	ebffe4c5 	bl	21f231cc <memcpy>
  p += n;
21f29eb4:	e51b2018 	ldr	r2, [fp, #-24]
21f29eb8:	e51b3014 	ldr	r3, [fp, #-20]
21f29ebc:	e0833002 	add	r3, r3, r2
21f29ec0:	e50b3014 	str	r3, [fp, #-20]
  q += n;
21f29ec4:	e51b2018 	ldr	r2, [fp, #-24]
21f29ec8:	e51b3010 	ldr	r3, [fp, #-16]
21f29ecc:	e0833002 	add	r3, r3, r2
21f29ed0:	e50b3010 	str	r3, [fp, #-16]

  /* see if more to copy at beginning of window */
  if (q == s->end)
21f29ed4:	e51b301c 	ldr	r3, [fp, #-28]
21f29ed8:	e593202c 	ldr	r2, [r3, #44]
21f29edc:	e51b3010 	ldr	r3, [fp, #-16]
21f29ee0:	e1520003 	cmp	r2, r3
21f29ee4:	1a000054 	bne	21f2a03c <inflate_flush+0x2e4>
  {
    /* wrap pointers */
    q = s->window;
21f29ee8:	e51b301c 	ldr	r3, [fp, #-28]
21f29eec:	e5933028 	ldr	r3, [r3, #40]
21f29ef0:	e50b3010 	str	r3, [fp, #-16]
    if (s->write == s->end)
21f29ef4:	e51b301c 	ldr	r3, [fp, #-28]
21f29ef8:	e5932034 	ldr	r2, [r3, #52]
21f29efc:	e51b301c 	ldr	r3, [fp, #-28]
21f29f00:	e593302c 	ldr	r3, [r3, #44]
21f29f04:	e1520003 	cmp	r2, r3
21f29f08:	1a000003 	bne	21f29f1c <inflate_flush+0x1c4>
      s->write = s->window;
21f29f0c:	e51b301c 	ldr	r3, [fp, #-28]
21f29f10:	e5932028 	ldr	r2, [r3, #40]
21f29f14:	e51b301c 	ldr	r3, [fp, #-28]
21f29f18:	e5832034 	str	r2, [r3, #52]

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
21f29f1c:	e51b301c 	ldr	r3, [fp, #-28]
21f29f20:	e5933034 	ldr	r3, [r3, #52]
21f29f24:	e1a02003 	mov	r2, r3
21f29f28:	e51b3010 	ldr	r3, [fp, #-16]
21f29f2c:	e0633002 	rsb	r3, r3, r2
21f29f30:	e50b3018 	str	r3, [fp, #-24]
    if (n > z->avail_out) n = z->avail_out;
21f29f34:	e51b3020 	ldr	r3, [fp, #-32]
21f29f38:	e5932010 	ldr	r2, [r3, #16]
21f29f3c:	e51b3018 	ldr	r3, [fp, #-24]
21f29f40:	e1520003 	cmp	r2, r3
21f29f44:	2a000002 	bcs	21f29f54 <inflate_flush+0x1fc>
21f29f48:	e51b3020 	ldr	r3, [fp, #-32]
21f29f4c:	e5933010 	ldr	r3, [r3, #16]
21f29f50:	e50b3018 	str	r3, [fp, #-24]
    if (n && r == Z_BUF_ERROR) r = Z_OK;
21f29f54:	e51b3018 	ldr	r3, [fp, #-24]
21f29f58:	e3530000 	cmp	r3, #0	; 0x0
21f29f5c:	0a000004 	beq	21f29f74 <inflate_flush+0x21c>
21f29f60:	e51b3024 	ldr	r3, [fp, #-36]
21f29f64:	e3730005 	cmn	r3, #5	; 0x5
21f29f68:	1a000001 	bne	21f29f74 <inflate_flush+0x21c>
21f29f6c:	e3a03000 	mov	r3, #0	; 0x0
21f29f70:	e50b3024 	str	r3, [fp, #-36]

    /* update counters */
    z->avail_out -= n;
21f29f74:	e51b3020 	ldr	r3, [fp, #-32]
21f29f78:	e5932010 	ldr	r2, [r3, #16]
21f29f7c:	e51b3018 	ldr	r3, [fp, #-24]
21f29f80:	e0632002 	rsb	r2, r3, r2
21f29f84:	e51b3020 	ldr	r3, [fp, #-32]
21f29f88:	e5832010 	str	r2, [r3, #16]
    z->total_out += n;
21f29f8c:	e51b3020 	ldr	r3, [fp, #-32]
21f29f90:	e5932014 	ldr	r2, [r3, #20]
21f29f94:	e51b3018 	ldr	r3, [fp, #-24]
21f29f98:	e0822003 	add	r2, r2, r3
21f29f9c:	e51b3020 	ldr	r3, [fp, #-32]
21f29fa0:	e5832014 	str	r2, [r3, #20]

    /* update check information */
    if (s->checkfn != Z_NULL)
21f29fa4:	e51b301c 	ldr	r3, [fp, #-28]
21f29fa8:	e5933038 	ldr	r3, [r3, #56]
21f29fac:	e3530000 	cmp	r3, #0	; 0x0
21f29fb0:	0a00000b 	beq	21f29fe4 <inflate_flush+0x28c>
      s->check = (*s->checkfn)(s->check, q, n);
21f29fb4:	e51b301c 	ldr	r3, [fp, #-28]
21f29fb8:	e593c038 	ldr	ip, [r3, #56]
21f29fbc:	e51b301c 	ldr	r3, [fp, #-28]
21f29fc0:	e593303c 	ldr	r3, [r3, #60]
21f29fc4:	e1a00003 	mov	r0, r3
21f29fc8:	e51b1010 	ldr	r1, [fp, #-16]
21f29fcc:	e51b2018 	ldr	r2, [fp, #-24]
21f29fd0:	e1a0e00f 	mov	lr, pc
21f29fd4:	e1a0f00c 	mov	pc, ip
21f29fd8:	e1a02000 	mov	r2, r0
21f29fdc:	e51b301c 	ldr	r3, [fp, #-28]
21f29fe0:	e583203c 	str	r2, [r3, #60]

    /* output callback */
    if (z->outcb != Z_NULL)
21f29fe4:	e51b3020 	ldr	r3, [fp, #-32]
21f29fe8:	e5933030 	ldr	r3, [r3, #48]
21f29fec:	e3530000 	cmp	r3, #0	; 0x0
21f29ff0:	0a000005 	beq	21f2a00c <inflate_flush+0x2b4>
	(*z->outcb)(q, n);
21f29ff4:	e51b3020 	ldr	r3, [fp, #-32]
21f29ff8:	e5933030 	ldr	r3, [r3, #48]
21f29ffc:	e51b0010 	ldr	r0, [fp, #-16]
21f2a000:	e51b1018 	ldr	r1, [fp, #-24]
21f2a004:	e1a0e00f 	mov	lr, pc
21f2a008:	e1a0f003 	mov	pc, r3

    /* copy */
    zmemcpy(p, q, n);
21f2a00c:	e51b0014 	ldr	r0, [fp, #-20]
21f2a010:	e51b1010 	ldr	r1, [fp, #-16]
21f2a014:	e51b2018 	ldr	r2, [fp, #-24]
21f2a018:	ebffe46b 	bl	21f231cc <memcpy>
    p += n;
21f2a01c:	e51b2018 	ldr	r2, [fp, #-24]
21f2a020:	e51b3014 	ldr	r3, [fp, #-20]
21f2a024:	e0833002 	add	r3, r3, r2
21f2a028:	e50b3014 	str	r3, [fp, #-20]
    q += n;
21f2a02c:	e51b2018 	ldr	r2, [fp, #-24]
21f2a030:	e51b3010 	ldr	r3, [fp, #-16]
21f2a034:	e0833002 	add	r3, r3, r2
21f2a038:	e50b3010 	str	r3, [fp, #-16]
  }

  /* update pointers */
  z->next_out = p;
21f2a03c:	e51b2020 	ldr	r2, [fp, #-32]
21f2a040:	e51b3014 	ldr	r3, [fp, #-20]
21f2a044:	e582300c 	str	r3, [r2, #12]
  s->read = q;
21f2a048:	e51b201c 	ldr	r2, [fp, #-28]
21f2a04c:	e51b3010 	ldr	r3, [fp, #-16]
21f2a050:	e5823030 	str	r3, [r2, #48]

  /* done */
  return r;
21f2a054:	e51b3024 	ldr	r3, [fp, #-36]
}
21f2a058:	e1a00003 	mov	r0, r3
21f2a05c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2a060:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2a064 <inflate_fast>:


/*+++++*/
/* inffast.c -- process literals and length/distance pairs fast
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* simplify the use of the inflate_huft type with some defines */
#define base more.Base
#define next more.Next
#define exop word.what.Exop
#define bits word.what.Bits

/* macros for bit input with no checking and for returning unused bytes */
#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define UNGRAB {n+=(c=k>>3);p-=c;k&=7;}

/* Called with number of bytes left to write in window at least 258
   (the maximum string length) and number of input bytes available
   at least ten.  The ten bytes are six bytes for the longest length/
   distance pair plus four bytes for overloading the bit buffer. */

local int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl, *td;
inflate_blocks_statef *s;
z_stream *z;
{
21f2a064:	e1a0c00d 	mov	ip, sp
21f2a068:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2a06c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2a070:	e24dd04c 	sub	sp, sp, #76	; 0x4c
21f2a074:	e50b0044 	str	r0, [fp, #-68]
21f2a078:	e50b1048 	str	r1, [fp, #-72]
21f2a07c:	e50b204c 	str	r2, [fp, #-76]
21f2a080:	e50b3050 	str	r3, [fp, #-80]
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  uInt ml;              /* mask for literal/length tree */
  uInt md;              /* mask for distance tree */
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD
21f2a084:	e59b3008 	ldr	r3, [fp, #8]
21f2a088:	e5933000 	ldr	r3, [r3]
21f2a08c:	e50b3030 	str	r3, [fp, #-48]
21f2a090:	e59b3008 	ldr	r3, [fp, #8]
21f2a094:	e5933004 	ldr	r3, [r3, #4]
21f2a098:	e50b302c 	str	r3, [fp, #-44]
21f2a09c:	e59b3004 	ldr	r3, [fp, #4]
21f2a0a0:	e5933024 	ldr	r3, [r3, #36]
21f2a0a4:	e50b3038 	str	r3, [fp, #-56]
21f2a0a8:	e59b3004 	ldr	r3, [fp, #4]
21f2a0ac:	e5933020 	ldr	r3, [r3, #32]
21f2a0b0:	e50b3034 	str	r3, [fp, #-52]
21f2a0b4:	e59b3004 	ldr	r3, [fp, #4]
21f2a0b8:	e5933034 	ldr	r3, [r3, #52]
21f2a0bc:	e50b3028 	str	r3, [fp, #-40]
21f2a0c0:	e59b3004 	ldr	r3, [fp, #4]
21f2a0c4:	e5932030 	ldr	r2, [r3, #48]
21f2a0c8:	e51b3028 	ldr	r3, [fp, #-40]
21f2a0cc:	e1520003 	cmp	r2, r3
21f2a0d0:	9a000007 	bls	21f2a0f4 <inflate_fast+0x90>
21f2a0d4:	e59b3004 	ldr	r3, [fp, #4]
21f2a0d8:	e5933030 	ldr	r3, [r3, #48]
21f2a0dc:	e1a02003 	mov	r2, r3
21f2a0e0:	e51b3028 	ldr	r3, [fp, #-40]
21f2a0e4:	e0633002 	rsb	r3, r3, r2
21f2a0e8:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a0ec:	e50b3058 	str	r3, [fp, #-88]
21f2a0f0:	ea000005 	b	21f2a10c <inflate_fast+0xa8>
21f2a0f4:	e59b3004 	ldr	r3, [fp, #4]
21f2a0f8:	e593302c 	ldr	r3, [r3, #44]
21f2a0fc:	e1a02003 	mov	r2, r3
21f2a100:	e51b3028 	ldr	r3, [fp, #-40]
21f2a104:	e0633002 	rsb	r3, r3, r2
21f2a108:	e50b3058 	str	r3, [fp, #-88]
21f2a10c:	e51b3058 	ldr	r3, [fp, #-88]
21f2a110:	e50b3024 	str	r3, [fp, #-36]

  /* initialize masks */
  ml = inflate_mask[bl];
21f2a114:	e51b2044 	ldr	r2, [fp, #-68]
21f2a118:	e59f3894 	ldr	r3, [pc, #2196]	; 21f2a9b4 <.text+0x2a9b4>
21f2a11c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f2a120:	e50b3020 	str	r3, [fp, #-32]
  md = inflate_mask[bd];
21f2a124:	e51b2048 	ldr	r2, [fp, #-72]
21f2a128:	e59f3884 	ldr	r3, [pc, #2180]	; 21f2a9b4 <.text+0x2a9b4>
21f2a12c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
21f2a130:	e50b301c 	str	r3, [fp, #-28]
21f2a134:	ea000010 	b	21f2a17c <inflate_fast+0x118>

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
21f2a138:	e51b302c 	ldr	r3, [fp, #-44]
21f2a13c:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a140:	e50b302c 	str	r3, [fp, #-44]
21f2a144:	e51b3030 	ldr	r3, [fp, #-48]
21f2a148:	e5d33000 	ldrb	r3, [r3]
21f2a14c:	e1a02003 	mov	r2, r3
21f2a150:	e51b3034 	ldr	r3, [fp, #-52]
21f2a154:	e1a02312 	mov	r2, r2, lsl r3
21f2a158:	e51b3038 	ldr	r3, [fp, #-56]
21f2a15c:	e1833002 	orr	r3, r3, r2
21f2a160:	e50b3038 	str	r3, [fp, #-56]
21f2a164:	e51b3030 	ldr	r3, [fp, #-48]
21f2a168:	e2833001 	add	r3, r3, #1	; 0x1
21f2a16c:	e50b3030 	str	r3, [fp, #-48]
21f2a170:	e51b3034 	ldr	r3, [fp, #-52]
21f2a174:	e2833008 	add	r3, r3, #8	; 0x8
21f2a178:	e50b3034 	str	r3, [fp, #-52]
21f2a17c:	e51b3034 	ldr	r3, [fp, #-52]
21f2a180:	e3530013 	cmp	r3, #19	; 0x13
21f2a184:	9affffeb 	bls	21f2a138 <inflate_fast+0xd4>
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
21f2a188:	e51b2038 	ldr	r2, [fp, #-56]
21f2a18c:	e51b3020 	ldr	r3, [fp, #-32]
21f2a190:	e0023003 	and	r3, r2, r3
21f2a194:	e1a03183 	mov	r3, r3, lsl #3
21f2a198:	e1a02003 	mov	r2, r3
21f2a19c:	e51b304c 	ldr	r3, [fp, #-76]
21f2a1a0:	e0823003 	add	r3, r2, r3
21f2a1a4:	e50b3040 	str	r3, [fp, #-64]
21f2a1a8:	e51b3040 	ldr	r3, [fp, #-64]
21f2a1ac:	e5d33000 	ldrb	r3, [r3]
21f2a1b0:	e50b303c 	str	r3, [fp, #-60]
21f2a1b4:	e51b303c 	ldr	r3, [fp, #-60]
21f2a1b8:	e3530000 	cmp	r3, #0	; 0x0
21f2a1bc:	1a000017 	bne	21f2a220 <inflate_fast+0x1bc>
    {
      DUMPBITS(t->bits)
21f2a1c0:	e51b3040 	ldr	r3, [fp, #-64]
21f2a1c4:	e5d33001 	ldrb	r3, [r3, #1]
21f2a1c8:	e1a02003 	mov	r2, r3
21f2a1cc:	e51b3038 	ldr	r3, [fp, #-56]
21f2a1d0:	e1a03233 	mov	r3, r3, lsr r2
21f2a1d4:	e50b3038 	str	r3, [fp, #-56]
21f2a1d8:	e51b3040 	ldr	r3, [fp, #-64]
21f2a1dc:	e5d33001 	ldrb	r3, [r3, #1]
21f2a1e0:	e1a02003 	mov	r2, r3
21f2a1e4:	e51b3034 	ldr	r3, [fp, #-52]
21f2a1e8:	e0623003 	rsb	r3, r2, r3
21f2a1ec:	e50b3034 	str	r3, [fp, #-52]
      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
		"inflate:         * literal '%c'\n" :
		"inflate:         * literal 0x%02x\n", t->base));
      *q++ = (Byte)t->base;
21f2a1f0:	e51b3040 	ldr	r3, [fp, #-64]
21f2a1f4:	e5933004 	ldr	r3, [r3, #4]
21f2a1f8:	e20330ff 	and	r3, r3, #255	; 0xff
21f2a1fc:	e51b2028 	ldr	r2, [fp, #-40]
21f2a200:	e5c23000 	strb	r3, [r2]
21f2a204:	e51b3028 	ldr	r3, [fp, #-40]
21f2a208:	e2833001 	add	r3, r3, #1	; 0x1
21f2a20c:	e50b3028 	str	r3, [fp, #-40]
      m--;
21f2a210:	e51b3024 	ldr	r3, [fp, #-36]
21f2a214:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a218:	e50b3024 	str	r3, [fp, #-36]
      continue;
21f2a21c:	ea0001b0 	b	21f2a8e4 <inflate_fast+0x880>
    }
    do {
      DUMPBITS(t->bits)
21f2a220:	e51b3040 	ldr	r3, [fp, #-64]
21f2a224:	e5d33001 	ldrb	r3, [r3, #1]
21f2a228:	e1a02003 	mov	r2, r3
21f2a22c:	e51b3038 	ldr	r3, [fp, #-56]
21f2a230:	e1a03233 	mov	r3, r3, lsr r2
21f2a234:	e50b3038 	str	r3, [fp, #-56]
21f2a238:	e51b3040 	ldr	r3, [fp, #-64]
21f2a23c:	e5d33001 	ldrb	r3, [r3, #1]
21f2a240:	e1a02003 	mov	r2, r3
21f2a244:	e51b3034 	ldr	r3, [fp, #-52]
21f2a248:	e0623003 	rsb	r3, r2, r3
21f2a24c:	e50b3034 	str	r3, [fp, #-52]
      if (e & 16)
21f2a250:	e51b303c 	ldr	r3, [fp, #-60]
21f2a254:	e1a03223 	mov	r3, r3, lsr #4
21f2a258:	e2033001 	and	r3, r3, #1	; 0x1
21f2a25c:	e20330ff 	and	r3, r3, #255	; 0xff
21f2a260:	e3530000 	cmp	r3, #0	; 0x0
21f2a264:	0a000114 	beq	21f2a6bc <inflate_fast+0x658>
      {
	/* get extra bits for length */
	e &= 15;
21f2a268:	e51b303c 	ldr	r3, [fp, #-60]
21f2a26c:	e203300f 	and	r3, r3, #15	; 0xf
21f2a270:	e50b303c 	str	r3, [fp, #-60]
	c = t->base + ((uInt)b & inflate_mask[e]);
21f2a274:	e51b3040 	ldr	r3, [fp, #-64]
21f2a278:	e5931004 	ldr	r1, [r3, #4]
21f2a27c:	e51b203c 	ldr	r2, [fp, #-60]
21f2a280:	e59f372c 	ldr	r3, [pc, #1836]	; 21f2a9b4 <.text+0x2a9b4>
21f2a284:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f2a288:	e51b3038 	ldr	r3, [fp, #-56]
21f2a28c:	e0023003 	and	r3, r2, r3
21f2a290:	e0813003 	add	r3, r1, r3
21f2a294:	e50b3018 	str	r3, [fp, #-24]
	DUMPBITS(e)
21f2a298:	e51b203c 	ldr	r2, [fp, #-60]
21f2a29c:	e51b3038 	ldr	r3, [fp, #-56]
21f2a2a0:	e1a03233 	mov	r3, r3, lsr r2
21f2a2a4:	e50b3038 	str	r3, [fp, #-56]
21f2a2a8:	e51b2034 	ldr	r2, [fp, #-52]
21f2a2ac:	e51b303c 	ldr	r3, [fp, #-60]
21f2a2b0:	e0633002 	rsb	r3, r3, r2
21f2a2b4:	e50b3034 	str	r3, [fp, #-52]
	Tracevv((stderr, "inflate:         * length %u\n", c));

	/* decode distance base of block to copy */
	GRABBITS(15);           /* max bits for distance code */
21f2a2b8:	ea000010 	b	21f2a300 <inflate_fast+0x29c>
21f2a2bc:	e51b302c 	ldr	r3, [fp, #-44]
21f2a2c0:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a2c4:	e50b302c 	str	r3, [fp, #-44]
21f2a2c8:	e51b3030 	ldr	r3, [fp, #-48]
21f2a2cc:	e5d33000 	ldrb	r3, [r3]
21f2a2d0:	e1a02003 	mov	r2, r3
21f2a2d4:	e51b3034 	ldr	r3, [fp, #-52]
21f2a2d8:	e1a02312 	mov	r2, r2, lsl r3
21f2a2dc:	e51b3038 	ldr	r3, [fp, #-56]
21f2a2e0:	e1833002 	orr	r3, r3, r2
21f2a2e4:	e50b3038 	str	r3, [fp, #-56]
21f2a2e8:	e51b3030 	ldr	r3, [fp, #-48]
21f2a2ec:	e2833001 	add	r3, r3, #1	; 0x1
21f2a2f0:	e50b3030 	str	r3, [fp, #-48]
21f2a2f4:	e51b3034 	ldr	r3, [fp, #-52]
21f2a2f8:	e2833008 	add	r3, r3, #8	; 0x8
21f2a2fc:	e50b3034 	str	r3, [fp, #-52]
21f2a300:	e51b3034 	ldr	r3, [fp, #-52]
21f2a304:	e353000e 	cmp	r3, #14	; 0xe
21f2a308:	9affffeb 	bls	21f2a2bc <inflate_fast+0x258>
	e = (t = td + ((uInt)b & md))->exop;
21f2a30c:	e51b2038 	ldr	r2, [fp, #-56]
21f2a310:	e51b301c 	ldr	r3, [fp, #-28]
21f2a314:	e0023003 	and	r3, r2, r3
21f2a318:	e1a03183 	mov	r3, r3, lsl #3
21f2a31c:	e1a02003 	mov	r2, r3
21f2a320:	e51b3050 	ldr	r3, [fp, #-80]
21f2a324:	e0823003 	add	r3, r2, r3
21f2a328:	e50b3040 	str	r3, [fp, #-64]
21f2a32c:	e51b3040 	ldr	r3, [fp, #-64]
21f2a330:	e5d33000 	ldrb	r3, [r3]
21f2a334:	e50b303c 	str	r3, [fp, #-60]
	do {
	  DUMPBITS(t->bits)
21f2a338:	e51b3040 	ldr	r3, [fp, #-64]
21f2a33c:	e5d33001 	ldrb	r3, [r3, #1]
21f2a340:	e1a02003 	mov	r2, r3
21f2a344:	e51b3038 	ldr	r3, [fp, #-56]
21f2a348:	e1a03233 	mov	r3, r3, lsr r2
21f2a34c:	e50b3038 	str	r3, [fp, #-56]
21f2a350:	e51b3040 	ldr	r3, [fp, #-64]
21f2a354:	e5d33001 	ldrb	r3, [r3, #1]
21f2a358:	e1a02003 	mov	r2, r3
21f2a35c:	e51b3034 	ldr	r3, [fp, #-52]
21f2a360:	e0623003 	rsb	r3, r2, r3
21f2a364:	e50b3034 	str	r3, [fp, #-52]
	  if (e & 16)
21f2a368:	e51b303c 	ldr	r3, [fp, #-60]
21f2a36c:	e1a03223 	mov	r3, r3, lsr #4
21f2a370:	e2033001 	and	r3, r3, #1	; 0x1
21f2a374:	e20330ff 	and	r3, r3, #255	; 0xff
21f2a378:	e3530000 	cmp	r3, #0	; 0x0
21f2a37c:	0a00008d 	beq	21f2a5b8 <inflate_fast+0x554>
	  {
	    /* get extra bits to add to distance base */
	    e &= 15;
21f2a380:	e51b303c 	ldr	r3, [fp, #-60]
21f2a384:	e203300f 	and	r3, r3, #15	; 0xf
21f2a388:	e50b303c 	str	r3, [fp, #-60]
	    GRABBITS(e)         /* get extra bits (up to 13) */
21f2a38c:	ea000010 	b	21f2a3d4 <inflate_fast+0x370>
21f2a390:	e51b302c 	ldr	r3, [fp, #-44]
21f2a394:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a398:	e50b302c 	str	r3, [fp, #-44]
21f2a39c:	e51b3030 	ldr	r3, [fp, #-48]
21f2a3a0:	e5d33000 	ldrb	r3, [r3]
21f2a3a4:	e1a02003 	mov	r2, r3
21f2a3a8:	e51b3034 	ldr	r3, [fp, #-52]
21f2a3ac:	e1a02312 	mov	r2, r2, lsl r3
21f2a3b0:	e51b3038 	ldr	r3, [fp, #-56]
21f2a3b4:	e1833002 	orr	r3, r3, r2
21f2a3b8:	e50b3038 	str	r3, [fp, #-56]
21f2a3bc:	e51b3030 	ldr	r3, [fp, #-48]
21f2a3c0:	e2833001 	add	r3, r3, #1	; 0x1
21f2a3c4:	e50b3030 	str	r3, [fp, #-48]
21f2a3c8:	e51b3034 	ldr	r3, [fp, #-52]
21f2a3cc:	e2833008 	add	r3, r3, #8	; 0x8
21f2a3d0:	e50b3034 	str	r3, [fp, #-52]
21f2a3d4:	e51b2034 	ldr	r2, [fp, #-52]
21f2a3d8:	e51b303c 	ldr	r3, [fp, #-60]
21f2a3dc:	e1520003 	cmp	r2, r3
21f2a3e0:	3affffea 	bcc	21f2a390 <inflate_fast+0x32c>
	    d = t->base + ((uInt)b & inflate_mask[e]);
21f2a3e4:	e51b3040 	ldr	r3, [fp, #-64]
21f2a3e8:	e5931004 	ldr	r1, [r3, #4]
21f2a3ec:	e51b203c 	ldr	r2, [fp, #-60]
21f2a3f0:	e59f35bc 	ldr	r3, [pc, #1468]	; 21f2a9b4 <.text+0x2a9b4>
21f2a3f4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f2a3f8:	e51b3038 	ldr	r3, [fp, #-56]
21f2a3fc:	e0023003 	and	r3, r2, r3
21f2a400:	e0813003 	add	r3, r1, r3
21f2a404:	e50b3014 	str	r3, [fp, #-20]
	    DUMPBITS(e)
21f2a408:	e51b203c 	ldr	r2, [fp, #-60]
21f2a40c:	e51b3038 	ldr	r3, [fp, #-56]
21f2a410:	e1a03233 	mov	r3, r3, lsr r2
21f2a414:	e50b3038 	str	r3, [fp, #-56]
21f2a418:	e51b2034 	ldr	r2, [fp, #-52]
21f2a41c:	e51b303c 	ldr	r3, [fp, #-60]
21f2a420:	e0633002 	rsb	r3, r3, r2
21f2a424:	e50b3034 	str	r3, [fp, #-52]
	    Tracevv((stderr, "inflate:         * distance %u\n", d));

	    /* do the copy */
	    m -= c;
21f2a428:	e51b2024 	ldr	r2, [fp, #-36]
21f2a42c:	e51b3018 	ldr	r3, [fp, #-24]
21f2a430:	e0633002 	rsb	r3, r3, r2
21f2a434:	e50b3024 	str	r3, [fp, #-36]
	    if ((uInt)(q - s->window) >= d)     /* offset before dest */
21f2a438:	e51b2028 	ldr	r2, [fp, #-40]
21f2a43c:	e59b3004 	ldr	r3, [fp, #4]
21f2a440:	e5933028 	ldr	r3, [r3, #40]
21f2a444:	e0633002 	rsb	r3, r3, r2
21f2a448:	e1a02003 	mov	r2, r3
21f2a44c:	e51b3014 	ldr	r3, [fp, #-20]
21f2a450:	e1520003 	cmp	r2, r3
21f2a454:	3a00001e 	bcc	21f2a4d4 <inflate_fast+0x470>
	    {                                   /*  just copy */
	      r = q - d;
21f2a458:	e51b2014 	ldr	r2, [fp, #-20]
21f2a45c:	e51b3028 	ldr	r3, [fp, #-40]
21f2a460:	e0623003 	rsb	r3, r2, r3
21f2a464:	e50b3010 	str	r3, [fp, #-16]
	      *q++ = *r++;  c--;        /* minimum count is three, */
21f2a468:	e51b3010 	ldr	r3, [fp, #-16]
21f2a46c:	e5d33000 	ldrb	r3, [r3]
21f2a470:	e51b2028 	ldr	r2, [fp, #-40]
21f2a474:	e5c23000 	strb	r3, [r2]
21f2a478:	e51b3028 	ldr	r3, [fp, #-40]
21f2a47c:	e2833001 	add	r3, r3, #1	; 0x1
21f2a480:	e50b3028 	str	r3, [fp, #-40]
21f2a484:	e51b3010 	ldr	r3, [fp, #-16]
21f2a488:	e2833001 	add	r3, r3, #1	; 0x1
21f2a48c:	e50b3010 	str	r3, [fp, #-16]
21f2a490:	e51b3018 	ldr	r3, [fp, #-24]
21f2a494:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a498:	e50b3018 	str	r3, [fp, #-24]
	      *q++ = *r++;  c--;        /*  so unroll loop a little */
21f2a49c:	e51b3010 	ldr	r3, [fp, #-16]
21f2a4a0:	e5d33000 	ldrb	r3, [r3]
21f2a4a4:	e51b2028 	ldr	r2, [fp, #-40]
21f2a4a8:	e5c23000 	strb	r3, [r2]
21f2a4ac:	e51b3028 	ldr	r3, [fp, #-40]
21f2a4b0:	e2833001 	add	r3, r3, #1	; 0x1
21f2a4b4:	e50b3028 	str	r3, [fp, #-40]
21f2a4b8:	e51b3010 	ldr	r3, [fp, #-16]
21f2a4bc:	e2833001 	add	r3, r3, #1	; 0x1
21f2a4c0:	e50b3010 	str	r3, [fp, #-16]
21f2a4c4:	e51b3018 	ldr	r3, [fp, #-24]
21f2a4c8:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a4cc:	e50b3018 	str	r3, [fp, #-24]
21f2a4d0:	ea000027 	b	21f2a574 <inflate_fast+0x510>
	    }
	    else                        /* else offset after destination */
	    {
	      e = d - (q - s->window);  /* bytes from offset to end */
21f2a4d4:	e51b2028 	ldr	r2, [fp, #-40]
21f2a4d8:	e59b3004 	ldr	r3, [fp, #4]
21f2a4dc:	e5933028 	ldr	r3, [r3, #40]
21f2a4e0:	e0633002 	rsb	r3, r3, r2
21f2a4e4:	e1a02003 	mov	r2, r3
21f2a4e8:	e51b3014 	ldr	r3, [fp, #-20]
21f2a4ec:	e0623003 	rsb	r3, r2, r3
21f2a4f0:	e50b303c 	str	r3, [fp, #-60]
	      r = s->end - e;           /* pointer to offset */
21f2a4f4:	e59b3004 	ldr	r3, [fp, #4]
21f2a4f8:	e593202c 	ldr	r2, [r3, #44]
21f2a4fc:	e51b303c 	ldr	r3, [fp, #-60]
21f2a500:	e0633002 	rsb	r3, r3, r2
21f2a504:	e50b3010 	str	r3, [fp, #-16]
	      if (c > e)                /* if source crosses, */
21f2a508:	e51b2018 	ldr	r2, [fp, #-24]
21f2a50c:	e51b303c 	ldr	r3, [fp, #-60]
21f2a510:	e1520003 	cmp	r2, r3
21f2a514:	9a000016 	bls	21f2a574 <inflate_fast+0x510>
	      {
		c -= e;                 /* copy to end of window */
21f2a518:	e51b3018 	ldr	r3, [fp, #-24]
21f2a51c:	e51b203c 	ldr	r2, [fp, #-60]
21f2a520:	e0623003 	rsb	r3, r2, r3
21f2a524:	e50b3018 	str	r3, [fp, #-24]
		do {
		  *q++ = *r++;
21f2a528:	e51b3010 	ldr	r3, [fp, #-16]
21f2a52c:	e5d33000 	ldrb	r3, [r3]
21f2a530:	e51b2028 	ldr	r2, [fp, #-40]
21f2a534:	e5c23000 	strb	r3, [r2]
21f2a538:	e51b3028 	ldr	r3, [fp, #-40]
21f2a53c:	e2833001 	add	r3, r3, #1	; 0x1
21f2a540:	e50b3028 	str	r3, [fp, #-40]
21f2a544:	e51b3010 	ldr	r3, [fp, #-16]
21f2a548:	e2833001 	add	r3, r3, #1	; 0x1
21f2a54c:	e50b3010 	str	r3, [fp, #-16]
		} while (--e);
21f2a550:	e51b303c 	ldr	r3, [fp, #-60]
21f2a554:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a558:	e50b303c 	str	r3, [fp, #-60]
21f2a55c:	e51b303c 	ldr	r3, [fp, #-60]
21f2a560:	e3530000 	cmp	r3, #0	; 0x0
21f2a564:	1affffef 	bne	21f2a528 <inflate_fast+0x4c4>
		r = s->window;          /* copy rest from start of window */
21f2a568:	e59b3004 	ldr	r3, [fp, #4]
21f2a56c:	e5933028 	ldr	r3, [r3, #40]
21f2a570:	e50b3010 	str	r3, [fp, #-16]
	      }
	    }
	    do {                        /* copy all or what's left */
	      *q++ = *r++;
21f2a574:	e51b3010 	ldr	r3, [fp, #-16]
21f2a578:	e5d33000 	ldrb	r3, [r3]
21f2a57c:	e51b2028 	ldr	r2, [fp, #-40]
21f2a580:	e5c23000 	strb	r3, [r2]
21f2a584:	e51b3028 	ldr	r3, [fp, #-40]
21f2a588:	e2833001 	add	r3, r3, #1	; 0x1
21f2a58c:	e50b3028 	str	r3, [fp, #-40]
21f2a590:	e51b3010 	ldr	r3, [fp, #-16]
21f2a594:	e2833001 	add	r3, r3, #1	; 0x1
21f2a598:	e50b3010 	str	r3, [fp, #-16]
	    } while (--c);
21f2a59c:	e51b3018 	ldr	r3, [fp, #-24]
21f2a5a0:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a5a4:	e50b3018 	str	r3, [fp, #-24]
21f2a5a8:	e51b3018 	ldr	r3, [fp, #-24]
21f2a5ac:	e3530000 	cmp	r3, #0	; 0x0
21f2a5b0:	1affffef 	bne	21f2a574 <inflate_fast+0x510>
21f2a5b4:	ea0000ca 	b	21f2a8e4 <inflate_fast+0x880>
	    break;
	  }
	  else if ((e & 64) == 0)
21f2a5b8:	e51b303c 	ldr	r3, [fp, #-60]
21f2a5bc:	e1a03323 	mov	r3, r3, lsr #6
21f2a5c0:	e2233001 	eor	r3, r3, #1	; 0x1
21f2a5c4:	e2033001 	and	r3, r3, #1	; 0x1
21f2a5c8:	e20330ff 	and	r3, r3, #255	; 0xff
21f2a5cc:	e3530000 	cmp	r3, #0	; 0x0
21f2a5d0:	0a00000d 	beq	21f2a60c <inflate_fast+0x5a8>
	    e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop;
21f2a5d4:	e51b3040 	ldr	r3, [fp, #-64]
21f2a5d8:	e5931004 	ldr	r1, [r3, #4]
21f2a5dc:	e51b203c 	ldr	r2, [fp, #-60]
21f2a5e0:	e59f33cc 	ldr	r3, [pc, #972]	; 21f2a9b4 <.text+0x2a9b4>
21f2a5e4:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f2a5e8:	e51b3038 	ldr	r3, [fp, #-56]
21f2a5ec:	e0023003 	and	r3, r2, r3
21f2a5f0:	e1a03183 	mov	r3, r3, lsl #3
21f2a5f4:	e0813003 	add	r3, r1, r3
21f2a5f8:	e50b3040 	str	r3, [fp, #-64]
21f2a5fc:	e51b3040 	ldr	r3, [fp, #-64]
21f2a600:	e5d33000 	ldrb	r3, [r3]
21f2a604:	e50b303c 	str	r3, [fp, #-60]
21f2a608:	eaffff4a 	b	21f2a338 <inflate_fast+0x2d4>
	  else
	  {
	    z->msg = "invalid distance code";
21f2a60c:	e59b2008 	ldr	r2, [fp, #8]
21f2a610:	e59f33a0 	ldr	r3, [pc, #928]	; 21f2a9b8 <.text+0x2a9b8>
21f2a614:	e5823018 	str	r3, [r2, #24]
	    UNGRAB
21f2a618:	e51b3034 	ldr	r3, [fp, #-52]
21f2a61c:	e1a031a3 	mov	r3, r3, lsr #3
21f2a620:	e50b3018 	str	r3, [fp, #-24]
21f2a624:	e51b202c 	ldr	r2, [fp, #-44]
21f2a628:	e51b3018 	ldr	r3, [fp, #-24]
21f2a62c:	e0823003 	add	r3, r2, r3
21f2a630:	e50b302c 	str	r3, [fp, #-44]
21f2a634:	e51b2018 	ldr	r2, [fp, #-24]
21f2a638:	e51b3030 	ldr	r3, [fp, #-48]
21f2a63c:	e0623003 	rsb	r3, r2, r3
21f2a640:	e50b3030 	str	r3, [fp, #-48]
21f2a644:	e51b3034 	ldr	r3, [fp, #-52]
21f2a648:	e2033007 	and	r3, r3, #7	; 0x7
21f2a64c:	e50b3034 	str	r3, [fp, #-52]
	    UPDATE
21f2a650:	e59b2004 	ldr	r2, [fp, #4]
21f2a654:	e51b3038 	ldr	r3, [fp, #-56]
21f2a658:	e5823024 	str	r3, [r2, #36]
21f2a65c:	e59b2004 	ldr	r2, [fp, #4]
21f2a660:	e51b3034 	ldr	r3, [fp, #-52]
21f2a664:	e5823020 	str	r3, [r2, #32]
21f2a668:	e59b2008 	ldr	r2, [fp, #8]
21f2a66c:	e51b302c 	ldr	r3, [fp, #-44]
21f2a670:	e5823004 	str	r3, [r2, #4]
21f2a674:	e59b3008 	ldr	r3, [fp, #8]
21f2a678:	e5931008 	ldr	r1, [r3, #8]
21f2a67c:	e51b2030 	ldr	r2, [fp, #-48]
21f2a680:	e59b3008 	ldr	r3, [fp, #8]
21f2a684:	e5933000 	ldr	r3, [r3]
21f2a688:	e0633002 	rsb	r3, r3, r2
21f2a68c:	e0812003 	add	r2, r1, r3
21f2a690:	e59b3008 	ldr	r3, [fp, #8]
21f2a694:	e5832008 	str	r2, [r3, #8]
21f2a698:	e59b2008 	ldr	r2, [fp, #8]
21f2a69c:	e51b3030 	ldr	r3, [fp, #-48]
21f2a6a0:	e5823000 	str	r3, [r2]
21f2a6a4:	e59b2004 	ldr	r2, [fp, #4]
21f2a6a8:	e51b3028 	ldr	r3, [fp, #-40]
21f2a6ac:	e5823034 	str	r3, [r2, #52]
	    return Z_DATA_ERROR;
21f2a6b0:	e3e03002 	mvn	r3, #2	; 0x2
21f2a6b4:	e50b3054 	str	r3, [fp, #-84]
21f2a6b8:	ea0000b9 	b	21f2a9a4 <inflate_fast+0x940>
	  }
	} while (1);
	break;
      }
      if ((e & 64) == 0)
21f2a6bc:	e51b303c 	ldr	r3, [fp, #-60]
21f2a6c0:	e1a03323 	mov	r3, r3, lsr #6
21f2a6c4:	e2233001 	eor	r3, r3, #1	; 0x1
21f2a6c8:	e2033001 	and	r3, r3, #1	; 0x1
21f2a6cc:	e20330ff 	and	r3, r3, #255	; 0xff
21f2a6d0:	e3530000 	cmp	r3, #0	; 0x0
21f2a6d4:	0a000027 	beq	21f2a778 <inflate_fast+0x714>
      {
	if ((e = (t = t->next + ((uInt)b & inflate_mask[e]))->exop) == 0)
21f2a6d8:	e51b3040 	ldr	r3, [fp, #-64]
21f2a6dc:	e5931004 	ldr	r1, [r3, #4]
21f2a6e0:	e51b203c 	ldr	r2, [fp, #-60]
21f2a6e4:	e59f32c8 	ldr	r3, [pc, #712]	; 21f2a9b4 <.text+0x2a9b4>
21f2a6e8:	e7932102 	ldr	r2, [r3, r2, lsl #2]
21f2a6ec:	e51b3038 	ldr	r3, [fp, #-56]
21f2a6f0:	e0023003 	and	r3, r2, r3
21f2a6f4:	e1a03183 	mov	r3, r3, lsl #3
21f2a6f8:	e0813003 	add	r3, r1, r3
21f2a6fc:	e50b3040 	str	r3, [fp, #-64]
21f2a700:	e51b3040 	ldr	r3, [fp, #-64]
21f2a704:	e5d33000 	ldrb	r3, [r3]
21f2a708:	e50b303c 	str	r3, [fp, #-60]
21f2a70c:	e51b303c 	ldr	r3, [fp, #-60]
21f2a710:	e3530000 	cmp	r3, #0	; 0x0
21f2a714:	1afffec1 	bne	21f2a220 <inflate_fast+0x1bc>
	{
	  DUMPBITS(t->bits)
21f2a718:	e51b3040 	ldr	r3, [fp, #-64]
21f2a71c:	e5d33001 	ldrb	r3, [r3, #1]
21f2a720:	e1a02003 	mov	r2, r3
21f2a724:	e51b3038 	ldr	r3, [fp, #-56]
21f2a728:	e1a03233 	mov	r3, r3, lsr r2
21f2a72c:	e50b3038 	str	r3, [fp, #-56]
21f2a730:	e51b3040 	ldr	r3, [fp, #-64]
21f2a734:	e5d33001 	ldrb	r3, [r3, #1]
21f2a738:	e1a02003 	mov	r2, r3
21f2a73c:	e51b3034 	ldr	r3, [fp, #-52]
21f2a740:	e0623003 	rsb	r3, r2, r3
21f2a744:	e50b3034 	str	r3, [fp, #-52]
	  Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
		    "inflate:         * literal '%c'\n" :
		    "inflate:         * literal 0x%02x\n", t->base));
	  *q++ = (Byte)t->base;
21f2a748:	e51b3040 	ldr	r3, [fp, #-64]
21f2a74c:	e5933004 	ldr	r3, [r3, #4]
21f2a750:	e20330ff 	and	r3, r3, #255	; 0xff
21f2a754:	e51b2028 	ldr	r2, [fp, #-40]
21f2a758:	e5c23000 	strb	r3, [r2]
21f2a75c:	e51b3028 	ldr	r3, [fp, #-40]
21f2a760:	e2833001 	add	r3, r3, #1	; 0x1
21f2a764:	e50b3028 	str	r3, [fp, #-40]
	  m--;
21f2a768:	e51b3024 	ldr	r3, [fp, #-36]
21f2a76c:	e2433001 	sub	r3, r3, #1	; 0x1
21f2a770:	e50b3024 	str	r3, [fp, #-36]
	  break;
21f2a774:	ea00005a 	b	21f2a8e4 <inflate_fast+0x880>
	}
      }
      else if (e & 32)
21f2a778:	e51b303c 	ldr	r3, [fp, #-60]
21f2a77c:	e1a032a3 	mov	r3, r3, lsr #5
21f2a780:	e2033001 	and	r3, r3, #1	; 0x1
21f2a784:	e20330ff 	and	r3, r3, #255	; 0xff
21f2a788:	e3530000 	cmp	r3, #0	; 0x0
21f2a78c:	0a000028 	beq	21f2a834 <inflate_fast+0x7d0>
      {
	Tracevv((stderr, "inflate:         * end of block\n"));
	UNGRAB
21f2a790:	e51b3034 	ldr	r3, [fp, #-52]
21f2a794:	e1a031a3 	mov	r3, r3, lsr #3
21f2a798:	e50b3018 	str	r3, [fp, #-24]
21f2a79c:	e51b202c 	ldr	r2, [fp, #-44]
21f2a7a0:	e51b3018 	ldr	r3, [fp, #-24]
21f2a7a4:	e0823003 	add	r3, r2, r3
21f2a7a8:	e50b302c 	str	r3, [fp, #-44]
21f2a7ac:	e51b2018 	ldr	r2, [fp, #-24]
21f2a7b0:	e51b3030 	ldr	r3, [fp, #-48]
21f2a7b4:	e0623003 	rsb	r3, r2, r3
21f2a7b8:	e50b3030 	str	r3, [fp, #-48]
21f2a7bc:	e51b3034 	ldr	r3, [fp, #-52]
21f2a7c0:	e2033007 	and	r3, r3, #7	; 0x7
21f2a7c4:	e50b3034 	str	r3, [fp, #-52]
	UPDATE
21f2a7c8:	e59b2004 	ldr	r2, [fp, #4]
21f2a7cc:	e51b3038 	ldr	r3, [fp, #-56]
21f2a7d0:	e5823024 	str	r3, [r2, #36]
21f2a7d4:	e59b2004 	ldr	r2, [fp, #4]
21f2a7d8:	e51b3034 	ldr	r3, [fp, #-52]
21f2a7dc:	e5823020 	str	r3, [r2, #32]
21f2a7e0:	e59b2008 	ldr	r2, [fp, #8]
21f2a7e4:	e51b302c 	ldr	r3, [fp, #-44]
21f2a7e8:	e5823004 	str	r3, [r2, #4]
21f2a7ec:	e59b3008 	ldr	r3, [fp, #8]
21f2a7f0:	e5931008 	ldr	r1, [r3, #8]
21f2a7f4:	e51b2030 	ldr	r2, [fp, #-48]
21f2a7f8:	e59b3008 	ldr	r3, [fp, #8]
21f2a7fc:	e5933000 	ldr	r3, [r3]
21f2a800:	e0633002 	rsb	r3, r3, r2
21f2a804:	e0812003 	add	r2, r1, r3
21f2a808:	e59b3008 	ldr	r3, [fp, #8]
21f2a80c:	e5832008 	str	r2, [r3, #8]
21f2a810:	e59b2008 	ldr	r2, [fp, #8]
21f2a814:	e51b3030 	ldr	r3, [fp, #-48]
21f2a818:	e5823000 	str	r3, [r2]
21f2a81c:	e59b2004 	ldr	r2, [fp, #4]
21f2a820:	e51b3028 	ldr	r3, [fp, #-40]
21f2a824:	e5823034 	str	r3, [r2, #52]
	return Z_STREAM_END;
21f2a828:	e3a03001 	mov	r3, #1	; 0x1
21f2a82c:	e50b3054 	str	r3, [fp, #-84]
21f2a830:	ea00005b 	b	21f2a9a4 <inflate_fast+0x940>
      }
      else
      {
	z->msg = "invalid literal/length code";
21f2a834:	e59b2008 	ldr	r2, [fp, #8]
21f2a838:	e59f317c 	ldr	r3, [pc, #380]	; 21f2a9bc <.text+0x2a9bc>
21f2a83c:	e5823018 	str	r3, [r2, #24]
	UNGRAB
21f2a840:	e51b3034 	ldr	r3, [fp, #-52]
21f2a844:	e1a031a3 	mov	r3, r3, lsr #3
21f2a848:	e50b3018 	str	r3, [fp, #-24]
21f2a84c:	e51b202c 	ldr	r2, [fp, #-44]
21f2a850:	e51b3018 	ldr	r3, [fp, #-24]
21f2a854:	e0823003 	add	r3, r2, r3
21f2a858:	e50b302c 	str	r3, [fp, #-44]
21f2a85c:	e51b2018 	ldr	r2, [fp, #-24]
21f2a860:	e51b3030 	ldr	r3, [fp, #-48]
21f2a864:	e0623003 	rsb	r3, r2, r3
21f2a868:	e50b3030 	str	r3, [fp, #-48]
21f2a86c:	e51b3034 	ldr	r3, [fp, #-52]
21f2a870:	e2033007 	and	r3, r3, #7	; 0x7
21f2a874:	e50b3034 	str	r3, [fp, #-52]
	UPDATE
21f2a878:	e59b2004 	ldr	r2, [fp, #4]
21f2a87c:	e51b3038 	ldr	r3, [fp, #-56]
21f2a880:	e5823024 	str	r3, [r2, #36]
21f2a884:	e59b2004 	ldr	r2, [fp, #4]
21f2a888:	e51b3034 	ldr	r3, [fp, #-52]
21f2a88c:	e5823020 	str	r3, [r2, #32]
21f2a890:	e59b2008 	ldr	r2, [fp, #8]
21f2a894:	e51b302c 	ldr	r3, [fp, #-44]
21f2a898:	e5823004 	str	r3, [r2, #4]
21f2a89c:	e59b3008 	ldr	r3, [fp, #8]
21f2a8a0:	e5931008 	ldr	r1, [r3, #8]
21f2a8a4:	e51b2030 	ldr	r2, [fp, #-48]
21f2a8a8:	e59b3008 	ldr	r3, [fp, #8]
21f2a8ac:	e5933000 	ldr	r3, [r3]
21f2a8b0:	e0633002 	rsb	r3, r3, r2
21f2a8b4:	e0812003 	add	r2, r1, r3
21f2a8b8:	e59b3008 	ldr	r3, [fp, #8]
21f2a8bc:	e5832008 	str	r2, [r3, #8]
21f2a8c0:	e59b2008 	ldr	r2, [fp, #8]
21f2a8c4:	e51b3030 	ldr	r3, [fp, #-48]
21f2a8c8:	e5823000 	str	r3, [r2]
21f2a8cc:	e59b2004 	ldr	r2, [fp, #4]
21f2a8d0:	e51b3028 	ldr	r3, [fp, #-40]
21f2a8d4:	e5823034 	str	r3, [r2, #52]
	return Z_DATA_ERROR;
21f2a8d8:	e3e03002 	mvn	r3, #2	; 0x2
21f2a8dc:	e50b3054 	str	r3, [fp, #-84]
21f2a8e0:	ea00002f 	b	21f2a9a4 <inflate_fast+0x940>
      }
    } while (1);
  } while (m >= 258 && n >= 10);
21f2a8e4:	e51b2024 	ldr	r2, [fp, #-36]
21f2a8e8:	e3a03c01 	mov	r3, #256	; 0x100
21f2a8ec:	e2833001 	add	r3, r3, #1	; 0x1
21f2a8f0:	e1520003 	cmp	r2, r3
21f2a8f4:	9a000002 	bls	21f2a904 <inflate_fast+0x8a0>
21f2a8f8:	e51b302c 	ldr	r3, [fp, #-44]
21f2a8fc:	e3530009 	cmp	r3, #9	; 0x9
21f2a900:	8afffe1d 	bhi	21f2a17c <inflate_fast+0x118>

  /* not enough input or output--restore pointers and return */
  UNGRAB
21f2a904:	e51b3034 	ldr	r3, [fp, #-52]
21f2a908:	e1a031a3 	mov	r3, r3, lsr #3
21f2a90c:	e50b3018 	str	r3, [fp, #-24]
21f2a910:	e51b202c 	ldr	r2, [fp, #-44]
21f2a914:	e51b3018 	ldr	r3, [fp, #-24]
21f2a918:	e0823003 	add	r3, r2, r3
21f2a91c:	e50b302c 	str	r3, [fp, #-44]
21f2a920:	e51b2018 	ldr	r2, [fp, #-24]
21f2a924:	e51b3030 	ldr	r3, [fp, #-48]
21f2a928:	e0623003 	rsb	r3, r2, r3
21f2a92c:	e50b3030 	str	r3, [fp, #-48]
21f2a930:	e51b3034 	ldr	r3, [fp, #-52]
21f2a934:	e2033007 	and	r3, r3, #7	; 0x7
21f2a938:	e50b3034 	str	r3, [fp, #-52]
  UPDATE
21f2a93c:	e59b2004 	ldr	r2, [fp, #4]
21f2a940:	e51b3038 	ldr	r3, [fp, #-56]
21f2a944:	e5823024 	str	r3, [r2, #36]
21f2a948:	e59b2004 	ldr	r2, [fp, #4]
21f2a94c:	e51b3034 	ldr	r3, [fp, #-52]
21f2a950:	e5823020 	str	r3, [r2, #32]
21f2a954:	e59b2008 	ldr	r2, [fp, #8]
21f2a958:	e51b302c 	ldr	r3, [fp, #-44]
21f2a95c:	e5823004 	str	r3, [r2, #4]
21f2a960:	e59b3008 	ldr	r3, [fp, #8]
21f2a964:	e5931008 	ldr	r1, [r3, #8]
21f2a968:	e51b2030 	ldr	r2, [fp, #-48]
21f2a96c:	e59b3008 	ldr	r3, [fp, #8]
21f2a970:	e5933000 	ldr	r3, [r3]
21f2a974:	e0633002 	rsb	r3, r3, r2
21f2a978:	e0812003 	add	r2, r1, r3
21f2a97c:	e59b3008 	ldr	r3, [fp, #8]
21f2a980:	e5832008 	str	r2, [r3, #8]
21f2a984:	e59b2008 	ldr	r2, [fp, #8]
21f2a988:	e51b3030 	ldr	r3, [fp, #-48]
21f2a98c:	e5823000 	str	r3, [r2]
21f2a990:	e59b2004 	ldr	r2, [fp, #4]
21f2a994:	e51b3028 	ldr	r3, [fp, #-40]
21f2a998:	e5823034 	str	r3, [r2, #52]
  return Z_OK;
21f2a99c:	e3a03000 	mov	r3, #0	; 0x0
21f2a9a0:	e50b3054 	str	r3, [fp, #-84]
21f2a9a4:	e51b3054 	ldr	r3, [fp, #-84]
}
21f2a9a8:	e1a00003 	mov	r0, r3
21f2a9ac:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2a9b0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2a9b4:	21f339d4 	ldrcssb	r3, [r3, #148]!
21f2a9b8:	21f32e6c 	mvncss	r2, ip, ror #28
21f2a9bc:	21f32e50 	mvncss	r2, r0, asr lr

21f2a9c0 <adler32>:


/*+++++*/
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */

char *zlib_version = ZLIB_VERSION;

char *z_errmsg[] = {
"stream end",          /* Z_STREAM_END    1 */
"",                    /* Z_OK            0 */
"file error",          /* Z_ERRNO        (-1) */
"stream error",        /* Z_STREAM_ERROR (-2) */
"data error",          /* Z_DATA_ERROR   (-3) */
"insufficient memory", /* Z_MEM_ERROR    (-4) */
"buffer error",        /* Z_BUF_ERROR    (-5) */
""};


/*+++++*/
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* From: adler32.c,v 1.6 1995/05/03 17:27:08 jloup Exp */

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf)  {s1 += *buf++; s2 += s1;}
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);
#define DO16(buf) DO8(buf); DO8(buf);

/* ========================================================================= */
uLong adler32(adler, buf, len)
    uLong adler;
    Bytef *buf;
    uInt len;
{
21f2a9c0:	e1a0c00d 	mov	ip, sp
21f2a9c4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2a9c8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2a9cc:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f2a9d0:	e50b001c 	str	r0, [fp, #-28]
21f2a9d4:	e50b1020 	str	r1, [fp, #-32]
21f2a9d8:	e50b2024 	str	r2, [fp, #-36]
    unsigned long s1 = adler & 0xffff;
21f2a9dc:	e51b301c 	ldr	r3, [fp, #-28]
21f2a9e0:	e1a03803 	mov	r3, r3, lsl #16
21f2a9e4:	e1a03823 	mov	r3, r3, lsr #16
21f2a9e8:	e50b3018 	str	r3, [fp, #-24]
    unsigned long s2 = (adler >> 16) & 0xffff;
21f2a9ec:	e51b301c 	ldr	r3, [fp, #-28]
21f2a9f0:	e1a03823 	mov	r3, r3, lsr #16
21f2a9f4:	e1a03803 	mov	r3, r3, lsl #16
21f2a9f8:	e1a03823 	mov	r3, r3, lsr #16
21f2a9fc:	e50b3014 	str	r3, [fp, #-20]
    int k;

    if (buf == Z_NULL) return 1L;
21f2aa00:	e51b3020 	ldr	r3, [fp, #-32]
21f2aa04:	e3530000 	cmp	r3, #0	; 0x0
21f2aa08:	1a000113 	bne	21f2ae5c <adler32+0x49c>
21f2aa0c:	e3a02001 	mov	r2, #1	; 0x1
21f2aa10:	e50b2028 	str	r2, [fp, #-40]
21f2aa14:	ea000118 	b	21f2ae7c <adler32+0x4bc>

    while (len > 0) {
	k = len < NMAX ? len : NMAX;
21f2aa18:	e51b2024 	ldr	r2, [fp, #-36]
21f2aa1c:	e3a03d56 	mov	r3, #5504	; 0x1580
21f2aa20:	e2833030 	add	r3, r3, #48	; 0x30
21f2aa24:	e1520003 	cmp	r2, r3
21f2aa28:	31a03002 	movcc	r3, r2
21f2aa2c:	e50b3010 	str	r3, [fp, #-16]
	len -= k;
21f2aa30:	e51b2010 	ldr	r2, [fp, #-16]
21f2aa34:	e51b3024 	ldr	r3, [fp, #-36]
21f2aa38:	e0623003 	rsb	r3, r2, r3
21f2aa3c:	e50b3024 	str	r3, [fp, #-36]
	while (k >= 16) {
21f2aa40:	ea0000d2 	b	21f2ad90 <adler32+0x3d0>
	    DO16(buf);
21f2aa44:	e51b3020 	ldr	r3, [fp, #-32]
21f2aa48:	e5d33000 	ldrb	r3, [r3]
21f2aa4c:	e1a02003 	mov	r2, r3
21f2aa50:	e51b3018 	ldr	r3, [fp, #-24]
21f2aa54:	e0833002 	add	r3, r3, r2
21f2aa58:	e50b3018 	str	r3, [fp, #-24]
21f2aa5c:	e51b3020 	ldr	r3, [fp, #-32]
21f2aa60:	e2833001 	add	r3, r3, #1	; 0x1
21f2aa64:	e50b3020 	str	r3, [fp, #-32]
21f2aa68:	e51b2014 	ldr	r2, [fp, #-20]
21f2aa6c:	e51b3018 	ldr	r3, [fp, #-24]
21f2aa70:	e0823003 	add	r3, r2, r3
21f2aa74:	e50b3014 	str	r3, [fp, #-20]
21f2aa78:	e51b3020 	ldr	r3, [fp, #-32]
21f2aa7c:	e5d33000 	ldrb	r3, [r3]
21f2aa80:	e1a02003 	mov	r2, r3
21f2aa84:	e51b3018 	ldr	r3, [fp, #-24]
21f2aa88:	e0833002 	add	r3, r3, r2
21f2aa8c:	e50b3018 	str	r3, [fp, #-24]
21f2aa90:	e51b3020 	ldr	r3, [fp, #-32]
21f2aa94:	e2833001 	add	r3, r3, #1	; 0x1
21f2aa98:	e50b3020 	str	r3, [fp, #-32]
21f2aa9c:	e51b2014 	ldr	r2, [fp, #-20]
21f2aaa0:	e51b3018 	ldr	r3, [fp, #-24]
21f2aaa4:	e0823003 	add	r3, r2, r3
21f2aaa8:	e50b3014 	str	r3, [fp, #-20]
21f2aaac:	e51b3020 	ldr	r3, [fp, #-32]
21f2aab0:	e5d33000 	ldrb	r3, [r3]
21f2aab4:	e1a02003 	mov	r2, r3
21f2aab8:	e51b3018 	ldr	r3, [fp, #-24]
21f2aabc:	e0833002 	add	r3, r3, r2
21f2aac0:	e50b3018 	str	r3, [fp, #-24]
21f2aac4:	e51b3020 	ldr	r3, [fp, #-32]
21f2aac8:	e2833001 	add	r3, r3, #1	; 0x1
21f2aacc:	e50b3020 	str	r3, [fp, #-32]
21f2aad0:	e51b2014 	ldr	r2, [fp, #-20]
21f2aad4:	e51b3018 	ldr	r3, [fp, #-24]
21f2aad8:	e0823003 	add	r3, r2, r3
21f2aadc:	e50b3014 	str	r3, [fp, #-20]
21f2aae0:	e51b3020 	ldr	r3, [fp, #-32]
21f2aae4:	e5d33000 	ldrb	r3, [r3]
21f2aae8:	e1a02003 	mov	r2, r3
21f2aaec:	e51b3018 	ldr	r3, [fp, #-24]
21f2aaf0:	e0833002 	add	r3, r3, r2
21f2aaf4:	e50b3018 	str	r3, [fp, #-24]
21f2aaf8:	e51b3020 	ldr	r3, [fp, #-32]
21f2aafc:	e2833001 	add	r3, r3, #1	; 0x1
21f2ab00:	e50b3020 	str	r3, [fp, #-32]
21f2ab04:	e51b2014 	ldr	r2, [fp, #-20]
21f2ab08:	e51b3018 	ldr	r3, [fp, #-24]
21f2ab0c:	e0823003 	add	r3, r2, r3
21f2ab10:	e50b3014 	str	r3, [fp, #-20]
21f2ab14:	e51b3020 	ldr	r3, [fp, #-32]
21f2ab18:	e5d33000 	ldrb	r3, [r3]
21f2ab1c:	e1a02003 	mov	r2, r3
21f2ab20:	e51b3018 	ldr	r3, [fp, #-24]
21f2ab24:	e0833002 	add	r3, r3, r2
21f2ab28:	e50b3018 	str	r3, [fp, #-24]
21f2ab2c:	e51b3020 	ldr	r3, [fp, #-32]
21f2ab30:	e2833001 	add	r3, r3, #1	; 0x1
21f2ab34:	e50b3020 	str	r3, [fp, #-32]
21f2ab38:	e51b2014 	ldr	r2, [fp, #-20]
21f2ab3c:	e51b3018 	ldr	r3, [fp, #-24]
21f2ab40:	e0823003 	add	r3, r2, r3
21f2ab44:	e50b3014 	str	r3, [fp, #-20]
21f2ab48:	e51b3020 	ldr	r3, [fp, #-32]
21f2ab4c:	e5d33000 	ldrb	r3, [r3]
21f2ab50:	e1a02003 	mov	r2, r3
21f2ab54:	e51b3018 	ldr	r3, [fp, #-24]
21f2ab58:	e0833002 	add	r3, r3, r2
21f2ab5c:	e50b3018 	str	r3, [fp, #-24]
21f2ab60:	e51b3020 	ldr	r3, [fp, #-32]
21f2ab64:	e2833001 	add	r3, r3, #1	; 0x1
21f2ab68:	e50b3020 	str	r3, [fp, #-32]
21f2ab6c:	e51b2014 	ldr	r2, [fp, #-20]
21f2ab70:	e51b3018 	ldr	r3, [fp, #-24]
21f2ab74:	e0823003 	add	r3, r2, r3
21f2ab78:	e50b3014 	str	r3, [fp, #-20]
21f2ab7c:	e51b3020 	ldr	r3, [fp, #-32]
21f2ab80:	e5d33000 	ldrb	r3, [r3]
21f2ab84:	e1a02003 	mov	r2, r3
21f2ab88:	e51b3018 	ldr	r3, [fp, #-24]
21f2ab8c:	e0833002 	add	r3, r3, r2
21f2ab90:	e50b3018 	str	r3, [fp, #-24]
21f2ab94:	e51b3020 	ldr	r3, [fp, #-32]
21f2ab98:	e2833001 	add	r3, r3, #1	; 0x1
21f2ab9c:	e50b3020 	str	r3, [fp, #-32]
21f2aba0:	e51b2014 	ldr	r2, [fp, #-20]
21f2aba4:	e51b3018 	ldr	r3, [fp, #-24]
21f2aba8:	e0823003 	add	r3, r2, r3
21f2abac:	e50b3014 	str	r3, [fp, #-20]
21f2abb0:	e51b3020 	ldr	r3, [fp, #-32]
21f2abb4:	e5d33000 	ldrb	r3, [r3]
21f2abb8:	e1a02003 	mov	r2, r3
21f2abbc:	e51b3018 	ldr	r3, [fp, #-24]
21f2abc0:	e0833002 	add	r3, r3, r2
21f2abc4:	e50b3018 	str	r3, [fp, #-24]
21f2abc8:	e51b3020 	ldr	r3, [fp, #-32]
21f2abcc:	e2833001 	add	r3, r3, #1	; 0x1
21f2abd0:	e50b3020 	str	r3, [fp, #-32]
21f2abd4:	e51b2014 	ldr	r2, [fp, #-20]
21f2abd8:	e51b3018 	ldr	r3, [fp, #-24]
21f2abdc:	e0823003 	add	r3, r2, r3
21f2abe0:	e50b3014 	str	r3, [fp, #-20]
21f2abe4:	e51b3020 	ldr	r3, [fp, #-32]
21f2abe8:	e5d33000 	ldrb	r3, [r3]
21f2abec:	e1a02003 	mov	r2, r3
21f2abf0:	e51b3018 	ldr	r3, [fp, #-24]
21f2abf4:	e0833002 	add	r3, r3, r2
21f2abf8:	e50b3018 	str	r3, [fp, #-24]
21f2abfc:	e51b3020 	ldr	r3, [fp, #-32]
21f2ac00:	e2833001 	add	r3, r3, #1	; 0x1
21f2ac04:	e50b3020 	str	r3, [fp, #-32]
21f2ac08:	e51b2014 	ldr	r2, [fp, #-20]
21f2ac0c:	e51b3018 	ldr	r3, [fp, #-24]
21f2ac10:	e0823003 	add	r3, r2, r3
21f2ac14:	e50b3014 	str	r3, [fp, #-20]
21f2ac18:	e51b3020 	ldr	r3, [fp, #-32]
21f2ac1c:	e5d33000 	ldrb	r3, [r3]
21f2ac20:	e1a02003 	mov	r2, r3
21f2ac24:	e51b3018 	ldr	r3, [fp, #-24]
21f2ac28:	e0833002 	add	r3, r3, r2
21f2ac2c:	e50b3018 	str	r3, [fp, #-24]
21f2ac30:	e51b3020 	ldr	r3, [fp, #-32]
21f2ac34:	e2833001 	add	r3, r3, #1	; 0x1
21f2ac38:	e50b3020 	str	r3, [fp, #-32]
21f2ac3c:	e51b2014 	ldr	r2, [fp, #-20]
21f2ac40:	e51b3018 	ldr	r3, [fp, #-24]
21f2ac44:	e0823003 	add	r3, r2, r3
21f2ac48:	e50b3014 	str	r3, [fp, #-20]
21f2ac4c:	e51b3020 	ldr	r3, [fp, #-32]
21f2ac50:	e5d33000 	ldrb	r3, [r3]
21f2ac54:	e1a02003 	mov	r2, r3
21f2ac58:	e51b3018 	ldr	r3, [fp, #-24]
21f2ac5c:	e0833002 	add	r3, r3, r2
21f2ac60:	e50b3018 	str	r3, [fp, #-24]
21f2ac64:	e51b3020 	ldr	r3, [fp, #-32]
21f2ac68:	e2833001 	add	r3, r3, #1	; 0x1
21f2ac6c:	e50b3020 	str	r3, [fp, #-32]
21f2ac70:	e51b2014 	ldr	r2, [fp, #-20]
21f2ac74:	e51b3018 	ldr	r3, [fp, #-24]
21f2ac78:	e0823003 	add	r3, r2, r3
21f2ac7c:	e50b3014 	str	r3, [fp, #-20]
21f2ac80:	e51b3020 	ldr	r3, [fp, #-32]
21f2ac84:	e5d33000 	ldrb	r3, [r3]
21f2ac88:	e1a02003 	mov	r2, r3
21f2ac8c:	e51b3018 	ldr	r3, [fp, #-24]
21f2ac90:	e0833002 	add	r3, r3, r2
21f2ac94:	e50b3018 	str	r3, [fp, #-24]
21f2ac98:	e51b3020 	ldr	r3, [fp, #-32]
21f2ac9c:	e2833001 	add	r3, r3, #1	; 0x1
21f2aca0:	e50b3020 	str	r3, [fp, #-32]
21f2aca4:	e51b2014 	ldr	r2, [fp, #-20]
21f2aca8:	e51b3018 	ldr	r3, [fp, #-24]
21f2acac:	e0823003 	add	r3, r2, r3
21f2acb0:	e50b3014 	str	r3, [fp, #-20]
21f2acb4:	e51b3020 	ldr	r3, [fp, #-32]
21f2acb8:	e5d33000 	ldrb	r3, [r3]
21f2acbc:	e1a02003 	mov	r2, r3
21f2acc0:	e51b3018 	ldr	r3, [fp, #-24]
21f2acc4:	e0833002 	add	r3, r3, r2
21f2acc8:	e50b3018 	str	r3, [fp, #-24]
21f2accc:	e51b3020 	ldr	r3, [fp, #-32]
21f2acd0:	e2833001 	add	r3, r3, #1	; 0x1
21f2acd4:	e50b3020 	str	r3, [fp, #-32]
21f2acd8:	e51b2014 	ldr	r2, [fp, #-20]
21f2acdc:	e51b3018 	ldr	r3, [fp, #-24]
21f2ace0:	e0823003 	add	r3, r2, r3
21f2ace4:	e50b3014 	str	r3, [fp, #-20]
21f2ace8:	e51b3020 	ldr	r3, [fp, #-32]
21f2acec:	e5d33000 	ldrb	r3, [r3]
21f2acf0:	e1a02003 	mov	r2, r3
21f2acf4:	e51b3018 	ldr	r3, [fp, #-24]
21f2acf8:	e0833002 	add	r3, r3, r2
21f2acfc:	e50b3018 	str	r3, [fp, #-24]
21f2ad00:	e51b3020 	ldr	r3, [fp, #-32]
21f2ad04:	e2833001 	add	r3, r3, #1	; 0x1
21f2ad08:	e50b3020 	str	r3, [fp, #-32]
21f2ad0c:	e51b2014 	ldr	r2, [fp, #-20]
21f2ad10:	e51b3018 	ldr	r3, [fp, #-24]
21f2ad14:	e0823003 	add	r3, r2, r3
21f2ad18:	e50b3014 	str	r3, [fp, #-20]
21f2ad1c:	e51b3020 	ldr	r3, [fp, #-32]
21f2ad20:	e5d33000 	ldrb	r3, [r3]
21f2ad24:	e1a02003 	mov	r2, r3
21f2ad28:	e51b3018 	ldr	r3, [fp, #-24]
21f2ad2c:	e0833002 	add	r3, r3, r2
21f2ad30:	e50b3018 	str	r3, [fp, #-24]
21f2ad34:	e51b3020 	ldr	r3, [fp, #-32]
21f2ad38:	e2833001 	add	r3, r3, #1	; 0x1
21f2ad3c:	e50b3020 	str	r3, [fp, #-32]
21f2ad40:	e51b2014 	ldr	r2, [fp, #-20]
21f2ad44:	e51b3018 	ldr	r3, [fp, #-24]
21f2ad48:	e0823003 	add	r3, r2, r3
21f2ad4c:	e50b3014 	str	r3, [fp, #-20]
21f2ad50:	e51b3020 	ldr	r3, [fp, #-32]
21f2ad54:	e5d33000 	ldrb	r3, [r3]
21f2ad58:	e1a02003 	mov	r2, r3
21f2ad5c:	e51b3018 	ldr	r3, [fp, #-24]
21f2ad60:	e0833002 	add	r3, r3, r2
21f2ad64:	e50b3018 	str	r3, [fp, #-24]
21f2ad68:	e51b3020 	ldr	r3, [fp, #-32]
21f2ad6c:	e2833001 	add	r3, r3, #1	; 0x1
21f2ad70:	e50b3020 	str	r3, [fp, #-32]
21f2ad74:	e51b2014 	ldr	r2, [fp, #-20]
21f2ad78:	e51b3018 	ldr	r3, [fp, #-24]
21f2ad7c:	e0823003 	add	r3, r2, r3
21f2ad80:	e50b3014 	str	r3, [fp, #-20]
	    k -= 16;
21f2ad84:	e51b3010 	ldr	r3, [fp, #-16]
21f2ad88:	e2433010 	sub	r3, r3, #16	; 0x10
21f2ad8c:	e50b3010 	str	r3, [fp, #-16]
21f2ad90:	e51b3010 	ldr	r3, [fp, #-16]
21f2ad94:	e353000f 	cmp	r3, #15	; 0xf
21f2ad98:	caffff29 	bgt	21f2aa44 <adler32+0x84>
	}
	if (k != 0) do {
21f2ad9c:	e51b3010 	ldr	r3, [fp, #-16]
21f2ada0:	e3530000 	cmp	r3, #0	; 0x0
21f2ada4:	0a000012 	beq	21f2adf4 <adler32+0x434>
	    DO1(buf);
21f2ada8:	e51b3020 	ldr	r3, [fp, #-32]
21f2adac:	e5d33000 	ldrb	r3, [r3]
21f2adb0:	e1a02003 	mov	r2, r3
21f2adb4:	e51b3018 	ldr	r3, [fp, #-24]
21f2adb8:	e0833002 	add	r3, r3, r2
21f2adbc:	e50b3018 	str	r3, [fp, #-24]
21f2adc0:	e51b3020 	ldr	r3, [fp, #-32]
21f2adc4:	e2833001 	add	r3, r3, #1	; 0x1
21f2adc8:	e50b3020 	str	r3, [fp, #-32]
21f2adcc:	e51b2014 	ldr	r2, [fp, #-20]
21f2add0:	e51b3018 	ldr	r3, [fp, #-24]
21f2add4:	e0823003 	add	r3, r2, r3
21f2add8:	e50b3014 	str	r3, [fp, #-20]
	} while (--k);
21f2addc:	e51b3010 	ldr	r3, [fp, #-16]
21f2ade0:	e2433001 	sub	r3, r3, #1	; 0x1
21f2ade4:	e50b3010 	str	r3, [fp, #-16]
21f2ade8:	e51b3010 	ldr	r3, [fp, #-16]
21f2adec:	e3530000 	cmp	r3, #0	; 0x0
21f2adf0:	1affffec 	bne	21f2ada8 <adler32+0x3e8>
	s1 %= BASE;
21f2adf4:	e51b1018 	ldr	r1, [fp, #-24]
21f2adf8:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2adfc:	e283391e 	add	r3, r3, #491520	; 0x78000
21f2ae00:	e2833071 	add	r3, r3, #113	; 0x71
21f2ae04:	e0832391 	umull	r2, r3, r1, r3
21f2ae08:	e1a027a3 	mov	r2, r3, lsr #15
21f2ae0c:	e1a03002 	mov	r3, r2
21f2ae10:	e1a03603 	mov	r3, r3, lsl #12
21f2ae14:	e0623003 	rsb	r3, r2, r3
21f2ae18:	e1a03203 	mov	r3, r3, lsl #4
21f2ae1c:	e0833002 	add	r3, r3, r2
21f2ae20:	e0633001 	rsb	r3, r3, r1
21f2ae24:	e50b3018 	str	r3, [fp, #-24]
	s2 %= BASE;
21f2ae28:	e51b1014 	ldr	r1, [fp, #-20]
21f2ae2c:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2ae30:	e283391e 	add	r3, r3, #491520	; 0x78000
21f2ae34:	e2833071 	add	r3, r3, #113	; 0x71
21f2ae38:	e0832391 	umull	r2, r3, r1, r3
21f2ae3c:	e1a027a3 	mov	r2, r3, lsr #15
21f2ae40:	e1a03002 	mov	r3, r2
21f2ae44:	e1a03603 	mov	r3, r3, lsl #12
21f2ae48:	e0623003 	rsb	r3, r2, r3
21f2ae4c:	e1a03203 	mov	r3, r3, lsl #4
21f2ae50:	e0833002 	add	r3, r3, r2
21f2ae54:	e0633001 	rsb	r3, r3, r1
21f2ae58:	e50b3014 	str	r3, [fp, #-20]
21f2ae5c:	e51b3024 	ldr	r3, [fp, #-36]
21f2ae60:	e3530000 	cmp	r3, #0	; 0x0
21f2ae64:	1afffeeb 	bne	21f2aa18 <adler32+0x58>
    }
    return (s2 << 16) | s1;
21f2ae68:	e51b3014 	ldr	r3, [fp, #-20]
21f2ae6c:	e1a02803 	mov	r2, r3, lsl #16
21f2ae70:	e51b3018 	ldr	r3, [fp, #-24]
21f2ae74:	e1822003 	orr	r2, r2, r3
21f2ae78:	e50b2028 	str	r2, [fp, #-40]
21f2ae7c:	e51b3028 	ldr	r3, [fp, #-40]
}
21f2ae80:	e1a00003 	mov	r0, r3
21f2ae84:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2ae88:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2ae8c <board_init>:
 * Miscelaneous platform dependent initialisations
 */

int board_init (void)
{
21f2ae8c:	e1a0c00d 	mov	ip, sp
21f2ae90:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2ae94:	e24cb004 	sub	fp, ip, #4	; 0x4
	/* Enable Ctrlc */
	console_init_f ();
21f2ae98:	ebffc3ba 	bl	21f1bd88 <console_init_f>

	/* Correct IRDA resistor problem */
	/* Set PA23_TXD in Output */
	((AT91PS_PIO) AT91C_BASE_PIOA)->PIO_OER = AT91C_PA23_TXD2;
21f2ae9c:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
21f2aea0:	e1a039c3 	mov	r3, r3, asr #19
21f2aea4:	e3a02502 	mov	r2, #8388608	; 0x800000
21f2aea8:	e5832010 	str	r2, [r3, #16]

	/* memory and cpu-speed are setup before relocation */
	/* so we do _nothing_ here */

	/* arch number of AT91RM9200DK-Board */
	gd->bd->bi_arch_number = MACH_TYPE_AT91RM9200;
21f2aeac:	e1a03008 	mov	r3, r8
21f2aeb0:	e5932000 	ldr	r2, [r3]
21f2aeb4:	e3a030fb 	mov	r3, #251	; 0xfb
21f2aeb8:	e5823014 	str	r3, [r2, #20]
	/* adress of boot parameters */
	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
21f2aebc:	e1a03008 	mov	r3, r8
21f2aec0:	e5932000 	ldr	r2, [r3]
21f2aec4:	e3a03202 	mov	r3, #536870912	; 0x20000000
21f2aec8:	e2833c01 	add	r3, r3, #256	; 0x100
21f2aecc:	e5823018 	str	r3, [r2, #24]

	return 0;
21f2aed0:	e3a03000 	mov	r3, #0	; 0x0
}
21f2aed4:	e1a00003 	mov	r0, r3
21f2aed8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2aedc <dram_init>:

int dram_init (void)
{
21f2aedc:	e1a0c00d 	mov	ip, sp
21f2aee0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2aee4:	e24cb004 	sub	fp, ip, #4	; 0x4
	gd->bd->bi_dram[0].start = PHYS_SDRAM;
21f2aee8:	e1a03008 	mov	r3, r8
21f2aeec:	e5932000 	ldr	r2, [r3]
21f2aef0:	e3a03202 	mov	r3, #536870912	; 0x20000000
21f2aef4:	e582301c 	str	r3, [r2, #28]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_SIZE;
21f2aef8:	e1a03008 	mov	r3, r8
21f2aefc:	e5932000 	ldr	r2, [r3]
21f2af00:	e3a03402 	mov	r3, #33554432	; 0x2000000
21f2af04:	e5823020 	str	r3, [r2, #32]
	return 0;
21f2af08:	e3a03000 	mov	r3, #0	; 0x0
}
21f2af0c:	e1a00003 	mov	r0, r3
21f2af10:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2af14 <at91rm9200_GetPhyInterface>:

#ifdef CONFIG_DRIVER_ETHER
#if (CONFIG_COMMANDS & CFG_CMD_NET)

/*
 * Name:
 *	at91rm9200_GetPhyInterface
 * Description:
 *	Initialise the interface functions to the PHY
 * Arguments:
 *	None
 * Return value:
 *	None
 */
void at91rm9200_GetPhyInterface(AT91PS_PhyOps p_phyops)
{
21f2af14:	e1a0c00d 	mov	ip, sp
21f2af18:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2af1c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2af20:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2af24:	e50b0010 	str	r0, [fp, #-16]
	p_phyops->Init = dm9161_InitPhy;
21f2af28:	e51b2010 	ldr	r2, [fp, #-16]
21f2af2c:	e59f3028 	ldr	r3, [pc, #40]	; 21f2af5c <.text+0x2af5c>
21f2af30:	e5823000 	str	r3, [r2]
	p_phyops->IsPhyConnected = dm9161_IsPhyConnected;
21f2af34:	e51b2010 	ldr	r2, [fp, #-16]
21f2af38:	e59f3020 	ldr	r3, [pc, #32]	; 21f2af60 <.text+0x2af60>
21f2af3c:	e5823004 	str	r3, [r2, #4]
	p_phyops->GetLinkSpeed = dm9161_GetLinkSpeed;
21f2af40:	e51b2010 	ldr	r2, [fp, #-16]
21f2af44:	e59f3018 	ldr	r3, [pc, #24]	; 21f2af64 <.text+0x2af64>
21f2af48:	e5823008 	str	r3, [r2, #8]
	p_phyops->AutoNegotiate = dm9161_AutoNegotiate;
21f2af4c:	e51b2010 	ldr	r2, [fp, #-16]
21f2af50:	e59f3010 	ldr	r3, [pc, #16]	; 21f2af68 <.text+0x2af68>
21f2af54:	e582300c 	str	r3, [r2, #12]
}
21f2af58:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f2af5c:	21f2d8c4 	mvncss	sp, r4, asr #17
21f2af60:	21f2d640 	mvncss	sp, r0, asr #12
21f2af64:	21f2d6dc 	ldrcssb	sp, [r2, #108]!
21f2af68:	21f2d960 	mvncss	sp, r0, ror #18

21f2af6c <AT91F_SpiInit>:
#define AT91C_TIMEOUT_WRDY			200000
#define AT91C_SPI_PCS0_SERIAL_DATAFLASH		0xE     /* Chip Select 0 : NPCS0 %1110 */
#define AT91C_SPI_PCS3_DATAFLASH_CARD		0x7     /* Chip Select 3 : NPCS3 %0111 */

void AT91F_SpiInit(void) {
21f2af6c:	e1a0c00d 	mov	ip, sp
21f2af70:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2af74:	e24cb004 	sub	fp, ip, #4	; 0x4

/*-------------------------------------------------------------------*/
/*	SPI DataFlash Init								*/
/*-------------------------------------------------------------------*/
	/* Configure PIOs */
	AT91C_BASE_PIOA->PIO_ASR = AT91C_PA3_NPCS0 | AT91C_PA4_NPCS1 | AT91C_PA1_MOSI | AT91C_PA5_NPCS2 |
21f2af78:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
21f2af7c:	e1a039c3 	mov	r3, r3, asr #19
21f2af80:	e3a0207f 	mov	r2, #127	; 0x7f
21f2af84:	e5832070 	str	r2, [r3, #112]
				   AT91C_PA6_NPCS3 | AT91C_PA0_MISO | AT91C_PA2_SPCK;
	AT91C_BASE_PIOA->PIO_PDR = AT91C_PA3_NPCS0 | AT91C_PA4_NPCS1 | AT91C_PA1_MOSI | AT91C_PA5_NPCS2 |
21f2af88:	e3a0320a 	mov	r3, #-1610612736	; 0xa0000000
21f2af8c:	e1a039c3 	mov	r3, r3, asr #19
21f2af90:	e3a0207f 	mov	r2, #127	; 0x7f
21f2af94:	e5832004 	str	r2, [r3, #4]
				   AT91C_PA6_NPCS3 | AT91C_PA0_MISO | AT91C_PA2_SPCK;
	/* Enable CLock */
	AT91C_BASE_PMC->PMC_PCER = 1 << AT91C_ID_SPI;
21f2af98:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2af9c:	e1a03ac3 	mov	r3, r3, asr #21
21f2afa0:	e3a02a02 	mov	r2, #8192	; 0x2000
21f2afa4:	e5832010 	str	r2, [r3, #16]

	/* Reset the SPI */
	AT91C_BASE_SPI->SPI_CR = AT91C_SPI_SWRST;
21f2afa8:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2afac:	e1a03743 	mov	r3, r3, asr #14
21f2afb0:	e3a02080 	mov	r2, #128	; 0x80
21f2afb4:	e5832000 	str	r2, [r3]

	/* Configure SPI in Master Mode with No CS selected !!! */
	AT91C_BASE_SPI->SPI_MR = AT91C_SPI_MSTR | AT91C_SPI_MODFDIS | AT91C_SPI_PCS;
21f2afb8:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2afbc:	e1a02742 	mov	r2, r2, asr #14
21f2afc0:	e3a0380f 	mov	r3, #983040	; 0xf0000
21f2afc4:	e2833011 	add	r3, r3, #17	; 0x11
21f2afc8:	e5823004 	str	r3, [r2, #4]

	/* Configure CS0 and CS3 */
	*(AT91C_SPI_CSR + 0) = AT91C_SPI_CPOL | (AT91C_SPI_DLYBS & DATAFLASH_TCSS) | (AT91C_SPI_DLYBCT &
21f2afcc:	e3e02b7f 	mvn	r2, #130048	; 0x1fc00
21f2afd0:	e2422ff3 	sub	r2, r2, #972	; 0x3cc
21f2afd4:	e2422003 	sub	r2, r2, #3	; 0x3
21f2afd8:	e3a03743 	mov	r3, #17563648	; 0x10c0000
21f2afdc:	e2833c02 	add	r3, r3, #512	; 0x200
21f2afe0:	e2833001 	add	r3, r3, #1	; 0x1
21f2afe4:	e5823000 	str	r3, [r2]
	DATAFLASH_TCHS) | ((AT91C_MASTER_CLOCK / (2*AT91C_SPI_CLK)) << 8);

	*(AT91C_SPI_CSR + 3) = AT91C_SPI_CPOL | (AT91C_SPI_DLYBS & DATAFLASH_TCSS) | (AT91C_SPI_DLYBCT &
21f2afe8:	e3e02b7f 	mvn	r2, #130048	; 0x1fc00
21f2afec:	e2422d0f 	sub	r2, r2, #960	; 0x3c0
21f2aff0:	e2422003 	sub	r2, r2, #3	; 0x3
21f2aff4:	e3a03743 	mov	r3, #17563648	; 0x10c0000
21f2aff8:	e2833c02 	add	r3, r3, #512	; 0x200
21f2affc:	e2833001 	add	r3, r3, #1	; 0x1
21f2b000:	e5823000 	str	r3, [r2]
	DATAFLASH_TCHS) | ((AT91C_MASTER_CLOCK / (2*AT91C_SPI_CLK)) << 8);

}
21f2b004:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2b008 <AT91F_SpiEnable>:

void AT91F_SpiEnable(int cs) {
21f2b008:	e1a0c00d 	mov	ip, sp
21f2b00c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b010:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b014:	e24dd008 	sub	sp, sp, #8	; 0x8
21f2b018:	e50b0010 	str	r0, [fp, #-16]
	switch(cs) {
21f2b01c:	e51b3010 	ldr	r3, [fp, #-16]
21f2b020:	e50b3014 	str	r3, [fp, #-20]
21f2b024:	e51b3014 	ldr	r3, [fp, #-20]
21f2b028:	e3530000 	cmp	r3, #0	; 0x0
21f2b02c:	0a000003 	beq	21f2b040 <AT91F_SpiEnable+0x38>
21f2b030:	e51b3014 	ldr	r3, [fp, #-20]
21f2b034:	e3530003 	cmp	r3, #3	; 0x3
21f2b038:	0a00000f 	beq	21f2b07c <AT91F_SpiEnable+0x74>
21f2b03c:	ea000028 	b	21f2b0e4 <AT91F_SpiEnable+0xdc>
	case 0:	/* Configure SPI CS0 for Serial DataFlash AT45DBxx */
		AT91C_BASE_SPI->SPI_MR &= 0xFFF0FFFF;
21f2b040:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b044:	e1a02742 	mov	r2, r2, asr #14
21f2b048:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b04c:	e1a03743 	mov	r3, r3, asr #14
21f2b050:	e5933004 	ldr	r3, [r3, #4]
21f2b054:	e3c3380f 	bic	r3, r3, #983040	; 0xf0000
21f2b058:	e5823004 	str	r3, [r2, #4]
		AT91C_BASE_SPI->SPI_MR |= ((AT91C_SPI_PCS0_SERIAL_DATAFLASH<<16) & AT91C_SPI_PCS);
21f2b05c:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b060:	e1a02742 	mov	r2, r2, asr #14
21f2b064:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b068:	e1a03743 	mov	r3, r3, asr #14
21f2b06c:	e5933004 	ldr	r3, [r3, #4]
21f2b070:	e383380e 	orr	r3, r3, #917504	; 0xe0000
21f2b074:	e5823004 	str	r3, [r2, #4]
		break;
21f2b078:	ea000019 	b	21f2b0e4 <AT91F_SpiEnable+0xdc>
	case 3:	/* Configure SPI CS3 for Serial DataFlash Card */
		/* Set up PIO SDC_TYPE to switch on DataFlash Card and not MMC/SDCard */
		AT91C_BASE_PIOB->PIO_PER = AT91C_PIO_PB7;	/* Set in PIO mode */
21f2b07c:	e3a0320b 	mov	r3, #-1342177280	; 0xb0000000
21f2b080:	e1a039c3 	mov	r3, r3, asr #19
21f2b084:	e3a02080 	mov	r2, #128	; 0x80
21f2b088:	e5832000 	str	r2, [r3]
		AT91C_BASE_PIOB->PIO_OER = AT91C_PIO_PB7;	/* Configure in output */
21f2b08c:	e3a0320b 	mov	r3, #-1342177280	; 0xb0000000
21f2b090:	e1a039c3 	mov	r3, r3, asr #19
21f2b094:	e3a02080 	mov	r2, #128	; 0x80
21f2b098:	e5832010 	str	r2, [r3, #16]
		/* Clear Output */
		AT91C_BASE_PIOB->PIO_CODR = AT91C_PIO_PB7;
21f2b09c:	e3a0320b 	mov	r3, #-1342177280	; 0xb0000000
21f2b0a0:	e1a039c3 	mov	r3, r3, asr #19
21f2b0a4:	e3a02080 	mov	r2, #128	; 0x80
21f2b0a8:	e5832034 	str	r2, [r3, #52]
		/* Configure PCS */
		AT91C_BASE_SPI->SPI_MR &= 0xFFF0FFFF;
21f2b0ac:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b0b0:	e1a02742 	mov	r2, r2, asr #14
21f2b0b4:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b0b8:	e1a03743 	mov	r3, r3, asr #14
21f2b0bc:	e5933004 	ldr	r3, [r3, #4]
21f2b0c0:	e3c3380f 	bic	r3, r3, #983040	; 0xf0000
21f2b0c4:	e5823004 	str	r3, [r2, #4]
		AT91C_BASE_SPI->SPI_MR |= ((AT91C_SPI_PCS3_DATAFLASH_CARD<<16) & AT91C_SPI_PCS);
21f2b0c8:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b0cc:	e1a02742 	mov	r2, r2, asr #14
21f2b0d0:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b0d4:	e1a03743 	mov	r3, r3, asr #14
21f2b0d8:	e5933004 	ldr	r3, [r3, #4]
21f2b0dc:	e3833807 	orr	r3, r3, #458752	; 0x70000
21f2b0e0:	e5823004 	str	r3, [r2, #4]
		break;
	}

	/* SPI_Enable */
	AT91C_BASE_SPI->SPI_CR = AT91C_SPI_SPIEN;
21f2b0e4:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b0e8:	e1a03743 	mov	r3, r3, asr #14
21f2b0ec:	e3a02001 	mov	r2, #1	; 0x1
21f2b0f0:	e5832000 	str	r2, [r3]
}
21f2b0f4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2b0f8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2b0fc <AT91F_SpiWrite>:

/*----------------------------------------------------------------------------*/
/* \fn    AT91F_SpiWrite						      */
/* \brief Set the PDC registers for a transfert				      */
/*----------------------------------------------------------------------------*/
unsigned int AT91F_SpiWrite ( AT91PS_DataflashDesc pDesc )
{
21f2b0fc:	e1a0c00d 	mov	ip, sp
21f2b100:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b104:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b108:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2b10c:	e50b0014 	str	r0, [fp, #-20]
	unsigned int timeout;

	pDesc->state = BUSY;
21f2b110:	e51b2014 	ldr	r2, [fp, #-20]
21f2b114:	e3a03001 	mov	r3, #1	; 0x1
21f2b118:	e5c23020 	strb	r3, [r2, #32]

	AT91C_BASE_SPI->SPI_PTCR = AT91C_PDC_TXTDIS + AT91C_PDC_RXTDIS;
21f2b11c:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b120:	e1a02742 	mov	r2, r2, asr #14
21f2b124:	e3a03c02 	mov	r3, #512	; 0x200
21f2b128:	e2833002 	add	r3, r3, #2	; 0x2
21f2b12c:	e5823120 	str	r3, [r2, #288]

	/* Initialize the Transmit and Receive Pointer */
	AT91C_BASE_SPI->SPI_RPR = (unsigned int)pDesc->rx_cmd_pt ;
21f2b130:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b134:	e1a02742 	mov	r2, r2, asr #14
21f2b138:	e51b3014 	ldr	r3, [fp, #-20]
21f2b13c:	e5933008 	ldr	r3, [r3, #8]
21f2b140:	e5823100 	str	r3, [r2, #256]
	AT91C_BASE_SPI->SPI_TPR = (unsigned int)pDesc->tx_cmd_pt ;
21f2b144:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b148:	e1a02742 	mov	r2, r2, asr #14
21f2b14c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b150:	e5933000 	ldr	r3, [r3]
21f2b154:	e5823108 	str	r3, [r2, #264]

	/* Intialize the Transmit and Receive Counters */
	AT91C_BASE_SPI->SPI_RCR = pDesc->rx_cmd_size;
21f2b158:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b15c:	e1a03743 	mov	r3, r3, asr #14
21f2b160:	e51b2014 	ldr	r2, [fp, #-20]
21f2b164:	e592200c 	ldr	r2, [r2, #12]
21f2b168:	e5832104 	str	r2, [r3, #260]
	AT91C_BASE_SPI->SPI_TCR = pDesc->tx_cmd_size;
21f2b16c:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b170:	e1a03743 	mov	r3, r3, asr #14
21f2b174:	e51b2014 	ldr	r2, [fp, #-20]
21f2b178:	e5922004 	ldr	r2, [r2, #4]
21f2b17c:	e583210c 	str	r2, [r3, #268]

	if ( pDesc->tx_data_size != 0 ) {
21f2b180:	e51b3014 	ldr	r3, [fp, #-20]
21f2b184:	e5933014 	ldr	r3, [r3, #20]
21f2b188:	e3530000 	cmp	r3, #0	; 0x0
21f2b18c:	0a000013 	beq	21f2b1e0 <AT91F_SpiWrite+0xe4>
		/* Initialize the Next Transmit and Next Receive Pointer */
		AT91C_BASE_SPI->SPI_RNPR = (unsigned int)pDesc->rx_data_pt ;
21f2b190:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b194:	e1a02742 	mov	r2, r2, asr #14
21f2b198:	e51b3014 	ldr	r3, [fp, #-20]
21f2b19c:	e5933018 	ldr	r3, [r3, #24]
21f2b1a0:	e5823110 	str	r3, [r2, #272]
		AT91C_BASE_SPI->SPI_TNPR = (unsigned int)pDesc->tx_data_pt ;
21f2b1a4:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b1a8:	e1a02742 	mov	r2, r2, asr #14
21f2b1ac:	e51b3014 	ldr	r3, [fp, #-20]
21f2b1b0:	e5933010 	ldr	r3, [r3, #16]
21f2b1b4:	e5823118 	str	r3, [r2, #280]

		/* Intialize the Next Transmit and Next Receive Counters */
		AT91C_BASE_SPI->SPI_RNCR = pDesc->rx_data_size ;
21f2b1b8:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b1bc:	e1a03743 	mov	r3, r3, asr #14
21f2b1c0:	e51b2014 	ldr	r2, [fp, #-20]
21f2b1c4:	e592201c 	ldr	r2, [r2, #28]
21f2b1c8:	e5832114 	str	r2, [r3, #276]
		AT91C_BASE_SPI->SPI_TNCR = pDesc->tx_data_size ;
21f2b1cc:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b1d0:	e1a03743 	mov	r3, r3, asr #14
21f2b1d4:	e51b2014 	ldr	r2, [fp, #-20]
21f2b1d8:	e5922014 	ldr	r2, [r2, #20]
21f2b1dc:	e583211c 	str	r2, [r3, #284]
	}

	/* arm simple, non interrupt dependent timer */
	reset_timer_masked();
21f2b1e0:	ebff5638 	bl	21f00ac8 <reset_timer_masked>
	timeout = 0;
21f2b1e4:	e3a03000 	mov	r3, #0	; 0x0
21f2b1e8:	e50b3010 	str	r3, [fp, #-16]

	AT91C_BASE_SPI->SPI_PTCR = AT91C_PDC_TXTEN + AT91C_PDC_RXTEN;
21f2b1ec:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b1f0:	e1a02742 	mov	r2, r2, asr #14
21f2b1f4:	e3a03c01 	mov	r3, #256	; 0x100
21f2b1f8:	e2833001 	add	r3, r3, #1	; 0x1
21f2b1fc:	e5823120 	str	r3, [r2, #288]
	while(!(AT91C_BASE_SPI->SPI_SR & AT91C_SPI_RXBUFF) && ((timeout = get_timer_masked() ) < CFG_SPI_WRITE_TOUT));
21f2b200:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
21f2b204:	e1a03743 	mov	r3, r3, asr #14
21f2b208:	e5933010 	ldr	r3, [r3, #16]
21f2b20c:	e1a03323 	mov	r3, r3, lsr #6
21f2b210:	e2033001 	and	r3, r3, #1	; 0x1
21f2b214:	e3530000 	cmp	r3, #0	; 0x0
21f2b218:	1a000007 	bne	21f2b23c <AT91F_SpiWrite+0x140>
21f2b21c:	ebff5667 	bl	21f00bc0 <get_timer_masked>
21f2b220:	e1a03000 	mov	r3, r0
21f2b224:	e50b3010 	str	r3, [fp, #-16]
21f2b228:	e51b2010 	ldr	r2, [fp, #-16]
21f2b22c:	e3a03d4e 	mov	r3, #4992	; 0x1380
21f2b230:	e2833007 	add	r3, r3, #7	; 0x7
21f2b234:	e1520003 	cmp	r2, r3
21f2b238:	9afffff0 	bls	21f2b200 <AT91F_SpiWrite+0x104>
	AT91C_BASE_SPI->SPI_PTCR = AT91C_PDC_TXTDIS + AT91C_PDC_RXTDIS;
21f2b23c:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
21f2b240:	e1a02742 	mov	r2, r2, asr #14
21f2b244:	e3a03c02 	mov	r3, #512	; 0x200
21f2b248:	e2833002 	add	r3, r3, #2	; 0x2
21f2b24c:	e5823120 	str	r3, [r2, #288]
	pDesc->state = IDLE;
21f2b250:	e51b2014 	ldr	r2, [fp, #-20]
21f2b254:	e3a03000 	mov	r3, #0	; 0x0
21f2b258:	e5c23020 	strb	r3, [r2, #32]

	if (timeout >= CFG_SPI_WRITE_TOUT){
21f2b25c:	e51b2010 	ldr	r2, [fp, #-16]
21f2b260:	e3a03d4e 	mov	r3, #4992	; 0x1380
21f2b264:	e2833007 	add	r3, r3, #7	; 0x7
21f2b268:	e1520003 	cmp	r2, r3
21f2b26c:	9a000004 	bls	21f2b284 <AT91F_SpiWrite+0x188>
		printf("Error Timeout\n\r");
21f2b270:	e59f0024 	ldr	r0, [pc, #36]	; 21f2b29c <.text+0x2b29c>
21f2b274:	ebffc204 	bl	21f1ba8c <printf>
		return DATAFLASH_ERROR;
21f2b278:	e3a03002 	mov	r3, #2	; 0x2
21f2b27c:	e50b3018 	str	r3, [fp, #-24]
21f2b280:	ea000001 	b	21f2b28c <AT91F_SpiWrite+0x190>
	}

	return DATAFLASH_OK;
21f2b284:	e3a03001 	mov	r3, #1	; 0x1
21f2b288:	e50b3018 	str	r3, [fp, #-24]
21f2b28c:	e51b3018 	ldr	r3, [fp, #-24]
}
21f2b290:	e1a00003 	mov	r0, r3
21f2b294:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2b298:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2b29c:	21f32ee8 	mvncss	r2, r8, ror #29

21f2b2a0 <AT91F_DataFlashSendCommand>:


/*----------------------------------------------------------------------*/
/* \fn    AT91F_DataFlashSendCommand					*/
/* \brief Generic function to send a command to the dataflash		*/
/*----------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_DataFlashSendCommand(
	AT91PS_DataFlash pDataFlash,
	unsigned char OpCode,
	unsigned int CmdSize,
	unsigned int DataflashAddress)
{
21f2b2a0:	e1a0c00d 	mov	ip, sp
21f2b2a4:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f2b2a8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b2ac:	e24dd018 	sub	sp, sp, #24	; 0x18
21f2b2b0:	e50b0018 	str	r0, [fp, #-24]
21f2b2b4:	e50b2020 	str	r2, [fp, #-32]
21f2b2b8:	e50b3024 	str	r3, [fp, #-36]
21f2b2bc:	e1a03001 	mov	r3, r1
21f2b2c0:	e54b301c 	strb	r3, [fp, #-28]
    unsigned int adr;

	if ( (pDataFlash->pDataFlashDesc->state) != IDLE)
21f2b2c4:	e51b3018 	ldr	r3, [fp, #-24]
21f2b2c8:	e5933000 	ldr	r3, [r3]
21f2b2cc:	e5d33020 	ldrb	r3, [r3, #32]
21f2b2d0:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b2d4:	e3530000 	cmp	r3, #0	; 0x0
21f2b2d8:	0a000002 	beq	21f2b2e8 <AT91F_DataFlashSendCommand+0x48>
		return DATAFLASH_BUSY;
21f2b2dc:	e3a03000 	mov	r3, #0	; 0x0
21f2b2e0:	e50b3028 	str	r3, [fp, #-40]
21f2b2e4:	ea000079 	b	21f2b4d0 <AT91F_DataFlashSendCommand+0x230>

	/* process the address to obtain page address and byte address */
	adr = ((DataflashAddress / (pDataFlash->pDevice->pages_size)) << pDataFlash->pDevice->page_offset) + (DataflashAddress % (pDataFlash->pDevice->pages_size));
21f2b2e8:	e51b3018 	ldr	r3, [fp, #-24]
21f2b2ec:	e5933004 	ldr	r3, [r3, #4]
21f2b2f0:	e5933004 	ldr	r3, [r3, #4]
21f2b2f4:	e51b0024 	ldr	r0, [fp, #-36]
21f2b2f8:	e1a01003 	mov	r1, r3
21f2b2fc:	ebff69ec 	bl	21f05ab4 <__udivsi3>
21f2b300:	e1a03000 	mov	r3, r0
21f2b304:	e1a02003 	mov	r2, r3
21f2b308:	e51b3018 	ldr	r3, [fp, #-24]
21f2b30c:	e5933004 	ldr	r3, [r3, #4]
21f2b310:	e5933008 	ldr	r3, [r3, #8]
21f2b314:	e1a04312 	mov	r4, r2, lsl r3
21f2b318:	e51b3018 	ldr	r3, [fp, #-24]
21f2b31c:	e5933004 	ldr	r3, [r3, #4]
21f2b320:	e5933004 	ldr	r3, [r3, #4]
21f2b324:	e1a02003 	mov	r2, r3
21f2b328:	e51b3024 	ldr	r3, [fp, #-36]
21f2b32c:	e1a00003 	mov	r0, r3
21f2b330:	e1a01002 	mov	r1, r2
21f2b334:	ebff6a04 	bl	21f05b4c <__umodsi3>
21f2b338:	e1a03000 	mov	r3, r0
21f2b33c:	e0843003 	add	r3, r4, r3
21f2b340:	e50b3014 	str	r3, [fp, #-20]

	/* fill the  command  buffer */
	pDataFlash->pDataFlashDesc->command[0] = OpCode;
21f2b344:	e51b3018 	ldr	r3, [fp, #-24]
21f2b348:	e5932000 	ldr	r2, [r3]
21f2b34c:	e55b301c 	ldrb	r3, [fp, #-28]
21f2b350:	e5c23022 	strb	r3, [r2, #34]
	if (pDataFlash->pDevice->pages_number >= 16384) {
21f2b354:	e51b3018 	ldr	r3, [fp, #-24]
21f2b358:	e5933004 	ldr	r3, [r3, #4]
21f2b35c:	e5932000 	ldr	r2, [r3]
21f2b360:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2b364:	e283303f 	add	r3, r3, #63	; 0x3f
21f2b368:	e1520003 	cmp	r2, r3
21f2b36c:	da00001a 	ble	21f2b3dc <AT91F_DataFlashSendCommand+0x13c>
		pDataFlash->pDataFlashDesc->command[1] = (unsigned char)((adr & 0x0F000000) >> 24);
21f2b370:	e51b3018 	ldr	r3, [fp, #-24]
21f2b374:	e5932000 	ldr	r2, [r3]
21f2b378:	e51b3014 	ldr	r3, [fp, #-20]
21f2b37c:	e203340f 	and	r3, r3, #251658240	; 0xf000000
21f2b380:	e1a03c23 	mov	r3, r3, lsr #24
21f2b384:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b388:	e5c23023 	strb	r3, [r2, #35]
		pDataFlash->pDataFlashDesc->command[2] = (unsigned char)((adr & 0x00FF0000) >> 16);
21f2b38c:	e51b3018 	ldr	r3, [fp, #-24]
21f2b390:	e5932000 	ldr	r2, [r3]
21f2b394:	e51b3014 	ldr	r3, [fp, #-20]
21f2b398:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f2b39c:	e1a03823 	mov	r3, r3, lsr #16
21f2b3a0:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b3a4:	e5c23024 	strb	r3, [r2, #36]
		pDataFlash->pDataFlashDesc->command[3] = (unsigned char)((adr & 0x0000FF00) >> 8);
21f2b3a8:	e51b3018 	ldr	r3, [fp, #-24]
21f2b3ac:	e5932000 	ldr	r2, [r3]
21f2b3b0:	e51b3014 	ldr	r3, [fp, #-20]
21f2b3b4:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f2b3b8:	e1a03423 	mov	r3, r3, lsr #8
21f2b3bc:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b3c0:	e5c23025 	strb	r3, [r2, #37]
		pDataFlash->pDataFlashDesc->command[4] = (unsigned char)(adr & 0x000000FF);
21f2b3c4:	e51b3018 	ldr	r3, [fp, #-24]
21f2b3c8:	e5932000 	ldr	r2, [r3]
21f2b3cc:	e51b3014 	ldr	r3, [fp, #-20]
21f2b3d0:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b3d4:	e5c23026 	strb	r3, [r2, #38]
21f2b3d8:	ea000016 	b	21f2b438 <AT91F_DataFlashSendCommand+0x198>
	} else {
		pDataFlash->pDataFlashDesc->command[1] = (unsigned char)((adr & 0x00FF0000) >> 16);
21f2b3dc:	e51b3018 	ldr	r3, [fp, #-24]
21f2b3e0:	e5932000 	ldr	r2, [r3]
21f2b3e4:	e51b3014 	ldr	r3, [fp, #-20]
21f2b3e8:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f2b3ec:	e1a03823 	mov	r3, r3, lsr #16
21f2b3f0:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b3f4:	e5c23023 	strb	r3, [r2, #35]
		pDataFlash->pDataFlashDesc->command[2] = (unsigned char)((adr & 0x0000FF00) >> 8);
21f2b3f8:	e51b3018 	ldr	r3, [fp, #-24]
21f2b3fc:	e5932000 	ldr	r2, [r3]
21f2b400:	e51b3014 	ldr	r3, [fp, #-20]
21f2b404:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f2b408:	e1a03423 	mov	r3, r3, lsr #8
21f2b40c:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b410:	e5c23024 	strb	r3, [r2, #36]
		pDataFlash->pDataFlashDesc->command[3] = (unsigned char)(adr & 0x000000FF) ;
21f2b414:	e51b3018 	ldr	r3, [fp, #-24]
21f2b418:	e5932000 	ldr	r2, [r3]
21f2b41c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b420:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b424:	e5c23025 	strb	r3, [r2, #37]
		pDataFlash->pDataFlashDesc->command[4] = 0;
21f2b428:	e51b3018 	ldr	r3, [fp, #-24]
21f2b42c:	e5932000 	ldr	r2, [r3]
21f2b430:	e3a03000 	mov	r3, #0	; 0x0
21f2b434:	e5c23026 	strb	r3, [r2, #38]
	}
	pDataFlash->pDataFlashDesc->command[5] = 0;
21f2b438:	e51b3018 	ldr	r3, [fp, #-24]
21f2b43c:	e5932000 	ldr	r2, [r3]
21f2b440:	e3a03000 	mov	r3, #0	; 0x0
21f2b444:	e5c23027 	strb	r3, [r2, #39]
	pDataFlash->pDataFlashDesc->command[6] = 0;
21f2b448:	e51b3018 	ldr	r3, [fp, #-24]
21f2b44c:	e5932000 	ldr	r2, [r3]
21f2b450:	e3a03000 	mov	r3, #0	; 0x0
21f2b454:	e5c23028 	strb	r3, [r2, #40]
	pDataFlash->pDataFlashDesc->command[7] = 0;
21f2b458:	e51b3018 	ldr	r3, [fp, #-24]
21f2b45c:	e5932000 	ldr	r2, [r3]
21f2b460:	e3a03000 	mov	r3, #0	; 0x0
21f2b464:	e5c23029 	strb	r3, [r2, #41]

	/* Initialize the SpiData structure for the spi write fuction */
	pDataFlash->pDataFlashDesc->tx_cmd_pt   =  pDataFlash->pDataFlashDesc->command ;
21f2b468:	e51b3018 	ldr	r3, [fp, #-24]
21f2b46c:	e5932000 	ldr	r2, [r3]
21f2b470:	e51b3018 	ldr	r3, [fp, #-24]
21f2b474:	e5933000 	ldr	r3, [r3]
21f2b478:	e2833022 	add	r3, r3, #34	; 0x22
21f2b47c:	e5823000 	str	r3, [r2]
	pDataFlash->pDataFlashDesc->tx_cmd_size =  CmdSize ;
21f2b480:	e51b3018 	ldr	r3, [fp, #-24]
21f2b484:	e5932000 	ldr	r2, [r3]
21f2b488:	e51b3020 	ldr	r3, [fp, #-32]
21f2b48c:	e5823004 	str	r3, [r2, #4]
	pDataFlash->pDataFlashDesc->rx_cmd_pt   =  pDataFlash->pDataFlashDesc->command ;
21f2b490:	e51b3018 	ldr	r3, [fp, #-24]
21f2b494:	e5932000 	ldr	r2, [r3]
21f2b498:	e51b3018 	ldr	r3, [fp, #-24]
21f2b49c:	e5933000 	ldr	r3, [r3]
21f2b4a0:	e2833022 	add	r3, r3, #34	; 0x22
21f2b4a4:	e5823008 	str	r3, [r2, #8]
	pDataFlash->pDataFlashDesc->rx_cmd_size =  CmdSize ;
21f2b4a8:	e51b3018 	ldr	r3, [fp, #-24]
21f2b4ac:	e5932000 	ldr	r2, [r3]
21f2b4b0:	e51b3020 	ldr	r3, [fp, #-32]
21f2b4b4:	e582300c 	str	r3, [r2, #12]

	/* send the command and read the data */
	return AT91F_SpiWrite (pDataFlash->pDataFlashDesc);
21f2b4b8:	e51b3018 	ldr	r3, [fp, #-24]
21f2b4bc:	e5933000 	ldr	r3, [r3]
21f2b4c0:	e1a00003 	mov	r0, r3
21f2b4c4:	ebffff0c 	bl	21f2b0fc <AT91F_SpiWrite>
21f2b4c8:	e1a03000 	mov	r3, r0
21f2b4cc:	e50b3028 	str	r3, [fp, #-40]
21f2b4d0:	e51b3028 	ldr	r3, [fp, #-40]
}
21f2b4d4:	e1a00003 	mov	r0, r3
21f2b4d8:	e24bd010 	sub	sp, fp, #16	; 0x10
21f2b4dc:	e89da810 	ldmia	sp, {r4, fp, sp, pc}

21f2b4e0 <AT91F_DataFlashGetStatus>:


/*----------------------------------------------------------------------*/
/* \fn    AT91F_DataFlashGetStatus					*/
/* \brief Read the status register of the dataflash			*/
/*----------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_DataFlashGetStatus(AT91PS_DataflashDesc pDesc)
{
21f2b4e0:	e1a0c00d 	mov	ip, sp
21f2b4e4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b4e8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b4ec:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2b4f0:	e50b0014 	str	r0, [fp, #-20]
	AT91S_DataFlashStatus status;

	/* if a transfert is in progress ==> return 0 */
	if( (pDesc->state) != IDLE)
21f2b4f4:	e51b3014 	ldr	r3, [fp, #-20]
21f2b4f8:	e5d33020 	ldrb	r3, [r3, #32]
21f2b4fc:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b500:	e3530000 	cmp	r3, #0	; 0x0
21f2b504:	0a000002 	beq	21f2b514 <AT91F_DataFlashGetStatus+0x34>
		return DATAFLASH_BUSY;
21f2b508:	e3a03000 	mov	r3, #0	; 0x0
21f2b50c:	e50b3018 	str	r3, [fp, #-24]
21f2b510:	ea000025 	b	21f2b5ac <AT91F_DataFlashGetStatus+0xcc>

	/* first send the read status command (D7H) */
	pDesc->command[0] = DB_STATUS;
21f2b514:	e51b2014 	ldr	r2, [fp, #-20]
21f2b518:	e3e03028 	mvn	r3, #40	; 0x28
21f2b51c:	e5c23022 	strb	r3, [r2, #34]
	pDesc->command[1] = 0;
21f2b520:	e51b2014 	ldr	r2, [fp, #-20]
21f2b524:	e3a03000 	mov	r3, #0	; 0x0
21f2b528:	e5c23023 	strb	r3, [r2, #35]

	pDesc->DataFlash_state  = GET_STATUS;
21f2b52c:	e51b2014 	ldr	r2, [fp, #-20]
21f2b530:	e3a0300f 	mov	r3, #15	; 0xf
21f2b534:	e5c23021 	strb	r3, [r2, #33]
	pDesc->tx_data_size 	= 0 ;	/* Transmit the command and receive response */
21f2b538:	e51b2014 	ldr	r2, [fp, #-20]
21f2b53c:	e3a03000 	mov	r3, #0	; 0x0
21f2b540:	e5823014 	str	r3, [r2, #20]
	pDesc->tx_cmd_pt 		= pDesc->command ;
21f2b544:	e51b3014 	ldr	r3, [fp, #-20]
21f2b548:	e2832022 	add	r2, r3, #34	; 0x22
21f2b54c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b550:	e5832000 	str	r2, [r3]
	pDesc->rx_cmd_pt 		= pDesc->command ;
21f2b554:	e51b3014 	ldr	r3, [fp, #-20]
21f2b558:	e2832022 	add	r2, r3, #34	; 0x22
21f2b55c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b560:	e5832008 	str	r2, [r3, #8]
	pDesc->rx_cmd_size 		= 2 ;
21f2b564:	e51b2014 	ldr	r2, [fp, #-20]
21f2b568:	e3a03002 	mov	r3, #2	; 0x2
21f2b56c:	e582300c 	str	r3, [r2, #12]
	pDesc->tx_cmd_size 		= 2 ;
21f2b570:	e51b2014 	ldr	r2, [fp, #-20]
21f2b574:	e3a03002 	mov	r3, #2	; 0x2
21f2b578:	e5823004 	str	r3, [r2, #4]
	status = AT91F_SpiWrite (pDesc);
21f2b57c:	e51b0014 	ldr	r0, [fp, #-20]
21f2b580:	ebfffedd 	bl	21f2b0fc <AT91F_SpiWrite>
21f2b584:	e1a03000 	mov	r3, r0
21f2b588:	e50b3010 	str	r3, [fp, #-16]

	pDesc->DataFlash_state = *( (unsigned char *) (pDesc->rx_cmd_pt) +1);
21f2b58c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b590:	e5933008 	ldr	r3, [r3, #8]
21f2b594:	e2833001 	add	r3, r3, #1	; 0x1
21f2b598:	e5d33000 	ldrb	r3, [r3]
21f2b59c:	e51b2014 	ldr	r2, [fp, #-20]
21f2b5a0:	e5c23021 	strb	r3, [r2, #33]

	return status;
21f2b5a4:	e51b3010 	ldr	r3, [fp, #-16]
21f2b5a8:	e50b3018 	str	r3, [fp, #-24]
21f2b5ac:	e51b3018 	ldr	r3, [fp, #-24]
}
21f2b5b0:	e1a00003 	mov	r0, r3
21f2b5b4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2b5b8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2b5bc <AT91F_DataFlashWaitReady>:


/*----------------------------------------------------------------------*/
/* \fn    AT91F_DataFlashWaitReady					*/
/* \brief wait for dataflash ready (bit7 of the status register == 1)	*/
/*----------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_DataFlashWaitReady(AT91PS_DataflashDesc pDataFlashDesc, unsigned int timeout)
{
21f2b5bc:	e1a0c00d 	mov	ip, sp
21f2b5c0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b5c4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b5c8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2b5cc:	e50b0010 	str	r0, [fp, #-16]
21f2b5d0:	e50b1014 	str	r1, [fp, #-20]
	pDataFlashDesc->DataFlash_state = IDLE;
21f2b5d4:	e51b3010 	ldr	r3, [fp, #-16]
21f2b5d8:	e3a02000 	mov	r2, #0	; 0x0
21f2b5dc:	e5c32021 	strb	r2, [r3, #33]

	do {
		AT91F_DataFlashGetStatus(pDataFlashDesc);
21f2b5e0:	e51b0010 	ldr	r0, [fp, #-16]
21f2b5e4:	ebffffbd 	bl	21f2b4e0 <AT91F_DataFlashGetStatus>
		timeout--;
21f2b5e8:	e51b3014 	ldr	r3, [fp, #-20]
21f2b5ec:	e2433001 	sub	r3, r3, #1	; 0x1
21f2b5f0:	e50b3014 	str	r3, [fp, #-20]
	} while( ((pDataFlashDesc->DataFlash_state & 0x80) != 0x80) && (timeout > 0) );
21f2b5f4:	e51b3010 	ldr	r3, [fp, #-16]
21f2b5f8:	e5d33021 	ldrb	r3, [r3, #33]
21f2b5fc:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b600:	e1a03c03 	mov	r3, r3, lsl #24
21f2b604:	e1a03c43 	mov	r3, r3, asr #24
21f2b608:	e3530000 	cmp	r3, #0	; 0x0
21f2b60c:	ba000002 	blt	21f2b61c <AT91F_DataFlashWaitReady+0x60>
21f2b610:	e51b3014 	ldr	r3, [fp, #-20]
21f2b614:	e3530000 	cmp	r3, #0	; 0x0
21f2b618:	1afffff0 	bne	21f2b5e0 <AT91F_DataFlashWaitReady+0x24>

	if((pDataFlashDesc->DataFlash_state & 0x80) != 0x80)
21f2b61c:	e51b3010 	ldr	r3, [fp, #-16]
21f2b620:	e5d33021 	ldrb	r3, [r3, #33]
21f2b624:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b628:	e1a03c03 	mov	r3, r3, lsl #24
21f2b62c:	e1a03c43 	mov	r3, r3, asr #24
21f2b630:	e3530000 	cmp	r3, #0	; 0x0
21f2b634:	ba000002 	blt	21f2b644 <AT91F_DataFlashWaitReady+0x88>
		return DATAFLASH_ERROR;
21f2b638:	e3a03002 	mov	r3, #2	; 0x2
21f2b63c:	e50b3018 	str	r3, [fp, #-24]
21f2b640:	ea000001 	b	21f2b64c <AT91F_DataFlashWaitReady+0x90>

	return DATAFLASH_OK;
21f2b644:	e3a03001 	mov	r3, #1	; 0x1
21f2b648:	e50b3018 	str	r3, [fp, #-24]
21f2b64c:	e51b3018 	ldr	r3, [fp, #-24]
}
21f2b650:	e1a00003 	mov	r0, r3
21f2b654:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2b658:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2b65c <AT91F_DataFlashContinuousRead>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_DataFlashContinuousRead 				*/
/* Object              : Continuous stream Read 				*/
/* Input Parameters    : DataFlash Service					*/
/*						: <src> = dataflash address	*/
/*                     : <*dataBuffer> = data buffer pointer			*/
/*                     : <sizeToRead> = data buffer size			*/
/* Return value		: State of the dataflash				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_DataFlashContinuousRead (
	AT91PS_DataFlash pDataFlash,
	int src,
	unsigned char *dataBuffer,
	int sizeToRead )
{
21f2b65c:	e1a0c00d 	mov	ip, sp
21f2b660:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b664:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b668:	e24dd018 	sub	sp, sp, #24	; 0x18
21f2b66c:	e50b0014 	str	r0, [fp, #-20]
21f2b670:	e50b1018 	str	r1, [fp, #-24]
21f2b674:	e50b201c 	str	r2, [fp, #-28]
21f2b678:	e50b3020 	str	r3, [fp, #-32]
	AT91S_DataFlashStatus status;
	/* Test the size to read in the device */
	if ( (src + sizeToRead) > (pDataFlash->pDevice->pages_size * (pDataFlash->pDevice->pages_number)))
21f2b67c:	e51b2018 	ldr	r2, [fp, #-24]
21f2b680:	e51b3020 	ldr	r3, [fp, #-32]
21f2b684:	e0821003 	add	r1, r2, r3
21f2b688:	e51b3014 	ldr	r3, [fp, #-20]
21f2b68c:	e5933004 	ldr	r3, [r3, #4]
21f2b690:	e5932004 	ldr	r2, [r3, #4]
21f2b694:	e51b3014 	ldr	r3, [fp, #-20]
21f2b698:	e5933004 	ldr	r3, [r3, #4]
21f2b69c:	e5933000 	ldr	r3, [r3]
21f2b6a0:	e0030392 	mul	r3, r2, r3
21f2b6a4:	e1510003 	cmp	r1, r3
21f2b6a8:	da000002 	ble	21f2b6b8 <AT91F_DataFlashContinuousRead+0x5c>
		return DATAFLASH_MEMORY_OVERFLOW;
21f2b6ac:	e3a03003 	mov	r3, #3	; 0x3
21f2b6b0:	e50b3024 	str	r3, [fp, #-36]
21f2b6b4:	ea000018 	b	21f2b71c <AT91F_DataFlashContinuousRead+0xc0>

	pDataFlash->pDataFlashDesc->rx_data_pt = dataBuffer;
21f2b6b8:	e51b3014 	ldr	r3, [fp, #-20]
21f2b6bc:	e5932000 	ldr	r2, [r3]
21f2b6c0:	e51b301c 	ldr	r3, [fp, #-28]
21f2b6c4:	e5823018 	str	r3, [r2, #24]
	pDataFlash->pDataFlashDesc->rx_data_size = sizeToRead;
21f2b6c8:	e51b3014 	ldr	r3, [fp, #-20]
21f2b6cc:	e5932000 	ldr	r2, [r3]
21f2b6d0:	e51b3020 	ldr	r3, [fp, #-32]
21f2b6d4:	e582301c 	str	r3, [r2, #28]
	pDataFlash->pDataFlashDesc->tx_data_pt = dataBuffer;
21f2b6d8:	e51b3014 	ldr	r3, [fp, #-20]
21f2b6dc:	e5932000 	ldr	r2, [r3]
21f2b6e0:	e51b301c 	ldr	r3, [fp, #-28]
21f2b6e4:	e5823010 	str	r3, [r2, #16]
	pDataFlash->pDataFlashDesc->tx_data_size = sizeToRead;
21f2b6e8:	e51b3014 	ldr	r3, [fp, #-20]
21f2b6ec:	e5932000 	ldr	r2, [r3]
21f2b6f0:	e51b3020 	ldr	r3, [fp, #-32]
21f2b6f4:	e5823014 	str	r3, [r2, #20]

	status = AT91F_DataFlashSendCommand (pDataFlash, DB_CONTINUOUS_ARRAY_READ, 8, src);
21f2b6f8:	e51b3018 	ldr	r3, [fp, #-24]
21f2b6fc:	e51b0014 	ldr	r0, [fp, #-20]
21f2b700:	e3a010e8 	mov	r1, #232	; 0xe8
21f2b704:	e3a02008 	mov	r2, #8	; 0x8
21f2b708:	ebfffee4 	bl	21f2b2a0 <AT91F_DataFlashSendCommand>
21f2b70c:	e1a03000 	mov	r3, r0
21f2b710:	e50b3010 	str	r3, [fp, #-16]
	/* Send the command to the dataflash */
	return(status);
21f2b714:	e51b3010 	ldr	r3, [fp, #-16]
21f2b718:	e50b3024 	str	r3, [fp, #-36]
21f2b71c:	e51b3024 	ldr	r3, [fp, #-36]
}
21f2b720:	e1a00003 	mov	r0, r3
21f2b724:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2b728:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2b72c <AT91F_DataFlashPagePgmBuf>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_DataFlashPagePgmBuf				*/
/* Object              : Main memory page program through buffer 1 or buffer 2	*/
/* Input Parameters    : DataFlash Service					*/
/*						: <*src> = Source buffer	*/
/*                     : <dest> = dataflash destination address			*/
/*                     : <SizeToWrite> = data buffer size			*/
/* Return value		: State of the dataflash				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_DataFlashPagePgmBuf(
	AT91PS_DataFlash pDataFlash,
	unsigned char *src,
	unsigned int dest,
	unsigned int SizeToWrite)
{
21f2b72c:	e1a0c00d 	mov	ip, sp
21f2b730:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b734:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b738:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2b73c:	e50b0014 	str	r0, [fp, #-20]
21f2b740:	e50b1018 	str	r1, [fp, #-24]
21f2b744:	e50b201c 	str	r2, [fp, #-28]
21f2b748:	e50b3020 	str	r3, [fp, #-32]
	int cmdsize;
	pDataFlash->pDataFlashDesc->tx_data_pt = src ;
21f2b74c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b750:	e5932000 	ldr	r2, [r3]
21f2b754:	e51b3018 	ldr	r3, [fp, #-24]
21f2b758:	e5823010 	str	r3, [r2, #16]
	pDataFlash->pDataFlashDesc->tx_data_size = SizeToWrite ;
21f2b75c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b760:	e5932000 	ldr	r2, [r3]
21f2b764:	e51b3020 	ldr	r3, [fp, #-32]
21f2b768:	e5823014 	str	r3, [r2, #20]
	pDataFlash->pDataFlashDesc->rx_data_pt = src;
21f2b76c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b770:	e5932000 	ldr	r2, [r3]
21f2b774:	e51b3018 	ldr	r3, [fp, #-24]
21f2b778:	e5823018 	str	r3, [r2, #24]
	pDataFlash->pDataFlashDesc->rx_data_size = SizeToWrite;
21f2b77c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b780:	e5932000 	ldr	r2, [r3]
21f2b784:	e51b3020 	ldr	r3, [fp, #-32]
21f2b788:	e582301c 	str	r3, [r2, #28]

	cmdsize = 4;
21f2b78c:	e3a03004 	mov	r3, #4	; 0x4
21f2b790:	e50b3010 	str	r3, [fp, #-16]
	/* Send the command to the dataflash */
	if (pDataFlash->pDevice->pages_number >= 16384)
21f2b794:	e51b3014 	ldr	r3, [fp, #-20]
21f2b798:	e5933004 	ldr	r3, [r3, #4]
21f2b79c:	e5932000 	ldr	r2, [r3]
21f2b7a0:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2b7a4:	e283303f 	add	r3, r3, #63	; 0x3f
21f2b7a8:	e1520003 	cmp	r2, r3
21f2b7ac:	da000001 	ble	21f2b7b8 <AT91F_DataFlashPagePgmBuf+0x8c>
		cmdsize = 5;
21f2b7b0:	e3a03005 	mov	r3, #5	; 0x5
21f2b7b4:	e50b3010 	str	r3, [fp, #-16]
	return(AT91F_DataFlashSendCommand (pDataFlash, DB_PAGE_PGM_BUF1, cmdsize, dest));
21f2b7b8:	e51b3010 	ldr	r3, [fp, #-16]
21f2b7bc:	e51b0014 	ldr	r0, [fp, #-20]
21f2b7c0:	e3a01082 	mov	r1, #130	; 0x82
21f2b7c4:	e1a02003 	mov	r2, r3
21f2b7c8:	e51b301c 	ldr	r3, [fp, #-28]
21f2b7cc:	ebfffeb3 	bl	21f2b2a0 <AT91F_DataFlashSendCommand>
21f2b7d0:	e1a03000 	mov	r3, r0
}
21f2b7d4:	e1a00003 	mov	r0, r3
21f2b7d8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2b7dc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2b7e0 <AT91F_MainMemoryToBufferTransfert>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_MainMemoryToBufferTransfert			*/
/* Object              : Read a page in the SRAM Buffer 1 or 2			*/
/* Input Parameters    : DataFlash Service					*/
/*                     : Page concerned						*/
/*                     : 							*/
/* Return value		: State of the dataflash				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_MainMemoryToBufferTransfert(
	AT91PS_DataFlash pDataFlash,
	unsigned char BufferCommand,
	unsigned int page)
{
21f2b7e0:	e1a0c00d 	mov	ip, sp
21f2b7e4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b7e8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b7ec:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2b7f0:	e50b0014 	str	r0, [fp, #-20]
21f2b7f4:	e1a03001 	mov	r3, r1
21f2b7f8:	e50b201c 	str	r2, [fp, #-28]
21f2b7fc:	e54b3018 	strb	r3, [fp, #-24]
	int cmdsize;
	/* Test if the buffer command is legal */
	if ((BufferCommand != DB_PAGE_2_BUF1_TRF) && (BufferCommand != DB_PAGE_2_BUF2_TRF))
21f2b800:	e55b3018 	ldrb	r3, [fp, #-24]
21f2b804:	e3530053 	cmp	r3, #83	; 0x53
21f2b808:	0a000005 	beq	21f2b824 <AT91F_MainMemoryToBufferTransfert+0x44>
21f2b80c:	e55b3018 	ldrb	r3, [fp, #-24]
21f2b810:	e3530055 	cmp	r3, #85	; 0x55
21f2b814:	0a000002 	beq	21f2b824 <AT91F_MainMemoryToBufferTransfert+0x44>
		return DATAFLASH_BAD_COMMAND;
21f2b818:	e3a03004 	mov	r3, #4	; 0x4
21f2b81c:	e50b3020 	str	r3, [fp, #-32]
21f2b820:	ea00001b 	b	21f2b894 <AT91F_MainMemoryToBufferTransfert+0xb4>

	/* no data to transmit or receive */
	pDataFlash->pDataFlashDesc->tx_data_size = 0;
21f2b824:	e51b3014 	ldr	r3, [fp, #-20]
21f2b828:	e5932000 	ldr	r2, [r3]
21f2b82c:	e3a03000 	mov	r3, #0	; 0x0
21f2b830:	e5823014 	str	r3, [r2, #20]
	cmdsize = 4;
21f2b834:	e3a03004 	mov	r3, #4	; 0x4
21f2b838:	e50b3010 	str	r3, [fp, #-16]
	if (pDataFlash->pDevice->pages_number >= 16384)
21f2b83c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b840:	e5933004 	ldr	r3, [r3, #4]
21f2b844:	e5932000 	ldr	r2, [r3]
21f2b848:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2b84c:	e283303f 	add	r3, r3, #63	; 0x3f
21f2b850:	e1520003 	cmp	r2, r3
21f2b854:	da000001 	ble	21f2b860 <AT91F_MainMemoryToBufferTransfert+0x80>
		cmdsize = 5;
21f2b858:	e3a03005 	mov	r3, #5	; 0x5
21f2b85c:	e50b3010 	str	r3, [fp, #-16]
	return(AT91F_DataFlashSendCommand (pDataFlash, BufferCommand, cmdsize, page*pDataFlash->pDevice->pages_size));
21f2b860:	e55b1018 	ldrb	r1, [fp, #-24]
21f2b864:	e51bc010 	ldr	ip, [fp, #-16]
21f2b868:	e51b3014 	ldr	r3, [fp, #-20]
21f2b86c:	e5933004 	ldr	r3, [r3, #4]
21f2b870:	e5933004 	ldr	r3, [r3, #4]
21f2b874:	e1a02003 	mov	r2, r3
21f2b878:	e51b301c 	ldr	r3, [fp, #-28]
21f2b87c:	e0030392 	mul	r3, r2, r3
21f2b880:	e51b0014 	ldr	r0, [fp, #-20]
21f2b884:	e1a0200c 	mov	r2, ip
21f2b888:	ebfffe84 	bl	21f2b2a0 <AT91F_DataFlashSendCommand>
21f2b88c:	e1a03000 	mov	r3, r0
21f2b890:	e50b3020 	str	r3, [fp, #-32]
21f2b894:	e51b3020 	ldr	r3, [fp, #-32]
}
21f2b898:	e1a00003 	mov	r0, r3
21f2b89c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2b8a0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2b8a4 <AT91F_DataFlashWriteBuffer>:


/*----------------------------------------------------------------------------- */
/* Function Name       : AT91F_DataFlashWriteBuffer				*/
/* Object              : Write data to the internal sram buffer 1 or 2		*/
/* Input Parameters    : DataFlash Service					*/
/*			: <BufferCommand> = command to write buffer1 or buffer2	*/
/*                     : <*dataBuffer> = data buffer to write			*/
/*                     : <bufferAddress> = address in the internal buffer	*/
/*                     : <SizeToWrite> = data buffer size			*/
/* Return value		: State of the dataflash				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_DataFlashWriteBuffer (
	AT91PS_DataFlash pDataFlash,
	unsigned char BufferCommand,
	unsigned char *dataBuffer,
	unsigned int bufferAddress,
	int SizeToWrite )
{
21f2b8a4:	e1a0c00d 	mov	ip, sp
21f2b8a8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2b8ac:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2b8b0:	e24dd018 	sub	sp, sp, #24	; 0x18
21f2b8b4:	e50b0014 	str	r0, [fp, #-20]
21f2b8b8:	e50b201c 	str	r2, [fp, #-28]
21f2b8bc:	e50b3020 	str	r3, [fp, #-32]
21f2b8c0:	e1a03001 	mov	r3, r1
21f2b8c4:	e54b3018 	strb	r3, [fp, #-24]
	int cmdsize;
	/* Test if the buffer command is legal */
	if ((BufferCommand != DB_BUF1_WRITE) && (BufferCommand != DB_BUF2_WRITE))
21f2b8c8:	e55b3018 	ldrb	r3, [fp, #-24]
21f2b8cc:	e3530084 	cmp	r3, #132	; 0x84
21f2b8d0:	0a000005 	beq	21f2b8ec <AT91F_DataFlashWriteBuffer+0x48>
21f2b8d4:	e55b3018 	ldrb	r3, [fp, #-24]
21f2b8d8:	e3530087 	cmp	r3, #135	; 0x87
21f2b8dc:	0a000002 	beq	21f2b8ec <AT91F_DataFlashWriteBuffer+0x48>
		return DATAFLASH_BAD_COMMAND;
21f2b8e0:	e3a03004 	mov	r3, #4	; 0x4
21f2b8e4:	e50b3024 	str	r3, [fp, #-36]
21f2b8e8:	ea000078 	b	21f2bad0 <AT91F_DataFlashWriteBuffer+0x22c>

	/* buffer address must be lower than page size */
	if (bufferAddress > pDataFlash->pDevice->pages_size)
21f2b8ec:	e51b3014 	ldr	r3, [fp, #-20]
21f2b8f0:	e5933004 	ldr	r3, [r3, #4]
21f2b8f4:	e5933004 	ldr	r3, [r3, #4]
21f2b8f8:	e1a02003 	mov	r2, r3
21f2b8fc:	e51b3020 	ldr	r3, [fp, #-32]
21f2b900:	e1520003 	cmp	r2, r3
21f2b904:	2a000002 	bcs	21f2b914 <AT91F_DataFlashWriteBuffer+0x70>
		return DATAFLASH_BAD_ADDRESS;
21f2b908:	e3a03005 	mov	r3, #5	; 0x5
21f2b90c:	e50b3024 	str	r3, [fp, #-36]
21f2b910:	ea00006e 	b	21f2bad0 <AT91F_DataFlashWriteBuffer+0x22c>

	if ( (pDataFlash->pDataFlashDesc->state)  != IDLE)
21f2b914:	e51b3014 	ldr	r3, [fp, #-20]
21f2b918:	e5933000 	ldr	r3, [r3]
21f2b91c:	e5d33020 	ldrb	r3, [r3, #32]
21f2b920:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b924:	e3530000 	cmp	r3, #0	; 0x0
21f2b928:	0a000002 	beq	21f2b938 <AT91F_DataFlashWriteBuffer+0x94>
		return DATAFLASH_BUSY;
21f2b92c:	e3a03000 	mov	r3, #0	; 0x0
21f2b930:	e50b3024 	str	r3, [fp, #-36]
21f2b934:	ea000065 	b	21f2bad0 <AT91F_DataFlashWriteBuffer+0x22c>

	/* Send first Write Command */
	pDataFlash->pDataFlashDesc->command[0] = BufferCommand;
21f2b938:	e51b3014 	ldr	r3, [fp, #-20]
21f2b93c:	e5932000 	ldr	r2, [r3]
21f2b940:	e55b3018 	ldrb	r3, [fp, #-24]
21f2b944:	e5c23022 	strb	r3, [r2, #34]
	pDataFlash->pDataFlashDesc->command[1] = 0;
21f2b948:	e51b3014 	ldr	r3, [fp, #-20]
21f2b94c:	e5932000 	ldr	r2, [r3]
21f2b950:	e3a03000 	mov	r3, #0	; 0x0
21f2b954:	e5c23023 	strb	r3, [r2, #35]
	if (pDataFlash->pDevice->pages_number >= 16384) {
21f2b958:	e51b3014 	ldr	r3, [fp, #-20]
21f2b95c:	e5933004 	ldr	r3, [r3, #4]
21f2b960:	e5932000 	ldr	r2, [r3]
21f2b964:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2b968:	e283303f 	add	r3, r3, #63	; 0x3f
21f2b96c:	e1520003 	cmp	r2, r3
21f2b970:	da000016 	ble	21f2b9d0 <AT91F_DataFlashWriteBuffer+0x12c>
	    	pDataFlash->pDataFlashDesc->command[2] = 0;
21f2b974:	e51b3014 	ldr	r3, [fp, #-20]
21f2b978:	e5932000 	ldr	r2, [r3]
21f2b97c:	e3a03000 	mov	r3, #0	; 0x0
21f2b980:	e5c23024 	strb	r3, [r2, #36]
	    	pDataFlash->pDataFlashDesc->command[3] = (unsigned char)(((unsigned int)(bufferAddress &  pDataFlash->pDevice->byte_mask)) >> 8) ;
21f2b984:	e51b3014 	ldr	r3, [fp, #-20]
21f2b988:	e5931000 	ldr	r1, [r3]
21f2b98c:	e51b3014 	ldr	r3, [fp, #-20]
21f2b990:	e5933004 	ldr	r3, [r3, #4]
21f2b994:	e593300c 	ldr	r3, [r3, #12]
21f2b998:	e1a02003 	mov	r2, r3
21f2b99c:	e51b3020 	ldr	r3, [fp, #-32]
21f2b9a0:	e0023003 	and	r3, r2, r3
21f2b9a4:	e1a03423 	mov	r3, r3, lsr #8
21f2b9a8:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b9ac:	e5c13025 	strb	r3, [r1, #37]
	    	pDataFlash->pDataFlashDesc->command[4] = (unsigned char)((unsigned int)bufferAddress  & 0x00FF) ;
21f2b9b0:	e51b3014 	ldr	r3, [fp, #-20]
21f2b9b4:	e5932000 	ldr	r2, [r3]
21f2b9b8:	e51b3020 	ldr	r3, [fp, #-32]
21f2b9bc:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b9c0:	e5c23026 	strb	r3, [r2, #38]
		cmdsize = 5;
21f2b9c4:	e3a03005 	mov	r3, #5	; 0x5
21f2b9c8:	e50b3010 	str	r3, [fp, #-16]
21f2b9cc:	ea000015 	b	21f2ba28 <AT91F_DataFlashWriteBuffer+0x184>
	} else {
	    	pDataFlash->pDataFlashDesc->command[2] = (unsigned char)(((unsigned int)(bufferAddress &  pDataFlash->pDevice->byte_mask)) >> 8) ;
21f2b9d0:	e51b3014 	ldr	r3, [fp, #-20]
21f2b9d4:	e5931000 	ldr	r1, [r3]
21f2b9d8:	e51b3014 	ldr	r3, [fp, #-20]
21f2b9dc:	e5933004 	ldr	r3, [r3, #4]
21f2b9e0:	e593300c 	ldr	r3, [r3, #12]
21f2b9e4:	e1a02003 	mov	r2, r3
21f2b9e8:	e51b3020 	ldr	r3, [fp, #-32]
21f2b9ec:	e0023003 	and	r3, r2, r3
21f2b9f0:	e1a03423 	mov	r3, r3, lsr #8
21f2b9f4:	e20330ff 	and	r3, r3, #255	; 0xff
21f2b9f8:	e5c13024 	strb	r3, [r1, #36]
	    	pDataFlash->pDataFlashDesc->command[3] = (unsigned char)((unsigned int)bufferAddress  & 0x00FF) ;
21f2b9fc:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba00:	e5932000 	ldr	r2, [r3]
21f2ba04:	e51b3020 	ldr	r3, [fp, #-32]
21f2ba08:	e20330ff 	and	r3, r3, #255	; 0xff
21f2ba0c:	e5c23025 	strb	r3, [r2, #37]
	    	pDataFlash->pDataFlashDesc->command[4] = 0;
21f2ba10:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba14:	e5932000 	ldr	r2, [r3]
21f2ba18:	e3a03000 	mov	r3, #0	; 0x0
21f2ba1c:	e5c23026 	strb	r3, [r2, #38]
		cmdsize = 4;
21f2ba20:	e3a03004 	mov	r3, #4	; 0x4
21f2ba24:	e50b3010 	str	r3, [fp, #-16]
	}

	pDataFlash->pDataFlashDesc->tx_cmd_pt 	 = pDataFlash->pDataFlashDesc->command ;
21f2ba28:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba2c:	e5932000 	ldr	r2, [r3]
21f2ba30:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba34:	e5933000 	ldr	r3, [r3]
21f2ba38:	e2833022 	add	r3, r3, #34	; 0x22
21f2ba3c:	e5823000 	str	r3, [r2]
	pDataFlash->pDataFlashDesc->tx_cmd_size = cmdsize ;
21f2ba40:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba44:	e5932000 	ldr	r2, [r3]
21f2ba48:	e51b3010 	ldr	r3, [fp, #-16]
21f2ba4c:	e5823004 	str	r3, [r2, #4]
	pDataFlash->pDataFlashDesc->rx_cmd_pt 	 = pDataFlash->pDataFlashDesc->command ;
21f2ba50:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba54:	e5932000 	ldr	r2, [r3]
21f2ba58:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba5c:	e5933000 	ldr	r3, [r3]
21f2ba60:	e2833022 	add	r3, r3, #34	; 0x22
21f2ba64:	e5823008 	str	r3, [r2, #8]
	pDataFlash->pDataFlashDesc->rx_cmd_size = cmdsize ;
21f2ba68:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba6c:	e5932000 	ldr	r2, [r3]
21f2ba70:	e51b3010 	ldr	r3, [fp, #-16]
21f2ba74:	e582300c 	str	r3, [r2, #12]

	pDataFlash->pDataFlashDesc->rx_data_pt 	= dataBuffer ;
21f2ba78:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba7c:	e5932000 	ldr	r2, [r3]
21f2ba80:	e51b301c 	ldr	r3, [fp, #-28]
21f2ba84:	e5823018 	str	r3, [r2, #24]
	pDataFlash->pDataFlashDesc->tx_data_pt 	= dataBuffer ;
21f2ba88:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba8c:	e5932000 	ldr	r2, [r3]
21f2ba90:	e51b301c 	ldr	r3, [fp, #-28]
21f2ba94:	e5823010 	str	r3, [r2, #16]
	pDataFlash->pDataFlashDesc->rx_data_size 	= SizeToWrite ;
21f2ba98:	e51b3014 	ldr	r3, [fp, #-20]
21f2ba9c:	e5932000 	ldr	r2, [r3]
21f2baa0:	e59b3004 	ldr	r3, [fp, #4]
21f2baa4:	e582301c 	str	r3, [r2, #28]
	pDataFlash->pDataFlashDesc->tx_data_size 	= SizeToWrite ;
21f2baa8:	e51b3014 	ldr	r3, [fp, #-20]
21f2baac:	e5932000 	ldr	r2, [r3]
21f2bab0:	e59b3004 	ldr	r3, [fp, #4]
21f2bab4:	e5823014 	str	r3, [r2, #20]

	return AT91F_SpiWrite(pDataFlash->pDataFlashDesc);
21f2bab8:	e51b3014 	ldr	r3, [fp, #-20]
21f2babc:	e5933000 	ldr	r3, [r3]
21f2bac0:	e1a00003 	mov	r0, r3
21f2bac4:	ebfffd8c 	bl	21f2b0fc <AT91F_SpiWrite>
21f2bac8:	e1a03000 	mov	r3, r0
21f2bacc:	e50b3024 	str	r3, [fp, #-36]
21f2bad0:	e51b3024 	ldr	r3, [fp, #-36]
}
21f2bad4:	e1a00003 	mov	r0, r3
21f2bad8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2badc:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2bae0 <AT91F_PageErase>:

/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_PageErase                                        */
/* Object              : Erase a page 						*/
/* Input Parameters    : DataFlash Service					*/
/*                     : Page concerned						*/
/*                     : 							*/
/* Return value		: State of the dataflash				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_PageErase(
	AT91PS_DataFlash pDataFlash,
	unsigned int page)
{
21f2bae0:	e1a0c00d 	mov	ip, sp
21f2bae4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2bae8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2baec:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2baf0:	e50b0014 	str	r0, [fp, #-20]
21f2baf4:	e50b1018 	str	r1, [fp, #-24]
	int cmdsize;
	/* Test if the buffer command is legal */
	/* no data to transmit or receive */
    	pDataFlash->pDataFlashDesc->tx_data_size = 0;
21f2baf8:	e51b3014 	ldr	r3, [fp, #-20]
21f2bafc:	e5932000 	ldr	r2, [r3]
21f2bb00:	e3a03000 	mov	r3, #0	; 0x0
21f2bb04:	e5823014 	str	r3, [r2, #20]

	cmdsize = 4;
21f2bb08:	e3a03004 	mov	r3, #4	; 0x4
21f2bb0c:	e50b3010 	str	r3, [fp, #-16]
	if (pDataFlash->pDevice->pages_number >= 16384)
21f2bb10:	e51b3014 	ldr	r3, [fp, #-20]
21f2bb14:	e5933004 	ldr	r3, [r3, #4]
21f2bb18:	e5932000 	ldr	r2, [r3]
21f2bb1c:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2bb20:	e283303f 	add	r3, r3, #63	; 0x3f
21f2bb24:	e1520003 	cmp	r2, r3
21f2bb28:	da000001 	ble	21f2bb34 <AT91F_PageErase+0x54>
		cmdsize = 5;
21f2bb2c:	e3a03005 	mov	r3, #5	; 0x5
21f2bb30:	e50b3010 	str	r3, [fp, #-16]
	return(AT91F_DataFlashSendCommand (pDataFlash, DB_PAGE_ERASE, cmdsize, page*pDataFlash->pDevice->pages_size));
21f2bb34:	e51bc010 	ldr	ip, [fp, #-16]
21f2bb38:	e51b3014 	ldr	r3, [fp, #-20]
21f2bb3c:	e5933004 	ldr	r3, [r3, #4]
21f2bb40:	e5933004 	ldr	r3, [r3, #4]
21f2bb44:	e1a02003 	mov	r2, r3
21f2bb48:	e51b3018 	ldr	r3, [fp, #-24]
21f2bb4c:	e0030392 	mul	r3, r2, r3
21f2bb50:	e51b0014 	ldr	r0, [fp, #-20]
21f2bb54:	e3a01081 	mov	r1, #129	; 0x81
21f2bb58:	e1a0200c 	mov	r2, ip
21f2bb5c:	ebfffdcf 	bl	21f2b2a0 <AT91F_DataFlashSendCommand>
21f2bb60:	e1a03000 	mov	r3, r0
}
21f2bb64:	e1a00003 	mov	r0, r3
21f2bb68:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2bb6c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2bb70 <AT91F_BlockErase>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_BlockErase                                       */
/* Object              : Erase a Block 						*/
/* Input Parameters    : DataFlash Service					*/
/*                     : Page concerned						*/
/*                     : 							*/
/* Return value		: State of the dataflash				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_BlockErase(
	AT91PS_DataFlash pDataFlash,
	unsigned int block)
{
21f2bb70:	e1a0c00d 	mov	ip, sp
21f2bb74:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2bb78:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2bb7c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2bb80:	e50b0014 	str	r0, [fp, #-20]
21f2bb84:	e50b1018 	str	r1, [fp, #-24]
	int cmdsize;
	/* Test if the buffer command is legal */
	/* no data to transmit or receive */
    	pDataFlash->pDataFlashDesc->tx_data_size = 0;
21f2bb88:	e51b3014 	ldr	r3, [fp, #-20]
21f2bb8c:	e5932000 	ldr	r2, [r3]
21f2bb90:	e3a03000 	mov	r3, #0	; 0x0
21f2bb94:	e5823014 	str	r3, [r2, #20]
	cmdsize = 4;
21f2bb98:	e3a03004 	mov	r3, #4	; 0x4
21f2bb9c:	e50b3010 	str	r3, [fp, #-16]
	if (pDataFlash->pDevice->pages_number >= 16384)
21f2bba0:	e51b3014 	ldr	r3, [fp, #-20]
21f2bba4:	e5933004 	ldr	r3, [r3, #4]
21f2bba8:	e5932000 	ldr	r2, [r3]
21f2bbac:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2bbb0:	e283303f 	add	r3, r3, #63	; 0x3f
21f2bbb4:	e1520003 	cmp	r2, r3
21f2bbb8:	da000001 	ble	21f2bbc4 <AT91F_BlockErase+0x54>
		cmdsize = 5;
21f2bbbc:	e3a03005 	mov	r3, #5	; 0x5
21f2bbc0:	e50b3010 	str	r3, [fp, #-16]
	return(AT91F_DataFlashSendCommand (pDataFlash, DB_BLOCK_ERASE,cmdsize, block*8*pDataFlash->pDevice->pages_size));
21f2bbc4:	e51bc010 	ldr	ip, [fp, #-16]
21f2bbc8:	e51b3014 	ldr	r3, [fp, #-20]
21f2bbcc:	e5933004 	ldr	r3, [r3, #4]
21f2bbd0:	e5933004 	ldr	r3, [r3, #4]
21f2bbd4:	e1a02003 	mov	r2, r3
21f2bbd8:	e51b3018 	ldr	r3, [fp, #-24]
21f2bbdc:	e0030392 	mul	r3, r2, r3
21f2bbe0:	e1a03183 	mov	r3, r3, lsl #3
21f2bbe4:	e51b0014 	ldr	r0, [fp, #-20]
21f2bbe8:	e3a01050 	mov	r1, #80	; 0x50
21f2bbec:	e1a0200c 	mov	r2, ip
21f2bbf0:	ebfffdaa 	bl	21f2b2a0 <AT91F_DataFlashSendCommand>
21f2bbf4:	e1a03000 	mov	r3, r0
}
21f2bbf8:	e1a00003 	mov	r0, r3
21f2bbfc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2bc00:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2bc04 <AT91F_WriteBufferToMain>:

/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_WriteBufferToMain				*/
/* Object              : Write buffer to the main memory			*/
/* Input Parameters    : DataFlash Service					*/
/*		: <BufferCommand> = command to send to buffer1 or buffer2	*/
/*                     : <dest> = main memory address				*/
/* Return value		: State of the dataflash				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_WriteBufferToMain (
	AT91PS_DataFlash pDataFlash,
	unsigned char BufferCommand,
	unsigned int dest )
{
21f2bc04:	e1a0c00d 	mov	ip, sp
21f2bc08:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2bc0c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2bc10:	e24dd014 	sub	sp, sp, #20	; 0x14
21f2bc14:	e50b0014 	str	r0, [fp, #-20]
21f2bc18:	e1a03001 	mov	r3, r1
21f2bc1c:	e50b201c 	str	r2, [fp, #-28]
21f2bc20:	e54b3018 	strb	r3, [fp, #-24]
	int cmdsize;
	/* Test if the buffer command is correct */
	if ((BufferCommand != DB_BUF1_PAGE_PGM) &&
21f2bc24:	e55b3018 	ldrb	r3, [fp, #-24]
21f2bc28:	e3530088 	cmp	r3, #136	; 0x88
21f2bc2c:	0a00000b 	beq	21f2bc60 <AT91F_WriteBufferToMain+0x5c>
21f2bc30:	e55b3018 	ldrb	r3, [fp, #-24]
21f2bc34:	e3530083 	cmp	r3, #131	; 0x83
21f2bc38:	0a000008 	beq	21f2bc60 <AT91F_WriteBufferToMain+0x5c>
21f2bc3c:	e55b3018 	ldrb	r3, [fp, #-24]
21f2bc40:	e3530089 	cmp	r3, #137	; 0x89
21f2bc44:	0a000005 	beq	21f2bc60 <AT91F_WriteBufferToMain+0x5c>
21f2bc48:	e55b3018 	ldrb	r3, [fp, #-24]
21f2bc4c:	e3530086 	cmp	r3, #134	; 0x86
21f2bc50:	0a000002 	beq	21f2bc60 <AT91F_WriteBufferToMain+0x5c>
	    (BufferCommand != DB_BUF1_PAGE_ERASE_PGM) &&
	    (BufferCommand != DB_BUF2_PAGE_PGM) &&
	    (BufferCommand != DB_BUF2_PAGE_ERASE_PGM) )
		return DATAFLASH_BAD_COMMAND;
21f2bc54:	e3a03004 	mov	r3, #4	; 0x4
21f2bc58:	e50b3020 	str	r3, [fp, #-32]
21f2bc5c:	ea000016 	b	21f2bcbc <AT91F_WriteBufferToMain+0xb8>

	/* no data to transmit or receive */
	pDataFlash->pDataFlashDesc->tx_data_size = 0;
21f2bc60:	e51b3014 	ldr	r3, [fp, #-20]
21f2bc64:	e5932000 	ldr	r2, [r3]
21f2bc68:	e3a03000 	mov	r3, #0	; 0x0
21f2bc6c:	e5823014 	str	r3, [r2, #20]

	cmdsize = 4;
21f2bc70:	e3a03004 	mov	r3, #4	; 0x4
21f2bc74:	e50b3010 	str	r3, [fp, #-16]
	if (pDataFlash->pDevice->pages_number >= 16384)
21f2bc78:	e51b3014 	ldr	r3, [fp, #-20]
21f2bc7c:	e5933004 	ldr	r3, [r3, #4]
21f2bc80:	e5932000 	ldr	r2, [r3]
21f2bc84:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2bc88:	e283303f 	add	r3, r3, #63	; 0x3f
21f2bc8c:	e1520003 	cmp	r2, r3
21f2bc90:	da000001 	ble	21f2bc9c <AT91F_WriteBufferToMain+0x98>
		cmdsize = 5;
21f2bc94:	e3a03005 	mov	r3, #5	; 0x5
21f2bc98:	e50b3010 	str	r3, [fp, #-16]
	/* Send the command to the dataflash */
	return(AT91F_DataFlashSendCommand (pDataFlash, BufferCommand, cmdsize, dest));
21f2bc9c:	e55b3018 	ldrb	r3, [fp, #-24]
21f2bca0:	e51b2010 	ldr	r2, [fp, #-16]
21f2bca4:	e51b0014 	ldr	r0, [fp, #-20]
21f2bca8:	e1a01003 	mov	r1, r3
21f2bcac:	e51b301c 	ldr	r3, [fp, #-28]
21f2bcb0:	ebfffd7a 	bl	21f2b2a0 <AT91F_DataFlashSendCommand>
21f2bcb4:	e1a03000 	mov	r3, r0
21f2bcb8:	e50b3020 	str	r3, [fp, #-32]
21f2bcbc:	e51b3020 	ldr	r3, [fp, #-32]
}
21f2bcc0:	e1a00003 	mov	r0, r3
21f2bcc4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2bcc8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2bccc <AT91F_PartialPageWrite>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_PartialPageWrite					*/
/* Object              : Erase partielly a page					*/
/* Input Parameters    : <page> = page number					*/
/*			: <AdrInpage> = adr to begin the fading			*/
/*                     : <length> = Number of bytes to erase			*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_PartialPageWrite (
	AT91PS_DataFlash pDataFlash,
	unsigned char *src,
	unsigned int dest,
	unsigned int size)
{
21f2bccc:	e1a0c00d 	mov	ip, sp
21f2bcd0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2bcd4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2bcd8:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f2bcdc:	e50b0018 	str	r0, [fp, #-24]
21f2bce0:	e50b101c 	str	r1, [fp, #-28]
21f2bce4:	e50b2020 	str	r2, [fp, #-32]
21f2bce8:	e50b3024 	str	r3, [fp, #-36]
	unsigned int page;
	unsigned int AdrInPage;

	page = dest / (pDataFlash->pDevice->pages_size);
21f2bcec:	e51b3018 	ldr	r3, [fp, #-24]
21f2bcf0:	e5933004 	ldr	r3, [r3, #4]
21f2bcf4:	e5933004 	ldr	r3, [r3, #4]
21f2bcf8:	e51b0020 	ldr	r0, [fp, #-32]
21f2bcfc:	e1a01003 	mov	r1, r3
21f2bd00:	ebff676b 	bl	21f05ab4 <__udivsi3>
21f2bd04:	e1a03000 	mov	r3, r0
21f2bd08:	e50b3014 	str	r3, [fp, #-20]
	AdrInPage = dest % (pDataFlash->pDevice->pages_size);
21f2bd0c:	e51b3018 	ldr	r3, [fp, #-24]
21f2bd10:	e5933004 	ldr	r3, [r3, #4]
21f2bd14:	e5933004 	ldr	r3, [r3, #4]
21f2bd18:	e1a02003 	mov	r2, r3
21f2bd1c:	e51b3020 	ldr	r3, [fp, #-32]
21f2bd20:	e1a00003 	mov	r0, r3
21f2bd24:	e1a01002 	mov	r1, r2
21f2bd28:	ebff6787 	bl	21f05b4c <__umodsi3>
21f2bd2c:	e1a03000 	mov	r3, r0
21f2bd30:	e50b3010 	str	r3, [fp, #-16]

	/* Read the contents of the page in the Sram Buffer */
	AT91F_MainMemoryToBufferTransfert(pDataFlash, DB_PAGE_2_BUF1_TRF, page);
21f2bd34:	e51b0018 	ldr	r0, [fp, #-24]
21f2bd38:	e3a01053 	mov	r1, #83	; 0x53
21f2bd3c:	e51b2014 	ldr	r2, [fp, #-20]
21f2bd40:	ebfffea6 	bl	21f2b7e0 <AT91F_MainMemoryToBufferTransfert>
	AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2bd44:	e51b3018 	ldr	r3, [fp, #-24]
21f2bd48:	e5933000 	ldr	r3, [r3]
21f2bd4c:	e1a00003 	mov	r0, r3
21f2bd50:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2bd54:	e2811d05 	add	r1, r1, #320	; 0x140
21f2bd58:	ebfffe17 	bl	21f2b5bc <AT91F_DataFlashWaitReady>
	/*Update the SRAM buffer */
	AT91F_DataFlashWriteBuffer(pDataFlash, DB_BUF1_WRITE, src, AdrInPage, size);
21f2bd5c:	e51b3024 	ldr	r3, [fp, #-36]
21f2bd60:	e58d3000 	str	r3, [sp]
21f2bd64:	e51b0018 	ldr	r0, [fp, #-24]
21f2bd68:	e3a01084 	mov	r1, #132	; 0x84
21f2bd6c:	e51b201c 	ldr	r2, [fp, #-28]
21f2bd70:	e51b3010 	ldr	r3, [fp, #-16]
21f2bd74:	ebfffeca 	bl	21f2b8a4 <AT91F_DataFlashWriteBuffer>

	AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2bd78:	e51b3018 	ldr	r3, [fp, #-24]
21f2bd7c:	e5933000 	ldr	r3, [r3]
21f2bd80:	e1a00003 	mov	r0, r3
21f2bd84:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2bd88:	e2811d05 	add	r1, r1, #320	; 0x140
21f2bd8c:	ebfffe0a 	bl	21f2b5bc <AT91F_DataFlashWaitReady>

	/* Erase page if a 128 Mbits device */
	if (pDataFlash->pDevice->pages_number >= 16384) {
21f2bd90:	e51b3018 	ldr	r3, [fp, #-24]
21f2bd94:	e5933004 	ldr	r3, [r3, #4]
21f2bd98:	e5932000 	ldr	r2, [r3]
21f2bd9c:	e3a03dff 	mov	r3, #16320	; 0x3fc0
21f2bda0:	e283303f 	add	r3, r3, #63	; 0x3f
21f2bda4:	e1520003 	cmp	r2, r3
21f2bda8:	da000008 	ble	21f2bdd0 <AT91F_PartialPageWrite+0x104>
		AT91F_PageErase(pDataFlash, page);
21f2bdac:	e51b0018 	ldr	r0, [fp, #-24]
21f2bdb0:	e51b1014 	ldr	r1, [fp, #-20]
21f2bdb4:	ebffff49 	bl	21f2bae0 <AT91F_PageErase>
		/* Rewrite the modified Sram Buffer in the main memory */
		AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2bdb8:	e51b3018 	ldr	r3, [fp, #-24]
21f2bdbc:	e5933000 	ldr	r3, [r3]
21f2bdc0:	e1a00003 	mov	r0, r3
21f2bdc4:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2bdc8:	e2811d05 	add	r1, r1, #320	; 0x140
21f2bdcc:	ebfffdfa 	bl	21f2b5bc <AT91F_DataFlashWaitReady>
	}

	/* Rewrite the modified Sram Buffer in the main memory */
	return(AT91F_WriteBufferToMain(pDataFlash, DB_BUF1_PAGE_ERASE_PGM, (page*pDataFlash->pDevice->pages_size)));
21f2bdd0:	e51b3018 	ldr	r3, [fp, #-24]
21f2bdd4:	e5933004 	ldr	r3, [r3, #4]
21f2bdd8:	e5933004 	ldr	r3, [r3, #4]
21f2bddc:	e1a02003 	mov	r2, r3
21f2bde0:	e51b3014 	ldr	r3, [fp, #-20]
21f2bde4:	e0030392 	mul	r3, r2, r3
21f2bde8:	e51b0018 	ldr	r0, [fp, #-24]
21f2bdec:	e3a01083 	mov	r1, #131	; 0x83
21f2bdf0:	e1a02003 	mov	r2, r3
21f2bdf4:	ebffff82 	bl	21f2bc04 <AT91F_WriteBufferToMain>
21f2bdf8:	e1a03000 	mov	r3, r0
}
21f2bdfc:	e1a00003 	mov	r0, r3
21f2be00:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2be04:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2be08 <AT91F_DataFlashWrite>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_DataFlashWrite					*/
/* Object              :							*/
/* Input Parameters    : <*src> = Source buffer					*/
/*                     : <dest> = dataflash adress				*/
/*                     : <size> = data buffer size				*/
/*------------------------------------------------------------------------------*/
AT91S_DataFlashStatus AT91F_DataFlashWrite(
	AT91PS_DataFlash pDataFlash,
	unsigned char *src,
	int dest,
	int size )
{
21f2be08:	e1a0c00d 	mov	ip, sp
21f2be0c:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f2be10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2be14:	e24dd024 	sub	sp, sp, #36	; 0x24
21f2be18:	e50b0020 	str	r0, [fp, #-32]
21f2be1c:	e50b1024 	str	r1, [fp, #-36]
21f2be20:	e50b2028 	str	r2, [fp, #-40]
21f2be24:	e50b302c 	str	r3, [fp, #-44]
	unsigned int length;
	unsigned int page;
	unsigned int status;

	AT91F_SpiEnable(pDataFlash->pDevice->cs);
21f2be28:	e51b3020 	ldr	r3, [fp, #-32]
21f2be2c:	e5933004 	ldr	r3, [r3, #4]
21f2be30:	e5933010 	ldr	r3, [r3, #16]
21f2be34:	e1a00003 	mov	r0, r3
21f2be38:	ebfffc72 	bl	21f2b008 <AT91F_SpiEnable>

	if ( (dest + size) > (pDataFlash->pDevice->pages_size * (pDataFlash->pDevice->pages_number)))
21f2be3c:	e51b2028 	ldr	r2, [fp, #-40]
21f2be40:	e51b302c 	ldr	r3, [fp, #-44]
21f2be44:	e0821003 	add	r1, r2, r3
21f2be48:	e51b3020 	ldr	r3, [fp, #-32]
21f2be4c:	e5933004 	ldr	r3, [r3, #4]
21f2be50:	e5932004 	ldr	r2, [r3, #4]
21f2be54:	e51b3020 	ldr	r3, [fp, #-32]
21f2be58:	e5933004 	ldr	r3, [r3, #4]
21f2be5c:	e5933000 	ldr	r3, [r3]
21f2be60:	e0030392 	mul	r3, r2, r3
21f2be64:	e1510003 	cmp	r1, r3
21f2be68:	da000002 	ble	21f2be78 <AT91F_DataFlashWrite+0x70>
		return DATAFLASH_MEMORY_OVERFLOW;
21f2be6c:	e3a03003 	mov	r3, #3	; 0x3
21f2be70:	e50b3030 	str	r3, [fp, #-48]
21f2be74:	ea0000ac 	b	21f2c12c <AT91F_DataFlashWrite+0x324>

	/* If destination does not fit a page start address */
	if ((dest % ((unsigned int)(pDataFlash->pDevice->pages_size)))  != 0 ) {
21f2be78:	e51b2028 	ldr	r2, [fp, #-40]
21f2be7c:	e51b3020 	ldr	r3, [fp, #-32]
21f2be80:	e5933004 	ldr	r3, [r3, #4]
21f2be84:	e5933004 	ldr	r3, [r3, #4]
21f2be88:	e1a00002 	mov	r0, r2
21f2be8c:	e1a01003 	mov	r1, r3
21f2be90:	ebff672d 	bl	21f05b4c <__umodsi3>
21f2be94:	e1a03000 	mov	r3, r0
21f2be98:	e3530000 	cmp	r3, #0	; 0x0
21f2be9c:	0a000083 	beq	21f2c0b0 <AT91F_DataFlashWrite+0x2a8>
		length = pDataFlash->pDevice->pages_size - (dest % ((unsigned int)(pDataFlash->pDevice->pages_size)));
21f2bea0:	e51b3020 	ldr	r3, [fp, #-32]
21f2bea4:	e5933004 	ldr	r3, [r3, #4]
21f2bea8:	e5933004 	ldr	r3, [r3, #4]
21f2beac:	e1a04003 	mov	r4, r3
21f2beb0:	e51b2028 	ldr	r2, [fp, #-40]
21f2beb4:	e51b3020 	ldr	r3, [fp, #-32]
21f2beb8:	e5933004 	ldr	r3, [r3, #4]
21f2bebc:	e5933004 	ldr	r3, [r3, #4]
21f2bec0:	e1a00002 	mov	r0, r2
21f2bec4:	e1a01003 	mov	r1, r3
21f2bec8:	ebff671f 	bl	21f05b4c <__umodsi3>
21f2becc:	e1a03000 	mov	r3, r0
21f2bed0:	e0633004 	rsb	r3, r3, r4
21f2bed4:	e50b301c 	str	r3, [fp, #-28]

		if (size < length)
21f2bed8:	e51b202c 	ldr	r2, [fp, #-44]
21f2bedc:	e51b301c 	ldr	r3, [fp, #-28]
21f2bee0:	e1520003 	cmp	r2, r3
21f2bee4:	2a000001 	bcs	21f2bef0 <AT91F_DataFlashWrite+0xe8>
			length = size;
21f2bee8:	e51b302c 	ldr	r3, [fp, #-44]
21f2beec:	e50b301c 	str	r3, [fp, #-28]

		if(!AT91F_PartialPageWrite(pDataFlash,src, dest, length))
21f2bef0:	e51b3028 	ldr	r3, [fp, #-40]
21f2bef4:	e51b0020 	ldr	r0, [fp, #-32]
21f2bef8:	e51b1024 	ldr	r1, [fp, #-36]
21f2befc:	e1a02003 	mov	r2, r3
21f2bf00:	e51b301c 	ldr	r3, [fp, #-28]
21f2bf04:	ebffff70 	bl	21f2bccc <AT91F_PartialPageWrite>
21f2bf08:	e1a03000 	mov	r3, r0
21f2bf0c:	e3530000 	cmp	r3, #0	; 0x0
21f2bf10:	1a000002 	bne	21f2bf20 <AT91F_DataFlashWrite+0x118>
			return DATAFLASH_ERROR;
21f2bf14:	e3a03002 	mov	r3, #2	; 0x2
21f2bf18:	e50b3030 	str	r3, [fp, #-48]
21f2bf1c:	ea000082 	b	21f2c12c <AT91F_DataFlashWrite+0x324>

		AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2bf20:	e51b3020 	ldr	r3, [fp, #-32]
21f2bf24:	e5933000 	ldr	r3, [r3]
21f2bf28:	e1a00003 	mov	r0, r3
21f2bf2c:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2bf30:	e2811d05 	add	r1, r1, #320	; 0x140
21f2bf34:	ebfffda0 	bl	21f2b5bc <AT91F_DataFlashWaitReady>

		/* Update size, source and destination pointers */
		size -= length;
21f2bf38:	e51b202c 	ldr	r2, [fp, #-44]
21f2bf3c:	e51b301c 	ldr	r3, [fp, #-28]
21f2bf40:	e0633002 	rsb	r3, r3, r2
21f2bf44:	e50b302c 	str	r3, [fp, #-44]
		dest += length;
21f2bf48:	e51b2028 	ldr	r2, [fp, #-40]
21f2bf4c:	e51b301c 	ldr	r3, [fp, #-28]
21f2bf50:	e0823003 	add	r3, r2, r3
21f2bf54:	e50b3028 	str	r3, [fp, #-40]
		src += length;
21f2bf58:	e51b201c 	ldr	r2, [fp, #-28]
21f2bf5c:	e51b3024 	ldr	r3, [fp, #-36]
21f2bf60:	e0833002 	add	r3, r3, r2
21f2bf64:	e50b3024 	str	r3, [fp, #-36]
21f2bf68:	ea000050 	b	21f2c0b0 <AT91F_DataFlashWrite+0x2a8>
	}

	while (( size - pDataFlash->pDevice->pages_size ) >= 0 ) {
		/* program dataflash page */
		page = (unsigned int)dest / (pDataFlash->pDevice->pages_size);
21f2bf6c:	e51b2028 	ldr	r2, [fp, #-40]
21f2bf70:	e51b3020 	ldr	r3, [fp, #-32]
21f2bf74:	e5933004 	ldr	r3, [r3, #4]
21f2bf78:	e5933004 	ldr	r3, [r3, #4]
21f2bf7c:	e1a00002 	mov	r0, r2
21f2bf80:	e1a01003 	mov	r1, r3
21f2bf84:	ebff66ca 	bl	21f05ab4 <__udivsi3>
21f2bf88:	e1a03000 	mov	r3, r0
21f2bf8c:	e50b3018 	str	r3, [fp, #-24]

		status = AT91F_DataFlashWriteBuffer(pDataFlash, DB_BUF1_WRITE, src, 0, pDataFlash->pDevice->pages_size);
21f2bf90:	e51b3020 	ldr	r3, [fp, #-32]
21f2bf94:	e5933004 	ldr	r3, [r3, #4]
21f2bf98:	e5933004 	ldr	r3, [r3, #4]
21f2bf9c:	e58d3000 	str	r3, [sp]
21f2bfa0:	e51b0020 	ldr	r0, [fp, #-32]
21f2bfa4:	e3a01084 	mov	r1, #132	; 0x84
21f2bfa8:	e51b2024 	ldr	r2, [fp, #-36]
21f2bfac:	e3a03000 	mov	r3, #0	; 0x0
21f2bfb0:	ebfffe3b 	bl	21f2b8a4 <AT91F_DataFlashWriteBuffer>
21f2bfb4:	e1a03000 	mov	r3, r0
21f2bfb8:	e50b3014 	str	r3, [fp, #-20]
		AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2bfbc:	e51b3020 	ldr	r3, [fp, #-32]
21f2bfc0:	e5933000 	ldr	r3, [r3]
21f2bfc4:	e1a00003 	mov	r0, r3
21f2bfc8:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2bfcc:	e2811d05 	add	r1, r1, #320	; 0x140
21f2bfd0:	ebfffd79 	bl	21f2b5bc <AT91F_DataFlashWaitReady>

		status = AT91F_PageErase(pDataFlash, page);
21f2bfd4:	e51b0020 	ldr	r0, [fp, #-32]
21f2bfd8:	e51b1018 	ldr	r1, [fp, #-24]
21f2bfdc:	ebfffebf 	bl	21f2bae0 <AT91F_PageErase>
21f2bfe0:	e1a03000 	mov	r3, r0
21f2bfe4:	e50b3014 	str	r3, [fp, #-20]
		AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2bfe8:	e51b3020 	ldr	r3, [fp, #-32]
21f2bfec:	e5933000 	ldr	r3, [r3]
21f2bff0:	e1a00003 	mov	r0, r3
21f2bff4:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2bff8:	e2811d05 	add	r1, r1, #320	; 0x140
21f2bffc:	ebfffd6e 	bl	21f2b5bc <AT91F_DataFlashWaitReady>
		if (!status)
21f2c000:	e51b3014 	ldr	r3, [fp, #-20]
21f2c004:	e3530000 	cmp	r3, #0	; 0x0
21f2c008:	1a000002 	bne	21f2c018 <AT91F_DataFlashWrite+0x210>
			return DATAFLASH_ERROR;
21f2c00c:	e3a03002 	mov	r3, #2	; 0x2
21f2c010:	e50b3030 	str	r3, [fp, #-48]
21f2c014:	ea000044 	b	21f2c12c <AT91F_DataFlashWrite+0x324>

		status = AT91F_WriteBufferToMain (pDataFlash, DB_BUF1_PAGE_PGM, dest);
21f2c018:	e51b3028 	ldr	r3, [fp, #-40]
21f2c01c:	e51b0020 	ldr	r0, [fp, #-32]
21f2c020:	e3a01088 	mov	r1, #136	; 0x88
21f2c024:	e1a02003 	mov	r2, r3
21f2c028:	ebfffef5 	bl	21f2bc04 <AT91F_WriteBufferToMain>
21f2c02c:	e1a03000 	mov	r3, r0
21f2c030:	e50b3014 	str	r3, [fp, #-20]
		if(!status)
21f2c034:	e51b3014 	ldr	r3, [fp, #-20]
21f2c038:	e3530000 	cmp	r3, #0	; 0x0
21f2c03c:	1a000002 	bne	21f2c04c <AT91F_DataFlashWrite+0x244>
			return DATAFLASH_ERROR;
21f2c040:	e3a03002 	mov	r3, #2	; 0x2
21f2c044:	e50b3030 	str	r3, [fp, #-48]
21f2c048:	ea000037 	b	21f2c12c <AT91F_DataFlashWrite+0x324>

		AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2c04c:	e51b3020 	ldr	r3, [fp, #-32]
21f2c050:	e5933000 	ldr	r3, [r3]
21f2c054:	e1a00003 	mov	r0, r3
21f2c058:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2c05c:	e2811d05 	add	r1, r1, #320	; 0x140
21f2c060:	ebfffd55 	bl	21f2b5bc <AT91F_DataFlashWaitReady>

		/* Update size, source and destination pointers */
		size -= pDataFlash->pDevice->pages_size ;
21f2c064:	e51b3020 	ldr	r3, [fp, #-32]
21f2c068:	e5933004 	ldr	r3, [r3, #4]
21f2c06c:	e5932004 	ldr	r2, [r3, #4]
21f2c070:	e51b302c 	ldr	r3, [fp, #-44]
21f2c074:	e0623003 	rsb	r3, r2, r3
21f2c078:	e50b302c 	str	r3, [fp, #-44]
		dest += pDataFlash->pDevice->pages_size ;
21f2c07c:	e51b3020 	ldr	r3, [fp, #-32]
21f2c080:	e5933004 	ldr	r3, [r3, #4]
21f2c084:	e5932004 	ldr	r2, [r3, #4]
21f2c088:	e51b3028 	ldr	r3, [fp, #-40]
21f2c08c:	e0833002 	add	r3, r3, r2
21f2c090:	e50b3028 	str	r3, [fp, #-40]
		src  += pDataFlash->pDevice->pages_size ;
21f2c094:	e51b3020 	ldr	r3, [fp, #-32]
21f2c098:	e5933004 	ldr	r3, [r3, #4]
21f2c09c:	e5933004 	ldr	r3, [r3, #4]
21f2c0a0:	e1a02003 	mov	r2, r3
21f2c0a4:	e51b3024 	ldr	r3, [fp, #-36]
21f2c0a8:	e0833002 	add	r3, r3, r2
21f2c0ac:	e50b3024 	str	r3, [fp, #-36]
21f2c0b0:	e51b3020 	ldr	r3, [fp, #-32]
21f2c0b4:	e5933004 	ldr	r3, [r3, #4]
21f2c0b8:	e5932004 	ldr	r2, [r3, #4]
21f2c0bc:	e51b302c 	ldr	r3, [fp, #-44]
21f2c0c0:	e0623003 	rsb	r3, r2, r3
21f2c0c4:	e3530000 	cmp	r3, #0	; 0x0
21f2c0c8:	aaffffa7 	bge	21f2bf6c <AT91F_DataFlashWrite+0x164>
	}

	/* If still some bytes to read */
	if ( size > 0 ) {
21f2c0cc:	e51b302c 	ldr	r3, [fp, #-44]
21f2c0d0:	e3530000 	cmp	r3, #0	; 0x0
21f2c0d4:	da000012 	ble	21f2c124 <AT91F_DataFlashWrite+0x31c>
		/* program dataflash page */
		if(!AT91F_PartialPageWrite(pDataFlash, src, dest, size) )
21f2c0d8:	e51b3028 	ldr	r3, [fp, #-40]
21f2c0dc:	e51bc02c 	ldr	ip, [fp, #-44]
21f2c0e0:	e51b0020 	ldr	r0, [fp, #-32]
21f2c0e4:	e51b1024 	ldr	r1, [fp, #-36]
21f2c0e8:	e1a02003 	mov	r2, r3
21f2c0ec:	e1a0300c 	mov	r3, ip
21f2c0f0:	ebfffef5 	bl	21f2bccc <AT91F_PartialPageWrite>
21f2c0f4:	e1a03000 	mov	r3, r0
21f2c0f8:	e3530000 	cmp	r3, #0	; 0x0
21f2c0fc:	1a000002 	bne	21f2c10c <AT91F_DataFlashWrite+0x304>
			return DATAFLASH_ERROR;
21f2c100:	e3a03002 	mov	r3, #2	; 0x2
21f2c104:	e50b3030 	str	r3, [fp, #-48]
21f2c108:	ea000007 	b	21f2c12c <AT91F_DataFlashWrite+0x324>

		AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY);
21f2c10c:	e51b3020 	ldr	r3, [fp, #-32]
21f2c110:	e5933000 	ldr	r3, [r3]
21f2c114:	e1a00003 	mov	r0, r3
21f2c118:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2c11c:	e2811d05 	add	r1, r1, #320	; 0x140
21f2c120:	ebfffd25 	bl	21f2b5bc <AT91F_DataFlashWaitReady>
	}
	return DATAFLASH_OK;
21f2c124:	e3a03001 	mov	r3, #1	; 0x1
21f2c128:	e50b3030 	str	r3, [fp, #-48]
21f2c12c:	e51b3030 	ldr	r3, [fp, #-48]
}
21f2c130:	e1a00003 	mov	r0, r3
21f2c134:	e24bd010 	sub	sp, fp, #16	; 0x10
21f2c138:	e89da810 	ldmia	sp, {r4, fp, sp, pc}

21f2c13c <AT91F_DataFlashRead>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_DataFlashRead 					*/
/* Object              : Read a block in dataflash				*/
/* Input Parameters    : 							*/
/* Return value		: 							*/
/*------------------------------------------------------------------------------*/
int AT91F_DataFlashRead(
	AT91PS_DataFlash pDataFlash,
	unsigned long addr,
	unsigned long size,
	char *buffer)
{
21f2c13c:	e1a0c00d 	mov	ip, sp
21f2c140:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2c144:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2c148:	e24dd018 	sub	sp, sp, #24	; 0x18
21f2c14c:	e50b0014 	str	r0, [fp, #-20]
21f2c150:	e50b1018 	str	r1, [fp, #-24]
21f2c154:	e50b201c 	str	r2, [fp, #-28]
21f2c158:	e50b3020 	str	r3, [fp, #-32]
	unsigned long SizeToRead;

	AT91F_SpiEnable(pDataFlash->pDevice->cs);
21f2c15c:	e51b3014 	ldr	r3, [fp, #-20]
21f2c160:	e5933004 	ldr	r3, [r3, #4]
21f2c164:	e5933010 	ldr	r3, [r3, #16]
21f2c168:	e1a00003 	mov	r0, r3
21f2c16c:	ebfffba5 	bl	21f2b008 <AT91F_SpiEnable>

	if(AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY) != DATAFLASH_OK)
21f2c170:	e51b3014 	ldr	r3, [fp, #-20]
21f2c174:	e5933000 	ldr	r3, [r3]
21f2c178:	e1a00003 	mov	r0, r3
21f2c17c:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2c180:	e2811d05 	add	r1, r1, #320	; 0x140
21f2c184:	ebfffd0c 	bl	21f2b5bc <AT91F_DataFlashWaitReady>
21f2c188:	e1a03000 	mov	r3, r0
21f2c18c:	e3530001 	cmp	r3, #1	; 0x1
21f2c190:	0a00002b 	beq	21f2c244 <AT91F_DataFlashRead+0x108>
		return -1;
21f2c194:	e3e03000 	mvn	r3, #0	; 0x0
21f2c198:	e50b3024 	str	r3, [fp, #-36]
21f2c19c:	ea00002d 	b	21f2c258 <AT91F_DataFlashRead+0x11c>

	while (size) {
		SizeToRead = (size < 0x8000)? size:0x8000;
21f2c1a0:	e51b301c 	ldr	r3, [fp, #-28]
21f2c1a4:	e3530902 	cmp	r3, #32768	; 0x8000
21f2c1a8:	23a03902 	movcs	r3, #32768	; 0x8000
21f2c1ac:	e50b3010 	str	r3, [fp, #-16]

		if (AT91F_DataFlashWaitReady(pDataFlash->pDataFlashDesc, AT91C_TIMEOUT_WRDY) != DATAFLASH_OK)
21f2c1b0:	e51b3014 	ldr	r3, [fp, #-20]
21f2c1b4:	e5933000 	ldr	r3, [r3]
21f2c1b8:	e1a00003 	mov	r0, r3
21f2c1bc:	e3a01bc3 	mov	r1, #199680	; 0x30c00
21f2c1c0:	e2811d05 	add	r1, r1, #320	; 0x140
21f2c1c4:	ebfffcfc 	bl	21f2b5bc <AT91F_DataFlashWaitReady>
21f2c1c8:	e1a03000 	mov	r3, r0
21f2c1cc:	e3530001 	cmp	r3, #1	; 0x1
21f2c1d0:	0a000002 	beq	21f2c1e0 <AT91F_DataFlashRead+0xa4>
			return -1;
21f2c1d4:	e3e03000 	mvn	r3, #0	; 0x0
21f2c1d8:	e50b3024 	str	r3, [fp, #-36]
21f2c1dc:	ea00001d 	b	21f2c258 <AT91F_DataFlashRead+0x11c>

		if (AT91F_DataFlashContinuousRead (pDataFlash, addr, (uchar *)buffer, SizeToRead) != DATAFLASH_OK)
21f2c1e0:	e51b3018 	ldr	r3, [fp, #-24]
21f2c1e4:	e51b2020 	ldr	r2, [fp, #-32]
21f2c1e8:	e51bc010 	ldr	ip, [fp, #-16]
21f2c1ec:	e51b0014 	ldr	r0, [fp, #-20]
21f2c1f0:	e1a01003 	mov	r1, r3
21f2c1f4:	e1a0300c 	mov	r3, ip
21f2c1f8:	ebfffd17 	bl	21f2b65c <AT91F_DataFlashContinuousRead>
21f2c1fc:	e1a03000 	mov	r3, r0
21f2c200:	e3530001 	cmp	r3, #1	; 0x1
21f2c204:	0a000002 	beq	21f2c214 <AT91F_DataFlashRead+0xd8>
			return -1;
21f2c208:	e3e03000 	mvn	r3, #0	; 0x0
21f2c20c:	e50b3024 	str	r3, [fp, #-36]
21f2c210:	ea000010 	b	21f2c258 <AT91F_DataFlashRead+0x11c>

		size -= SizeToRead;
21f2c214:	e51b201c 	ldr	r2, [fp, #-28]
21f2c218:	e51b3010 	ldr	r3, [fp, #-16]
21f2c21c:	e0633002 	rsb	r3, r3, r2
21f2c220:	e50b301c 	str	r3, [fp, #-28]
		addr += SizeToRead;
21f2c224:	e51b2018 	ldr	r2, [fp, #-24]
21f2c228:	e51b3010 	ldr	r3, [fp, #-16]
21f2c22c:	e0823003 	add	r3, r2, r3
21f2c230:	e50b3018 	str	r3, [fp, #-24]
		buffer += SizeToRead;
21f2c234:	e51b2010 	ldr	r2, [fp, #-16]
21f2c238:	e51b3020 	ldr	r3, [fp, #-32]
21f2c23c:	e0833002 	add	r3, r3, r2
21f2c240:	e50b3020 	str	r3, [fp, #-32]
21f2c244:	e51b301c 	ldr	r3, [fp, #-28]
21f2c248:	e3530000 	cmp	r3, #0	; 0x0
21f2c24c:	1affffd3 	bne	21f2c1a0 <AT91F_DataFlashRead+0x64>
	}

	return DATAFLASH_OK;
21f2c250:	e3a03001 	mov	r3, #1	; 0x1
21f2c254:	e50b3024 	str	r3, [fp, #-36]
21f2c258:	e51b3024 	ldr	r3, [fp, #-36]
}
21f2c25c:	e1a00003 	mov	r0, r3
21f2c260:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2c264:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2c268 <AT91F_DataflashProbe>:


/*------------------------------------------------------------------------------*/
/* Function Name       : AT91F_DataflashProbe 					*/
/* Object              : 							*/
/* Input Parameters    : 							*/
/* Return value	       : Dataflash status register				*/
/*------------------------------------------------------------------------------*/
int AT91F_DataflashProbe(int cs, AT91PS_DataflashDesc pDesc)
{
21f2c268:	e1a0c00d 	mov	ip, sp
21f2c26c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2c270:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2c274:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2c278:	e50b0010 	str	r0, [fp, #-16]
21f2c27c:	e50b1014 	str	r1, [fp, #-20]
	AT91F_SpiEnable(cs);
21f2c280:	e51b0010 	ldr	r0, [fp, #-16]
21f2c284:	ebfffb5f 	bl	21f2b008 <AT91F_SpiEnable>
	AT91F_DataFlashGetStatus(pDesc);
21f2c288:	e51b0014 	ldr	r0, [fp, #-20]
21f2c28c:	ebfffc93 	bl	21f2b4e0 <AT91F_DataFlashGetStatus>
	return((pDesc->command[1] == 0xFF)? 0: pDesc->command[1] & 0x3C);
21f2c290:	e51b3014 	ldr	r3, [fp, #-20]
21f2c294:	e5d33023 	ldrb	r3, [r3, #35]
21f2c298:	e35300ff 	cmp	r3, #255	; 0xff
21f2c29c:	0a000004 	beq	21f2c2b4 <AT91F_DataflashProbe+0x4c>
21f2c2a0:	e51b3014 	ldr	r3, [fp, #-20]
21f2c2a4:	e5d33023 	ldrb	r3, [r3, #35]
21f2c2a8:	e203303c 	and	r3, r3, #60	; 0x3c
21f2c2ac:	e50b3018 	str	r3, [fp, #-24]
21f2c2b0:	ea000001 	b	21f2c2bc <AT91F_DataflashProbe+0x54>
21f2c2b4:	e3a03000 	mov	r3, #0	; 0x0
21f2c2b8:	e50b3018 	str	r3, [fp, #-24]
21f2c2bc:	e51b3018 	ldr	r3, [fp, #-24]
}
21f2c2c0:	e1a00003 	mov	r0, r3
21f2c2c4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2c2c8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2c2cc <flash_identification>:

/*-----------------------------------------------------------------------
 */
void flash_identification (flash_info_t * info)
{
21f2c2cc:	e1a0c00d 	mov	ip, sp
21f2c2d0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2c2d4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2c2d8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2c2dc:	e50b0018 	str	r0, [fp, #-24]
	volatile u16 manuf_code, device_code, add_device_code;

	MEM_FLASH_ADDR1 = FLASH_CODE1;
21f2c2e0:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c2e4:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2c2e8:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2c2ec:	e3a020aa 	mov	r2, #170	; 0xaa
21f2c2f0:	e1c320b0 	strh	r2, [r3]
	MEM_FLASH_ADDR2 = FLASH_CODE2;
21f2c2f4:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c2f8:	e2833c55 	add	r3, r3, #21760	; 0x5500
21f2c2fc:	e2833054 	add	r3, r3, #84	; 0x54
21f2c300:	e3a02055 	mov	r2, #85	; 0x55
21f2c304:	e1c320b0 	strh	r2, [r3]
	MEM_FLASH_ADDR1 = ID_IN_CODE;
21f2c308:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c30c:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2c310:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2c314:	e3a02090 	mov	r2, #144	; 0x90
21f2c318:	e1c320b0 	strh	r2, [r3]

	manuf_code = *(volatile u16 *) CFG_FLASH_BASE;
21f2c31c:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c320:	e1d330b0 	ldrh	r3, [r3]
21f2c324:	e1a03803 	mov	r3, r3, lsl #16
21f2c328:	e1a03823 	mov	r3, r3, lsr #16
21f2c32c:	e14b30be 	strh	r3, [fp, #-14]
	device_code = *(volatile u16 *) (CFG_FLASH_BASE + 2);
21f2c330:	e3a03221 	mov	r3, #268435458	; 0x10000002
21f2c334:	e1d330b0 	ldrh	r3, [r3]
21f2c338:	e1a03803 	mov	r3, r3, lsl #16
21f2c33c:	e1a03823 	mov	r3, r3, lsr #16
21f2c340:	e14b31b0 	strh	r3, [fp, #-16]
	add_device_code = *(volatile u16 *) (CFG_FLASH_BASE + (3 << 1));
21f2c344:	e3a03261 	mov	r3, #268435462	; 0x10000006
21f2c348:	e1d330b0 	ldrh	r3, [r3]
21f2c34c:	e1a03803 	mov	r3, r3, lsl #16
21f2c350:	e1a03823 	mov	r3, r3, lsr #16
21f2c354:	e14b31b2 	strh	r3, [fp, #-18]

	MEM_FLASH_ADDR1 = FLASH_CODE1;
21f2c358:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c35c:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2c360:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2c364:	e3a020aa 	mov	r2, #170	; 0xaa
21f2c368:	e1c320b0 	strh	r2, [r3]
	MEM_FLASH_ADDR2 = FLASH_CODE2;
21f2c36c:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c370:	e2833c55 	add	r3, r3, #21760	; 0x5500
21f2c374:	e2833054 	add	r3, r3, #84	; 0x54
21f2c378:	e3a02055 	mov	r2, #85	; 0x55
21f2c37c:	e1c320b0 	strh	r2, [r3]
	MEM_FLASH_ADDR1 = ID_OUT_CODE;
21f2c380:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c384:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2c388:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2c38c:	e3a020f0 	mov	r2, #240	; 0xf0
21f2c390:	e1c320b0 	strh	r2, [r3]

	/* Vendor type */
	info->flash_id = ATM_MANUFACT & FLASH_VENDMASK;
21f2c394:	e51b2018 	ldr	r2, [fp, #-24]
21f2c398:	e3a0381f 	mov	r3, #2031616	; 0x1f0000
21f2c39c:	e5823008 	str	r3, [r2, #8]
	printf ("Atmel: ");
21f2c3a0:	e59f00a0 	ldr	r0, [pc, #160]	; 21f2c448 <.text+0x2c448>
21f2c3a4:	ebffbdb8 	bl	21f1ba8c <printf>

	if ((device_code & FLASH_TYPEMASK) == (ATM_ID_BV1614 & FLASH_TYPEMASK)) {
21f2c3a8:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2c3ac:	e1a03803 	mov	r3, r3, lsl #16
21f2c3b0:	e1a03823 	mov	r3, r3, lsr #16
21f2c3b4:	e35300c0 	cmp	r3, #192	; 0xc0
21f2c3b8:	1a000014 	bne	21f2c410 <flash_identification+0x144>

		if ((add_device_code & FLASH_TYPEMASK) ==
21f2c3bc:	e15b31b2 	ldrh	r3, [fp, #-18]
21f2c3c0:	e1a03803 	mov	r3, r3, lsl #16
21f2c3c4:	e1a03823 	mov	r3, r3, lsr #16
21f2c3c8:	e35300c8 	cmp	r3, #200	; 0xc8
21f2c3cc:	1a000007 	bne	21f2c3f0 <flash_identification+0x124>
			(ATM_ID_BV1614A & FLASH_TYPEMASK)) {
			info->flash_id |= ATM_ID_BV1614A & FLASH_TYPEMASK;
21f2c3d0:	e51b3018 	ldr	r3, [fp, #-24]
21f2c3d4:	e5933008 	ldr	r3, [r3, #8]
21f2c3d8:	e38320c8 	orr	r2, r3, #200	; 0xc8
21f2c3dc:	e51b3018 	ldr	r3, [fp, #-24]
21f2c3e0:	e5832008 	str	r2, [r3, #8]
			printf ("AT49BV1614A (16Mbit)\n");
21f2c3e4:	e59f0060 	ldr	r0, [pc, #96]	; 21f2c44c <.text+0x2c44c>
21f2c3e8:	ebffbda7 	bl	21f1ba8c <printf>
21f2c3ec:	ea000013 	b	21f2c440 <flash_identification+0x174>
		} else {				/* AT49BV1614 Flash */
			info->flash_id |= ATM_ID_BV1614 & FLASH_TYPEMASK;
21f2c3f0:	e51b3018 	ldr	r3, [fp, #-24]
21f2c3f4:	e5933008 	ldr	r3, [r3, #8]
21f2c3f8:	e38320c0 	orr	r2, r3, #192	; 0xc0
21f2c3fc:	e51b3018 	ldr	r3, [fp, #-24]
21f2c400:	e5832008 	str	r2, [r3, #8]
			printf ("AT49BV1614 (16Mbit)\n");
21f2c404:	e59f0044 	ldr	r0, [pc, #68]	; 21f2c450 <.text+0x2c450>
21f2c408:	ebffbd9f 	bl	21f1ba8c <printf>
21f2c40c:	ea00000b 	b	21f2c440 <flash_identification+0x174>
		}

	} else if ((device_code & FLASH_TYPEMASK) == (ATM_ID_BV6416 & FLASH_TYPEMASK)) {
21f2c410:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2c414:	e1a03803 	mov	r3, r3, lsl #16
21f2c418:	e1a03823 	mov	r3, r3, lsr #16
21f2c41c:	e35300d6 	cmp	r3, #214	; 0xd6
21f2c420:	1a000006 	bne	21f2c440 <flash_identification+0x174>
		info->flash_id |= ATM_ID_BV6416 & FLASH_TYPEMASK;
21f2c424:	e51b3018 	ldr	r3, [fp, #-24]
21f2c428:	e5933008 	ldr	r3, [r3, #8]
21f2c42c:	e38320d6 	orr	r2, r3, #214	; 0xd6
21f2c430:	e51b3018 	ldr	r3, [fp, #-24]
21f2c434:	e5832008 	str	r2, [r3, #8]
		printf ("AT49BV6416 (64Mbit)\n");
21f2c438:	e59f0014 	ldr	r0, [pc, #20]	; 21f2c454 <.text+0x2c454>
21f2c43c:	ebffbd92 	bl	21f1ba8c <printf>
	}
}
21f2c440:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2c444:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2c448:	21f32ef8 	ldrcssh	r2, [r3, #232]!
21f2c44c:	21f32f00 	mvncss	r2, r0, lsl #30
21f2c450:	21f32f18 	mvncss	r2, r8, lsl pc
21f2c454:	21f32f30 	mvncss	r2, r0, lsr pc

21f2c458 <flash_number_sector>:

ushort flash_number_sector(OrgDef *pOrgDef, unsigned int nb_blocks)
{
21f2c458:	e1a0c00d 	mov	ip, sp
21f2c45c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2c460:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2c464:	e24dd010 	sub	sp, sp, #16	; 0x10
21f2c468:	e50b0018 	str	r0, [fp, #-24]
21f2c46c:	e50b101c 	str	r1, [fp, #-28]
	int i, nb_sectors = 0;
21f2c470:	e3a03000 	mov	r3, #0	; 0x0
21f2c474:	e50b3010 	str	r3, [fp, #-16]

	for (i=0; i<nb_blocks; i++){
21f2c478:	e3a03000 	mov	r3, #0	; 0x0
21f2c47c:	e50b3014 	str	r3, [fp, #-20]
21f2c480:	ea00000b 	b	21f2c4b4 <flash_number_sector+0x5c>
		nb_sectors += pOrgDef[i].sector_number;
21f2c484:	e51b3014 	ldr	r3, [fp, #-20]
21f2c488:	e1a03183 	mov	r3, r3, lsl #3
21f2c48c:	e1a02003 	mov	r2, r3
21f2c490:	e51b3018 	ldr	r3, [fp, #-24]
21f2c494:	e0823003 	add	r3, r2, r3
21f2c498:	e5932000 	ldr	r2, [r3]
21f2c49c:	e51b3010 	ldr	r3, [fp, #-16]
21f2c4a0:	e0823003 	add	r3, r2, r3
21f2c4a4:	e50b3010 	str	r3, [fp, #-16]
21f2c4a8:	e51b3014 	ldr	r3, [fp, #-20]
21f2c4ac:	e2833001 	add	r3, r3, #1	; 0x1
21f2c4b0:	e50b3014 	str	r3, [fp, #-20]
21f2c4b4:	e51b2014 	ldr	r2, [fp, #-20]
21f2c4b8:	e51b301c 	ldr	r3, [fp, #-28]
21f2c4bc:	e1520003 	cmp	r2, r3
21f2c4c0:	3affffef 	bcc	21f2c484 <flash_number_sector+0x2c>
	}

	return nb_sectors;
21f2c4c4:	e51b3010 	ldr	r3, [fp, #-16]
21f2c4c8:	e1a03803 	mov	r3, r3, lsl #16
21f2c4cc:	e1a03823 	mov	r3, r3, lsr #16
}
21f2c4d0:	e1a00003 	mov	r0, r3
21f2c4d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2c4d8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2c4dc <flash_unlock_sector>:

void flash_unlock_sector(flash_info_t * info, unsigned int sector)
{
21f2c4dc:	e1a0c00d 	mov	ip, sp
21f2c4e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2c4e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2c4e8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2c4ec:	e50b0014 	str	r0, [fp, #-20]
21f2c4f0:	e50b1018 	str	r1, [fp, #-24]
	volatile u16 *addr = (volatile u16 *) (info->start[sector]);
21f2c4f4:	e51b3018 	ldr	r3, [fp, #-24]
21f2c4f8:	e51b2014 	ldr	r2, [fp, #-20]
21f2c4fc:	e3a0100c 	mov	r1, #12	; 0xc
21f2c500:	e1a03103 	mov	r3, r3, lsl #2
21f2c504:	e0833002 	add	r3, r3, r2
21f2c508:	e0833001 	add	r3, r3, r1
21f2c50c:	e5933000 	ldr	r3, [r3]
21f2c510:	e50b3010 	str	r3, [fp, #-16]

	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
21f2c514:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c518:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2c51c:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2c520:	e3a020aa 	mov	r2, #170	; 0xaa
21f2c524:	e1c320b0 	strh	r2, [r3]
	*addr = CMD_SECTOR_UNLOCK;
21f2c528:	e51b2010 	ldr	r2, [fp, #-16]
21f2c52c:	e3a03070 	mov	r3, #112	; 0x70
21f2c530:	e1c230b0 	strh	r3, [r2]
}
21f2c534:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2c538:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2c53c <flash_init>:


ulong flash_init (void)
{
21f2c53c:	e1a0c00d 	mov	ip, sp
21f2c540:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f2c544:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2c548:	e24dd024 	sub	sp, sp, #36	; 0x24
	int i, j, k;
	unsigned int flash_nb_blocks, sector;
	unsigned int start_address;
	OrgDef *pOrgDef;

	ulong size = 0;
21f2c54c:	e3a03000 	mov	r3, #0	; 0x0
21f2c550:	e50b3018 	str	r3, [fp, #-24]

	for (i = 0; i < CFG_MAX_FLASH_BANKS; i++) {
21f2c554:	e3a03000 	mov	r3, #0	; 0x0
21f2c558:	e50b3034 	str	r3, [fp, #-52]
21f2c55c:	ea000144 	b	21f2ca74 <flash_init+0x538>
		ulong flashbase = 0;
21f2c560:	e3a03000 	mov	r3, #0	; 0x0
21f2c564:	e50b3014 	str	r3, [fp, #-20]

		flash_identification (&flash_info[i]);
21f2c568:	e51b2034 	ldr	r2, [fp, #-52]
21f2c56c:	e1a03002 	mov	r3, r2
21f2c570:	e1a03183 	mov	r3, r3, lsl #3
21f2c574:	e0833002 	add	r3, r3, r2
21f2c578:	e1a03083 	mov	r3, r3, lsl #1
21f2c57c:	e0833002 	add	r3, r3, r2
21f2c580:	e1a02203 	mov	r2, r3, lsl #4
21f2c584:	e0833002 	add	r3, r3, r2
21f2c588:	e1a03103 	mov	r3, r3, lsl #2
21f2c58c:	e1a02003 	mov	r2, r3
21f2c590:	e59f354c 	ldr	r3, [pc, #1356]	; 21f2cae4 <.text+0x2cae4>
21f2c594:	e0823003 	add	r3, r2, r3
21f2c598:	e1a00003 	mov	r0, r3
21f2c59c:	ebffff4a 	bl	21f2c2cc <flash_identification>

		if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
21f2c5a0:	e51b2034 	ldr	r2, [fp, #-52]
21f2c5a4:	e59f1538 	ldr	r1, [pc, #1336]	; 21f2cae4 <.text+0x2cae4>
21f2c5a8:	e3a00008 	mov	r0, #8	; 0x8
21f2c5ac:	e1a03002 	mov	r3, r2
21f2c5b0:	e1a03183 	mov	r3, r3, lsl #3
21f2c5b4:	e0833002 	add	r3, r3, r2
21f2c5b8:	e1a03083 	mov	r3, r3, lsl #1
21f2c5bc:	e0833002 	add	r3, r3, r2
21f2c5c0:	e1a02203 	mov	r2, r3, lsl #4
21f2c5c4:	e0833002 	add	r3, r3, r2
21f2c5c8:	e1a03103 	mov	r3, r3, lsl #2
21f2c5cc:	e0833001 	add	r3, r3, r1
21f2c5d0:	e0833000 	add	r3, r3, r0
21f2c5d4:	e5933000 	ldr	r3, [r3]
21f2c5d8:	e1a03803 	mov	r3, r3, lsl #16
21f2c5dc:	e1a03823 	mov	r3, r3, lsr #16
21f2c5e0:	e35300c0 	cmp	r3, #192	; 0xc0
21f2c5e4:	1a000004 	bne	21f2c5fc <flash_init+0xc0>
			(ATM_ID_BV1614 & FLASH_TYPEMASK)) {

			pOrgDef = OrgAT49BV16x4;
21f2c5e8:	e59f34f8 	ldr	r3, [pc, #1272]	; 21f2cae8 <.text+0x2cae8>
21f2c5ec:	e50b301c 	str	r3, [fp, #-28]
			flash_nb_blocks = sizeof (OrgAT49BV16x4) / sizeof (OrgDef);
21f2c5f0:	e3a03003 	mov	r3, #3	; 0x3
21f2c5f4:	e50b3028 	str	r3, [fp, #-40]
21f2c5f8:	ea000031 	b	21f2c6c4 <flash_init+0x188>
		} else if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
21f2c5fc:	e51b2034 	ldr	r2, [fp, #-52]
21f2c600:	e59f14dc 	ldr	r1, [pc, #1244]	; 21f2cae4 <.text+0x2cae4>
21f2c604:	e3a00008 	mov	r0, #8	; 0x8
21f2c608:	e1a03002 	mov	r3, r2
21f2c60c:	e1a03183 	mov	r3, r3, lsl #3
21f2c610:	e0833002 	add	r3, r3, r2
21f2c614:	e1a03083 	mov	r3, r3, lsl #1
21f2c618:	e0833002 	add	r3, r3, r2
21f2c61c:	e1a02203 	mov	r2, r3, lsl #4
21f2c620:	e0833002 	add	r3, r3, r2
21f2c624:	e1a03103 	mov	r3, r3, lsl #2
21f2c628:	e0833001 	add	r3, r3, r1
21f2c62c:	e0833000 	add	r3, r3, r0
21f2c630:	e5933000 	ldr	r3, [r3]
21f2c634:	e1a03803 	mov	r3, r3, lsl #16
21f2c638:	e1a03823 	mov	r3, r3, lsr #16
21f2c63c:	e35300c8 	cmp	r3, #200	; 0xc8
21f2c640:	1a000004 	bne	21f2c658 <flash_init+0x11c>
			(ATM_ID_BV1614A & FLASH_TYPEMASK)){	/* AT49BV1614A Flash */

			pOrgDef = OrgAT49BV16x4A;
21f2c644:	e59f34a0 	ldr	r3, [pc, #1184]	; 21f2caec <.text+0x2caec>
21f2c648:	e50b301c 	str	r3, [fp, #-28]
			flash_nb_blocks = sizeof (OrgAT49BV16x4A) / sizeof (OrgDef);
21f2c64c:	e3a03002 	mov	r3, #2	; 0x2
21f2c650:	e50b3028 	str	r3, [fp, #-40]
21f2c654:	ea00001a 	b	21f2c6c4 <flash_init+0x188>
		} else if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
21f2c658:	e51b2034 	ldr	r2, [fp, #-52]
21f2c65c:	e59f1480 	ldr	r1, [pc, #1152]	; 21f2cae4 <.text+0x2cae4>
21f2c660:	e3a00008 	mov	r0, #8	; 0x8
21f2c664:	e1a03002 	mov	r3, r2
21f2c668:	e1a03183 	mov	r3, r3, lsl #3
21f2c66c:	e0833002 	add	r3, r3, r2
21f2c670:	e1a03083 	mov	r3, r3, lsl #1
21f2c674:	e0833002 	add	r3, r3, r2
21f2c678:	e1a02203 	mov	r2, r3, lsl #4
21f2c67c:	e0833002 	add	r3, r3, r2
21f2c680:	e1a03103 	mov	r3, r3, lsl #2
21f2c684:	e0833001 	add	r3, r3, r1
21f2c688:	e0833000 	add	r3, r3, r0
21f2c68c:	e5933000 	ldr	r3, [r3]
21f2c690:	e1a03803 	mov	r3, r3, lsl #16
21f2c694:	e1a03823 	mov	r3, r3, lsr #16
21f2c698:	e35300d6 	cmp	r3, #214	; 0xd6
21f2c69c:	1a000004 	bne	21f2c6b4 <flash_init+0x178>
			(ATM_ID_BV6416 & FLASH_TYPEMASK)){	/* AT49BV6416 Flash */

			pOrgDef = OrgAT49BV6416;
21f2c6a0:	e59f3448 	ldr	r3, [pc, #1096]	; 21f2caf0 <.text+0x2caf0>
21f2c6a4:	e50b301c 	str	r3, [fp, #-28]
			flash_nb_blocks = sizeof (OrgAT49BV6416) / sizeof (OrgDef);
21f2c6a8:	e3a03002 	mov	r3, #2	; 0x2
21f2c6ac:	e50b3028 	str	r3, [fp, #-40]
21f2c6b0:	ea000003 	b	21f2c6c4 <flash_init+0x188>
		} else {
			flash_nb_blocks = 0;
21f2c6b4:	e3a03000 	mov	r3, #0	; 0x0
21f2c6b8:	e50b3028 	str	r3, [fp, #-40]
			pOrgDef = OrgAT49BV16x4;
21f2c6bc:	e59f3424 	ldr	r3, [pc, #1060]	; 21f2cae8 <.text+0x2cae8>
21f2c6c0:	e50b301c 	str	r3, [fp, #-28]
		}

		flash_info[i].sector_count = flash_number_sector(pOrgDef, flash_nb_blocks);
21f2c6c4:	e51b4034 	ldr	r4, [fp, #-52]
21f2c6c8:	e51b001c 	ldr	r0, [fp, #-28]
21f2c6cc:	e51b1028 	ldr	r1, [fp, #-40]
21f2c6d0:	ebffff60 	bl	21f2c458 <flash_number_sector>
21f2c6d4:	e1a03000 	mov	r3, r0
21f2c6d8:	e1a0c003 	mov	ip, r3
21f2c6dc:	e59f1400 	ldr	r1, [pc, #1024]	; 21f2cae4 <.text+0x2cae4>
21f2c6e0:	e3a00004 	mov	r0, #4	; 0x4
21f2c6e4:	e1a03004 	mov	r3, r4
21f2c6e8:	e1a03183 	mov	r3, r3, lsl #3
21f2c6ec:	e0833004 	add	r3, r3, r4
21f2c6f0:	e1a03083 	mov	r3, r3, lsl #1
21f2c6f4:	e0833004 	add	r3, r3, r4
21f2c6f8:	e1a02203 	mov	r2, r3, lsl #4
21f2c6fc:	e0833002 	add	r3, r3, r2
21f2c700:	e1a03103 	mov	r3, r3, lsl #2
21f2c704:	e0833001 	add	r3, r3, r1
21f2c708:	e0833000 	add	r3, r3, r0
21f2c70c:	e1c3c0b0 	strh	ip, [r3]
		memset (flash_info[i].protect, 0, flash_info[i].sector_count);
21f2c710:	e51b2034 	ldr	r2, [fp, #-52]
21f2c714:	e1a03002 	mov	r3, r2
21f2c718:	e1a03183 	mov	r3, r3, lsl #3
21f2c71c:	e0833002 	add	r3, r3, r2
21f2c720:	e1a03083 	mov	r3, r3, lsl #1
21f2c724:	e0833002 	add	r3, r3, r2
21f2c728:	e1a02203 	mov	r2, r3, lsl #4
21f2c72c:	e0833002 	add	r3, r3, r2
21f2c730:	e1a03103 	mov	r3, r3, lsl #2
21f2c734:	e2833b01 	add	r3, r3, #1024	; 0x400
21f2c738:	e283300c 	add	r3, r3, #12	; 0xc
21f2c73c:	e59f23a0 	ldr	r2, [pc, #928]	; 21f2cae4 <.text+0x2cae4>
21f2c740:	e083c002 	add	ip, r3, r2
21f2c744:	e51b2034 	ldr	r2, [fp, #-52]
21f2c748:	e59f1394 	ldr	r1, [pc, #916]	; 21f2cae4 <.text+0x2cae4>
21f2c74c:	e3a00004 	mov	r0, #4	; 0x4
21f2c750:	e1a03002 	mov	r3, r2
21f2c754:	e1a03183 	mov	r3, r3, lsl #3
21f2c758:	e0833002 	add	r3, r3, r2
21f2c75c:	e1a03083 	mov	r3, r3, lsl #1
21f2c760:	e0833002 	add	r3, r3, r2
21f2c764:	e1a02203 	mov	r2, r3, lsl #4
21f2c768:	e0833002 	add	r3, r3, r2
21f2c76c:	e1a03103 	mov	r3, r3, lsl #2
21f2c770:	e0833001 	add	r3, r3, r1
21f2c774:	e0833000 	add	r3, r3, r0
21f2c778:	e1d330b0 	ldrh	r3, [r3]
21f2c77c:	e1a0000c 	mov	r0, ip
21f2c780:	e3a01000 	mov	r1, #0	; 0x0
21f2c784:	e1a02003 	mov	r2, r3
21f2c788:	ebffda56 	bl	21f230e8 <memset>

		if (i == 0)
21f2c78c:	e51b3034 	ldr	r3, [fp, #-52]
21f2c790:	e3530000 	cmp	r3, #0	; 0x0
21f2c794:	1a000002 	bne	21f2c7a4 <flash_init+0x268>
			flashbase = PHYS_FLASH_1;
21f2c798:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2c79c:	e50b3014 	str	r3, [fp, #-20]
21f2c7a0:	ea000001 	b	21f2c7ac <flash_init+0x270>
		else
			panic ("configured too many flash banks!\n");
21f2c7a4:	e59f0348 	ldr	r0, [pc, #840]	; 21f2caf4 <.text+0x2caf4>
21f2c7a8:	ebffdfd9 	bl	21f24714 <panic>

		sector = 0;
21f2c7ac:	e3a03000 	mov	r3, #0	; 0x0
21f2c7b0:	e50b3024 	str	r3, [fp, #-36]
		start_address = flashbase;
21f2c7b4:	e51b3014 	ldr	r3, [fp, #-20]
21f2c7b8:	e50b3020 	str	r3, [fp, #-32]
		flash_info[i].size = 0;
21f2c7bc:	e51b2034 	ldr	r2, [fp, #-52]
21f2c7c0:	e59f131c 	ldr	r1, [pc, #796]	; 21f2cae4 <.text+0x2cae4>
21f2c7c4:	e1a03002 	mov	r3, r2
21f2c7c8:	e1a03183 	mov	r3, r3, lsl #3
21f2c7cc:	e0833002 	add	r3, r3, r2
21f2c7d0:	e1a03083 	mov	r3, r3, lsl #1
21f2c7d4:	e0833002 	add	r3, r3, r2
21f2c7d8:	e1a02203 	mov	r2, r3, lsl #4
21f2c7dc:	e0833002 	add	r3, r3, r2
21f2c7e0:	e1a03103 	mov	r3, r3, lsl #2
21f2c7e4:	e0832001 	add	r2, r3, r1
21f2c7e8:	e3a03000 	mov	r3, #0	; 0x0
21f2c7ec:	e5823000 	str	r3, [r2]

		for (j = 0; j < flash_nb_blocks; j++) {
21f2c7f0:	e3a03000 	mov	r3, #0	; 0x0
21f2c7f4:	e50b3030 	str	r3, [fp, #-48]
21f2c7f8:	ea00004d 	b	21f2c934 <flash_init+0x3f8>
			for (k = 0; k < pOrgDef[j].sector_number; k++) {
21f2c7fc:	e3a03000 	mov	r3, #0	; 0x0
21f2c800:	e50b302c 	str	r3, [fp, #-44]
21f2c804:	ea00003e 	b	21f2c904 <flash_init+0x3c8>
				flash_info[i].start[sector++] = start_address;
21f2c808:	e51b2034 	ldr	r2, [fp, #-52]
21f2c80c:	e51b1024 	ldr	r1, [fp, #-36]
21f2c810:	e59f02cc 	ldr	r0, [pc, #716]	; 21f2cae4 <.text+0x2cae4>
21f2c814:	e1a03002 	mov	r3, r2
21f2c818:	e1a03183 	mov	r3, r3, lsl #3
21f2c81c:	e0833002 	add	r3, r3, r2
21f2c820:	e1a03083 	mov	r3, r3, lsl #1
21f2c824:	e0833002 	add	r3, r3, r2
21f2c828:	e1a02203 	mov	r2, r3, lsl #4
21f2c82c:	e0833002 	add	r3, r3, r2
21f2c830:	e0833001 	add	r3, r3, r1
21f2c834:	e3a0200c 	mov	r2, #12	; 0xc
21f2c838:	e1a03103 	mov	r3, r3, lsl #2
21f2c83c:	e0833000 	add	r3, r3, r0
21f2c840:	e0832002 	add	r2, r3, r2
21f2c844:	e51b3020 	ldr	r3, [fp, #-32]
21f2c848:	e5823000 	str	r3, [r2]
21f2c84c:	e51b3024 	ldr	r3, [fp, #-36]
21f2c850:	e2833001 	add	r3, r3, #1	; 0x1
21f2c854:	e50b3024 	str	r3, [fp, #-36]
				start_address += pOrgDef[j].sector_size;
21f2c858:	e51b3030 	ldr	r3, [fp, #-48]
21f2c85c:	e1a03183 	mov	r3, r3, lsl #3
21f2c860:	e1a02003 	mov	r2, r3
21f2c864:	e51b301c 	ldr	r3, [fp, #-28]
21f2c868:	e0823003 	add	r3, r2, r3
21f2c86c:	e5932004 	ldr	r2, [r3, #4]
21f2c870:	e51b3020 	ldr	r3, [fp, #-32]
21f2c874:	e0833002 	add	r3, r3, r2
21f2c878:	e50b3020 	str	r3, [fp, #-32]
				flash_info[i].size += pOrgDef[j].sector_size;
21f2c87c:	e51b1034 	ldr	r1, [fp, #-52]
21f2c880:	e51b2034 	ldr	r2, [fp, #-52]
21f2c884:	e59f0258 	ldr	r0, [pc, #600]	; 21f2cae4 <.text+0x2cae4>
21f2c888:	e1a03002 	mov	r3, r2
21f2c88c:	e1a03183 	mov	r3, r3, lsl #3
21f2c890:	e0833002 	add	r3, r3, r2
21f2c894:	e1a03083 	mov	r3, r3, lsl #1
21f2c898:	e0833002 	add	r3, r3, r2
21f2c89c:	e1a02203 	mov	r2, r3, lsl #4
21f2c8a0:	e0833002 	add	r3, r3, r2
21f2c8a4:	e1a03103 	mov	r3, r3, lsl #2
21f2c8a8:	e0833000 	add	r3, r3, r0
21f2c8ac:	e5930000 	ldr	r0, [r3]
21f2c8b0:	e51b3030 	ldr	r3, [fp, #-48]
21f2c8b4:	e1a03183 	mov	r3, r3, lsl #3
21f2c8b8:	e1a02003 	mov	r2, r3
21f2c8bc:	e51b301c 	ldr	r3, [fp, #-28]
21f2c8c0:	e0823003 	add	r3, r2, r3
21f2c8c4:	e5933004 	ldr	r3, [r3, #4]
21f2c8c8:	e080c003 	add	ip, r0, r3
21f2c8cc:	e59f0210 	ldr	r0, [pc, #528]	; 21f2cae4 <.text+0x2cae4>
21f2c8d0:	e1a03001 	mov	r3, r1
21f2c8d4:	e1a03183 	mov	r3, r3, lsl #3
21f2c8d8:	e0833001 	add	r3, r3, r1
21f2c8dc:	e1a03083 	mov	r3, r3, lsl #1
21f2c8e0:	e0833001 	add	r3, r3, r1
21f2c8e4:	e1a02203 	mov	r2, r3, lsl #4
21f2c8e8:	e0833002 	add	r3, r3, r2
21f2c8ec:	e1a03103 	mov	r3, r3, lsl #2
21f2c8f0:	e0833000 	add	r3, r3, r0
21f2c8f4:	e583c000 	str	ip, [r3]
21f2c8f8:	e51b302c 	ldr	r3, [fp, #-44]
21f2c8fc:	e2833001 	add	r3, r3, #1	; 0x1
21f2c900:	e50b302c 	str	r3, [fp, #-44]
21f2c904:	e51b102c 	ldr	r1, [fp, #-44]
21f2c908:	e51b3030 	ldr	r3, [fp, #-48]
21f2c90c:	e1a03183 	mov	r3, r3, lsl #3
21f2c910:	e1a02003 	mov	r2, r3
21f2c914:	e51b301c 	ldr	r3, [fp, #-28]
21f2c918:	e0823003 	add	r3, r2, r3
21f2c91c:	e5933000 	ldr	r3, [r3]
21f2c920:	e1510003 	cmp	r1, r3
21f2c924:	3affffb7 	bcc	21f2c808 <flash_init+0x2cc>
21f2c928:	e51b3030 	ldr	r3, [fp, #-48]
21f2c92c:	e2833001 	add	r3, r3, #1	; 0x1
21f2c930:	e50b3030 	str	r3, [fp, #-48]
21f2c934:	e51b2030 	ldr	r2, [fp, #-48]
21f2c938:	e51b3028 	ldr	r3, [fp, #-40]
21f2c93c:	e1520003 	cmp	r2, r3
21f2c940:	3affffad 	bcc	21f2c7fc <flash_init+0x2c0>
			}
		}

		size += flash_info[i].size;
21f2c944:	e51b2034 	ldr	r2, [fp, #-52]
21f2c948:	e59f1194 	ldr	r1, [pc, #404]	; 21f2cae4 <.text+0x2cae4>
21f2c94c:	e1a03002 	mov	r3, r2
21f2c950:	e1a03183 	mov	r3, r3, lsl #3
21f2c954:	e0833002 	add	r3, r3, r2
21f2c958:	e1a03083 	mov	r3, r3, lsl #1
21f2c95c:	e0833002 	add	r3, r3, r2
21f2c960:	e1a02203 	mov	r2, r3, lsl #4
21f2c964:	e0833002 	add	r3, r3, r2
21f2c968:	e1a03103 	mov	r3, r3, lsl #2
21f2c96c:	e0833001 	add	r3, r3, r1
21f2c970:	e5932000 	ldr	r2, [r3]
21f2c974:	e51b3018 	ldr	r3, [fp, #-24]
21f2c978:	e0833002 	add	r3, r3, r2
21f2c97c:	e50b3018 	str	r3, [fp, #-24]

		if ((flash_info[i].flash_id & FLASH_TYPEMASK) ==
21f2c980:	e51b2034 	ldr	r2, [fp, #-52]
21f2c984:	e59f1158 	ldr	r1, [pc, #344]	; 21f2cae4 <.text+0x2cae4>
21f2c988:	e3a00008 	mov	r0, #8	; 0x8
21f2c98c:	e1a03002 	mov	r3, r2
21f2c990:	e1a03183 	mov	r3, r3, lsl #3
21f2c994:	e0833002 	add	r3, r3, r2
21f2c998:	e1a03083 	mov	r3, r3, lsl #1
21f2c99c:	e0833002 	add	r3, r3, r2
21f2c9a0:	e1a02203 	mov	r2, r3, lsl #4
21f2c9a4:	e0833002 	add	r3, r3, r2
21f2c9a8:	e1a03103 	mov	r3, r3, lsl #2
21f2c9ac:	e0833001 	add	r3, r3, r1
21f2c9b0:	e0833000 	add	r3, r3, r0
21f2c9b4:	e5933000 	ldr	r3, [r3]
21f2c9b8:	e1a03803 	mov	r3, r3, lsl #16
21f2c9bc:	e1a03823 	mov	r3, r3, lsr #16
21f2c9c0:	e35300d6 	cmp	r3, #214	; 0xd6
21f2c9c4:	1a000027 	bne	21f2ca68 <flash_init+0x52c>
			(ATM_ID_BV6416 & FLASH_TYPEMASK)){	/* AT49BV6416 Flash */

			/* Unlock all sectors at reset */
			for (j=0; j<flash_info[i].sector_count; j++){
21f2c9c8:	e3a03000 	mov	r3, #0	; 0x0
21f2c9cc:	e50b3030 	str	r3, [fp, #-48]
21f2c9d0:	ea000012 	b	21f2ca20 <flash_init+0x4e4>
				flash_unlock_sector(&flash_info[i], j);
21f2c9d4:	e51b2034 	ldr	r2, [fp, #-52]
21f2c9d8:	e1a03002 	mov	r3, r2
21f2c9dc:	e1a03183 	mov	r3, r3, lsl #3
21f2c9e0:	e0833002 	add	r3, r3, r2
21f2c9e4:	e1a03083 	mov	r3, r3, lsl #1
21f2c9e8:	e0833002 	add	r3, r3, r2
21f2c9ec:	e1a02203 	mov	r2, r3, lsl #4
21f2c9f0:	e0833002 	add	r3, r3, r2
21f2c9f4:	e1a03103 	mov	r3, r3, lsl #2
21f2c9f8:	e1a02003 	mov	r2, r3
21f2c9fc:	e59f30e0 	ldr	r3, [pc, #224]	; 21f2cae4 <.text+0x2cae4>
21f2ca00:	e0823003 	add	r3, r2, r3
21f2ca04:	e51b2030 	ldr	r2, [fp, #-48]
21f2ca08:	e1a00003 	mov	r0, r3
21f2ca0c:	e1a01002 	mov	r1, r2
21f2ca10:	ebfffeb1 	bl	21f2c4dc <flash_unlock_sector>
21f2ca14:	e51b3030 	ldr	r3, [fp, #-48]
21f2ca18:	e2833001 	add	r3, r3, #1	; 0x1
21f2ca1c:	e50b3030 	str	r3, [fp, #-48]
21f2ca20:	e51b2034 	ldr	r2, [fp, #-52]
21f2ca24:	e59f10b8 	ldr	r1, [pc, #184]	; 21f2cae4 <.text+0x2cae4>
21f2ca28:	e3a00004 	mov	r0, #4	; 0x4
21f2ca2c:	e1a03002 	mov	r3, r2
21f2ca30:	e1a03183 	mov	r3, r3, lsl #3
21f2ca34:	e0833002 	add	r3, r3, r2
21f2ca38:	e1a03083 	mov	r3, r3, lsl #1
21f2ca3c:	e0833002 	add	r3, r3, r2
21f2ca40:	e1a02203 	mov	r2, r3, lsl #4
21f2ca44:	e0833002 	add	r3, r3, r2
21f2ca48:	e1a03103 	mov	r3, r3, lsl #2
21f2ca4c:	e0833001 	add	r3, r3, r1
21f2ca50:	e0833000 	add	r3, r3, r0
21f2ca54:	e1d330b0 	ldrh	r3, [r3]
21f2ca58:	e1a02003 	mov	r2, r3
21f2ca5c:	e51b3030 	ldr	r3, [fp, #-48]
21f2ca60:	e1520003 	cmp	r2, r3
21f2ca64:	caffffda 	bgt	21f2c9d4 <flash_init+0x498>
21f2ca68:	e51b3034 	ldr	r3, [fp, #-52]
21f2ca6c:	e2833001 	add	r3, r3, #1	; 0x1
21f2ca70:	e50b3034 	str	r3, [fp, #-52]
21f2ca74:	e51b3034 	ldr	r3, [fp, #-52]
21f2ca78:	e3530000 	cmp	r3, #0	; 0x0
21f2ca7c:	dafffeb7 	ble	21f2c560 <flash_init+0x24>
			}
		}
	}

	/* Protect binary boot image */
	flash_protect (FLAG_PROTECT_SET,
21f2ca80:	e3a00001 	mov	r0, #1	; 0x1
21f2ca84:	e3a01201 	mov	r1, #268435456	; 0x10000000
21f2ca88:	e3a02201 	mov	r2, #268435456	; 0x10000000
21f2ca8c:	e2822c5f 	add	r2, r2, #24320	; 0x5f00
21f2ca90:	e28220ff 	add	r2, r2, #255	; 0xff
21f2ca94:	e59f3048 	ldr	r3, [pc, #72]	; 21f2cae4 <.text+0x2cae4>
21f2ca98:	ebffc9d6 	bl	21f1f1f8 <flash_protect>
		       CFG_FLASH_BASE,
		       CFG_FLASH_BASE + CFG_BOOT_SIZE - 1, &flash_info[0]);

	/* Protect environment variables */
	flash_protect (FLAG_PROTECT_SET,
21f2ca9c:	e3a00001 	mov	r0, #1	; 0x1
21f2caa0:	e3a01201 	mov	r1, #268435456	; 0x10000000
21f2caa4:	e2811a0e 	add	r1, r1, #57344	; 0xe000
21f2caa8:	e3e024ef 	mvn	r2, #-285212672	; 0xef000000
21f2caac:	e24228ff 	sub	r2, r2, #16711680	; 0xff0000
21f2cab0:	e59f302c 	ldr	r3, [pc, #44]	; 21f2cae4 <.text+0x2cae4>
21f2cab4:	ebffc9cf 	bl	21f1f1f8 <flash_protect>
		       CFG_ENV_ADDR,
		       CFG_ENV_ADDR + CFG_ENV_SIZE - 1, &flash_info[0]);

	/* Protect U-Boot gzipped image */
	flash_protect (FLAG_PROTECT_SET,
21f2cab8:	e3a00001 	mov	r0, #1	; 0x1
21f2cabc:	e3a01201 	mov	r1, #268435456	; 0x10000000
21f2cac0:	e2811801 	add	r1, r1, #65536	; 0x10000
21f2cac4:	e3e024ef 	mvn	r2, #-285212672	; 0xef000000
21f2cac8:	e24228fe 	sub	r2, r2, #16646144	; 0xfe0000
21f2cacc:	e59f3010 	ldr	r3, [pc, #16]	; 21f2cae4 <.text+0x2cae4>
21f2cad0:	ebffc9c8 	bl	21f1f1f8 <flash_protect>
		       CFG_U_BOOT_BASE,
		       CFG_U_BOOT_BASE + CFG_U_BOOT_SIZE - 1, &flash_info[0]);

	return size;
21f2cad4:	e51b3018 	ldr	r3, [fp, #-24]
}
21f2cad8:	e1a00003 	mov	r0, r3
21f2cadc:	e24bd010 	sub	sp, fp, #16	; 0x10
21f2cae0:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f2cae4:	21f68ca0 	mvncss	r8, r0, lsr #25
21f2cae8:	21f33d74 	mvncss	r3, r4, ror sp
21f2caec:	21f33d8c 	mvncss	r3, ip, lsl #27
21f2caf0:	21f33d9c 	ldrcsb	r3, [r3, #220]!
21f2caf4:	21f32f48 	mvncss	r2, r8, asr #30

21f2caf8 <flash_print_info>:

/*-----------------------------------------------------------------------
 */
void flash_print_info (flash_info_t * info)
{
21f2caf8:	e1a0c00d 	mov	ip, sp
21f2cafc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2cb00:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2cb04:	e24dd018 	sub	sp, sp, #24	; 0x18
21f2cb08:	e50b0014 	str	r0, [fp, #-20]
	int i;

	switch (info->flash_id & FLASH_VENDMASK) {
21f2cb0c:	e51b3014 	ldr	r3, [fp, #-20]
21f2cb10:	e5933008 	ldr	r3, [r3, #8]
21f2cb14:	e1a03823 	mov	r3, r3, lsr #16
21f2cb18:	e1a03803 	mov	r3, r3, lsl #16
21f2cb1c:	e353081f 	cmp	r3, #2031616	; 0x1f0000
21f2cb20:	0a000000 	beq	21f2cb28 <flash_print_info+0x30>
21f2cb24:	ea000002 	b	21f2cb34 <flash_print_info+0x3c>
	case (ATM_MANUFACT & FLASH_VENDMASK):
		printf ("Atmel: ");
21f2cb28:	e59f019c 	ldr	r0, [pc, #412]	; 21f2cccc <.text+0x2cccc>
21f2cb2c:	ebffbbd6 	bl	21f1ba8c <printf>
		break;
21f2cb30:	ea000001 	b	21f2cb3c <flash_print_info+0x44>
	default:
		printf ("Unknown Vendor ");
21f2cb34:	e59f0194 	ldr	r0, [pc, #404]	; 21f2ccd0 <.text+0x2ccd0>
21f2cb38:	ebffbbd3 	bl	21f1ba8c <printf>
		break;
	}

	switch (info->flash_id & FLASH_TYPEMASK) {
21f2cb3c:	e51b3014 	ldr	r3, [fp, #-20]
21f2cb40:	e5933008 	ldr	r3, [r3, #8]
21f2cb44:	e1a03803 	mov	r3, r3, lsl #16
21f2cb48:	e50b3024 	str	r3, [fp, #-36]
21f2cb4c:	e51b2024 	ldr	r2, [fp, #-36]
21f2cb50:	e1a02822 	mov	r2, r2, lsr #16
21f2cb54:	e50b2024 	str	r2, [fp, #-36]
21f2cb58:	e51b3024 	ldr	r3, [fp, #-36]
21f2cb5c:	e35300c8 	cmp	r3, #200	; 0xc8
21f2cb60:	0a000009 	beq	21f2cb8c <flash_print_info+0x94>
21f2cb64:	e51b2024 	ldr	r2, [fp, #-36]
21f2cb68:	e35200d6 	cmp	r2, #214	; 0xd6
21f2cb6c:	0a000009 	beq	21f2cb98 <flash_print_info+0xa0>
21f2cb70:	e51b3024 	ldr	r3, [fp, #-36]
21f2cb74:	e35300c0 	cmp	r3, #192	; 0xc0
21f2cb78:	0a000000 	beq	21f2cb80 <flash_print_info+0x88>
21f2cb7c:	ea000008 	b	21f2cba4 <flash_print_info+0xac>
	case (ATM_ID_BV1614 & FLASH_TYPEMASK):
		printf ("AT49BV1614 (16Mbit)\n");
21f2cb80:	e59f014c 	ldr	r0, [pc, #332]	; 21f2ccd4 <.text+0x2ccd4>
21f2cb84:	ebffbbc0 	bl	21f1ba8c <printf>
		break;
21f2cb88:	ea000008 	b	21f2cbb0 <flash_print_info+0xb8>
	case (ATM_ID_BV1614A & FLASH_TYPEMASK):
		printf ("AT49BV1614A (16Mbit)\n");
21f2cb8c:	e59f0144 	ldr	r0, [pc, #324]	; 21f2ccd8 <.text+0x2ccd8>
21f2cb90:	ebffbbbd 	bl	21f1ba8c <printf>
		break;
21f2cb94:	ea000005 	b	21f2cbb0 <flash_print_info+0xb8>
	case (ATM_ID_BV6416 & FLASH_TYPEMASK):
		printf ("AT49BV6416 (64Mbit)\n");
21f2cb98:	e59f013c 	ldr	r0, [pc, #316]	; 21f2ccdc <.text+0x2ccdc>
21f2cb9c:	ebffbbba 	bl	21f1ba8c <printf>
		break;
21f2cba0:	ea000002 	b	21f2cbb0 <flash_print_info+0xb8>
	default:
		printf ("Unknown Chip Type\n");
21f2cba4:	e59f0134 	ldr	r0, [pc, #308]	; 21f2cce0 <.text+0x2cce0>
21f2cba8:	ebffbbb7 	bl	21f1ba8c <printf>
		return;
21f2cbac:	ea000044 	b	21f2ccc4 <flash_print_info+0x1cc>
	}

	printf ("  Size: %ld MB in %d Sectors\n",
21f2cbb0:	e51b3014 	ldr	r3, [fp, #-20]
21f2cbb4:	e5933000 	ldr	r3, [r3]
21f2cbb8:	e1a02a23 	mov	r2, r3, lsr #20
21f2cbbc:	e51b3014 	ldr	r3, [fp, #-20]
21f2cbc0:	e1d330b4 	ldrh	r3, [r3, #4]
21f2cbc4:	e59f0118 	ldr	r0, [pc, #280]	; 21f2cce4 <.text+0x2cce4>
21f2cbc8:	e1a01002 	mov	r1, r2
21f2cbcc:	e1a02003 	mov	r2, r3
21f2cbd0:	ebffbbad 	bl	21f1ba8c <printf>
		info->size >> 20, info->sector_count);

	printf ("  Sector Start Addresses:");
21f2cbd4:	e59f010c 	ldr	r0, [pc, #268]	; 21f2cce8 <.text+0x2cce8>
21f2cbd8:	ebffbbab 	bl	21f1ba8c <printf>
	for (i = 0; i < info->sector_count; i++) {
21f2cbdc:	e3a03000 	mov	r3, #0	; 0x0
21f2cbe0:	e50b3010 	str	r3, [fp, #-16]
21f2cbe4:	ea00002e 	b	21f2cca4 <flash_print_info+0x1ac>
		if ((i % 5) == 0) {
21f2cbe8:	e51b1010 	ldr	r1, [fp, #-16]
21f2cbec:	e59f30f8 	ldr	r3, [pc, #248]	; 21f2ccec <.text+0x2ccec>
21f2cbf0:	e0c32391 	smull	r2, r3, r1, r3
21f2cbf4:	e1a020c3 	mov	r2, r3, asr #1
21f2cbf8:	e1a03fc1 	mov	r3, r1, asr #31
21f2cbfc:	e0632002 	rsb	r2, r3, r2
21f2cc00:	e50b2020 	str	r2, [fp, #-32]
21f2cc04:	e51b3020 	ldr	r3, [fp, #-32]
21f2cc08:	e1a03103 	mov	r3, r3, lsl #2
21f2cc0c:	e51b2020 	ldr	r2, [fp, #-32]
21f2cc10:	e0833002 	add	r3, r3, r2
21f2cc14:	e0631001 	rsb	r1, r3, r1
21f2cc18:	e50b1020 	str	r1, [fp, #-32]
21f2cc1c:	e51b3020 	ldr	r3, [fp, #-32]
21f2cc20:	e3530000 	cmp	r3, #0	; 0x0
21f2cc24:	1a000001 	bne	21f2cc30 <flash_print_info+0x138>
			printf ("\n   ");
21f2cc28:	e59f00c0 	ldr	r0, [pc, #192]	; 21f2ccf0 <.text+0x2ccf0>
21f2cc2c:	ebffbb96 	bl	21f1ba8c <printf>
		}
		printf (" %08lX%s", info->start[i],
21f2cc30:	e51b3010 	ldr	r3, [fp, #-16]
21f2cc34:	e51b2014 	ldr	r2, [fp, #-20]
21f2cc38:	e3a0100c 	mov	r1, #12	; 0xc
21f2cc3c:	e1a03103 	mov	r3, r3, lsl #2
21f2cc40:	e0833002 	add	r3, r3, r2
21f2cc44:	e0833001 	add	r3, r3, r1
21f2cc48:	e5933000 	ldr	r3, [r3]
21f2cc4c:	e50b301c 	str	r3, [fp, #-28]
21f2cc50:	e51b1010 	ldr	r1, [fp, #-16]
21f2cc54:	e51b2014 	ldr	r2, [fp, #-20]
21f2cc58:	e3a03b01 	mov	r3, #1024	; 0x400
21f2cc5c:	e283300c 	add	r3, r3, #12	; 0xc
21f2cc60:	e0812002 	add	r2, r1, r2
21f2cc64:	e0823003 	add	r3, r2, r3
21f2cc68:	e5d33000 	ldrb	r3, [r3]
21f2cc6c:	e3530000 	cmp	r3, #0	; 0x0
21f2cc70:	0a000002 	beq	21f2cc80 <flash_print_info+0x188>
21f2cc74:	e59f2078 	ldr	r2, [pc, #120]	; 21f2ccf4 <.text+0x2ccf4>
21f2cc78:	e50b2018 	str	r2, [fp, #-24]
21f2cc7c:	ea000001 	b	21f2cc88 <flash_print_info+0x190>
21f2cc80:	e59f3070 	ldr	r3, [pc, #112]	; 21f2ccf8 <.text+0x2ccf8>
21f2cc84:	e50b3018 	str	r3, [fp, #-24]
21f2cc88:	e59f006c 	ldr	r0, [pc, #108]	; 21f2ccfc <.text+0x2ccfc>
21f2cc8c:	e51b101c 	ldr	r1, [fp, #-28]
21f2cc90:	e51b2018 	ldr	r2, [fp, #-24]
21f2cc94:	ebffbb7c 	bl	21f1ba8c <printf>
21f2cc98:	e51b3010 	ldr	r3, [fp, #-16]
21f2cc9c:	e2833001 	add	r3, r3, #1	; 0x1
21f2cca0:	e50b3010 	str	r3, [fp, #-16]
21f2cca4:	e51b3014 	ldr	r3, [fp, #-20]
21f2cca8:	e1d330b4 	ldrh	r3, [r3, #4]
21f2ccac:	e1a02003 	mov	r2, r3
21f2ccb0:	e51b3010 	ldr	r3, [fp, #-16]
21f2ccb4:	e1520003 	cmp	r2, r3
21f2ccb8:	caffffca 	bgt	21f2cbe8 <flash_print_info+0xf0>
			info->protect[i] ? " (RO)" : "     ");
	}
	printf ("\n");
21f2ccbc:	e59f003c 	ldr	r0, [pc, #60]	; 21f2cd00 <.text+0x2cd00>
21f2ccc0:	ebffbb71 	bl	21f1ba8c <printf>
}
21f2ccc4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2ccc8:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2cccc:	21f32ef8 	ldrcssh	r2, [r3, #232]!
21f2ccd0:	21f32f6c 	mvncss	r2, ip, ror #30
21f2ccd4:	21f32f18 	mvncss	r2, r8, lsl pc
21f2ccd8:	21f32f00 	mvncss	r2, r0, lsl #30
21f2ccdc:	21f32f30 	mvncss	r2, r0, lsr pc
21f2cce0:	21f32f7c 	mvncss	r2, ip, ror pc
21f2cce4:	21f32f90 	ldrcsb	r2, [r3, #240]!
21f2cce8:	21f32fb0 	ldrcsh	r2, [r3, #240]!
21f2ccec:	66666667 	strvsbt	r6, [r6], -r7, ror #12
21f2ccf0:	21f32fcc 	mvncss	r2, ip, asr #31
21f2ccf4:	21f32fd4 	ldrcssb	r2, [r3, #244]!
21f2ccf8:	21f32fdc 	ldrcssb	r2, [r3, #252]!
21f2ccfc:	21f32fe4 	mvncss	r2, r4, ror #31
21f2cd00:	21f32ff0 	ldrcssh	r2, [r3, #240]!

21f2cd04 <flash_erase>:

/*-----------------------------------------------------------------------
 */

int flash_erase (flash_info_t * info, int s_first, int s_last)
{
21f2cd04:	e1a0c00d 	mov	ip, sp
21f2cd08:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2cd0c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2cd10:	e24dd030 	sub	sp, sp, #48	; 0x30
21f2cd14:	e50b0030 	str	r0, [fp, #-48]
21f2cd18:	e50b1034 	str	r1, [fp, #-52]
21f2cd1c:	e50b2038 	str	r2, [fp, #-56]
	ulong result;
	int iflag, cflag, prot, sect;
	int rc = ERR_OK;
21f2cd20:	e3a03000 	mov	r3, #0	; 0x0
21f2cd24:	e50b3018 	str	r3, [fp, #-24]
	int chip1;

	/* first look for protection bits */

	if (info->flash_id == FLASH_UNKNOWN)
21f2cd28:	e51b3030 	ldr	r3, [fp, #-48]
21f2cd2c:	e5932008 	ldr	r2, [r3, #8]
21f2cd30:	e3a03cff 	mov	r3, #65280	; 0xff00
21f2cd34:	e28330ff 	add	r3, r3, #255	; 0xff
21f2cd38:	e1520003 	cmp	r2, r3
21f2cd3c:	1a000002 	bne	21f2cd4c <flash_erase+0x48>
		return ERR_UNKNOWN_FLASH_TYPE;
21f2cd40:	e3a03040 	mov	r3, #64	; 0x40
21f2cd44:	e50b303c 	str	r3, [fp, #-60]
21f2cd48:	ea0000c0 	b	21f2d050 <flash_erase+0x34c>

	if ((s_first < 0) || (s_first > s_last)) {
21f2cd4c:	e51b3034 	ldr	r3, [fp, #-52]
21f2cd50:	e3530000 	cmp	r3, #0	; 0x0
21f2cd54:	ba000003 	blt	21f2cd68 <flash_erase+0x64>
21f2cd58:	e51b2034 	ldr	r2, [fp, #-52]
21f2cd5c:	e51b3038 	ldr	r3, [fp, #-56]
21f2cd60:	e1520003 	cmp	r2, r3
21f2cd64:	da000002 	ble	21f2cd74 <flash_erase+0x70>
		return ERR_INVAL;
21f2cd68:	e3a03008 	mov	r3, #8	; 0x8
21f2cd6c:	e50b303c 	str	r3, [fp, #-60]
21f2cd70:	ea0000b6 	b	21f2d050 <flash_erase+0x34c>
	}

	if ((info->flash_id & FLASH_VENDMASK) !=
21f2cd74:	e51b3030 	ldr	r3, [fp, #-48]
21f2cd78:	e5933008 	ldr	r3, [r3, #8]
21f2cd7c:	e1a03823 	mov	r3, r3, lsr #16
21f2cd80:	e1a03803 	mov	r3, r3, lsl #16
21f2cd84:	e353081f 	cmp	r3, #2031616	; 0x1f0000
21f2cd88:	0a000002 	beq	21f2cd98 <flash_erase+0x94>
		(ATM_MANUFACT & FLASH_VENDMASK)) {
		return ERR_UNKNOWN_FLASH_VENDOR;
21f2cd8c:	e3a03020 	mov	r3, #32	; 0x20
21f2cd90:	e50b303c 	str	r3, [fp, #-60]
21f2cd94:	ea0000ad 	b	21f2d050 <flash_erase+0x34c>
	}

	prot = 0;
21f2cd98:	e3a03000 	mov	r3, #0	; 0x0
21f2cd9c:	e50b3020 	str	r3, [fp, #-32]
	for (sect = s_first; sect <= s_last; ++sect) {
21f2cda0:	e51b3034 	ldr	r3, [fp, #-52]
21f2cda4:	e50b301c 	str	r3, [fp, #-28]
21f2cda8:	ea00000e 	b	21f2cde8 <flash_erase+0xe4>
		if (info->protect[sect]) {
21f2cdac:	e51b101c 	ldr	r1, [fp, #-28]
21f2cdb0:	e51b2030 	ldr	r2, [fp, #-48]
21f2cdb4:	e3a03b01 	mov	r3, #1024	; 0x400
21f2cdb8:	e283300c 	add	r3, r3, #12	; 0xc
21f2cdbc:	e0812002 	add	r2, r1, r2
21f2cdc0:	e0823003 	add	r3, r2, r3
21f2cdc4:	e5d33000 	ldrb	r3, [r3]
21f2cdc8:	e3530000 	cmp	r3, #0	; 0x0
21f2cdcc:	0a000002 	beq	21f2cddc <flash_erase+0xd8>
			prot++;
21f2cdd0:	e51b3020 	ldr	r3, [fp, #-32]
21f2cdd4:	e2833001 	add	r3, r3, #1	; 0x1
21f2cdd8:	e50b3020 	str	r3, [fp, #-32]
21f2cddc:	e51b301c 	ldr	r3, [fp, #-28]
21f2cde0:	e2833001 	add	r3, r3, #1	; 0x1
21f2cde4:	e50b301c 	str	r3, [fp, #-28]
21f2cde8:	e51b201c 	ldr	r2, [fp, #-28]
21f2cdec:	e51b3038 	ldr	r3, [fp, #-56]
21f2cdf0:	e1520003 	cmp	r2, r3
21f2cdf4:	daffffec 	ble	21f2cdac <flash_erase+0xa8>
		}
	}
	if (prot)
21f2cdf8:	e51b3020 	ldr	r3, [fp, #-32]
21f2cdfc:	e3530000 	cmp	r3, #0	; 0x0
21f2ce00:	0a000002 	beq	21f2ce10 <flash_erase+0x10c>
		return ERR_PROTECTED;
21f2ce04:	e3a03004 	mov	r3, #4	; 0x4
21f2ce08:	e50b303c 	str	r3, [fp, #-60]
21f2ce0c:	ea00008f 	b	21f2d050 <flash_erase+0x34c>

	/*
	 * Disable interrupts which might cause a timeout
	 * here. Remember that our exception vectors are
	 * at address 0 in the flash, and we don't want a
	 * (ticker) exception to happen while the flash
	 * chip is in programming mode.
	 */
	cflag = icache_status ();
21f2ce10:	eb0001dd 	bl	21f2d58c <icache_status>
21f2ce14:	e1a03000 	mov	r3, r0
21f2ce18:	e50b3024 	str	r3, [fp, #-36]
	icache_disable ();
21f2ce1c:	eb0001cd 	bl	21f2d558 <icache_disable>
	iflag = disable_interrupts ();
21f2ce20:	ebff4d5f 	bl	21f003a4 <disable_interrupts>
21f2ce24:	e1a03000 	mov	r3, r0
21f2ce28:	e50b3028 	str	r3, [fp, #-40]

	/* Start erase on unprotected sectors */
	for (sect = s_first; sect <= s_last && !ctrlc (); sect++) {
21f2ce2c:	e51b3034 	ldr	r3, [fp, #-52]
21f2ce30:	e50b301c 	str	r3, [fp, #-28]
21f2ce34:	ea00006a 	b	21f2cfe4 <flash_erase+0x2e0>
		printf ("Erasing sector %2d ... ", sect);
21f2ce38:	e59f0220 	ldr	r0, [pc, #544]	; 21f2d060 <.text+0x2d060>
21f2ce3c:	e51b101c 	ldr	r1, [fp, #-28]
21f2ce40:	ebffbb11 	bl	21f1ba8c <printf>

		/* arm simple, non interrupt dependent timer */
		reset_timer_masked ();
21f2ce44:	ebff4f1f 	bl	21f00ac8 <reset_timer_masked>

		if (info->protect[sect] == 0) {	/* not protected */
21f2ce48:	e51b101c 	ldr	r1, [fp, #-28]
21f2ce4c:	e51b2030 	ldr	r2, [fp, #-48]
21f2ce50:	e3a03b01 	mov	r3, #1024	; 0x400
21f2ce54:	e283300c 	add	r3, r3, #12	; 0xc
21f2ce58:	e0812002 	add	r2, r1, r2
21f2ce5c:	e0823003 	add	r3, r2, r3
21f2ce60:	e5d33000 	ldrb	r3, [r3]
21f2ce64:	e3530000 	cmp	r3, #0	; 0x0
21f2ce68:	1a000058 	bne	21f2cfd0 <flash_erase+0x2cc>
			volatile u16 *addr = (volatile u16 *) (info->start[sect]);
21f2ce6c:	e51b301c 	ldr	r3, [fp, #-28]
21f2ce70:	e51b2030 	ldr	r2, [fp, #-48]
21f2ce74:	e3a0100c 	mov	r1, #12	; 0xc
21f2ce78:	e1a03103 	mov	r3, r3, lsl #2
21f2ce7c:	e0833002 	add	r3, r3, r2
21f2ce80:	e0833001 	add	r3, r3, r1
21f2ce84:	e5933000 	ldr	r3, [r3]
21f2ce88:	e50b3010 	str	r3, [fp, #-16]

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
21f2ce8c:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2ce90:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2ce94:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2ce98:	e3a020aa 	mov	r2, #170	; 0xaa
21f2ce9c:	e1c320b0 	strh	r2, [r3]
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
21f2cea0:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2cea4:	e2833c55 	add	r3, r3, #21760	; 0x5500
21f2cea8:	e2833054 	add	r3, r3, #84	; 0x54
21f2ceac:	e3a02055 	mov	r2, #85	; 0x55
21f2ceb0:	e1c320b0 	strh	r2, [r3]
			MEM_FLASH_ADDR1 = CMD_ERASE_SETUP;
21f2ceb4:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2ceb8:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2cebc:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2cec0:	e3a02080 	mov	r2, #128	; 0x80
21f2cec4:	e1c320b0 	strh	r2, [r3]

			MEM_FLASH_ADDR1 = CMD_UNLOCK1;
21f2cec8:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2cecc:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2ced0:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2ced4:	e3a020aa 	mov	r2, #170	; 0xaa
21f2ced8:	e1c320b0 	strh	r2, [r3]
			MEM_FLASH_ADDR2 = CMD_UNLOCK2;
21f2cedc:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2cee0:	e2833c55 	add	r3, r3, #21760	; 0x5500
21f2cee4:	e2833054 	add	r3, r3, #84	; 0x54
21f2cee8:	e3a02055 	mov	r2, #85	; 0x55
21f2ceec:	e1c320b0 	strh	r2, [r3]
			*addr = CMD_ERASE_CONFIRM;
21f2cef0:	e51b2010 	ldr	r2, [fp, #-16]
21f2cef4:	e3a03030 	mov	r3, #48	; 0x30
21f2cef8:	e1c230b0 	strh	r3, [r2]

			/* wait until flash is ready */
			chip1 = 0;
21f2cefc:	e3a03000 	mov	r3, #0	; 0x0
21f2cf00:	e50b3014 	str	r3, [fp, #-20]

			do {
				result = *addr;
21f2cf04:	e51b3010 	ldr	r3, [fp, #-16]
21f2cf08:	e1d330b0 	ldrh	r3, [r3]
21f2cf0c:	e1a03803 	mov	r3, r3, lsl #16
21f2cf10:	e1a03823 	mov	r3, r3, lsr #16
21f2cf14:	e50b302c 	str	r3, [fp, #-44]

				/* check timeout */
				if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
21f2cf18:	ebff4f28 	bl	21f00bc0 <get_timer_masked>
21f2cf1c:	e1a03000 	mov	r3, r0
21f2cf20:	e3530e7d 	cmp	r3, #2000	; 0x7d0
21f2cf24:	9a000007 	bls	21f2cf48 <flash_erase+0x244>
					MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
21f2cf28:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2cf2c:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2cf30:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2cf34:	e3a020f0 	mov	r2, #240	; 0xf0
21f2cf38:	e1c320b0 	strh	r2, [r3]
					chip1 = TMO;
21f2cf3c:	e3a03004 	mov	r3, #4	; 0x4
21f2cf40:	e50b3014 	str	r3, [fp, #-20]
					break;
21f2cf44:	ea00000d 	b	21f2cf80 <flash_erase+0x27c>
				}

				if (!chip1 && (result & 0xFFFF) & BIT_ERASE_DONE)
21f2cf48:	e51b3014 	ldr	r3, [fp, #-20]
21f2cf4c:	e3530000 	cmp	r3, #0	; 0x0
21f2cf50:	1a000007 	bne	21f2cf74 <flash_erase+0x270>
21f2cf54:	e51b302c 	ldr	r3, [fp, #-44]
21f2cf58:	e1a033a3 	mov	r3, r3, lsr #7
21f2cf5c:	e2033001 	and	r3, r3, #1	; 0x1
21f2cf60:	e20330ff 	and	r3, r3, #255	; 0xff
21f2cf64:	e3530000 	cmp	r3, #0	; 0x0
21f2cf68:	0a000001 	beq	21f2cf74 <flash_erase+0x270>
					chip1 = READY;
21f2cf6c:	e3a03001 	mov	r3, #1	; 0x1
21f2cf70:	e50b3014 	str	r3, [fp, #-20]

			} while (!chip1);
21f2cf74:	e51b3014 	ldr	r3, [fp, #-20]
21f2cf78:	e3530000 	cmp	r3, #0	; 0x0
21f2cf7c:	0affffe0 	beq	21f2cf04 <flash_erase+0x200>

			MEM_FLASH_ADDR1 = CMD_READ_ARRAY;
21f2cf80:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2cf84:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2cf88:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2cf8c:	e3a020f0 	mov	r2, #240	; 0xf0
21f2cf90:	e1c320b0 	strh	r2, [r3]

			if (chip1 == ERR) {
21f2cf94:	e51b3014 	ldr	r3, [fp, #-20]
21f2cf98:	e3530002 	cmp	r3, #2	; 0x2
21f2cf9c:	1a000002 	bne	21f2cfac <flash_erase+0x2a8>
				rc = ERR_PROG_ERROR;
21f2cfa0:	e3a03080 	mov	r3, #128	; 0x80
21f2cfa4:	e50b3018 	str	r3, [fp, #-24]
				goto outahere;
21f2cfa8:	ea00001b 	b	21f2d01c <flash_erase+0x318>
			}
			if (chip1 == TMO) {
21f2cfac:	e51b3014 	ldr	r3, [fp, #-20]
21f2cfb0:	e3530004 	cmp	r3, #4	; 0x4
21f2cfb4:	1a000002 	bne	21f2cfc4 <flash_erase+0x2c0>
				rc = ERR_TIMOUT;
21f2cfb8:	e3a03001 	mov	r3, #1	; 0x1
21f2cfbc:	e50b3018 	str	r3, [fp, #-24]
				goto outahere;
21f2cfc0:	ea000015 	b	21f2d01c <flash_erase+0x318>
			}

			printf ("ok.\n");
21f2cfc4:	e59f0098 	ldr	r0, [pc, #152]	; 21f2d064 <.text+0x2d064>
21f2cfc8:	ebffbaaf 	bl	21f1ba8c <printf>
21f2cfcc:	ea000001 	b	21f2cfd8 <flash_erase+0x2d4>
		} else {			/* it was protected */
			printf ("protected!\n");
21f2cfd0:	e59f0090 	ldr	r0, [pc, #144]	; 21f2d068 <.text+0x2d068>
21f2cfd4:	ebffbaac 	bl	21f1ba8c <printf>
21f2cfd8:	e51b301c 	ldr	r3, [fp, #-28]
21f2cfdc:	e2833001 	add	r3, r3, #1	; 0x1
21f2cfe0:	e50b301c 	str	r3, [fp, #-28]
21f2cfe4:	e51b201c 	ldr	r2, [fp, #-28]
21f2cfe8:	e51b3038 	ldr	r3, [fp, #-56]
21f2cfec:	e1520003 	cmp	r2, r3
21f2cff0:	ca000003 	bgt	21f2d004 <flash_erase+0x300>
21f2cff4:	ebffbacd 	bl	21f1bb30 <ctrlc>
21f2cff8:	e1a03000 	mov	r3, r0
21f2cffc:	e3530000 	cmp	r3, #0	; 0x0
21f2d000:	0affff8c 	beq	21f2ce38 <flash_erase+0x134>
		}
	}

	if (ctrlc ())
21f2d004:	ebffbac9 	bl	21f1bb30 <ctrlc>
21f2d008:	e1a03000 	mov	r3, r0
21f2d00c:	e3530000 	cmp	r3, #0	; 0x0
21f2d010:	0a000001 	beq	21f2d01c <flash_erase+0x318>
		printf ("User Interrupt!\n");
21f2d014:	e59f0050 	ldr	r0, [pc, #80]	; 21f2d06c <.text+0x2d06c>
21f2d018:	ebffba9b 	bl	21f1ba8c <printf>

outahere:
	/* allow flash to settle - wait 10 ms */
	udelay_masked (10000);
21f2d01c:	e3a00c27 	mov	r0, #9984	; 0x2700
21f2d020:	e2800010 	add	r0, r0, #16	; 0x10
21f2d024:	ebff4ef1 	bl	21f00bf0 <udelay_masked>

	if (iflag)
21f2d028:	e51b3028 	ldr	r3, [fp, #-40]
21f2d02c:	e3530000 	cmp	r3, #0	; 0x0
21f2d030:	0a000000 	beq	21f2d038 <flash_erase+0x334>
		enable_interrupts ();
21f2d034:	ebff4cd1 	bl	21f00380 <enable_interrupts>

	if (cflag)
21f2d038:	e51b3024 	ldr	r3, [fp, #-36]
21f2d03c:	e3530000 	cmp	r3, #0	; 0x0
21f2d040:	0a000000 	beq	21f2d048 <flash_erase+0x344>
		icache_enable ();
21f2d044:	eb000136 	bl	21f2d524 <icache_enable>

	return rc;
21f2d048:	e51b3018 	ldr	r3, [fp, #-24]
21f2d04c:	e50b303c 	str	r3, [fp, #-60]
21f2d050:	e51b303c 	ldr	r3, [fp, #-60]
}
21f2d054:	e1a00003 	mov	r0, r3
21f2d058:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2d05c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2d060:	21f32ff4 	ldrcssh	r2, [r3, #244]!
21f2d064:	21f3300c 	mvncss	r3, ip
21f2d068:	21f33014 	mvncss	r3, r4, lsl r0
21f2d06c:	21f33020 	mvncss	r3, r0, lsr #32

21f2d070 <write_word>:

/*-----------------------------------------------------------------------
 * Copy memory to flash
 */

static int write_word (flash_info_t * info, ulong dest, ulong data)
{
21f2d070:	e1a0c00d 	mov	ip, sp
21f2d074:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d078:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d07c:	e24dd028 	sub	sp, sp, #40	; 0x28
21f2d080:	e50b0028 	str	r0, [fp, #-40]
21f2d084:	e50b102c 	str	r1, [fp, #-44]
21f2d088:	e50b2030 	str	r2, [fp, #-48]
	volatile u16 *addr = (volatile u16 *) dest;
21f2d08c:	e51b302c 	ldr	r3, [fp, #-44]
21f2d090:	e50b3024 	str	r3, [fp, #-36]
	ulong result;
	int rc = ERR_OK;
21f2d094:	e3a03000 	mov	r3, #0	; 0x0
21f2d098:	e50b301c 	str	r3, [fp, #-28]
	int cflag, iflag;
	int chip1;

	/*
	 * Check if Flash is (sufficiently) erased
	 */
	result = *addr;
21f2d09c:	e51b3024 	ldr	r3, [fp, #-36]
21f2d0a0:	e1d330b0 	ldrh	r3, [r3]
21f2d0a4:	e1a03803 	mov	r3, r3, lsl #16
21f2d0a8:	e1a03823 	mov	r3, r3, lsr #16
21f2d0ac:	e50b3020 	str	r3, [fp, #-32]
	if ((result & data) != data)
21f2d0b0:	e51b2020 	ldr	r2, [fp, #-32]
21f2d0b4:	e51b3030 	ldr	r3, [fp, #-48]
21f2d0b8:	e0022003 	and	r2, r2, r3
21f2d0bc:	e51b3030 	ldr	r3, [fp, #-48]
21f2d0c0:	e1520003 	cmp	r2, r3
21f2d0c4:	0a000002 	beq	21f2d0d4 <write_word+0x64>
		return ERR_NOT_ERASED;
21f2d0c8:	e3a03002 	mov	r3, #2	; 0x2
21f2d0cc:	e50b3034 	str	r3, [fp, #-52]
21f2d0d0:	ea000051 	b	21f2d21c <write_word+0x1ac>

	/*
	 * Disable interrupts which might cause a timeout
	 * here. Remember that our exception vectors are
	 * at address 0 in the flash, and we don't want a
	 * (ticker) exception to happen while the flash
	 * chip is in programming mode.
	 */
	cflag = icache_status ();
21f2d0d4:	eb00012c 	bl	21f2d58c <icache_status>
21f2d0d8:	e1a03000 	mov	r3, r0
21f2d0dc:	e50b3018 	str	r3, [fp, #-24]
	icache_disable ();
21f2d0e0:	eb00011c 	bl	21f2d558 <icache_disable>
	iflag = disable_interrupts ();
21f2d0e4:	ebff4cae 	bl	21f003a4 <disable_interrupts>
21f2d0e8:	e1a03000 	mov	r3, r0
21f2d0ec:	e50b3014 	str	r3, [fp, #-20]

	MEM_FLASH_ADDR1 = CMD_UNLOCK1;
21f2d0f0:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2d0f4:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2d0f8:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2d0fc:	e3a020aa 	mov	r2, #170	; 0xaa
21f2d100:	e1c320b0 	strh	r2, [r3]
	MEM_FLASH_ADDR2 = CMD_UNLOCK2;
21f2d104:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2d108:	e2833c55 	add	r3, r3, #21760	; 0x5500
21f2d10c:	e2833054 	add	r3, r3, #84	; 0x54
21f2d110:	e3a02055 	mov	r2, #85	; 0x55
21f2d114:	e1c320b0 	strh	r2, [r3]
	MEM_FLASH_ADDR1 = CMD_PROGRAM;
21f2d118:	e3a03201 	mov	r3, #268435456	; 0x10000000
21f2d11c:	e2833caa 	add	r3, r3, #43520	; 0xaa00
21f2d120:	e28330aa 	add	r3, r3, #170	; 0xaa
21f2d124:	e3a020a0 	mov	r2, #160	; 0xa0
21f2d128:	e1c320b0 	strh	r2, [r3]
	*addr = data;
21f2d12c:	e51b3030 	ldr	r3, [fp, #-48]
21f2d130:	e1a03803 	mov	r3, r3, lsl #16
21f2d134:	e1a02823 	mov	r2, r3, lsr #16
21f2d138:	e51b3024 	ldr	r3, [fp, #-36]
21f2d13c:	e1c320b0 	strh	r2, [r3]

	/* arm simple, non interrupt dependent timer */
	reset_timer_masked ();
21f2d140:	ebff4e60 	bl	21f00ac8 <reset_timer_masked>

	/* wait until flash is ready */
	chip1 = 0;
21f2d144:	e3a03000 	mov	r3, #0	; 0x0
21f2d148:	e50b3010 	str	r3, [fp, #-16]
	do {
		result = *addr;
21f2d14c:	e51b3024 	ldr	r3, [fp, #-36]
21f2d150:	e1d330b0 	ldrh	r3, [r3]
21f2d154:	e1a03803 	mov	r3, r3, lsl #16
21f2d158:	e1a03823 	mov	r3, r3, lsr #16
21f2d15c:	e50b3020 	str	r3, [fp, #-32]

		/* check timeout */
		if (get_timer_masked () > CFG_FLASH_ERASE_TOUT) {
21f2d160:	ebff4e96 	bl	21f00bc0 <get_timer_masked>
21f2d164:	e1a03000 	mov	r3, r0
21f2d168:	e3530e7d 	cmp	r3, #2000	; 0x7d0
21f2d16c:	9a000002 	bls	21f2d17c <write_word+0x10c>
			chip1 = ERR | TMO;
21f2d170:	e3a03006 	mov	r3, #6	; 0x6
21f2d174:	e50b3010 	str	r3, [fp, #-16]
			break;
21f2d178:	ea00000d 	b	21f2d1b4 <write_word+0x144>
		}
		if (!chip1 && ((result & 0x80) == (data & 0x80)))
21f2d17c:	e51b3010 	ldr	r3, [fp, #-16]
21f2d180:	e3530000 	cmp	r3, #0	; 0x0
21f2d184:	1a000007 	bne	21f2d1a8 <write_word+0x138>
21f2d188:	e51b3020 	ldr	r3, [fp, #-32]
21f2d18c:	e2032080 	and	r2, r3, #128	; 0x80
21f2d190:	e51b3030 	ldr	r3, [fp, #-48]
21f2d194:	e2033080 	and	r3, r3, #128	; 0x80
21f2d198:	e1520003 	cmp	r2, r3
21f2d19c:	1a000001 	bne	21f2d1a8 <write_word+0x138>
			chip1 = READY;
21f2d1a0:	e3a03001 	mov	r3, #1	; 0x1
21f2d1a4:	e50b3010 	str	r3, [fp, #-16]

	} while (!chip1);
21f2d1a8:	e51b3010 	ldr	r3, [fp, #-16]
21f2d1ac:	e3530000 	cmp	r3, #0	; 0x0
21f2d1b0:	0affffe5 	beq	21f2d14c <write_word+0xdc>

	*addr = CMD_READ_ARRAY;
21f2d1b4:	e51b2024 	ldr	r2, [fp, #-36]
21f2d1b8:	e3a030f0 	mov	r3, #240	; 0xf0
21f2d1bc:	e1c230b0 	strh	r3, [r2]

	if (chip1 == ERR || *addr != data)
21f2d1c0:	e51b3010 	ldr	r3, [fp, #-16]
21f2d1c4:	e3530002 	cmp	r3, #2	; 0x2
21f2d1c8:	0a000007 	beq	21f2d1ec <write_word+0x17c>
21f2d1cc:	e51b3024 	ldr	r3, [fp, #-36]
21f2d1d0:	e1d330b0 	ldrh	r3, [r3]
21f2d1d4:	e1a03803 	mov	r3, r3, lsl #16
21f2d1d8:	e1a03823 	mov	r3, r3, lsr #16
21f2d1dc:	e1a02003 	mov	r2, r3
21f2d1e0:	e51b3030 	ldr	r3, [fp, #-48]
21f2d1e4:	e1520003 	cmp	r2, r3
21f2d1e8:	0a000001 	beq	21f2d1f4 <write_word+0x184>
		rc = ERR_PROG_ERROR;
21f2d1ec:	e3a03080 	mov	r3, #128	; 0x80
21f2d1f0:	e50b301c 	str	r3, [fp, #-28]

	if (iflag)
21f2d1f4:	e51b3014 	ldr	r3, [fp, #-20]
21f2d1f8:	e3530000 	cmp	r3, #0	; 0x0
21f2d1fc:	0a000000 	beq	21f2d204 <write_word+0x194>
		enable_interrupts ();
21f2d200:	ebff4c5e 	bl	21f00380 <enable_interrupts>

	if (cflag)
21f2d204:	e51b3018 	ldr	r3, [fp, #-24]
21f2d208:	e3530000 	cmp	r3, #0	; 0x0
21f2d20c:	0a000000 	beq	21f2d214 <write_word+0x1a4>
		icache_enable ();
21f2d210:	eb0000c3 	bl	21f2d524 <icache_enable>

	return rc;
21f2d214:	e51b301c 	ldr	r3, [fp, #-28]
21f2d218:	e50b3034 	str	r3, [fp, #-52]
21f2d21c:	e51b3034 	ldr	r3, [fp, #-52]
}
21f2d220:	e1a00003 	mov	r0, r3
21f2d224:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2d228:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2d22c <write_buff>:

/*-----------------------------------------------------------------------
 * Copy memory to flash.
 */

int write_buff (flash_info_t * info, uchar * src, ulong addr, ulong cnt)
{
21f2d22c:	e1a0c00d 	mov	ip, sp
21f2d230:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d234:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d238:	e24dd020 	sub	sp, sp, #32	; 0x20
21f2d23c:	e50b001c 	str	r0, [fp, #-28]
21f2d240:	e50b1020 	str	r1, [fp, #-32]
21f2d244:	e50b2024 	str	r2, [fp, #-36]
21f2d248:	e50b3028 	str	r3, [fp, #-40]
	ulong wp, data;
	int rc;

	if (addr & 1) {
21f2d24c:	e51b3024 	ldr	r3, [fp, #-36]
21f2d250:	e2033001 	and	r3, r3, #1	; 0x1
21f2d254:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d258:	e3530000 	cmp	r3, #0	; 0x0
21f2d25c:	0a000004 	beq	21f2d274 <write_buff+0x48>
		printf ("unaligned destination not supported\n");
21f2d260:	e59f0158 	ldr	r0, [pc, #344]	; 21f2d3c0 <.text+0x2d3c0>
21f2d264:	ebffba08 	bl	21f1ba8c <printf>
		return ERR_ALIGN;
21f2d268:	e3a03010 	mov	r3, #16	; 0x10
21f2d26c:	e50b302c 	str	r3, [fp, #-44]
21f2d270:	ea00004e 	b	21f2d3b0 <write_buff+0x184>
	};

	if ((int) src & 1) {
21f2d274:	e51b3020 	ldr	r3, [fp, #-32]
21f2d278:	e2033001 	and	r3, r3, #1	; 0x1
21f2d27c:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d280:	e3530000 	cmp	r3, #0	; 0x0
21f2d284:	0a000004 	beq	21f2d29c <write_buff+0x70>
		printf ("unaligned source not supported\n");
21f2d288:	e59f0134 	ldr	r0, [pc, #308]	; 21f2d3c4 <.text+0x2d3c4>
21f2d28c:	ebffb9fe 	bl	21f1ba8c <printf>
		return ERR_ALIGN;
21f2d290:	e3a03010 	mov	r3, #16	; 0x10
21f2d294:	e50b302c 	str	r3, [fp, #-44]
21f2d298:	ea000044 	b	21f2d3b0 <write_buff+0x184>
	};

	wp = addr;
21f2d29c:	e51b3024 	ldr	r3, [fp, #-36]
21f2d2a0:	e50b3018 	str	r3, [fp, #-24]

	while (cnt >= 2) {
21f2d2a4:	ea000019 	b	21f2d310 <write_buff+0xe4>
		data = *((volatile u16 *) src);
21f2d2a8:	e51b3020 	ldr	r3, [fp, #-32]
21f2d2ac:	e1d330b0 	ldrh	r3, [r3]
21f2d2b0:	e1a03803 	mov	r3, r3, lsl #16
21f2d2b4:	e1a03823 	mov	r3, r3, lsr #16
21f2d2b8:	e50b3014 	str	r3, [fp, #-20]
		if ((rc = write_word (info, wp, data)) != 0) {
21f2d2bc:	e51b001c 	ldr	r0, [fp, #-28]
21f2d2c0:	e51b1018 	ldr	r1, [fp, #-24]
21f2d2c4:	e51b2014 	ldr	r2, [fp, #-20]
21f2d2c8:	ebffff68 	bl	21f2d070 <write_word>
21f2d2cc:	e1a03000 	mov	r3, r0
21f2d2d0:	e50b3010 	str	r3, [fp, #-16]
21f2d2d4:	e51b3010 	ldr	r3, [fp, #-16]
21f2d2d8:	e3530000 	cmp	r3, #0	; 0x0
21f2d2dc:	0a000002 	beq	21f2d2ec <write_buff+0xc0>
			return (rc);
21f2d2e0:	e51b3010 	ldr	r3, [fp, #-16]
21f2d2e4:	e50b302c 	str	r3, [fp, #-44]
21f2d2e8:	ea000030 	b	21f2d3b0 <write_buff+0x184>
		}
		src += 2;
21f2d2ec:	e51b3020 	ldr	r3, [fp, #-32]
21f2d2f0:	e2833002 	add	r3, r3, #2	; 0x2
21f2d2f4:	e50b3020 	str	r3, [fp, #-32]
		wp += 2;
21f2d2f8:	e51b3018 	ldr	r3, [fp, #-24]
21f2d2fc:	e2833002 	add	r3, r3, #2	; 0x2
21f2d300:	e50b3018 	str	r3, [fp, #-24]
		cnt -= 2;
21f2d304:	e51b3028 	ldr	r3, [fp, #-40]
21f2d308:	e2433002 	sub	r3, r3, #2	; 0x2
21f2d30c:	e50b3028 	str	r3, [fp, #-40]
21f2d310:	e51b3028 	ldr	r3, [fp, #-40]
21f2d314:	e3530001 	cmp	r3, #1	; 0x1
21f2d318:	8affffe2 	bhi	21f2d2a8 <write_buff+0x7c>
	}

	if (cnt == 1) {
21f2d31c:	e51b3028 	ldr	r3, [fp, #-40]
21f2d320:	e3530001 	cmp	r3, #1	; 0x1
21f2d324:	1a00001f 	bne	21f2d3a8 <write_buff+0x17c>
		data = (*((volatile u8 *) src)) | (*((volatile u8 *) (wp + 1)) <<
21f2d328:	e51b3020 	ldr	r3, [fp, #-32]
21f2d32c:	e5d33000 	ldrb	r3, [r3]
21f2d330:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d334:	e1a02003 	mov	r2, r3
21f2d338:	e51b3018 	ldr	r3, [fp, #-24]
21f2d33c:	e2833001 	add	r3, r3, #1	; 0x1
21f2d340:	e5d33000 	ldrb	r3, [r3]
21f2d344:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d348:	e1a03403 	mov	r3, r3, lsl #8
21f2d34c:	e1823003 	orr	r3, r2, r3
21f2d350:	e50b3014 	str	r3, [fp, #-20]
										   8);
		if ((rc = write_word (info, wp, data)) != 0) {
21f2d354:	e51b001c 	ldr	r0, [fp, #-28]
21f2d358:	e51b1018 	ldr	r1, [fp, #-24]
21f2d35c:	e51b2014 	ldr	r2, [fp, #-20]
21f2d360:	ebffff42 	bl	21f2d070 <write_word>
21f2d364:	e1a03000 	mov	r3, r0
21f2d368:	e50b3010 	str	r3, [fp, #-16]
21f2d36c:	e51b3010 	ldr	r3, [fp, #-16]
21f2d370:	e3530000 	cmp	r3, #0	; 0x0
21f2d374:	0a000002 	beq	21f2d384 <write_buff+0x158>
			return (rc);
21f2d378:	e51b3010 	ldr	r3, [fp, #-16]
21f2d37c:	e50b302c 	str	r3, [fp, #-44]
21f2d380:	ea00000a 	b	21f2d3b0 <write_buff+0x184>
		}
		src += 1;
21f2d384:	e51b3020 	ldr	r3, [fp, #-32]
21f2d388:	e2833001 	add	r3, r3, #1	; 0x1
21f2d38c:	e50b3020 	str	r3, [fp, #-32]
		wp += 1;
21f2d390:	e51b3018 	ldr	r3, [fp, #-24]
21f2d394:	e2833001 	add	r3, r3, #1	; 0x1
21f2d398:	e50b3018 	str	r3, [fp, #-24]
		cnt -= 1;
21f2d39c:	e51b3028 	ldr	r3, [fp, #-40]
21f2d3a0:	e2433001 	sub	r3, r3, #1	; 0x1
21f2d3a4:	e50b3028 	str	r3, [fp, #-40]
	};

	return ERR_OK;
21f2d3a8:	e3a03000 	mov	r3, #0	; 0x0
21f2d3ac:	e50b302c 	str	r3, [fp, #-44]
21f2d3b0:	e51b302c 	ldr	r3, [fp, #-44]
}
21f2d3b4:	e1a00003 	mov	r0, r3
21f2d3b8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2d3bc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2d3c0:	21f33034 	mvncss	r3, r4, lsr r0
21f2d3c4:	21f3305c 	mvncss	r3, ip, asr r0

21f2d3c8 <read_p15_c1>:
#endif

/* read co-processor 15, register #1 (control register) */
static unsigned long read_p15_c1 (void)
{
21f2d3c8:	e1a0c00d 	mov	ip, sp
21f2d3cc:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d3d0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d3d4:	e24dd004 	sub	sp, sp, #4	; 0x4
	unsigned long value;

	__asm__ __volatile__(
21f2d3d8:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
21f2d3dc:	e50b3010 	str	r3, [fp, #-16]
		"mrc	p15, 0, %0, c1, c0, 0   @ read control reg\n"
		: "=r" (value)
		:
		: "memory");

#ifdef MMU_DEBUG
	printf ("p15/c1 is = %08lx\n", value);
#endif
	return value;
21f2d3e0:	e51b3010 	ldr	r3, [fp, #-16]
}
21f2d3e4:	e1a00003 	mov	r0, r3
21f2d3e8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d3ec <write_p15_c1>:

/* write to co-processor 15, register #1 (control register) */
static void write_p15_c1 (unsigned long value)
{
21f2d3ec:	e1a0c00d 	mov	ip, sp
21f2d3f0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d3f4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d3f8:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2d3fc:	e50b0010 	str	r0, [fp, #-16]
#ifdef MMU_DEBUG
	printf ("write %08lx to p15/c1\n", value);
#endif
	__asm__ __volatile__(
21f2d400:	e51b3010 	ldr	r3, [fp, #-16]
21f2d404:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
		"mcr	p15, 0, %0, c1, c0, 0   @ write it back\n"
		:
		: "r" (value)
		: "memory");

	read_p15_c1 ();
21f2d408:	ebffffee 	bl	21f2d3c8 <read_p15_c1>
}
21f2d40c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d410 <cp_delay>:

static void cp_delay (void)
{
21f2d410:	e1a0c00d 	mov	ip, sp
21f2d414:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d418:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d41c:	e24dd004 	sub	sp, sp, #4	; 0x4
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++);
21f2d420:	e3a03000 	mov	r3, #0	; 0x0
21f2d424:	e50b3010 	str	r3, [fp, #-16]
21f2d428:	ea000002 	b	21f2d438 <cp_delay+0x28>
21f2d42c:	e51b3010 	ldr	r3, [fp, #-16]
21f2d430:	e2833001 	add	r3, r3, #1	; 0x1
21f2d434:	e50b3010 	str	r3, [fp, #-16]
21f2d438:	e51b3010 	ldr	r3, [fp, #-16]
21f2d43c:	e3530063 	cmp	r3, #99	; 0x63
21f2d440:	dafffff9 	ble	21f2d42c <cp_delay+0x1c>
}
21f2d444:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d448 <cpu_init>:

/* See also ARM920T    Technical reference Manual */
#define C1_MMU		(1<<0)		/* mmu off/on */
#define C1_ALIGN	(1<<1)		/* alignment faults off/on */
#define C1_DC		(1<<2)		/* dcache off/on */

#define C1_BIG_ENDIAN	(1<<7)		/* big endian off/on */
#define C1_SYS_PROT	(1<<8)		/* system protection */
#define C1_ROM_PROT	(1<<9)		/* ROM protection */
#define C1_IC		(1<<12)		/* icache off/on */
#define C1_HIGH_VECTORS	(1<<13)		/* location of vectors: low/high addresses */


int cpu_init (void)
{
21f2d448:	e1a0c00d 	mov	ip, sp
21f2d44c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d450:	e24cb004 	sub	fp, ip, #4	; 0x4
	/*
	 * setup up stacks if necessary
	 */
#ifdef CONFIG_USE_IRQ
	IRQ_STACK_START = _armboot_start - CFG_MALLOC_LEN - CFG_GBL_DATA_SIZE - 4;
21f2d454:	e59f3030 	ldr	r3, [pc, #48]	; 21f2d48c <.text+0x2d48c>
21f2d458:	e5933000 	ldr	r3, [r3]
21f2d45c:	e2433a22 	sub	r3, r3, #139264	; 0x22000
21f2d460:	e2433084 	sub	r3, r3, #132	; 0x84
21f2d464:	e59f2024 	ldr	r2, [pc, #36]	; 21f2d490 <.text+0x2d490>
21f2d468:	e5823000 	str	r3, [r2]
	FIQ_STACK_START = IRQ_STACK_START - CONFIG_STACKSIZE_IRQ;
21f2d46c:	e59f301c 	ldr	r3, [pc, #28]	; 21f2d490 <.text+0x2d490>
21f2d470:	e5933000 	ldr	r3, [r3]
21f2d474:	e2432040 	sub	r2, r3, #64	; 0x40
21f2d478:	e59f3014 	ldr	r3, [pc, #20]	; 21f2d494 <.text+0x2d494>
21f2d47c:	e5832000 	str	r2, [r3]
#endif
	return 0;
21f2d480:	e3a03000 	mov	r3, #0	; 0x0
}
21f2d484:	e1a00003 	mov	r0, r3
21f2d488:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2d48c:	21f00044 	mvncss	r0, r4, asr #32
21f2d490:	21f00050 	mvncss	r0, r0, asr r0
21f2d494:	21f00054 	mvncss	r0, r4, asr r0

21f2d498 <cleanup_before_linux>:

int cleanup_before_linux (void)
{
21f2d498:	e1a0c00d 	mov	ip, sp
21f2d49c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d4a0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d4a4:	e24dd004 	sub	sp, sp, #4	; 0x4
	/*
	 * this function is called just before we call linux
	 * it prepares the processor for linux
	 *
	 * we turn off caches etc ...
	 */

	unsigned long i;

	disable_interrupts ();
21f2d4a8:	ebff4bbd 	bl	21f003a4 <disable_interrupts>

	/* turn off I/D-cache */
	asm ("mrc p15, 0, %0, c1, c0, 0":"=r" (i));
21f2d4ac:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
21f2d4b0:	e50b3010 	str	r3, [fp, #-16]
	i &= ~(C1_DC | C1_IC);
21f2d4b4:	e51b3010 	ldr	r3, [fp, #-16]
21f2d4b8:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
21f2d4bc:	e3c33004 	bic	r3, r3, #4	; 0x4
21f2d4c0:	e50b3010 	str	r3, [fp, #-16]
	asm ("mcr p15, 0, %0, c1, c0, 0": :"r" (i));
21f2d4c4:	e51b3010 	ldr	r3, [fp, #-16]
21f2d4c8:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}

	/* flush I/D-cache */
	i = 0;
21f2d4cc:	e3a03000 	mov	r3, #0	; 0x0
21f2d4d0:	e50b3010 	str	r3, [fp, #-16]
	asm ("mcr p15, 0, %0, c7, c7, 0": :"r" (i));
21f2d4d4:	e51b3010 	ldr	r3, [fp, #-16]
21f2d4d8:	ee073f17 	mcr	15, 0, r3, cr7, cr7, {0}

	return (0);
21f2d4dc:	e3a03000 	mov	r3, #0	; 0x0
}
21f2d4e0:	e1a00003 	mov	r0, r3
21f2d4e4:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d4e8 <do_reset>:

int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
{
21f2d4e8:	e1a0c00d 	mov	ip, sp
21f2d4ec:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d4f0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d4f4:	e24dd010 	sub	sp, sp, #16	; 0x10
21f2d4f8:	e50b0010 	str	r0, [fp, #-16]
21f2d4fc:	e50b1014 	str	r1, [fp, #-20]
21f2d500:	e50b2018 	str	r2, [fp, #-24]
21f2d504:	e50b301c 	str	r3, [fp, #-28]
	disable_interrupts ();
21f2d508:	ebff4ba5 	bl	21f003a4 <disable_interrupts>
	reset_cpu (0);
21f2d50c:	e3a00000 	mov	r0, #0	; 0x0
21f2d510:	ebff4deb 	bl	21f00cc4 <reset_cpu>
	/*NOTREACHED*/
	return (0);
21f2d514:	e3a03000 	mov	r3, #0	; 0x0
}
21f2d518:	e1a00003 	mov	r0, r3
21f2d51c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2d520:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2d524 <icache_enable>:

void icache_enable (void)
{
21f2d524:	e1a0c00d 	mov	ip, sp
21f2d528:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d52c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d530:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong reg;

	reg = read_p15_c1 ();		/* get control reg. */
21f2d534:	ebffffa3 	bl	21f2d3c8 <read_p15_c1>
21f2d538:	e1a03000 	mov	r3, r0
21f2d53c:	e50b3010 	str	r3, [fp, #-16]
	cp_delay ();
21f2d540:	ebffffb2 	bl	21f2d410 <cp_delay>
	write_p15_c1 (reg | C1_IC);
21f2d544:	e51b3010 	ldr	r3, [fp, #-16]
21f2d548:	e3833a01 	orr	r3, r3, #4096	; 0x1000
21f2d54c:	e1a00003 	mov	r0, r3
21f2d550:	ebffffa5 	bl	21f2d3ec <write_p15_c1>
}
21f2d554:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d558 <icache_disable>:

void icache_disable (void)
{
21f2d558:	e1a0c00d 	mov	ip, sp
21f2d55c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d560:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d564:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong reg;

	reg = read_p15_c1 ();
21f2d568:	ebffff96 	bl	21f2d3c8 <read_p15_c1>
21f2d56c:	e1a03000 	mov	r3, r0
21f2d570:	e50b3010 	str	r3, [fp, #-16]
	cp_delay ();
21f2d574:	ebffffa5 	bl	21f2d410 <cp_delay>
	write_p15_c1 (reg & ~C1_IC);
21f2d578:	e51b3010 	ldr	r3, [fp, #-16]
21f2d57c:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
21f2d580:	e1a00003 	mov	r0, r3
21f2d584:	ebffff98 	bl	21f2d3ec <write_p15_c1>
}
21f2d588:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d58c <icache_status>:

int icache_status (void)
{
21f2d58c:	e1a0c00d 	mov	ip, sp
21f2d590:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d594:	e24cb004 	sub	fp, ip, #4	; 0x4
	return (read_p15_c1 () & C1_IC) != 0;
21f2d598:	ebffff8a 	bl	21f2d3c8 <read_p15_c1>
21f2d59c:	e1a03000 	mov	r3, r0
21f2d5a0:	e1a03623 	mov	r3, r3, lsr #12
21f2d5a4:	e2033001 	and	r3, r3, #1	; 0x1
}
21f2d5a8:	e1a00003 	mov	r0, r3
21f2d5ac:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2d5b0 <dcache_enable>:

#ifdef USE_920T_MMU
/* It makes no sense to use the dcache if the MMU is not enabled */
void dcache_enable (void)
{
21f2d5b0:	e1a0c00d 	mov	ip, sp
21f2d5b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d5b8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d5bc:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong reg;

	reg = read_p15_c1 ();
21f2d5c0:	ebffff80 	bl	21f2d3c8 <read_p15_c1>
21f2d5c4:	e1a03000 	mov	r3, r0
21f2d5c8:	e50b3010 	str	r3, [fp, #-16]
	cp_delay ();
21f2d5cc:	ebffff8f 	bl	21f2d410 <cp_delay>
	write_p15_c1 (reg | C1_DC);
21f2d5d0:	e51b3010 	ldr	r3, [fp, #-16]
21f2d5d4:	e3833004 	orr	r3, r3, #4	; 0x4
21f2d5d8:	e1a00003 	mov	r0, r3
21f2d5dc:	ebffff82 	bl	21f2d3ec <write_p15_c1>
}
21f2d5e0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d5e4 <dcache_disable>:

void dcache_disable (void)
{
21f2d5e4:	e1a0c00d 	mov	ip, sp
21f2d5e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d5ec:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d5f0:	e24dd004 	sub	sp, sp, #4	; 0x4
	ulong reg;

	reg = read_p15_c1 ();
21f2d5f4:	ebffff73 	bl	21f2d3c8 <read_p15_c1>
21f2d5f8:	e1a03000 	mov	r3, r0
21f2d5fc:	e50b3010 	str	r3, [fp, #-16]
	cp_delay ();
21f2d600:	ebffff82 	bl	21f2d410 <cp_delay>
	reg &= ~C1_DC;
21f2d604:	e51b3010 	ldr	r3, [fp, #-16]
21f2d608:	e3c33004 	bic	r3, r3, #4	; 0x4
21f2d60c:	e50b3010 	str	r3, [fp, #-16]
	write_p15_c1 (reg);
21f2d610:	e51b0010 	ldr	r0, [fp, #-16]
21f2d614:	ebffff74 	bl	21f2d3ec <write_p15_c1>
}
21f2d618:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2d61c <dcache_status>:

int dcache_status (void)
{
21f2d61c:	e1a0c00d 	mov	ip, sp
21f2d620:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d624:	e24cb004 	sub	fp, ip, #4	; 0x4
	return (read_p15_c1 () & C1_DC) != 0;
21f2d628:	ebffff66 	bl	21f2d3c8 <read_p15_c1>
21f2d62c:	e1a03000 	mov	r3, r0
21f2d630:	e1a03123 	mov	r3, r3, lsr #2
21f2d634:	e2033001 	and	r3, r3, #1	; 0x1
}
21f2d638:	e1a00003 	mov	r0, r3
21f2d63c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2d640 <dm9161_IsPhyConnected>:
 *	TRUE - if id read successfully
 *	FALSE- if error
 */
unsigned int dm9161_IsPhyConnected (AT91PS_EMAC p_mac)
{
21f2d640:	e1a0c00d 	mov	ip, sp
21f2d644:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d648:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d64c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2d650:	e50b0014 	str	r0, [fp, #-20]
	unsigned short Id1, Id2;

	at91rm9200_EmacEnableMDIO (p_mac);
21f2d654:	e51b0014 	ldr	r0, [fp, #-20]
21f2d658:	eb000176 	bl	21f2dc38 <at91rm9200_EmacEnableMDIO>
	at91rm9200_EmacReadPhy (p_mac, DM9161_PHYID1, &Id1);
21f2d65c:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2d660:	e51b0014 	ldr	r0, [fp, #-20]
21f2d664:	e3a01002 	mov	r1, #2	; 0x2
21f2d668:	e1a02003 	mov	r2, r3
21f2d66c:	eb000187 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
	at91rm9200_EmacReadPhy (p_mac, DM9161_PHYID2, &Id2);
21f2d670:	e24b3010 	sub	r3, fp, #16	; 0x10
21f2d674:	e51b0014 	ldr	r0, [fp, #-20]
21f2d678:	e3a01003 	mov	r1, #3	; 0x3
21f2d67c:	e1a02003 	mov	r2, r3
21f2d680:	eb000182 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
	at91rm9200_EmacDisableMDIO (p_mac);
21f2d684:	e51b0014 	ldr	r0, [fp, #-20]
21f2d688:	eb000175 	bl	21f2dc64 <at91rm9200_EmacDisableMDIO>

	if ((Id1 == (DM9161_PHYID1_OUI >> 6)) &&
21f2d68c:	e15b20be 	ldrh	r2, [fp, #-14]
21f2d690:	e3a03d06 	mov	r3, #384	; 0x180
21f2d694:	e2833001 	add	r3, r3, #1	; 0x1
21f2d698:	e1520003 	cmp	r2, r3
21f2d69c:	1a000008 	bne	21f2d6c4 <dm9161_IsPhyConnected+0x84>
21f2d6a0:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2d6a4:	e1a03523 	mov	r3, r3, lsr #10
21f2d6a8:	e1a03803 	mov	r3, r3, lsl #16
21f2d6ac:	e1a03823 	mov	r3, r3, lsr #16
21f2d6b0:	e353002e 	cmp	r3, #46	; 0x2e
21f2d6b4:	1a000002 	bne	21f2d6c4 <dm9161_IsPhyConnected+0x84>
		((Id2 >> 10) == (DM9161_PHYID1_OUI & DM9161_LSB_MASK)))
		return TRUE;
21f2d6b8:	e3a03001 	mov	r3, #1	; 0x1
21f2d6bc:	e50b3018 	str	r3, [fp, #-24]
21f2d6c0:	ea000001 	b	21f2d6cc <dm9161_IsPhyConnected+0x8c>

	return FALSE;
21f2d6c4:	e3a03000 	mov	r3, #0	; 0x0
21f2d6c8:	e50b3018 	str	r3, [fp, #-24]
21f2d6cc:	e51b3018 	ldr	r3, [fp, #-24]
}
21f2d6d0:	e1a00003 	mov	r0, r3
21f2d6d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2d6d8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2d6dc <dm9161_GetLinkSpeed>:

/*
 * Name:
 *	dm9161_GetLinkSpeed
 * Description:
 *	Link parallel detection status of MAC is checked and set in the
 *	MAC configuration registers
 * Arguments:
 *	p_mac - pointer to MAC
 * Return value:
 *	TRUE - if link status set succesfully
 *	FALSE - if link status not set
 */
UCHAR dm9161_GetLinkSpeed (AT91PS_EMAC p_mac)
{
21f2d6dc:	e1a0c00d 	mov	ip, sp
21f2d6e0:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d6e4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d6e8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2d6ec:	e50b0014 	str	r0, [fp, #-20]
	unsigned short stat1, stat2;

	if (!at91rm9200_EmacReadPhy (p_mac, DM9161_BMSR, &stat1))
21f2d6f0:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2d6f4:	e51b0014 	ldr	r0, [fp, #-20]
21f2d6f8:	e3a01001 	mov	r1, #1	; 0x1
21f2d6fc:	e1a02003 	mov	r2, r3
21f2d700:	eb000162 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
21f2d704:	e1a03000 	mov	r3, r0
21f2d708:	e3530000 	cmp	r3, #0	; 0x0
21f2d70c:	1a000002 	bne	21f2d71c <dm9161_GetLinkSpeed+0x40>
		return FALSE;
21f2d710:	e3a03000 	mov	r3, #0	; 0x0
21f2d714:	e50b3018 	str	r3, [fp, #-24]
21f2d718:	ea000065 	b	21f2d8b4 <dm9161_GetLinkSpeed+0x1d8>

	if (!(stat1 & DM9161_LINK_STATUS))	/* link status up? */
21f2d71c:	e15b30be 	ldrh	r3, [fp, #-14]
21f2d720:	e1a03123 	mov	r3, r3, lsr #2
21f2d724:	e2033001 	and	r3, r3, #1	; 0x1
21f2d728:	e3530000 	cmp	r3, #0	; 0x0
21f2d72c:	1a000002 	bne	21f2d73c <dm9161_GetLinkSpeed+0x60>
		return FALSE;
21f2d730:	e3a03000 	mov	r3, #0	; 0x0
21f2d734:	e50b3018 	str	r3, [fp, #-24]
21f2d738:	ea00005d 	b	21f2d8b4 <dm9161_GetLinkSpeed+0x1d8>

	if (!at91rm9200_EmacReadPhy (p_mac, DM9161_DSCSR, &stat2))
21f2d73c:	e24b3010 	sub	r3, fp, #16	; 0x10
21f2d740:	e51b0014 	ldr	r0, [fp, #-20]
21f2d744:	e3a01011 	mov	r1, #17	; 0x11
21f2d748:	e1a02003 	mov	r2, r3
21f2d74c:	eb00014f 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
21f2d750:	e1a03000 	mov	r3, r0
21f2d754:	e3530000 	cmp	r3, #0	; 0x0
21f2d758:	1a000002 	bne	21f2d768 <dm9161_GetLinkSpeed+0x8c>
		return FALSE;
21f2d75c:	e3a03000 	mov	r3, #0	; 0x0
21f2d760:	e50b3018 	str	r3, [fp, #-24]
21f2d764:	ea000052 	b	21f2d8b4 <dm9161_GetLinkSpeed+0x1d8>

	if ((stat1 & DM9161_100BASE_TX_FD) && (stat2 & DM9161_100FDX)) {
21f2d768:	e15b30be 	ldrh	r3, [fp, #-14]
21f2d76c:	e1a03723 	mov	r3, r3, lsr #14
21f2d770:	e2033001 	and	r3, r3, #1	; 0x1
21f2d774:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d778:	e3530000 	cmp	r3, #0	; 0x0
21f2d77c:	0a00000c 	beq	21f2d7b4 <dm9161_GetLinkSpeed+0xd8>
21f2d780:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2d784:	e1a03803 	mov	r3, r3, lsl #16
21f2d788:	e1a03843 	mov	r3, r3, asr #16
21f2d78c:	e3530000 	cmp	r3, #0	; 0x0
21f2d790:	aa000007 	bge	21f2d7b4 <dm9161_GetLinkSpeed+0xd8>
		/*set Emac for 100BaseTX and Full Duplex  */
		p_mac->EMAC_CFG |= AT91C_EMAC_SPD | AT91C_EMAC_FD;
21f2d794:	e51b3014 	ldr	r3, [fp, #-20]
21f2d798:	e5933004 	ldr	r3, [r3, #4]
21f2d79c:	e3832003 	orr	r2, r3, #3	; 0x3
21f2d7a0:	e51b3014 	ldr	r3, [fp, #-20]
21f2d7a4:	e5832004 	str	r2, [r3, #4]
		return TRUE;
21f2d7a8:	e3a03001 	mov	r3, #1	; 0x1
21f2d7ac:	e50b3018 	str	r3, [fp, #-24]
21f2d7b0:	ea00003f 	b	21f2d8b4 <dm9161_GetLinkSpeed+0x1d8>
	}

	if ((stat1 & DM9161_10BASE_T_FD) && (stat2 & DM9161_10FDX)) {
21f2d7b4:	e15b30be 	ldrh	r3, [fp, #-14]
21f2d7b8:	e1a03623 	mov	r3, r3, lsr #12
21f2d7bc:	e2033001 	and	r3, r3, #1	; 0x1
21f2d7c0:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d7c4:	e3530000 	cmp	r3, #0	; 0x0
21f2d7c8:	0a00000e 	beq	21f2d808 <dm9161_GetLinkSpeed+0x12c>
21f2d7cc:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2d7d0:	e1a036a3 	mov	r3, r3, lsr #13
21f2d7d4:	e2033001 	and	r3, r3, #1	; 0x1
21f2d7d8:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d7dc:	e3530000 	cmp	r3, #0	; 0x0
21f2d7e0:	0a000008 	beq	21f2d808 <dm9161_GetLinkSpeed+0x12c>
		/*set MII for 10BaseT and Full Duplex  */
		p_mac->EMAC_CFG = (p_mac->EMAC_CFG &
21f2d7e4:	e51b3014 	ldr	r3, [fp, #-20]
21f2d7e8:	e5933004 	ldr	r3, [r3, #4]
21f2d7ec:	e3c33003 	bic	r3, r3, #3	; 0x3
21f2d7f0:	e3832002 	orr	r2, r3, #2	; 0x2
21f2d7f4:	e51b3014 	ldr	r3, [fp, #-20]
21f2d7f8:	e5832004 	str	r2, [r3, #4]
				~(AT91C_EMAC_SPD | AT91C_EMAC_FD))
				| AT91C_EMAC_FD;
		return TRUE;
21f2d7fc:	e3a03001 	mov	r3, #1	; 0x1
21f2d800:	e50b3018 	str	r3, [fp, #-24]
21f2d804:	ea00002a 	b	21f2d8b4 <dm9161_GetLinkSpeed+0x1d8>
	}

	if ((stat1 & DM9161_100BASE_T4_HD) && (stat2 & DM9161_100HDX)) {
21f2d808:	e15b30be 	ldrh	r3, [fp, #-14]
21f2d80c:	e1a036a3 	mov	r3, r3, lsr #13
21f2d810:	e2033001 	and	r3, r3, #1	; 0x1
21f2d814:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d818:	e3530000 	cmp	r3, #0	; 0x0
21f2d81c:	0a00000e 	beq	21f2d85c <dm9161_GetLinkSpeed+0x180>
21f2d820:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2d824:	e1a03723 	mov	r3, r3, lsr #14
21f2d828:	e2033001 	and	r3, r3, #1	; 0x1
21f2d82c:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d830:	e3530000 	cmp	r3, #0	; 0x0
21f2d834:	0a000008 	beq	21f2d85c <dm9161_GetLinkSpeed+0x180>
		/*set MII for 100BaseTX and Half Duplex  */
		p_mac->EMAC_CFG = (p_mac->EMAC_CFG &
21f2d838:	e51b3014 	ldr	r3, [fp, #-20]
21f2d83c:	e5933004 	ldr	r3, [r3, #4]
21f2d840:	e3c33003 	bic	r3, r3, #3	; 0x3
21f2d844:	e3832001 	orr	r2, r3, #1	; 0x1
21f2d848:	e51b3014 	ldr	r3, [fp, #-20]
21f2d84c:	e5832004 	str	r2, [r3, #4]
				~(AT91C_EMAC_SPD | AT91C_EMAC_FD))
				| AT91C_EMAC_SPD;
		return TRUE;
21f2d850:	e3a03001 	mov	r3, #1	; 0x1
21f2d854:	e50b3018 	str	r3, [fp, #-24]
21f2d858:	ea000015 	b	21f2d8b4 <dm9161_GetLinkSpeed+0x1d8>
	}

	if ((stat1 & DM9161_10BASE_T_HD) && (stat2 & DM9161_10HDX)) {
21f2d85c:	e15b30be 	ldrh	r3, [fp, #-14]
21f2d860:	e1a035a3 	mov	r3, r3, lsr #11
21f2d864:	e2033001 	and	r3, r3, #1	; 0x1
21f2d868:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d86c:	e3530000 	cmp	r3, #0	; 0x0
21f2d870:	0a00000d 	beq	21f2d8ac <dm9161_GetLinkSpeed+0x1d0>
21f2d874:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2d878:	e1a03623 	mov	r3, r3, lsr #12
21f2d87c:	e2033001 	and	r3, r3, #1	; 0x1
21f2d880:	e20330ff 	and	r3, r3, #255	; 0xff
21f2d884:	e3530000 	cmp	r3, #0	; 0x0
21f2d888:	0a000007 	beq	21f2d8ac <dm9161_GetLinkSpeed+0x1d0>
		/*set MII for 10BaseT and Half Duplex  */
		p_mac->EMAC_CFG &= ~(AT91C_EMAC_SPD | AT91C_EMAC_FD);
21f2d88c:	e51b3014 	ldr	r3, [fp, #-20]
21f2d890:	e5933004 	ldr	r3, [r3, #4]
21f2d894:	e3c32003 	bic	r2, r3, #3	; 0x3
21f2d898:	e51b3014 	ldr	r3, [fp, #-20]
21f2d89c:	e5832004 	str	r2, [r3, #4]
		return TRUE;
21f2d8a0:	e3a03001 	mov	r3, #1	; 0x1
21f2d8a4:	e50b3018 	str	r3, [fp, #-24]
21f2d8a8:	ea000001 	b	21f2d8b4 <dm9161_GetLinkSpeed+0x1d8>
	}
	return FALSE;
21f2d8ac:	e3a03000 	mov	r3, #0	; 0x0
21f2d8b0:	e50b3018 	str	r3, [fp, #-24]
21f2d8b4:	e51b3018 	ldr	r3, [fp, #-24]
}
21f2d8b8:	e1a00003 	mov	r0, r3
21f2d8bc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2d8c0:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2d8c4 <dm9161_InitPhy>:


/*
 * Name:
 *	dm9161_InitPhy
 * Description:
 *	MAC starts checking its link by using parallel detection and
 *	Autonegotiation and the same is set in the MAC configuration registers
 * Arguments:
 *	p_mac - pointer to struct AT91S_EMAC
 * Return value:
 *	TRUE - if link status set succesfully
 *	FALSE - if link status not set
 */
UCHAR dm9161_InitPhy (AT91PS_EMAC p_mac)
{
21f2d8c4:	e1a0c00d 	mov	ip, sp
21f2d8c8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d8cc:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d8d0:	e24dd008 	sub	sp, sp, #8	; 0x8
21f2d8d4:	e50b0014 	str	r0, [fp, #-20]
	UCHAR ret = TRUE;
21f2d8d8:	e3a03001 	mov	r3, #1	; 0x1
21f2d8dc:	e54b300d 	strb	r3, [fp, #-13]
	unsigned short IntValue;

	at91rm9200_EmacEnableMDIO (p_mac);
21f2d8e0:	e51b0014 	ldr	r0, [fp, #-20]
21f2d8e4:	eb0000d3 	bl	21f2dc38 <at91rm9200_EmacEnableMDIO>

	if (!dm9161_GetLinkSpeed (p_mac)) {
21f2d8e8:	e51b0014 	ldr	r0, [fp, #-20]
21f2d8ec:	ebffff7a 	bl	21f2d6dc <dm9161_GetLinkSpeed>
21f2d8f0:	e1a03000 	mov	r3, r0
21f2d8f4:	e3530000 	cmp	r3, #0	; 0x0
21f2d8f8:	1a000003 	bne	21f2d90c <dm9161_InitPhy+0x48>
		/* Try another time */
		ret = dm9161_GetLinkSpeed (p_mac);
21f2d8fc:	e51b0014 	ldr	r0, [fp, #-20]
21f2d900:	ebffff75 	bl	21f2d6dc <dm9161_GetLinkSpeed>
21f2d904:	e1a03000 	mov	r3, r0
21f2d908:	e54b300d 	strb	r3, [fp, #-13]
	}

	/* Disable PHY Interrupts */
	at91rm9200_EmacReadPhy (p_mac, DM9161_MDINTR, &IntValue);
21f2d90c:	e24b3010 	sub	r3, fp, #16	; 0x10
21f2d910:	e51b0014 	ldr	r0, [fp, #-20]
21f2d914:	e3a01015 	mov	r1, #21	; 0x15
21f2d918:	e1a02003 	mov	r2, r3
21f2d91c:	eb0000db 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
	/* set FDX, SPD, Link, INTR masks */
	IntValue |= (DM9161_FDX_MASK | DM9161_SPD_MASK |
21f2d920:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2d924:	e3833c0f 	orr	r3, r3, #3840	; 0xf00
21f2d928:	e1a03803 	mov	r3, r3, lsl #16
21f2d92c:	e1a03823 	mov	r3, r3, lsr #16
21f2d930:	e14b31b0 	strh	r3, [fp, #-16]
		     DM9161_LINK_MASK | DM9161_INTR_MASK);
	at91rm9200_EmacWritePhy (p_mac, DM9161_MDINTR, &IntValue);
21f2d934:	e24b3010 	sub	r3, fp, #16	; 0x10
21f2d938:	e51b0014 	ldr	r0, [fp, #-20]
21f2d93c:	e3a01015 	mov	r1, #21	; 0x15
21f2d940:	e1a02003 	mov	r2, r3
21f2d944:	eb0000ec 	bl	21f2dcfc <at91rm9200_EmacWritePhy>
	at91rm9200_EmacDisableMDIO (p_mac);
21f2d948:	e51b0014 	ldr	r0, [fp, #-20]
21f2d94c:	eb0000c4 	bl	21f2dc64 <at91rm9200_EmacDisableMDIO>

	return (ret);
21f2d950:	e55b300d 	ldrb	r3, [fp, #-13]
}
21f2d954:	e1a00003 	mov	r0, r3
21f2d958:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2d95c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2d960 <dm9161_AutoNegotiate>:


/*
 * Name:
 *	dm9161_AutoNegotiate
 * Description:
 *	MAC Autonegotiates with the partner status of same is set in the
 *	MAC configuration registers
 * Arguments:
 *	dev - pointer to struct net_device
 * Return value:
 *	TRUE - if link status set successfully
 *	FALSE - if link status not set
 */
UCHAR dm9161_AutoNegotiate (AT91PS_EMAC p_mac, int *status)
{
21f2d960:	e1a0c00d 	mov	ip, sp
21f2d964:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2d968:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2d96c:	e24dd01c 	sub	sp, sp, #28	; 0x1c
21f2d970:	e50b0018 	str	r0, [fp, #-24]
21f2d974:	e50b101c 	str	r1, [fp, #-28]
	unsigned short value;
	unsigned short PhyAnar;
	unsigned short PhyAnalpar;

	/* Set dm9161 control register */
	if (!at91rm9200_EmacReadPhy (p_mac, DM9161_BMCR, &value))
21f2d978:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2d97c:	e51b0018 	ldr	r0, [fp, #-24]
21f2d980:	e3a01000 	mov	r1, #0	; 0x0
21f2d984:	e1a02003 	mov	r2, r3
21f2d988:	eb0000c0 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
21f2d98c:	e1a03000 	mov	r3, r0
21f2d990:	e3530000 	cmp	r3, #0	; 0x0
21f2d994:	1a000002 	bne	21f2d9a4 <dm9161_AutoNegotiate+0x44>
		return FALSE;
21f2d998:	e3a02000 	mov	r2, #0	; 0x0
21f2d99c:	e50b2028 	str	r2, [fp, #-40]
21f2d9a0:	ea0000a0 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>
	value &= ~DM9161_AUTONEG;	/* remove autonegotiation enable */
21f2d9a4:	e15b30be 	ldrh	r3, [fp, #-14]
21f2d9a8:	e50b3024 	str	r3, [fp, #-36]
21f2d9ac:	e51b2024 	ldr	r2, [fp, #-36]
21f2d9b0:	e3c23a01 	bic	r3, r2, #4096	; 0x1000
21f2d9b4:	e1a03803 	mov	r3, r3, lsl #16
21f2d9b8:	e1a03823 	mov	r3, r3, lsr #16
21f2d9bc:	e50b3024 	str	r3, [fp, #-36]
21f2d9c0:	e51b3024 	ldr	r3, [fp, #-36]
21f2d9c4:	e14b30be 	strh	r3, [fp, #-14]
	value |= DM9161_ISOLATE;	/* Electrically isolate PHY */
21f2d9c8:	e15b30be 	ldrh	r3, [fp, #-14]
21f2d9cc:	e3833b01 	orr	r3, r3, #1024	; 0x400
21f2d9d0:	e1a03803 	mov	r3, r3, lsl #16
21f2d9d4:	e1a03823 	mov	r3, r3, lsr #16
21f2d9d8:	e14b30be 	strh	r3, [fp, #-14]
	if (!at91rm9200_EmacWritePhy (p_mac, DM9161_BMCR, &value))
21f2d9dc:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2d9e0:	e51b0018 	ldr	r0, [fp, #-24]
21f2d9e4:	e3a01000 	mov	r1, #0	; 0x0
21f2d9e8:	e1a02003 	mov	r2, r3
21f2d9ec:	eb0000c2 	bl	21f2dcfc <at91rm9200_EmacWritePhy>
21f2d9f0:	e1a03000 	mov	r3, r0
21f2d9f4:	e3530000 	cmp	r3, #0	; 0x0
21f2d9f8:	1a000002 	bne	21f2da08 <dm9161_AutoNegotiate+0xa8>
		return FALSE;
21f2d9fc:	e3a02000 	mov	r2, #0	; 0x0
21f2da00:	e50b2028 	str	r2, [fp, #-40]
21f2da04:	ea000087 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>

	/* Set the Auto_negotiation Advertisement Register */
	/* MII advertising for Next page, 100BaseTxFD and HD, 10BaseTFD and HD, IEEE 802.3 */
	PhyAnar = DM9161_NP | DM9161_TX_FDX | DM9161_TX_HDX |
21f2da08:	e3e03c7e 	mvn	r3, #32256	; 0x7e00
21f2da0c:	e243301e 	sub	r3, r3, #30	; 0x1e
21f2da10:	e14b31b0 	strh	r3, [fp, #-16]
		  DM9161_10_FDX | DM9161_10_HDX | DM9161_AN_IEEE_802_3;
	if (!at91rm9200_EmacWritePhy (p_mac, DM9161_ANAR, &PhyAnar))
21f2da14:	e24b3010 	sub	r3, fp, #16	; 0x10
21f2da18:	e51b0018 	ldr	r0, [fp, #-24]
21f2da1c:	e3a01004 	mov	r1, #4	; 0x4
21f2da20:	e1a02003 	mov	r2, r3
21f2da24:	eb0000b4 	bl	21f2dcfc <at91rm9200_EmacWritePhy>
21f2da28:	e1a03000 	mov	r3, r0
21f2da2c:	e3530000 	cmp	r3, #0	; 0x0
21f2da30:	1a000002 	bne	21f2da40 <dm9161_AutoNegotiate+0xe0>
		return FALSE;
21f2da34:	e3a03000 	mov	r3, #0	; 0x0
21f2da38:	e50b3028 	str	r3, [fp, #-40]
21f2da3c:	ea000079 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>

	/* Read the Control Register     */
	if (!at91rm9200_EmacReadPhy (p_mac, DM9161_BMCR, &value))
21f2da40:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2da44:	e51b0018 	ldr	r0, [fp, #-24]
21f2da48:	e3a01000 	mov	r1, #0	; 0x0
21f2da4c:	e1a02003 	mov	r2, r3
21f2da50:	eb00008e 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
21f2da54:	e1a03000 	mov	r3, r0
21f2da58:	e3530000 	cmp	r3, #0	; 0x0
21f2da5c:	1a000002 	bne	21f2da6c <dm9161_AutoNegotiate+0x10c>
		return FALSE;
21f2da60:	e3a02000 	mov	r2, #0	; 0x0
21f2da64:	e50b2028 	str	r2, [fp, #-40]
21f2da68:	ea00006e 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>

	value |= DM9161_SPEED_SELECT | DM9161_AUTONEG | DM9161_DUPLEX_MODE;
21f2da6c:	e15b30be 	ldrh	r3, [fp, #-14]
21f2da70:	e3833c31 	orr	r3, r3, #12544	; 0x3100
21f2da74:	e1a03803 	mov	r3, r3, lsl #16
21f2da78:	e1a03823 	mov	r3, r3, lsr #16
21f2da7c:	e14b30be 	strh	r3, [fp, #-14]
	if (!at91rm9200_EmacWritePhy (p_mac, DM9161_BMCR, &value))
21f2da80:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2da84:	e51b0018 	ldr	r0, [fp, #-24]
21f2da88:	e3a01000 	mov	r1, #0	; 0x0
21f2da8c:	e1a02003 	mov	r2, r3
21f2da90:	eb000099 	bl	21f2dcfc <at91rm9200_EmacWritePhy>
21f2da94:	e1a03000 	mov	r3, r0
21f2da98:	e3530000 	cmp	r3, #0	; 0x0
21f2da9c:	1a000002 	bne	21f2daac <dm9161_AutoNegotiate+0x14c>
		return FALSE;
21f2daa0:	e3a03000 	mov	r3, #0	; 0x0
21f2daa4:	e50b3028 	str	r3, [fp, #-40]
21f2daa8:	ea00005e 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>
	/* Restart Auto_negotiation  */
	value |= DM9161_RESTART_AUTONEG;
21f2daac:	e15b30be 	ldrh	r3, [fp, #-14]
21f2dab0:	e3833c02 	orr	r3, r3, #512	; 0x200
21f2dab4:	e1a03803 	mov	r3, r3, lsl #16
21f2dab8:	e1a03823 	mov	r3, r3, lsr #16
21f2dabc:	e14b30be 	strh	r3, [fp, #-14]
	value &= ~DM9161_ISOLATE;
21f2dac0:	e15b30be 	ldrh	r3, [fp, #-14]
21f2dac4:	e50b3020 	str	r3, [fp, #-32]
21f2dac8:	e51b2020 	ldr	r2, [fp, #-32]
21f2dacc:	e3c23b01 	bic	r3, r2, #1024	; 0x400
21f2dad0:	e1a03803 	mov	r3, r3, lsl #16
21f2dad4:	e1a03823 	mov	r3, r3, lsr #16
21f2dad8:	e50b3020 	str	r3, [fp, #-32]
21f2dadc:	e51b3020 	ldr	r3, [fp, #-32]
21f2dae0:	e14b30be 	strh	r3, [fp, #-14]
	if (!at91rm9200_EmacWritePhy (p_mac, DM9161_BMCR, &value))
21f2dae4:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2dae8:	e51b0018 	ldr	r0, [fp, #-24]
21f2daec:	e3a01000 	mov	r1, #0	; 0x0
21f2daf0:	e1a02003 	mov	r2, r3
21f2daf4:	eb000080 	bl	21f2dcfc <at91rm9200_EmacWritePhy>
21f2daf8:	e1a03000 	mov	r3, r0
21f2dafc:	e3530000 	cmp	r3, #0	; 0x0
21f2db00:	1a000002 	bne	21f2db10 <dm9161_AutoNegotiate+0x1b0>
		return FALSE;
21f2db04:	e3a02000 	mov	r2, #0	; 0x0
21f2db08:	e50b2028 	str	r2, [fp, #-40]
21f2db0c:	ea000045 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>

	/*check AutoNegotiate complete */
	udelay (10000);
21f2db10:	e3a00c27 	mov	r0, #9984	; 0x2700
21f2db14:	e2800010 	add	r0, r0, #16	; 0x10
21f2db18:	ebff4be2 	bl	21f00aa8 <udelay>
	at91rm9200_EmacReadPhy (p_mac, DM9161_BMSR, &value);
21f2db1c:	e24b300e 	sub	r3, fp, #14	; 0xe
21f2db20:	e51b0018 	ldr	r0, [fp, #-24]
21f2db24:	e3a01001 	mov	r1, #1	; 0x1
21f2db28:	e1a02003 	mov	r2, r3
21f2db2c:	eb000057 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
	if (!(value & DM9161_AUTONEG_COMP))
21f2db30:	e15b30be 	ldrh	r3, [fp, #-14]
21f2db34:	e1a032a3 	mov	r3, r3, lsr #5
21f2db38:	e2033001 	and	r3, r3, #1	; 0x1
21f2db3c:	e3530000 	cmp	r3, #0	; 0x0
21f2db40:	1a000002 	bne	21f2db50 <dm9161_AutoNegotiate+0x1f0>
		return FALSE;
21f2db44:	e3a03000 	mov	r3, #0	; 0x0
21f2db48:	e50b3028 	str	r3, [fp, #-40]
21f2db4c:	ea000035 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>

	/* Get the AutoNeg Link partner base page */
	if (!at91rm9200_EmacReadPhy (p_mac, DM9161_ANLPAR, &PhyAnalpar))
21f2db50:	e24b3012 	sub	r3, fp, #18	; 0x12
21f2db54:	e51b0018 	ldr	r0, [fp, #-24]
21f2db58:	e3a01005 	mov	r1, #5	; 0x5
21f2db5c:	e1a02003 	mov	r2, r3
21f2db60:	eb00004a 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
21f2db64:	e1a03000 	mov	r3, r0
21f2db68:	e3530000 	cmp	r3, #0	; 0x0
21f2db6c:	1a000002 	bne	21f2db7c <dm9161_AutoNegotiate+0x21c>
		return FALSE;
21f2db70:	e3a02000 	mov	r2, #0	; 0x0
21f2db74:	e50b2028 	str	r2, [fp, #-40]
21f2db78:	ea00002a 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>

	if ((PhyAnar & DM9161_TX_FDX) && (PhyAnalpar & DM9161_TX_FDX)) {
21f2db7c:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2db80:	e1a03423 	mov	r3, r3, lsr #8
21f2db84:	e2033001 	and	r3, r3, #1	; 0x1
21f2db88:	e20330ff 	and	r3, r3, #255	; 0xff
21f2db8c:	e3530000 	cmp	r3, #0	; 0x0
21f2db90:	0a00000d 	beq	21f2dbcc <dm9161_AutoNegotiate+0x26c>
21f2db94:	e15b31b2 	ldrh	r3, [fp, #-18]
21f2db98:	e1a03423 	mov	r3, r3, lsr #8
21f2db9c:	e2033001 	and	r3, r3, #1	; 0x1
21f2dba0:	e20330ff 	and	r3, r3, #255	; 0xff
21f2dba4:	e3530000 	cmp	r3, #0	; 0x0
21f2dba8:	0a000007 	beq	21f2dbcc <dm9161_AutoNegotiate+0x26c>
		/*set MII for 100BaseTX and Full Duplex  */
		p_mac->EMAC_CFG |= AT91C_EMAC_SPD | AT91C_EMAC_FD;
21f2dbac:	e51b3018 	ldr	r3, [fp, #-24]
21f2dbb0:	e5933004 	ldr	r3, [r3, #4]
21f2dbb4:	e3832003 	orr	r2, r3, #3	; 0x3
21f2dbb8:	e51b3018 	ldr	r3, [fp, #-24]
21f2dbbc:	e5832004 	str	r2, [r3, #4]
		return TRUE;
21f2dbc0:	e3a03001 	mov	r3, #1	; 0x1
21f2dbc4:	e50b3028 	str	r3, [fp, #-40]
21f2dbc8:	ea000016 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>
	}

	if ((PhyAnar & DM9161_10_FDX) && (PhyAnalpar & DM9161_10_FDX)) {
21f2dbcc:	e15b31b0 	ldrh	r3, [fp, #-16]
21f2dbd0:	e1a03323 	mov	r3, r3, lsr #6
21f2dbd4:	e2033001 	and	r3, r3, #1	; 0x1
21f2dbd8:	e20330ff 	and	r3, r3, #255	; 0xff
21f2dbdc:	e3530000 	cmp	r3, #0	; 0x0
21f2dbe0:	0a00000e 	beq	21f2dc20 <dm9161_AutoNegotiate+0x2c0>
21f2dbe4:	e15b31b2 	ldrh	r3, [fp, #-18]
21f2dbe8:	e1a03323 	mov	r3, r3, lsr #6
21f2dbec:	e2033001 	and	r3, r3, #1	; 0x1
21f2dbf0:	e20330ff 	and	r3, r3, #255	; 0xff
21f2dbf4:	e3530000 	cmp	r3, #0	; 0x0
21f2dbf8:	0a000008 	beq	21f2dc20 <dm9161_AutoNegotiate+0x2c0>
		/*set MII for 10BaseT and Full Duplex  */
		p_mac->EMAC_CFG = (p_mac->EMAC_CFG &
21f2dbfc:	e51b3018 	ldr	r3, [fp, #-24]
21f2dc00:	e5933004 	ldr	r3, [r3, #4]
21f2dc04:	e3c33003 	bic	r3, r3, #3	; 0x3
21f2dc08:	e3832002 	orr	r2, r3, #2	; 0x2
21f2dc0c:	e51b3018 	ldr	r3, [fp, #-24]
21f2dc10:	e5832004 	str	r2, [r3, #4]
				~(AT91C_EMAC_SPD | AT91C_EMAC_FD))
				| AT91C_EMAC_FD;
		return TRUE;
21f2dc14:	e3a02001 	mov	r2, #1	; 0x1
21f2dc18:	e50b2028 	str	r2, [fp, #-40]
21f2dc1c:	ea000001 	b	21f2dc28 <dm9161_AutoNegotiate+0x2c8>
	}
	return FALSE;
21f2dc20:	e3a03000 	mov	r3, #0	; 0x0
21f2dc24:	e50b3028 	str	r3, [fp, #-40]
21f2dc28:	e51b3028 	ldr	r3, [fp, #-40]
}
21f2dc2c:	e1a00003 	mov	r0, r3
21f2dc30:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2dc34:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2dc38 <at91rm9200_EmacEnableMDIO>:
 * Return value:
 *	none
 */
void at91rm9200_EmacEnableMDIO (AT91PS_EMAC p_mac)
{
21f2dc38:	e1a0c00d 	mov	ip, sp
21f2dc3c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2dc40:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2dc44:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2dc48:	e50b0010 	str	r0, [fp, #-16]
	/* Mac CTRL reg set for MDIO enable */
	p_mac->EMAC_CTL |= AT91C_EMAC_MPE;	/* Management port enable */
21f2dc4c:	e51b3010 	ldr	r3, [fp, #-16]
21f2dc50:	e5933000 	ldr	r3, [r3]
21f2dc54:	e3832010 	orr	r2, r3, #16	; 0x10
21f2dc58:	e51b3010 	ldr	r3, [fp, #-16]
21f2dc5c:	e5832000 	str	r2, [r3]
}
21f2dc60:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2dc64 <at91rm9200_EmacDisableMDIO>:

/*
 * Name:
 *	at91rm9200_EmacDisableMDIO
 * Description:
 *	Disables the MDIO bit in MAC control register
 * Arguments:
 *	p_mac - pointer to struct AT91S_EMAC
 * Return value:
 *	none
 */
void at91rm9200_EmacDisableMDIO (AT91PS_EMAC p_mac)
{
21f2dc64:	e1a0c00d 	mov	ip, sp
21f2dc68:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2dc6c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2dc70:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2dc74:	e50b0010 	str	r0, [fp, #-16]
	/* Mac CTRL reg set for MDIO disable */
	p_mac->EMAC_CTL &= ~AT91C_EMAC_MPE;	/* Management port disable */
21f2dc78:	e51b3010 	ldr	r3, [fp, #-16]
21f2dc7c:	e5933000 	ldr	r3, [r3]
21f2dc80:	e3c32010 	bic	r2, r3, #16	; 0x10
21f2dc84:	e51b3010 	ldr	r3, [fp, #-16]
21f2dc88:	e5832000 	str	r2, [r3]
}
21f2dc8c:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2dc90 <at91rm9200_EmacReadPhy>:


/*
 * Name:
 *	at91rm9200_EmacReadPhy
 * Description:
 *	Reads data from the PHY register
 * Arguments:
 *	dev - pointer to struct net_device
 *	RegisterAddress - unsigned char
 * 	pInput - pointer to value read from register
 * Return value:
 *	TRUE - if data read successfully
 */
UCHAR at91rm9200_EmacReadPhy (AT91PS_EMAC p_mac,
				     unsigned char RegisterAddress,
				     unsigned short *pInput)
{
21f2dc90:	e1a0c00d 	mov	ip, sp
21f2dc94:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2dc98:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2dc9c:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2dca0:	e50b0010 	str	r0, [fp, #-16]
21f2dca4:	e1a03001 	mov	r3, r1
21f2dca8:	e50b2018 	str	r2, [fp, #-24]
21f2dcac:	e54b3014 	strb	r3, [fp, #-20]
	p_mac->EMAC_MAN = (AT91C_EMAC_HIGH & ~AT91C_EMAC_LOW) |
21f2dcb0:	e55b3014 	ldrb	r3, [fp, #-20]
21f2dcb4:	e1a03903 	mov	r3, r3, lsl #18
21f2dcb8:	e3833206 	orr	r3, r3, #1610612736	; 0x60000000
21f2dcbc:	e3833802 	orr	r3, r3, #131072	; 0x20000
21f2dcc0:	e51b2010 	ldr	r2, [fp, #-16]
21f2dcc4:	e5823034 	str	r3, [r2, #52]
			  (AT91C_EMAC_RW_R) |
			  (RegisterAddress << 18) |
			  (AT91C_EMAC_CODE_802_3);

	udelay (10000);
21f2dcc8:	e3a00c27 	mov	r0, #9984	; 0x2700
21f2dccc:	e2800010 	add	r0, r0, #16	; 0x10
21f2dcd0:	ebff4b74 	bl	21f00aa8 <udelay>

	*pInput = (unsigned short) p_mac->EMAC_MAN;
21f2dcd4:	e51b3010 	ldr	r3, [fp, #-16]
21f2dcd8:	e5933034 	ldr	r3, [r3, #52]
21f2dcdc:	e1a03803 	mov	r3, r3, lsl #16
21f2dce0:	e1a02823 	mov	r2, r3, lsr #16
21f2dce4:	e51b3018 	ldr	r3, [fp, #-24]
21f2dce8:	e1c320b0 	strh	r2, [r3]

	return TRUE;
21f2dcec:	e3a03001 	mov	r3, #1	; 0x1
}
21f2dcf0:	e1a00003 	mov	r0, r3
21f2dcf4:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2dcf8:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2dcfc <at91rm9200_EmacWritePhy>:


/*
 * Name:
 *	at91rm9200_EmacWritePhy
 * Description:
 *	Writes data to the PHY register
 * Arguments:
 *	dev - pointer to struct net_device
 *	RegisterAddress - unsigned char
 * 	pOutput - pointer to value to be written in the register
 * Return value:
 *	TRUE - if data read successfully
 */
UCHAR at91rm9200_EmacWritePhy (AT91PS_EMAC p_mac,
				      unsigned char RegisterAddress,
				      unsigned short *pOutput)
{
21f2dcfc:	e1a0c00d 	mov	ip, sp
21f2dd00:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2dd04:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2dd08:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2dd0c:	e50b0010 	str	r0, [fp, #-16]
21f2dd10:	e1a03001 	mov	r3, r1
21f2dd14:	e50b2018 	str	r2, [fp, #-24]
21f2dd18:	e54b3014 	strb	r3, [fp, #-20]
	p_mac->EMAC_MAN = (AT91C_EMAC_HIGH & ~AT91C_EMAC_LOW) |
21f2dd1c:	e55b3014 	ldrb	r3, [fp, #-20]
21f2dd20:	e1a03903 	mov	r3, r3, lsl #18
21f2dd24:	e1a02003 	mov	r2, r3
21f2dd28:	e51b3018 	ldr	r3, [fp, #-24]
21f2dd2c:	e1d330b0 	ldrh	r3, [r3]
21f2dd30:	e1823003 	orr	r3, r2, r3
21f2dd34:	e3833205 	orr	r3, r3, #1342177280	; 0x50000000
21f2dd38:	e3833802 	orr	r3, r3, #131072	; 0x20000
21f2dd3c:	e51b2010 	ldr	r2, [fp, #-16]
21f2dd40:	e5823034 	str	r3, [r2, #52]
			AT91C_EMAC_CODE_802_3 | AT91C_EMAC_RW_W |
			(RegisterAddress << 18) | *pOutput;

	udelay (10000);
21f2dd44:	e3a00c27 	mov	r0, #9984	; 0x2700
21f2dd48:	e2800010 	add	r0, r0, #16	; 0x10
21f2dd4c:	ebff4b55 	bl	21f00aa8 <udelay>

	return TRUE;
21f2dd50:	e3a03001 	mov	r3, #1	; 0x1
}
21f2dd54:	e1a00003 	mov	r0, r3
21f2dd58:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2dd5c:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2dd60 <eth_init>:

int eth_init (bd_t * bd)
{
21f2dd60:	e1a0c00d 	mov	ip, sp
21f2dd64:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2dd68:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2dd6c:	e24dd010 	sub	sp, sp, #16	; 0x10
21f2dd70:	e50b0018 	str	r0, [fp, #-24]
	int ret;
	int i;

	p_mac = AT91C_BASE_EMAC;
21f2dd74:	e59f22c8 	ldr	r2, [pc, #712]	; 21f2e044 <.text+0x2e044>
21f2dd78:	e3a0332f 	mov	r3, #-1140850688	; 0xbc000000
21f2dd7c:	e1a03643 	mov	r3, r3, asr #12
21f2dd80:	e5823000 	str	r3, [r2]

	/* PIO Disable Register */
	*AT91C_PIOA_PDR = AT91C_PA16_EMDIO | AT91C_PA15_EMDC | AT91C_PA14_ERXER |
21f2dd84:	e3e02ebf 	mvn	r2, #3056	; 0xbf0
21f2dd88:	e242200b 	sub	r2, r2, #11	; 0xb
21f2dd8c:	e3a03b7f 	mov	r3, #130048	; 0x1fc00
21f2dd90:	e2833d0e 	add	r3, r3, #896	; 0x380
21f2dd94:	e5823000 	str	r3, [r2]
			  AT91C_PA13_ERX1 | AT91C_PA12_ERX0 | AT91C_PA11_ECRS_ECRSDV |
			  AT91C_PA10_ETX1 | AT91C_PA9_ETX0 | AT91C_PA8_ETXEN |
			  AT91C_PA7_ETXCK_EREFCK;

#ifdef CONFIG_AT91C_USE_RMII
	*AT91C_PIOB_PDR = AT91C_PB19_ERXCK;
21f2dd98:	e3e03e9f 	mvn	r3, #2544	; 0x9f0
21f2dd9c:	e243300b 	sub	r3, r3, #11	; 0xb
21f2dda0:	e3a02702 	mov	r2, #524288	; 0x80000
21f2dda4:	e5832000 	str	r2, [r3]
	*AT91C_PIOB_BSR = AT91C_PB19_ERXCK;
21f2dda8:	e3e03d26 	mvn	r3, #2432	; 0x980
21f2ddac:	e243300b 	sub	r3, r3, #11	; 0xb
21f2ddb0:	e3a02702 	mov	r2, #524288	; 0x80000
21f2ddb4:	e5832000 	str	r2, [r3]
#else
	*AT91C_PIOB_PDR = AT91C_PB19_ERXCK | AT91C_PB18_ECOL | AT91C_PB17_ERXDV |
			  AT91C_PB16_ERX3 | AT91C_PB15_ERX2 | AT91C_PB14_ETXER |
			  AT91C_PB13_ETX3 | AT91C_PB12_ETX2;

	/* Select B Register */
	*AT91C_PIOB_BSR = AT91C_PB19_ERXCK | AT91C_PB18_ECOL |
			  AT91C_PB17_ERXDV | AT91C_PB16_ERX3 | AT91C_PB15_ERX2 |
			  AT91C_PB14_ETXER | AT91C_PB13_ETX3 | AT91C_PB12_ETX2;
#endif

	*AT91C_PMC_PCER = 1 << AT91C_ID_EMAC;	/* Peripheral Clock Enable Register */
21f2ddb8:	e3a03482 	mov	r3, #-2113929216	; 0x82000000
21f2ddbc:	e1a03ac3 	mov	r3, r3, asr #21
21f2ddc0:	e3a02401 	mov	r2, #16777216	; 0x1000000
21f2ddc4:	e5832000 	str	r2, [r3]

	p_mac->EMAC_CFG |= AT91C_EMAC_CSR;	/* Clear statistics */
21f2ddc8:	e59f3274 	ldr	r3, [pc, #628]	; 21f2e044 <.text+0x2e044>
21f2ddcc:	e5932000 	ldr	r2, [r3]
21f2ddd0:	e59f326c 	ldr	r3, [pc, #620]	; 21f2e044 <.text+0x2e044>
21f2ddd4:	e5933000 	ldr	r3, [r3]
21f2ddd8:	e5933004 	ldr	r3, [r3, #4]
21f2dddc:	e3833020 	orr	r3, r3, #32	; 0x20
21f2dde0:	e5823004 	str	r3, [r2, #4]

	/* Init Ehternet buffers */
	for (i = 0; i < RBF_FRAMEMAX; i++) {
21f2dde4:	e3a03000 	mov	r3, #0	; 0x0
21f2dde8:	e50b3010 	str	r3, [fp, #-16]
21f2ddec:	ea000016 	b	21f2de4c <eth_init+0xec>
		rbfdt[i].addr = (unsigned long)rbf_framebuf[i];
21f2ddf0:	e51b1010 	ldr	r1, [fp, #-16]
21f2ddf4:	e51b2010 	ldr	r2, [fp, #-16]
21f2ddf8:	e1a03002 	mov	r3, r2
21f2ddfc:	e1a03083 	mov	r3, r3, lsl #1
21f2de00:	e0833002 	add	r3, r3, r2
21f2de04:	e1a03483 	mov	r3, r3, lsl #9
21f2de08:	e1a02003 	mov	r2, r3
21f2de0c:	e59f3234 	ldr	r3, [pc, #564]	; 21f2e048 <.text+0x2e048>
21f2de10:	e0823003 	add	r3, r2, r3
21f2de14:	e1a02003 	mov	r2, r3
21f2de18:	e59f322c 	ldr	r3, [pc, #556]	; 21f2e04c <.text+0x2e04c>
21f2de1c:	e7832181 	str	r2, [r3, r1, lsl #3]
		rbfdt[i].size = 0;
21f2de20:	e51b3010 	ldr	r3, [fp, #-16]
21f2de24:	e59f2220 	ldr	r2, [pc, #544]	; 21f2e04c <.text+0x2e04c>
21f2de28:	e3a01004 	mov	r1, #4	; 0x4
21f2de2c:	e1a03183 	mov	r3, r3, lsl #3
21f2de30:	e0833002 	add	r3, r3, r2
21f2de34:	e0832001 	add	r2, r3, r1
21f2de38:	e3a03000 	mov	r3, #0	; 0x0
21f2de3c:	e5823000 	str	r3, [r2]
21f2de40:	e51b3010 	ldr	r3, [fp, #-16]
21f2de44:	e2833001 	add	r3, r3, #1	; 0x1
21f2de48:	e50b3010 	str	r3, [fp, #-16]
21f2de4c:	e51b3010 	ldr	r3, [fp, #-16]
21f2de50:	e353003f 	cmp	r3, #63	; 0x3f
21f2de54:	daffffe5 	ble	21f2ddf0 <eth_init+0x90>
	}
	rbfdt[RBF_FRAMEMAX - 1].addr |= RBF_WRAP;
21f2de58:	e59f31ec 	ldr	r3, [pc, #492]	; 21f2e04c <.text+0x2e04c>
21f2de5c:	e59331f8 	ldr	r3, [r3, #504]
21f2de60:	e3832002 	orr	r2, r3, #2	; 0x2
21f2de64:	e59f31e0 	ldr	r3, [pc, #480]	; 21f2e04c <.text+0x2e04c>
21f2de68:	e58321f8 	str	r2, [r3, #504]
	rbfp = &rbfdt[0];
21f2de6c:	e59f21dc 	ldr	r2, [pc, #476]	; 21f2e050 <.text+0x2e050>
21f2de70:	e59f31d4 	ldr	r3, [pc, #468]	; 21f2e04c <.text+0x2e04c>
21f2de74:	e5823000 	str	r3, [r2]

	p_mac->EMAC_SA2L = (bd->bi_enetaddr[3] << 24) | (bd->bi_enetaddr[2] << 16)
21f2de78:	e59f31c4 	ldr	r3, [pc, #452]	; 21f2e044 <.text+0x2e044>
21f2de7c:	e5931000 	ldr	r1, [r3]
21f2de80:	e51b3018 	ldr	r3, [fp, #-24]
21f2de84:	e5d3300b 	ldrb	r3, [r3, #11]
21f2de88:	e1a02c03 	mov	r2, r3, lsl #24
21f2de8c:	e51b3018 	ldr	r3, [fp, #-24]
21f2de90:	e5d3300a 	ldrb	r3, [r3, #10]
21f2de94:	e1a03803 	mov	r3, r3, lsl #16
21f2de98:	e1822003 	orr	r2, r2, r3
21f2de9c:	e51b3018 	ldr	r3, [fp, #-24]
21f2dea0:	e5d33009 	ldrb	r3, [r3, #9]
21f2dea4:	e1a03403 	mov	r3, r3, lsl #8
21f2dea8:	e1822003 	orr	r2, r2, r3
21f2deac:	e51b3018 	ldr	r3, [fp, #-24]
21f2deb0:	e5d33008 	ldrb	r3, [r3, #8]
21f2deb4:	e1823003 	orr	r3, r2, r3
21f2deb8:	e58130a0 	str	r3, [r1, #160]
			 | (bd->bi_enetaddr[1] <<  8) | (bd->bi_enetaddr[0]);
	p_mac->EMAC_SA2H = (bd->bi_enetaddr[5] <<  8) | (bd->bi_enetaddr[4]);
21f2debc:	e59f3180 	ldr	r3, [pc, #384]	; 21f2e044 <.text+0x2e044>
21f2dec0:	e5931000 	ldr	r1, [r3]
21f2dec4:	e51b3018 	ldr	r3, [fp, #-24]
21f2dec8:	e5d3300d 	ldrb	r3, [r3, #13]
21f2decc:	e1a02403 	mov	r2, r3, lsl #8
21f2ded0:	e51b3018 	ldr	r3, [fp, #-24]
21f2ded4:	e5d3300c 	ldrb	r3, [r3, #12]
21f2ded8:	e1823003 	orr	r3, r2, r3
21f2dedc:	e58130a4 	str	r3, [r1, #164]

	p_mac->EMAC_RBQP = (long) (&rbfdt[0]);
21f2dee0:	e59f315c 	ldr	r3, [pc, #348]	; 21f2e044 <.text+0x2e044>
21f2dee4:	e5932000 	ldr	r2, [r3]
21f2dee8:	e59f315c 	ldr	r3, [pc, #348]	; 21f2e04c <.text+0x2e04c>
21f2deec:	e5823018 	str	r3, [r2, #24]
	p_mac->EMAC_RSR &= ~(AT91C_EMAC_RSR_OVR | AT91C_EMAC_REC | AT91C_EMAC_BNA);
21f2def0:	e59f314c 	ldr	r3, [pc, #332]	; 21f2e044 <.text+0x2e044>
21f2def4:	e5932000 	ldr	r2, [r3]
21f2def8:	e59f3144 	ldr	r3, [pc, #324]	; 21f2e044 <.text+0x2e044>
21f2defc:	e5933000 	ldr	r3, [r3]
21f2df00:	e5933020 	ldr	r3, [r3, #32]
21f2df04:	e3c33007 	bic	r3, r3, #7	; 0x7
21f2df08:	e5823020 	str	r3, [r2, #32]

	p_mac->EMAC_CFG = (p_mac->EMAC_CFG | AT91C_EMAC_CAF | AT91C_EMAC_NBC)
21f2df0c:	e59f3130 	ldr	r3, [pc, #304]	; 21f2e044 <.text+0x2e044>
21f2df10:	e5932000 	ldr	r2, [r3]
21f2df14:	e59f3128 	ldr	r3, [pc, #296]	; 21f2e044 <.text+0x2e044>
21f2df18:	e5933000 	ldr	r3, [r3]
21f2df1c:	e5933004 	ldr	r3, [r3, #4]
21f2df20:	e3833030 	orr	r3, r3, #48	; 0x30
21f2df24:	e3c33b03 	bic	r3, r3, #3072	; 0xc00
21f2df28:	e5823004 	str	r3, [r2, #4]
			& ~AT91C_EMAC_CLK;

#ifdef CONFIG_AT91C_USE_RMII
	p_mac->EMAC_CFG |= AT91C_EMAC_RMII;
21f2df2c:	e59f3110 	ldr	r3, [pc, #272]	; 21f2e044 <.text+0x2e044>
21f2df30:	e5932000 	ldr	r2, [r3]
21f2df34:	e59f3108 	ldr	r3, [pc, #264]	; 21f2e044 <.text+0x2e044>
21f2df38:	e5933000 	ldr	r3, [r3]
21f2df3c:	e5933004 	ldr	r3, [r3, #4]
21f2df40:	e3833a02 	orr	r3, r3, #8192	; 0x2000
21f2df44:	e5823004 	str	r3, [r2, #4]
#endif

#if (AT91C_MASTER_CLOCK > 40000000)
	/* MDIO clock must not exceed 2.5 MHz, so enable MCK divider */
	p_mac->EMAC_CFG |= AT91C_EMAC_CLK_HCLK_64;
21f2df48:	e59f30f4 	ldr	r3, [pc, #244]	; 21f2e044 <.text+0x2e044>
21f2df4c:	e5932000 	ldr	r2, [r3]
21f2df50:	e59f30ec 	ldr	r3, [pc, #236]	; 21f2e044 <.text+0x2e044>
21f2df54:	e5933000 	ldr	r3, [r3]
21f2df58:	e5933004 	ldr	r3, [r3, #4]
21f2df5c:	e3833b03 	orr	r3, r3, #3072	; 0xc00
21f2df60:	e5823004 	str	r3, [r2, #4]
#endif

	p_mac->EMAC_CTL |= AT91C_EMAC_TE | AT91C_EMAC_RE;
21f2df64:	e59f30d8 	ldr	r3, [pc, #216]	; 21f2e044 <.text+0x2e044>
21f2df68:	e5932000 	ldr	r2, [r3]
21f2df6c:	e59f30d0 	ldr	r3, [pc, #208]	; 21f2e044 <.text+0x2e044>
21f2df70:	e5933000 	ldr	r3, [r3]
21f2df74:	e5933000 	ldr	r3, [r3]
21f2df78:	e383300c 	orr	r3, r3, #12	; 0xc
21f2df7c:	e5823000 	str	r3, [r2]

	at91rm9200_GetPhyInterface (& PhyOps);
21f2df80:	e59f00cc 	ldr	r0, [pc, #204]	; 21f2e054 <.text+0x2e054>
21f2df84:	ebfff3e2 	bl	21f2af14 <at91rm9200_GetPhyInterface>

	if (!PhyOps.IsPhyConnected (p_mac))
21f2df88:	e59f30c4 	ldr	r3, [pc, #196]	; 21f2e054 <.text+0x2e054>
21f2df8c:	e5932004 	ldr	r2, [r3, #4]
21f2df90:	e59f30ac 	ldr	r3, [pc, #172]	; 21f2e044 <.text+0x2e044>
21f2df94:	e5933000 	ldr	r3, [r3]
21f2df98:	e1a00003 	mov	r0, r3
21f2df9c:	e1a0e00f 	mov	lr, pc
21f2dfa0:	e1a0f002 	mov	pc, r2
21f2dfa4:	e1a03000 	mov	r3, r0
21f2dfa8:	e3530000 	cmp	r3, #0	; 0x0
21f2dfac:	1a000001 	bne	21f2dfb8 <eth_init+0x258>
		printf ("PHY not connected!!\n\r");
21f2dfb0:	e59f00a0 	ldr	r0, [pc, #160]	; 21f2e058 <.text+0x2e058>
21f2dfb4:	ebffb6b4 	bl	21f1ba8c <printf>

	/* MII management start from here */
	if (!(p_mac->EMAC_SR & AT91C_EMAC_LINK)) {
21f2dfb8:	e59f3084 	ldr	r3, [pc, #132]	; 21f2e044 <.text+0x2e044>
21f2dfbc:	e5933000 	ldr	r3, [r3]
21f2dfc0:	e5933008 	ldr	r3, [r3, #8]
21f2dfc4:	e1a034a3 	mov	r3, r3, lsr #9
21f2dfc8:	e2033001 	and	r3, r3, #1	; 0x1
21f2dfcc:	e3530000 	cmp	r3, #0	; 0x0
21f2dfd0:	1a000010 	bne	21f2e018 <eth_init+0x2b8>
		if (!(ret = PhyOps.Init (p_mac))) {
21f2dfd4:	e59f3078 	ldr	r3, [pc, #120]	; 21f2e054 <.text+0x2e054>
21f2dfd8:	e5932000 	ldr	r2, [r3]
21f2dfdc:	e59f3060 	ldr	r3, [pc, #96]	; 21f2e044 <.text+0x2e044>
21f2dfe0:	e5933000 	ldr	r3, [r3]
21f2dfe4:	e1a00003 	mov	r0, r3
21f2dfe8:	e1a0e00f 	mov	lr, pc
21f2dfec:	e1a0f002 	mov	pc, r2
21f2dff0:	e1a03000 	mov	r3, r0
21f2dff4:	e50b3014 	str	r3, [fp, #-20]
21f2dff8:	e51b3014 	ldr	r3, [fp, #-20]
21f2dffc:	e3530000 	cmp	r3, #0	; 0x0
21f2e000:	1a000009 	bne	21f2e02c <eth_init+0x2cc>
			printf ("MAC: error during MII initialization\n");
21f2e004:	e59f0050 	ldr	r0, [pc, #80]	; 21f2e05c <.text+0x2e05c>
21f2e008:	ebffb69f 	bl	21f1ba8c <printf>
			return 0;
21f2e00c:	e3a03000 	mov	r3, #0	; 0x0
21f2e010:	e50b301c 	str	r3, [fp, #-28]
21f2e014:	ea000006 	b	21f2e034 <eth_init+0x2d4>
		}
	} else {
		printf ("No link\n\r");
21f2e018:	e59f0040 	ldr	r0, [pc, #64]	; 21f2e060 <.text+0x2e060>
21f2e01c:	ebffb69a 	bl	21f1ba8c <printf>
		return 0;
21f2e020:	e3a03000 	mov	r3, #0	; 0x0
21f2e024:	e50b301c 	str	r3, [fp, #-28]
21f2e028:	ea000001 	b	21f2e034 <eth_init+0x2d4>
	}

	return 0;
21f2e02c:	e3a03000 	mov	r3, #0	; 0x0
21f2e030:	e50b301c 	str	r3, [fp, #-28]
21f2e034:	e51b301c 	ldr	r3, [fp, #-28]
}
21f2e038:	e1a00003 	mov	r0, r3
21f2e03c:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2e040:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e044:	21f81414 	mvncss	r1, r4, lsl r4
21f2e048:	21f69404 	mvncss	r9, r4, lsl #8
21f2e04c:	21f69200 	mvncss	r9, r0, lsl #4
21f2e050:	21f69400 	mvncss	r9, r0, lsl #8
21f2e054:	21f81404 	mvncss	r1, r4, lsl #8
21f2e058:	21f3307c 	mvncss	r3, ip, ror r0
21f2e05c:	21f33094 	ldrcsb	r3, [r3, #4]!
21f2e060:	21f330bc 	ldrcsh	r3, [r3, #12]!

21f2e064 <eth_send>:

int eth_send (volatile void *packet, int length)
{
21f2e064:	e1a0c00d 	mov	ip, sp
21f2e068:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e06c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e070:	e24dd008 	sub	sp, sp, #8	; 0x8
21f2e074:	e50b0010 	str	r0, [fp, #-16]
21f2e078:	e50b1014 	str	r1, [fp, #-20]
	while (!(p_mac->EMAC_TSR & AT91C_EMAC_BNQ));
21f2e07c:	e59f307c 	ldr	r3, [pc, #124]	; 21f2e100 <.text+0x2e100>
21f2e080:	e5933000 	ldr	r3, [r3]
21f2e084:	e5933014 	ldr	r3, [r3, #20]
21f2e088:	e1a03223 	mov	r3, r3, lsr #4
21f2e08c:	e2033001 	and	r3, r3, #1	; 0x1
21f2e090:	e3530000 	cmp	r3, #0	; 0x0
21f2e094:	0afffff8 	beq	21f2e07c <eth_send+0x18>
	p_mac->EMAC_TAR = (long) packet;
21f2e098:	e59f3060 	ldr	r3, [pc, #96]	; 21f2e100 <.text+0x2e100>
21f2e09c:	e5932000 	ldr	r2, [r3]
21f2e0a0:	e51b3010 	ldr	r3, [fp, #-16]
21f2e0a4:	e582300c 	str	r3, [r2, #12]
	p_mac->EMAC_TCR = length;
21f2e0a8:	e59f3050 	ldr	r3, [pc, #80]	; 21f2e100 <.text+0x2e100>
21f2e0ac:	e5932000 	ldr	r2, [r3]
21f2e0b0:	e51b3014 	ldr	r3, [fp, #-20]
21f2e0b4:	e5823010 	str	r3, [r2, #16]
	while (p_mac->EMAC_TCR & 0x7ff);
21f2e0b8:	e59f3040 	ldr	r3, [pc, #64]	; 21f2e100 <.text+0x2e100>
21f2e0bc:	e5933000 	ldr	r3, [r3]
21f2e0c0:	e5933010 	ldr	r3, [r3, #16]
21f2e0c4:	e1a03a83 	mov	r3, r3, lsl #21
21f2e0c8:	e1a03aa3 	mov	r3, r3, lsr #21
21f2e0cc:	e3530000 	cmp	r3, #0	; 0x0
21f2e0d0:	1afffff8 	bne	21f2e0b8 <eth_send+0x54>
	p_mac->EMAC_TSR |= AT91C_EMAC_COMP;
21f2e0d4:	e59f3024 	ldr	r3, [pc, #36]	; 21f2e100 <.text+0x2e100>
21f2e0d8:	e5932000 	ldr	r2, [r3]
21f2e0dc:	e59f301c 	ldr	r3, [pc, #28]	; 21f2e100 <.text+0x2e100>
21f2e0e0:	e5933000 	ldr	r3, [r3]
21f2e0e4:	e5933014 	ldr	r3, [r3, #20]
21f2e0e8:	e3833020 	orr	r3, r3, #32	; 0x20
21f2e0ec:	e5823014 	str	r3, [r2, #20]
	return 0;
21f2e0f0:	e3a03000 	mov	r3, #0	; 0x0
}
21f2e0f4:	e1a00003 	mov	r0, r3
21f2e0f8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2e0fc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e100:	21f81414 	mvncss	r1, r4, lsl r4

21f2e104 <eth_rx>:

int eth_rx (void)
{
21f2e104:	e1a0c00d 	mov	ip, sp
21f2e108:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e10c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e110:	e24dd008 	sub	sp, sp, #8	; 0x8
	int size;

	if (!(rbfp->addr & RBF_OWNER))
21f2e114:	e59f30e4 	ldr	r3, [pc, #228]	; 21f2e200 <.text+0x2e200>
21f2e118:	e5933000 	ldr	r3, [r3]
21f2e11c:	e5933000 	ldr	r3, [r3]
21f2e120:	e2033001 	and	r3, r3, #1	; 0x1
21f2e124:	e3530000 	cmp	r3, #0	; 0x0
21f2e128:	1a000002 	bne	21f2e138 <eth_rx+0x34>
		return 0;
21f2e12c:	e3a03000 	mov	r3, #0	; 0x0
21f2e130:	e50b3014 	str	r3, [fp, #-20]
21f2e134:	ea00002d 	b	21f2e1f0 <eth_rx+0xec>

	size = rbfp->size & RBF_SIZE;
21f2e138:	e59f30c0 	ldr	r3, [pc, #192]	; 21f2e200 <.text+0x2e200>
21f2e13c:	e5933000 	ldr	r3, [r3]
21f2e140:	e5933004 	ldr	r3, [r3, #4]
21f2e144:	e1a03a83 	mov	r3, r3, lsl #21
21f2e148:	e1a03aa3 	mov	r3, r3, lsr #21
21f2e14c:	e50b3010 	str	r3, [fp, #-16]
	NetReceive ((volatile uchar *) (rbfp->addr & RBF_ADDR), size);
21f2e150:	e59f30a8 	ldr	r3, [pc, #168]	; 21f2e200 <.text+0x2e200>
21f2e154:	e5933000 	ldr	r3, [r3]
21f2e158:	e5933000 	ldr	r3, [r3]
21f2e15c:	e3c33003 	bic	r3, r3, #3	; 0x3
21f2e160:	e1a00003 	mov	r0, r3
21f2e164:	e51b1010 	ldr	r1, [fp, #-16]
21f2e168:	ebff6d7d 	bl	21f09764 <NetReceive>

	rbfp->addr &= ~RBF_OWNER;
21f2e16c:	e59f308c 	ldr	r3, [pc, #140]	; 21f2e200 <.text+0x2e200>
21f2e170:	e5932000 	ldr	r2, [r3]
21f2e174:	e59f3084 	ldr	r3, [pc, #132]	; 21f2e200 <.text+0x2e200>
21f2e178:	e5933000 	ldr	r3, [r3]
21f2e17c:	e5933000 	ldr	r3, [r3]
21f2e180:	e3c33001 	bic	r3, r3, #1	; 0x1
21f2e184:	e5823000 	str	r3, [r2]
	if (rbfp->addr & RBF_WRAP)
21f2e188:	e59f3070 	ldr	r3, [pc, #112]	; 21f2e200 <.text+0x2e200>
21f2e18c:	e5933000 	ldr	r3, [r3]
21f2e190:	e5933000 	ldr	r3, [r3]
21f2e194:	e1a030a3 	mov	r3, r3, lsr #1
21f2e198:	e2033001 	and	r3, r3, #1	; 0x1
21f2e19c:	e20330ff 	and	r3, r3, #255	; 0xff
21f2e1a0:	e3530000 	cmp	r3, #0	; 0x0
21f2e1a4:	0a000003 	beq	21f2e1b8 <eth_rx+0xb4>
		rbfp = &rbfdt[0];
21f2e1a8:	e59f2050 	ldr	r2, [pc, #80]	; 21f2e200 <.text+0x2e200>
21f2e1ac:	e59f3050 	ldr	r3, [pc, #80]	; 21f2e204 <.text+0x2e204>
21f2e1b0:	e5823000 	str	r3, [r2]
21f2e1b4:	ea000004 	b	21f2e1cc <eth_rx+0xc8>
	else
		rbfp++;
21f2e1b8:	e59f3040 	ldr	r3, [pc, #64]	; 21f2e200 <.text+0x2e200>
21f2e1bc:	e5933000 	ldr	r3, [r3]
21f2e1c0:	e2832008 	add	r2, r3, #8	; 0x8
21f2e1c4:	e59f3034 	ldr	r3, [pc, #52]	; 21f2e200 <.text+0x2e200>
21f2e1c8:	e5832000 	str	r2, [r3]

	p_mac->EMAC_RSR |= AT91C_EMAC_REC;
21f2e1cc:	e59f3034 	ldr	r3, [pc, #52]	; 21f2e208 <.text+0x2e208>
21f2e1d0:	e5932000 	ldr	r2, [r3]
21f2e1d4:	e59f302c 	ldr	r3, [pc, #44]	; 21f2e208 <.text+0x2e208>
21f2e1d8:	e5933000 	ldr	r3, [r3]
21f2e1dc:	e5933020 	ldr	r3, [r3, #32]
21f2e1e0:	e3833002 	orr	r3, r3, #2	; 0x2
21f2e1e4:	e5823020 	str	r3, [r2, #32]

	return size;
21f2e1e8:	e51b3010 	ldr	r3, [fp, #-16]
21f2e1ec:	e50b3014 	str	r3, [fp, #-20]
21f2e1f0:	e51b3014 	ldr	r3, [fp, #-20]
}
21f2e1f4:	e1a00003 	mov	r0, r3
21f2e1f8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2e1fc:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e200:	21f69400 	mvncss	r9, r0, lsl #8
21f2e204:	21f69200 	mvncss	r9, r0, lsl #4
21f2e208:	21f81414 	mvncss	r1, r4, lsl r4

21f2e20c <eth_halt>:

void eth_halt (void)
{
21f2e20c:	e1a0c00d 	mov	ip, sp
21f2e210:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e214:	e24cb004 	sub	fp, ip, #4	; 0x4
};
21f2e218:	e89da800 	ldmia	sp, {fp, sp, pc}

21f2e21c <at91rm9200_miiphy_read>:

#if defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII)
int  at91rm9200_miiphy_read(char *devname, unsigned char addr,
		unsigned char reg, unsigned short * value)
{
21f2e21c:	e1a0c00d 	mov	ip, sp
21f2e220:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e224:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e228:	e24dd010 	sub	sp, sp, #16	; 0x10
21f2e22c:	e50b0010 	str	r0, [fp, #-16]
21f2e230:	e50b301c 	str	r3, [fp, #-28]
21f2e234:	e1a03001 	mov	r3, r1
21f2e238:	e54b3014 	strb	r3, [fp, #-20]
21f2e23c:	e1a03002 	mov	r3, r2
21f2e240:	e54b3018 	strb	r3, [fp, #-24]
	at91rm9200_EmacEnableMDIO (p_mac);
21f2e244:	e59f3044 	ldr	r3, [pc, #68]	; 21f2e290 <.text+0x2e290>
21f2e248:	e5933000 	ldr	r3, [r3]
21f2e24c:	e1a00003 	mov	r0, r3
21f2e250:	ebfffe78 	bl	21f2dc38 <at91rm9200_EmacEnableMDIO>
	at91rm9200_EmacReadPhy (p_mac, reg, value);
21f2e254:	e59f3034 	ldr	r3, [pc, #52]	; 21f2e290 <.text+0x2e290>
21f2e258:	e5933000 	ldr	r3, [r3]
21f2e25c:	e55b2018 	ldrb	r2, [fp, #-24]
21f2e260:	e1a00003 	mov	r0, r3
21f2e264:	e1a01002 	mov	r1, r2
21f2e268:	e51b201c 	ldr	r2, [fp, #-28]
21f2e26c:	ebfffe87 	bl	21f2dc90 <at91rm9200_EmacReadPhy>
	at91rm9200_EmacDisableMDIO (p_mac);
21f2e270:	e59f3018 	ldr	r3, [pc, #24]	; 21f2e290 <.text+0x2e290>
21f2e274:	e5933000 	ldr	r3, [r3]
21f2e278:	e1a00003 	mov	r0, r3
21f2e27c:	ebfffe78 	bl	21f2dc64 <at91rm9200_EmacDisableMDIO>
	return 0;
21f2e280:	e3a03000 	mov	r3, #0	; 0x0
}
21f2e284:	e1a00003 	mov	r0, r3
21f2e288:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2e28c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e290:	21f81414 	mvncss	r1, r4, lsl r4

21f2e294 <at91rm9200_miiphy_write>:

int  at91rm9200_miiphy_write(char *devname, unsigned char addr,
		unsigned char reg, unsigned short value)
{
21f2e294:	e1a0c00d 	mov	ip, sp
21f2e298:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e29c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e2a0:	e24dd010 	sub	sp, sp, #16	; 0x10
21f2e2a4:	e50b0010 	str	r0, [fp, #-16]
21f2e2a8:	e1a00003 	mov	r0, r3
21f2e2ac:	e1a03001 	mov	r3, r1
21f2e2b0:	e54b3014 	strb	r3, [fp, #-20]
21f2e2b4:	e1a03002 	mov	r3, r2
21f2e2b8:	e54b3018 	strb	r3, [fp, #-24]
21f2e2bc:	e14b01bc 	strh	r0, [fp, #-28]
	at91rm9200_EmacEnableMDIO (p_mac);
21f2e2c0:	e59f3048 	ldr	r3, [pc, #72]	; 21f2e310 <.text+0x2e310>
21f2e2c4:	e5933000 	ldr	r3, [r3]
21f2e2c8:	e1a00003 	mov	r0, r3
21f2e2cc:	ebfffe59 	bl	21f2dc38 <at91rm9200_EmacEnableMDIO>
	at91rm9200_EmacWritePhy (p_mac, reg, &value);
21f2e2d0:	e59f3038 	ldr	r3, [pc, #56]	; 21f2e310 <.text+0x2e310>
21f2e2d4:	e5933000 	ldr	r3, [r3]
21f2e2d8:	e55b2018 	ldrb	r2, [fp, #-24]
21f2e2dc:	e24bc01c 	sub	ip, fp, #28	; 0x1c
21f2e2e0:	e1a00003 	mov	r0, r3
21f2e2e4:	e1a01002 	mov	r1, r2
21f2e2e8:	e1a0200c 	mov	r2, ip
21f2e2ec:	ebfffe82 	bl	21f2dcfc <at91rm9200_EmacWritePhy>
	at91rm9200_EmacDisableMDIO (p_mac);
21f2e2f0:	e59f3018 	ldr	r3, [pc, #24]	; 21f2e310 <.text+0x2e310>
21f2e2f4:	e5933000 	ldr	r3, [r3]
21f2e2f8:	e1a00003 	mov	r0, r3
21f2e2fc:	ebfffe58 	bl	21f2dc64 <at91rm9200_EmacDisableMDIO>
	return 0;
21f2e300:	e3a03000 	mov	r3, #0	; 0x0
}
21f2e304:	e1a00003 	mov	r0, r3
21f2e308:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2e30c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e310:	21f81414 	mvncss	r1, r4, lsl r4

21f2e314 <at91rm9200_miiphy_initialize>:

#endif	/* defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII) */

int at91rm9200_miiphy_initialize(bd_t *bis)
{
21f2e314:	e1a0c00d 	mov	ip, sp
21f2e318:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e31c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e320:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2e324:	e50b0010 	str	r0, [fp, #-16]
#if defined(CONFIG_MII) || (CONFIG_COMMANDS & CFG_CMD_MII)
	miiphy_register("at91rm9200phy", at91rm9200_miiphy_read, at91rm9200_miiphy_write);
21f2e328:	e59f0014 	ldr	r0, [pc, #20]	; 21f2e344 <.text+0x2e344>
21f2e32c:	e59f1014 	ldr	r1, [pc, #20]	; 21f2e348 <.text+0x2e348>
21f2e330:	e59f2014 	ldr	r2, [pc, #20]	; 21f2e34c <.text+0x2e34c>
21f2e334:	ebffc7d3 	bl	21f20288 <miiphy_register>
#endif
	return 0;
21f2e338:	e3a03000 	mov	r3, #0	; 0x0
}
21f2e33c:	e1a00003 	mov	r0, r3
21f2e340:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f2e344:	21f330c8 	mvncss	r3, r8, asr #1
21f2e348:	21f2e21c 	mvncss	lr, ip, lsl r2
21f2e34c:	21f2e294 	ldrcsb	lr, [r2, #36]!

21f2e350 <serial_setbrg>:
AT91PS_USART us = (AT91PS_USART) AT91C_BASE_US1;
#endif

void serial_setbrg (void)
{
21f2e350:	e1a0c00d 	mov	ip, sp
21f2e354:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f2e358:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e35c:	e24dd004 	sub	sp, sp, #4	; 0x4
	int baudrate;

	if ((baudrate = gd->baudrate) <= 0)
21f2e360:	e1a03008 	mov	r3, r8
21f2e364:	e5933008 	ldr	r3, [r3, #8]
21f2e368:	e50b3014 	str	r3, [fp, #-20]
21f2e36c:	e51b3014 	ldr	r3, [fp, #-20]
21f2e370:	e3530000 	cmp	r3, #0	; 0x0
21f2e374:	ca000002 	bgt	21f2e384 <serial_setbrg+0x34>
		baudrate = CONFIG_BAUDRATE;
21f2e378:	e3a03907 	mov	r3, #114688	; 0x1c000
21f2e37c:	e2833c02 	add	r3, r3, #512	; 0x200
21f2e380:	e50b3014 	str	r3, [fp, #-20]
	/* MASTER_CLOCK/(16 * baudrate) */
	us->US_BRGR = (AT91C_MASTER_CLOCK >> 4) / (unsigned)baudrate;
21f2e384:	e59f3020 	ldr	r3, [pc, #32]	; 21f2e3ac <.text+0x2e3ac>
21f2e388:	e5934000 	ldr	r4, [r3]
21f2e38c:	e51b3014 	ldr	r3, [fp, #-20]
21f2e390:	e3a00839 	mov	r0, #3735552	; 0x390000
21f2e394:	e2800c21 	add	r0, r0, #8448	; 0x2100
21f2e398:	e1a01003 	mov	r1, r3
21f2e39c:	ebff5dc4 	bl	21f05ab4 <__udivsi3>
21f2e3a0:	e1a03000 	mov	r3, r0
21f2e3a4:	e5843020 	str	r3, [r4, #32]
}
21f2e3a8:	e89da818 	ldmia	sp, {r3, r4, fp, sp, pc}
21f2e3ac:	21f33dac 	mvncss	r3, ip, lsr #27

21f2e3b0 <serial_init>:

int serial_init (void)
{
21f2e3b0:	e1a0c00d 	mov	ip, sp
21f2e3b4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e3b8:	e24cb004 	sub	fp, ip, #4	; 0x4
	/* make any port initializations specific to this port */
#ifdef CONFIG_DBGU
	*AT91C_PIOA_PDR = AT91C_PA31_DTXD | AT91C_PA30_DRXD;	/* PA 31 & 30 */
21f2e3bc:	e3e03ebf 	mvn	r3, #3056	; 0xbf0
21f2e3c0:	e243300b 	sub	r3, r3, #11	; 0xb
21f2e3c4:	e3a02103 	mov	r2, #-1073741824	; 0xc0000000
21f2e3c8:	e5832000 	str	r2, [r3]
	*AT91C_PMC_PCER = 1 << AT91C_ID_SYS;	/* enable clock */
21f2e3cc:	e3a03482 	mov	r3, #-2113929216	; 0x82000000
21f2e3d0:	e1a03ac3 	mov	r3, r3, asr #21
21f2e3d4:	e3a02002 	mov	r2, #2	; 0x2
21f2e3d8:	e5832000 	str	r2, [r3]
#endif
#ifdef CONFIG_USART0
	*AT91C_PIOA_PDR = AT91C_PA17_TXD0 | AT91C_PA18_RXD0;
	*AT91C_PMC_PCER |= 1 << AT91C_ID_USART0;	/* enable clock */
#endif
#ifdef CONFIG_USART1
	*AT91C_PIOB_PDR = AT91C_PB21_TXD1 | AT91C_PB20_RXD1;
	*AT91C_PMC_PCER |= 1 << AT91C_ID_USART1;	/* enable clock */
#endif
	serial_setbrg ();
21f2e3dc:	ebffffdb 	bl	21f2e350 <serial_setbrg>

	us->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX;
21f2e3e0:	e59f3044 	ldr	r3, [pc, #68]	; 21f2e42c <.text+0x2e42c>
21f2e3e4:	e5932000 	ldr	r2, [r3]
21f2e3e8:	e3a0300c 	mov	r3, #12	; 0xc
21f2e3ec:	e5823000 	str	r3, [r2]
	us->US_CR = AT91C_US_RXEN | AT91C_US_TXEN;
21f2e3f0:	e59f3034 	ldr	r3, [pc, #52]	; 21f2e42c <.text+0x2e42c>
21f2e3f4:	e5932000 	ldr	r2, [r3]
21f2e3f8:	e3a03050 	mov	r3, #80	; 0x50
21f2e3fc:	e5823000 	str	r3, [r2]
	us->US_MR =
21f2e400:	e59f3024 	ldr	r3, [pc, #36]	; 21f2e42c <.text+0x2e42c>
21f2e404:	e5932000 	ldr	r2, [r3]
21f2e408:	e3a03d23 	mov	r3, #2240	; 0x8c0
21f2e40c:	e5823004 	str	r3, [r2, #4]
		(AT91C_US_CLKS_CLOCK | AT91C_US_CHRL_8_BITS |
		 AT91C_US_PAR_NONE | AT91C_US_NBSTOP_1_BIT);
	us->US_IMR = ~0ul;
21f2e410:	e59f3014 	ldr	r3, [pc, #20]	; 21f2e42c <.text+0x2e42c>
21f2e414:	e5932000 	ldr	r2, [r3]
21f2e418:	e3e03000 	mvn	r3, #0	; 0x0
21f2e41c:	e5823010 	str	r3, [r2, #16]
	return (0);
21f2e420:	e3a03000 	mov	r3, #0	; 0x0
}
21f2e424:	e1a00003 	mov	r0, r3
21f2e428:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e42c:	21f33dac 	mvncss	r3, ip, lsr #27

21f2e430 <serial_putc>:

void serial_putc (const char c)
{
21f2e430:	e1a0c00d 	mov	ip, sp
21f2e434:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e438:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e43c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2e440:	e1a03000 	mov	r3, r0
21f2e444:	e54b3010 	strb	r3, [fp, #-16]
	if (c == '\n')
21f2e448:	e55b3010 	ldrb	r3, [fp, #-16]
21f2e44c:	e353000a 	cmp	r3, #10	; 0xa
21f2e450:	1a000001 	bne	21f2e45c <serial_putc+0x2c>
		serial_putc ('\r');
21f2e454:	e3a0000d 	mov	r0, #13	; 0xd
21f2e458:	ebfffff4 	bl	21f2e430 <serial_putc>
	while ((us->US_CSR & AT91C_US_TXRDY) == 0);
21f2e45c:	e59f3030 	ldr	r3, [pc, #48]	; 21f2e494 <.text+0x2e494>
21f2e460:	e5933000 	ldr	r3, [r3]
21f2e464:	e5933014 	ldr	r3, [r3, #20]
21f2e468:	e1a030a3 	mov	r3, r3, lsr #1
21f2e46c:	e2233001 	eor	r3, r3, #1	; 0x1
21f2e470:	e2033001 	and	r3, r3, #1	; 0x1
21f2e474:	e20330ff 	and	r3, r3, #255	; 0xff
21f2e478:	e3530000 	cmp	r3, #0	; 0x0
21f2e47c:	1afffff6 	bne	21f2e45c <serial_putc+0x2c>
	us->US_THR = c;
21f2e480:	e59f300c 	ldr	r3, [pc, #12]	; 21f2e494 <.text+0x2e494>
21f2e484:	e5932000 	ldr	r2, [r3]
21f2e488:	e55b3010 	ldrb	r3, [fp, #-16]
21f2e48c:	e582301c 	str	r3, [r2, #28]
}
21f2e490:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f2e494:	21f33dac 	mvncss	r3, ip, lsr #27

21f2e498 <serial_puts>:

void serial_puts (const char *s)
{
21f2e498:	e1a0c00d 	mov	ip, sp
21f2e49c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e4a0:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e4a4:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2e4a8:	e50b0010 	str	r0, [fp, #-16]
	while (*s) {
21f2e4ac:	ea000007 	b	21f2e4d0 <serial_puts+0x38>
		serial_putc (*s++);
21f2e4b0:	e51b3010 	ldr	r3, [fp, #-16]
21f2e4b4:	e5d33000 	ldrb	r3, [r3]
21f2e4b8:	e1a02003 	mov	r2, r3
21f2e4bc:	e51b3010 	ldr	r3, [fp, #-16]
21f2e4c0:	e2833001 	add	r3, r3, #1	; 0x1
21f2e4c4:	e50b3010 	str	r3, [fp, #-16]
21f2e4c8:	e1a00002 	mov	r0, r2
21f2e4cc:	ebffffd7 	bl	21f2e430 <serial_putc>
21f2e4d0:	e51b3010 	ldr	r3, [fp, #-16]
21f2e4d4:	e5d33000 	ldrb	r3, [r3]
21f2e4d8:	e3530000 	cmp	r3, #0	; 0x0
21f2e4dc:	1afffff3 	bne	21f2e4b0 <serial_puts+0x18>
	}
}
21f2e4e0:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2e4e4 <serial_getc>:

int serial_getc (void)
{
21f2e4e4:	e1a0c00d 	mov	ip, sp
21f2e4e8:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e4ec:	e24cb004 	sub	fp, ip, #4	; 0x4
	while ((us->US_CSR & AT91C_US_RXRDY) == 0);
21f2e4f0:	e59f302c 	ldr	r3, [pc, #44]	; 21f2e524 <.text+0x2e524>
21f2e4f4:	e5933000 	ldr	r3, [r3]
21f2e4f8:	e5933014 	ldr	r3, [r3, #20]
21f2e4fc:	e2233001 	eor	r3, r3, #1	; 0x1
21f2e500:	e2033001 	and	r3, r3, #1	; 0x1
21f2e504:	e20330ff 	and	r3, r3, #255	; 0xff
21f2e508:	e3530000 	cmp	r3, #0	; 0x0
21f2e50c:	1afffff7 	bne	21f2e4f0 <serial_getc+0xc>
	return us->US_RHR;
21f2e510:	e59f300c 	ldr	r3, [pc, #12]	; 21f2e524 <.text+0x2e524>
21f2e514:	e5933000 	ldr	r3, [r3]
21f2e518:	e5933018 	ldr	r3, [r3, #24]
}
21f2e51c:	e1a00003 	mov	r0, r3
21f2e520:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e524:	21f33dac 	mvncss	r3, ip, lsr #27

21f2e528 <serial_tstc>:

int serial_tstc (void)
{
21f2e528:	e1a0c00d 	mov	ip, sp
21f2e52c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e530:	e24cb004 	sub	fp, ip, #4	; 0x4
	return ((us->US_CSR & AT91C_US_RXRDY) == AT91C_US_RXRDY);
21f2e534:	e59f3010 	ldr	r3, [pc, #16]	; 21f2e54c <.text+0x2e54c>
21f2e538:	e5933000 	ldr	r3, [r3]
21f2e53c:	e5933014 	ldr	r3, [r3, #20]
21f2e540:	e2033001 	and	r3, r3, #1	; 0x1
}
21f2e544:	e1a00003 	mov	r0, r3
21f2e548:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e54c:	21f33dac 	mvncss	r3, ip, lsr #27

21f2e550 <do_bootm_linux>:


void do_bootm_linux (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
		     ulong addr, ulong *len_ptr, int verify)
{
21f2e550:	e1a0c00d 	mov	ip, sp
21f2e554:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2e558:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2e55c:	e24dd040 	sub	sp, sp, #64	; 0x40
21f2e560:	e50b0040 	str	r0, [fp, #-64]
21f2e564:	e50b1044 	str	r1, [fp, #-68]
21f2e568:	e50b2048 	str	r2, [fp, #-72]
21f2e56c:	e50b304c 	str	r3, [fp, #-76]
	ulong len = 0, checksum;
21f2e570:	e3a03000 	mov	r3, #0	; 0x0
21f2e574:	e50b303c 	str	r3, [fp, #-60]
	ulong initrd_start, initrd_end;
	ulong data;
	void (*theKernel)(int zero, int arch, uint params);
	image_header_t *hdr = &header;
21f2e578:	e59f3454 	ldr	r3, [pc, #1108]	; 21f2e9d4 <.text+0x2e9d4>
21f2e57c:	e50b3024 	str	r3, [fp, #-36]
	bd_t *bd = gd->bd;
21f2e580:	e1a03008 	mov	r3, r8
21f2e584:	e5933000 	ldr	r3, [r3]
21f2e588:	e50b3020 	str	r3, [fp, #-32]

#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv ("bootargs");
21f2e58c:	e59f0444 	ldr	r0, [pc, #1092]	; 21f2e9d8 <.text+0x2e9d8>
21f2e590:	ebffb1a0 	bl	21f1ac18 <getenv>
21f2e594:	e1a03000 	mov	r3, r0
21f2e598:	e50b301c 	str	r3, [fp, #-28]
#endif

	theKernel = (void (*)(int, int, uint))ntohl(hdr->ih_ep);
21f2e59c:	e51b3024 	ldr	r3, [fp, #-36]
21f2e5a0:	e5933014 	ldr	r3, [r3, #20]
21f2e5a4:	e1a00003 	mov	r0, r3
21f2e5a8:	eb000114 	bl	21f2ea00 <__fswab32>
21f2e5ac:	e1a03000 	mov	r3, r0
21f2e5b0:	e50b3028 	str	r3, [fp, #-40]

	/*
	 * Check if there is an initrd image
	 */
	if (argc >= 3) {
21f2e5b4:	e51b3048 	ldr	r3, [fp, #-72]
21f2e5b8:	e3530002 	cmp	r3, #2	; 0x2
21f2e5bc:	da000092 	ble	21f2e80c <do_bootm_linux+0x2bc>
		SHOW_BOOT_PROGRESS (9);

		addr = simple_strtoul (argv[2], NULL, 16);
21f2e5c0:	e51b304c 	ldr	r3, [fp, #-76]
21f2e5c4:	e2833008 	add	r3, r3, #8	; 0x8
21f2e5c8:	e5933000 	ldr	r3, [r3]
21f2e5cc:	e1a00003 	mov	r0, r3
21f2e5d0:	e3a01000 	mov	r1, #0	; 0x0
21f2e5d4:	e3a02010 	mov	r2, #16	; 0x10
21f2e5d8:	ebffd3fa 	bl	21f235c8 <simple_strtoul>
21f2e5dc:	e1a03000 	mov	r3, r0
21f2e5e0:	e58b3004 	str	r3, [fp, #4]

		printf ("## Loading Ramdisk Image at %08lx ...\n", addr);
21f2e5e4:	e59f03f0 	ldr	r0, [pc, #1008]	; 21f2e9dc <.text+0x2e9dc>
21f2e5e8:	e59b1004 	ldr	r1, [fp, #4]
21f2e5ec:	ebffb526 	bl	21f1ba8c <printf>

		/* Copy header so we can blank CRC field for re-calculation */
#ifdef CONFIG_HAS_DATAFLASH
		if (addr_dataflash (addr)) {
21f2e5f0:	e59b0004 	ldr	r0, [fp, #4]
21f2e5f4:	ebff87c6 	bl	21f10514 <addr_dataflash>
21f2e5f8:	e1a03000 	mov	r3, r0
21f2e5fc:	e3530000 	cmp	r3, #0	; 0x0
21f2e600:	0a000005 	beq	21f2e61c <do_bootm_linux+0xcc>
			read_dataflash (addr, sizeof (image_header_t),
21f2e604:	e59f33c8 	ldr	r3, [pc, #968]	; 21f2e9d4 <.text+0x2e9d4>
21f2e608:	e59b0004 	ldr	r0, [fp, #4]
21f2e60c:	e3a01040 	mov	r1, #64	; 0x40
21f2e610:	e1a02003 	mov	r2, r3
21f2e614:	ebff88ff 	bl	21f10a18 <read_dataflash>
21f2e618:	ea000004 	b	21f2e630 <do_bootm_linux+0xe0>
					(char *) &header);
		} else
#endif
			memcpy (&header, (char *) addr,
21f2e61c:	e59b3004 	ldr	r3, [fp, #4]
21f2e620:	e59f03ac 	ldr	r0, [pc, #940]	; 21f2e9d4 <.text+0x2e9d4>
21f2e624:	e1a01003 	mov	r1, r3
21f2e628:	e3a02040 	mov	r2, #64	; 0x40
21f2e62c:	ebffd2e6 	bl	21f231cc <memcpy>
				sizeof (image_header_t));

		if (ntohl (hdr->ih_magic) != IH_MAGIC) {
21f2e630:	e51b3024 	ldr	r3, [fp, #-36]
21f2e634:	e5933000 	ldr	r3, [r3]
21f2e638:	e1a00003 	mov	r0, r3
21f2e63c:	eb0000ef 	bl	21f2ea00 <__fswab32>
21f2e640:	e1a03000 	mov	r3, r0
21f2e644:	e1a02003 	mov	r2, r3
21f2e648:	e59f3390 	ldr	r3, [pc, #912]	; 21f2e9e0 <.text+0x2e9e0>
21f2e64c:	e1520003 	cmp	r2, r3
21f2e650:	0a000006 	beq	21f2e670 <do_bootm_linux+0x120>
			printf ("Bad Magic Number\n");
21f2e654:	e59f0388 	ldr	r0, [pc, #904]	; 21f2e9e4 <.text+0x2e9e4>
21f2e658:	ebffb50b 	bl	21f1ba8c <printf>
			SHOW_BOOT_PROGRESS (-10);
			do_reset (cmdtp, flag, argc, argv);
21f2e65c:	e51b0040 	ldr	r0, [fp, #-64]
21f2e660:	e51b1044 	ldr	r1, [fp, #-68]
21f2e664:	e51b2048 	ldr	r2, [fp, #-72]
21f2e668:	e51b304c 	ldr	r3, [fp, #-76]
21f2e66c:	ebfffb9d 	bl	21f2d4e8 <do_reset>
		}

		data = (ulong) & header;
21f2e670:	e59f335c 	ldr	r3, [pc, #860]	; 21f2e9d4 <.text+0x2e9d4>
21f2e674:	e50b302c 	str	r3, [fp, #-44]
		len = sizeof (image_header_t);
21f2e678:	e3a03040 	mov	r3, #64	; 0x40
21f2e67c:	e50b303c 	str	r3, [fp, #-60]

		checksum = ntohl (hdr->ih_hcrc);
21f2e680:	e51b3024 	ldr	r3, [fp, #-36]
21f2e684:	e5933004 	ldr	r3, [r3, #4]
21f2e688:	e1a00003 	mov	r0, r3
21f2e68c:	eb0000db 	bl	21f2ea00 <__fswab32>
21f2e690:	e1a03000 	mov	r3, r0
21f2e694:	e50b3038 	str	r3, [fp, #-56]
		hdr->ih_hcrc = 0;
21f2e698:	e51b2024 	ldr	r2, [fp, #-36]
21f2e69c:	e3a03000 	mov	r3, #0	; 0x0
21f2e6a0:	e5823004 	str	r3, [r2, #4]

		if (crc32 (0, (unsigned char *) data, len) != checksum) {
21f2e6a4:	e51b302c 	ldr	r3, [fp, #-44]
21f2e6a8:	e3a00000 	mov	r0, #0	; 0x0
21f2e6ac:	e1a01003 	mov	r1, r3
21f2e6b0:	e51b203c 	ldr	r2, [fp, #-60]
21f2e6b4:	ebffcf0f 	bl	21f222f8 <crc32>
21f2e6b8:	e1a02000 	mov	r2, r0
21f2e6bc:	e51b3038 	ldr	r3, [fp, #-56]
21f2e6c0:	e1520003 	cmp	r2, r3
21f2e6c4:	0a000006 	beq	21f2e6e4 <do_bootm_linux+0x194>
			printf ("Bad Header Checksum\n");
21f2e6c8:	e59f0318 	ldr	r0, [pc, #792]	; 21f2e9e8 <.text+0x2e9e8>
21f2e6cc:	ebffb4ee 	bl	21f1ba8c <printf>
			SHOW_BOOT_PROGRESS (-11);
			do_reset (cmdtp, flag, argc, argv);
21f2e6d0:	e51b0040 	ldr	r0, [fp, #-64]
21f2e6d4:	e51b1044 	ldr	r1, [fp, #-68]
21f2e6d8:	e51b2048 	ldr	r2, [fp, #-72]
21f2e6dc:	e51b304c 	ldr	r3, [fp, #-76]
21f2e6e0:	ebfffb80 	bl	21f2d4e8 <do_reset>
		}

		SHOW_BOOT_PROGRESS (10);

		print_image_hdr (hdr);
21f2e6e4:	e51b0024 	ldr	r0, [fp, #-36]
21f2e6e8:	ebff90c0 	bl	21f129f0 <print_image_hdr>

		data = addr + sizeof (image_header_t);
21f2e6ec:	e59b3004 	ldr	r3, [fp, #4]
21f2e6f0:	e2833040 	add	r3, r3, #64	; 0x40
21f2e6f4:	e50b302c 	str	r3, [fp, #-44]
		len = ntohl (hdr->ih_size);
21f2e6f8:	e51b3024 	ldr	r3, [fp, #-36]
21f2e6fc:	e593300c 	ldr	r3, [r3, #12]
21f2e700:	e1a00003 	mov	r0, r3
21f2e704:	eb0000bd 	bl	21f2ea00 <__fswab32>
21f2e708:	e1a03000 	mov	r3, r0
21f2e70c:	e50b303c 	str	r3, [fp, #-60]

#ifdef CONFIG_HAS_DATAFLASH
		if (addr_dataflash (addr)) {
21f2e710:	e59b0004 	ldr	r0, [fp, #4]
21f2e714:	ebff877e 	bl	21f10514 <addr_dataflash>
21f2e718:	e1a03000 	mov	r3, r0
21f2e71c:	e3530000 	cmp	r3, #0	; 0x0
21f2e720:	0a000005 	beq	21f2e73c <do_bootm_linux+0x1ec>
			read_dataflash (data, len, (char *) CFG_LOAD_ADDR);
21f2e724:	e51b002c 	ldr	r0, [fp, #-44]
21f2e728:	e51b103c 	ldr	r1, [fp, #-60]
21f2e72c:	e3a02421 	mov	r2, #553648128	; 0x21000000
21f2e730:	ebff88b8 	bl	21f10a18 <read_dataflash>
			data = CFG_LOAD_ADDR;
21f2e734:	e3a03421 	mov	r3, #553648128	; 0x21000000
21f2e738:	e50b302c 	str	r3, [fp, #-44]
		}
#endif

		if (verify) {
21f2e73c:	e59b300c 	ldr	r3, [fp, #12]
21f2e740:	e3530000 	cmp	r3, #0	; 0x0
21f2e744:	0a00001c 	beq	21f2e7bc <do_bootm_linux+0x26c>
			ulong csum = 0;
21f2e748:	e3a03000 	mov	r3, #0	; 0x0
21f2e74c:	e50b3018 	str	r3, [fp, #-24]

			printf ("   Verifying Checksum ... ");
21f2e750:	e59f0294 	ldr	r0, [pc, #660]	; 21f2e9ec <.text+0x2e9ec>
21f2e754:	ebffb4cc 	bl	21f1ba8c <printf>
			csum = crc32 (0, (unsigned char *) data, len);
21f2e758:	e51b302c 	ldr	r3, [fp, #-44]
21f2e75c:	e3a00000 	mov	r0, #0	; 0x0
21f2e760:	e1a01003 	mov	r1, r3
21f2e764:	e51b203c 	ldr	r2, [fp, #-60]
21f2e768:	ebffcee2 	bl	21f222f8 <crc32>
21f2e76c:	e1a03000 	mov	r3, r0
21f2e770:	e50b3018 	str	r3, [fp, #-24]
			if (csum != ntohl (hdr->ih_dcrc)) {
21f2e774:	e51b3024 	ldr	r3, [fp, #-36]
21f2e778:	e5933018 	ldr	r3, [r3, #24]
21f2e77c:	e1a00003 	mov	r0, r3
21f2e780:	eb00009e 	bl	21f2ea00 <__fswab32>
21f2e784:	e1a03000 	mov	r3, r0
21f2e788:	e1a02003 	mov	r2, r3
21f2e78c:	e51b3018 	ldr	r3, [fp, #-24]
21f2e790:	e1520003 	cmp	r2, r3
21f2e794:	0a000006 	beq	21f2e7b4 <do_bootm_linux+0x264>
				printf ("Bad Data CRC\n");
21f2e798:	e59f0250 	ldr	r0, [pc, #592]	; 21f2e9f0 <.text+0x2e9f0>
21f2e79c:	ebffb4ba 	bl	21f1ba8c <printf>
				SHOW_BOOT_PROGRESS (-12);
				do_reset (cmdtp, flag, argc, argv);
21f2e7a0:	e51b0040 	ldr	r0, [fp, #-64]
21f2e7a4:	e51b1044 	ldr	r1, [fp, #-68]
21f2e7a8:	e51b2048 	ldr	r2, [fp, #-72]
21f2e7ac:	e51b304c 	ldr	r3, [fp, #-76]
21f2e7b0:	ebfffb4c 	bl	21f2d4e8 <do_reset>
			}
			printf ("OK\n");
21f2e7b4:	e59f0238 	ldr	r0, [pc, #568]	; 21f2e9f4 <.text+0x2e9f4>
21f2e7b8:	ebffb4b3 	bl	21f1ba8c <printf>
		}

		SHOW_BOOT_PROGRESS (11);

		if ((hdr->ih_os != IH_OS_LINUX) ||
21f2e7bc:	e51b3024 	ldr	r3, [fp, #-36]
21f2e7c0:	e5d3301c 	ldrb	r3, [r3, #28]
21f2e7c4:	e3530005 	cmp	r3, #5	; 0x5
21f2e7c8:	1a000007 	bne	21f2e7ec <do_bootm_linux+0x29c>
21f2e7cc:	e51b3024 	ldr	r3, [fp, #-36]
21f2e7d0:	e5d3301d 	ldrb	r3, [r3, #29]
21f2e7d4:	e3530002 	cmp	r3, #2	; 0x2
21f2e7d8:	1a000003 	bne	21f2e7ec <do_bootm_linux+0x29c>
21f2e7dc:	e51b3024 	ldr	r3, [fp, #-36]
21f2e7e0:	e5d3301e 	ldrb	r3, [r3, #30]
21f2e7e4:	e3530003 	cmp	r3, #3	; 0x3
21f2e7e8:	0a000048 	beq	21f2e910 <do_bootm_linux+0x3c0>
		    (hdr->ih_arch != IH_CPU_ARM) ||
		    (hdr->ih_type != IH_TYPE_RAMDISK)) {
			printf ("No Linux ARM Ramdisk Image\n");
21f2e7ec:	e59f0204 	ldr	r0, [pc, #516]	; 21f2e9f8 <.text+0x2e9f8>
21f2e7f0:	ebffb4a5 	bl	21f1ba8c <printf>
			SHOW_BOOT_PROGRESS (-13);
			do_reset (cmdtp, flag, argc, argv);
21f2e7f4:	e51b0040 	ldr	r0, [fp, #-64]
21f2e7f8:	e51b1044 	ldr	r1, [fp, #-68]
21f2e7fc:	e51b2048 	ldr	r2, [fp, #-72]
21f2e800:	e51b304c 	ldr	r3, [fp, #-76]
21f2e804:	ebfffb37 	bl	21f2d4e8 <do_reset>
21f2e808:	ea000040 	b	21f2e910 <do_bootm_linux+0x3c0>
		}

#if defined(CONFIG_B2) || defined(CONFIG_EVB4510) || defined(CONFIG_ARMADILLO)
		/*
		 *we need to copy the ramdisk to SRAM to let Linux boot
		 */
		memmove ((void *) ntohl(hdr->ih_load), (uchar *)data, len);
		data = ntohl(hdr->ih_load);
#endif /* CONFIG_B2 || CONFIG_EVB4510 */

		/*
		 * Now check if we have a multifile image
		 */
	} else if ((hdr->ih_type == IH_TYPE_MULTI) && (len_ptr[1])) {
21f2e80c:	e51b3024 	ldr	r3, [fp, #-36]
21f2e810:	e5d3301e 	ldrb	r3, [r3, #30]
21f2e814:	e3530004 	cmp	r3, #4	; 0x4
21f2e818:	1a000038 	bne	21f2e900 <do_bootm_linux+0x3b0>
21f2e81c:	e59b3008 	ldr	r3, [fp, #8]
21f2e820:	e2833004 	add	r3, r3, #4	; 0x4
21f2e824:	e5933000 	ldr	r3, [r3]
21f2e828:	e3530000 	cmp	r3, #0	; 0x0
21f2e82c:	0a000033 	beq	21f2e900 <do_bootm_linux+0x3b0>
		ulong tail = ntohl (len_ptr[0]) % 4;
21f2e830:	e59b3008 	ldr	r3, [fp, #8]
21f2e834:	e5933000 	ldr	r3, [r3]
21f2e838:	e1a00003 	mov	r0, r3
21f2e83c:	eb00006f 	bl	21f2ea00 <__fswab32>
21f2e840:	e1a03000 	mov	r3, r0
21f2e844:	e2033003 	and	r3, r3, #3	; 0x3
21f2e848:	e50b3014 	str	r3, [fp, #-20]
		int i;

		SHOW_BOOT_PROGRESS (13);

		/* skip kernel length and terminator */
		data = (ulong) (&len_ptr[2]);
21f2e84c:	e59b3008 	ldr	r3, [fp, #8]
21f2e850:	e2833008 	add	r3, r3, #8	; 0x8
21f2e854:	e50b302c 	str	r3, [fp, #-44]
		/* skip any additional image length fields */
		for (i = 1; len_ptr[i]; ++i)
21f2e858:	e3a03001 	mov	r3, #1	; 0x1
21f2e85c:	e50b3010 	str	r3, [fp, #-16]
21f2e860:	ea000005 	b	21f2e87c <do_bootm_linux+0x32c>
			data += 4;
21f2e864:	e51b302c 	ldr	r3, [fp, #-44]
21f2e868:	e2833004 	add	r3, r3, #4	; 0x4
21f2e86c:	e50b302c 	str	r3, [fp, #-44]
21f2e870:	e51b3010 	ldr	r3, [fp, #-16]
21f2e874:	e2833001 	add	r3, r3, #1	; 0x1
21f2e878:	e50b3010 	str	r3, [fp, #-16]
21f2e87c:	e51b3010 	ldr	r3, [fp, #-16]
21f2e880:	e1a03103 	mov	r3, r3, lsl #2
21f2e884:	e1a02003 	mov	r2, r3
21f2e888:	e59b3008 	ldr	r3, [fp, #8]
21f2e88c:	e0823003 	add	r3, r2, r3
21f2e890:	e5933000 	ldr	r3, [r3]
21f2e894:	e3530000 	cmp	r3, #0	; 0x0
21f2e898:	1afffff1 	bne	21f2e864 <do_bootm_linux+0x314>
		/* add kernel length, and align */
		data += ntohl (len_ptr[0]);
21f2e89c:	e59b3008 	ldr	r3, [fp, #8]
21f2e8a0:	e5933000 	ldr	r3, [r3]
21f2e8a4:	e1a00003 	mov	r0, r3
21f2e8a8:	eb000054 	bl	21f2ea00 <__fswab32>
21f2e8ac:	e1a03000 	mov	r3, r0
21f2e8b0:	e1a02003 	mov	r2, r3
21f2e8b4:	e51b302c 	ldr	r3, [fp, #-44]
21f2e8b8:	e0833002 	add	r3, r3, r2
21f2e8bc:	e50b302c 	str	r3, [fp, #-44]
		if (tail) {
21f2e8c0:	e51b3014 	ldr	r3, [fp, #-20]
21f2e8c4:	e3530000 	cmp	r3, #0	; 0x0
21f2e8c8:	0a000004 	beq	21f2e8e0 <do_bootm_linux+0x390>
			data += 4 - tail;
21f2e8cc:	e51b202c 	ldr	r2, [fp, #-44]
21f2e8d0:	e51b3014 	ldr	r3, [fp, #-20]
21f2e8d4:	e0633002 	rsb	r3, r3, r2
21f2e8d8:	e2833004 	add	r3, r3, #4	; 0x4
21f2e8dc:	e50b302c 	str	r3, [fp, #-44]
		}

		len = ntohl (len_ptr[1]);
21f2e8e0:	e59b3008 	ldr	r3, [fp, #8]
21f2e8e4:	e2833004 	add	r3, r3, #4	; 0x4
21f2e8e8:	e5933000 	ldr	r3, [r3]
21f2e8ec:	e1a00003 	mov	r0, r3
21f2e8f0:	eb000042 	bl	21f2ea00 <__fswab32>
21f2e8f4:	e1a03000 	mov	r3, r0
21f2e8f8:	e50b303c 	str	r3, [fp, #-60]
21f2e8fc:	ea000003 	b	21f2e910 <do_bootm_linux+0x3c0>

	} else {
		/*
		 * no initrd image
		 */
		SHOW_BOOT_PROGRESS (14);

		len = data = 0;
21f2e900:	e3a03000 	mov	r3, #0	; 0x0
21f2e904:	e50b302c 	str	r3, [fp, #-44]
21f2e908:	e51b302c 	ldr	r3, [fp, #-44]
21f2e90c:	e50b303c 	str	r3, [fp, #-60]
	}

#ifdef	DEBUG
	if (!data) {
		printf ("No initrd\n");
	}
#endif

	if (data) {
21f2e910:	e51b302c 	ldr	r3, [fp, #-44]
21f2e914:	e3530000 	cmp	r3, #0	; 0x0
21f2e918:	0a000006 	beq	21f2e938 <do_bootm_linux+0x3e8>
		initrd_start = data;
21f2e91c:	e51b302c 	ldr	r3, [fp, #-44]
21f2e920:	e50b3034 	str	r3, [fp, #-52]
		initrd_end = initrd_start + len;
21f2e924:	e51b2034 	ldr	r2, [fp, #-52]
21f2e928:	e51b303c 	ldr	r3, [fp, #-60]
21f2e92c:	e0823003 	add	r3, r2, r3
21f2e930:	e50b3030 	str	r3, [fp, #-48]
21f2e934:	ea000003 	b	21f2e948 <do_bootm_linux+0x3f8>
	} else {
		initrd_start = 0;
21f2e938:	e3a03000 	mov	r3, #0	; 0x0
21f2e93c:	e50b3034 	str	r3, [fp, #-52]
		initrd_end = 0;
21f2e940:	e3a03000 	mov	r3, #0	; 0x0
21f2e944:	e50b3030 	str	r3, [fp, #-48]
	}

	SHOW_BOOT_PROGRESS (15);

	debug ("## Transferring control to Linux (at address %08lx) ...\n",
	       (ulong) theKernel);

#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
    defined (CONFIG_CMDLINE_TAG) || \
    defined (CONFIG_INITRD_TAG) || \
    defined (CONFIG_SERIAL_TAG) || \
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
	setup_start_tag (bd);
21f2e948:	e51b0020 	ldr	r0, [fp, #-32]
21f2e94c:	eb000041 	bl	21f2ea58 <setup_start_tag>
#ifdef CONFIG_SERIAL_TAG
	setup_serial_tag (&params);
#endif
#ifdef CONFIG_REVISION_TAG
	setup_revision_tag (&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
	setup_memory_tags (bd);
21f2e950:	e51b0020 	ldr	r0, [fp, #-32]
21f2e954:	eb00006b 	bl	21f2eb08 <setup_memory_tags>
#endif
#ifdef CONFIG_CMDLINE_TAG
	setup_commandline_tag (bd, commandline);
21f2e958:	e51b0020 	ldr	r0, [fp, #-32]
21f2e95c:	e51b101c 	ldr	r1, [fp, #-28]
21f2e960:	eb0000a1 	bl	21f2ebec <setup_commandline_tag>
#endif
#ifdef CONFIG_INITRD_TAG
	if (initrd_start && initrd_end)
21f2e964:	e51b3034 	ldr	r3, [fp, #-52]
21f2e968:	e3530000 	cmp	r3, #0	; 0x0
21f2e96c:	0a000006 	beq	21f2e98c <do_bootm_linux+0x43c>
21f2e970:	e51b3030 	ldr	r3, [fp, #-48]
21f2e974:	e3530000 	cmp	r3, #0	; 0x0
21f2e978:	0a000003 	beq	21f2e98c <do_bootm_linux+0x43c>
		setup_initrd_tag (bd, initrd_start, initrd_end);
21f2e97c:	e51b0020 	ldr	r0, [fp, #-32]
21f2e980:	e51b1034 	ldr	r1, [fp, #-52]
21f2e984:	e51b2030 	ldr	r2, [fp, #-48]
21f2e988:	eb0000d0 	bl	21f2ecd0 <setup_initrd_tag>
#endif
#if defined (CONFIG_VFD) || defined (CONFIG_LCD)
	setup_videolfb_tag ((gd_t *) gd);
#endif
	setup_end_tag (bd);
21f2e98c:	e51b0020 	ldr	r0, [fp, #-32]
21f2e990:	eb0000f7 	bl	21f2ed74 <setup_end_tag>
#endif

	/* we assume that the kernel is in place */
	printf ("\nStarting kernel ...\n\n");
21f2e994:	e59f0060 	ldr	r0, [pc, #96]	; 21f2e9fc <.text+0x2e9fc>
21f2e998:	ebffb43b 	bl	21f1ba8c <printf>

#ifdef CONFIG_USB_DEVICE
	{
		extern void udc_disconnect (void);
		udc_disconnect ();
	}
#endif

	cleanup_before_linux ();
21f2e99c:	ebfffabd 	bl	21f2d498 <cleanup_before_linux>

	theKernel (0, bd->bi_arch_number, bd->bi_boot_params);
21f2e9a0:	e51b3020 	ldr	r3, [fp, #-32]
21f2e9a4:	e5933014 	ldr	r3, [r3, #20]
21f2e9a8:	e1a02003 	mov	r2, r3
21f2e9ac:	e51b3020 	ldr	r3, [fp, #-32]
21f2e9b0:	e5933018 	ldr	r3, [r3, #24]
21f2e9b4:	e51bc028 	ldr	ip, [fp, #-40]
21f2e9b8:	e3a00000 	mov	r0, #0	; 0x0
21f2e9bc:	e1a01002 	mov	r1, r2
21f2e9c0:	e1a02003 	mov	r2, r3
21f2e9c4:	e1a0e00f 	mov	lr, pc
21f2e9c8:	e1a0f00c 	mov	pc, ip
}
21f2e9cc:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2e9d0:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2e9d4:	21f67664 	mvncss	r7, r4, ror #12
21f2e9d8:	21f330d8 	ldrcssb	r3, [r3, #8]!
21f2e9dc:	21f330e4 	mvncss	r3, r4, ror #1
21f2e9e0:	27051956 	smlsdcs	r5, r6, r9, r1
21f2e9e4:	21f3310c 	mvncss	r3, ip, lsl #2
21f2e9e8:	21f33120 	mvncss	r3, r0, lsr #2
21f2e9ec:	21f33138 	mvncss	r3, r8, lsr r1
21f2e9f0:	21f33154 	mvncss	r3, r4, asr r1
21f2e9f4:	21f33164 	mvncss	r3, r4, ror #2
21f2e9f8:	21f33168 	mvncss	r3, r8, ror #2
21f2e9fc:	21f33184 	mvncss	r3, r4, lsl #3

21f2ea00 <__fswab32>:
	__arch__swab16s(addr);
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
21f2ea00:	e1a0c00d 	mov	ip, sp
21f2ea04:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2ea08:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2ea0c:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2ea10:	e50b0010 	str	r0, [fp, #-16]
	return __arch__swab32(x);
21f2ea14:	e51b3010 	ldr	r3, [fp, #-16]
21f2ea18:	e20330ff 	and	r3, r3, #255	; 0xff
21f2ea1c:	e1a02c03 	mov	r2, r3, lsl #24
21f2ea20:	e51b3010 	ldr	r3, [fp, #-16]
21f2ea24:	e2033cff 	and	r3, r3, #65280	; 0xff00
21f2ea28:	e1a03403 	mov	r3, r3, lsl #8
21f2ea2c:	e1822003 	orr	r2, r2, r3
21f2ea30:	e51b3010 	ldr	r3, [fp, #-16]
21f2ea34:	e20338ff 	and	r3, r3, #16711680	; 0xff0000
21f2ea38:	e1a03423 	mov	r3, r3, lsr #8
21f2ea3c:	e1822003 	orr	r2, r2, r3
21f2ea40:	e51b3010 	ldr	r3, [fp, #-16]
21f2ea44:	e20334ff 	and	r3, r3, #-16777216	; 0xff000000
21f2ea48:	e1a03c23 	mov	r3, r3, lsr #24
21f2ea4c:	e1823003 	orr	r3, r2, r3
}
21f2ea50:	e1a00003 	mov	r0, r3
21f2ea54:	e89da808 	ldmia	sp, {r3, fp, sp, pc}

21f2ea58 <setup_start_tag>:


#if defined (CONFIG_SETUP_MEMORY_TAGS) || \
    defined (CONFIG_CMDLINE_TAG) || \
    defined (CONFIG_INITRD_TAG) || \
    defined (CONFIG_SERIAL_TAG) || \
    defined (CONFIG_REVISION_TAG) || \
    defined (CONFIG_LCD) || \
    defined (CONFIG_VFD)
static void setup_start_tag (bd_t *bd)
{
21f2ea58:	e1a0c00d 	mov	ip, sp
21f2ea5c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2ea60:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2ea64:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2ea68:	e50b0010 	str	r0, [fp, #-16]
	params = (struct tag *) bd->bi_boot_params;
21f2ea6c:	e51b3010 	ldr	r3, [fp, #-16]
21f2ea70:	e5933018 	ldr	r3, [r3, #24]
21f2ea74:	e1a02003 	mov	r2, r3
21f2ea78:	e59f3084 	ldr	r3, [pc, #132]	; 21f2eb04 <.text+0x2eb04>
21f2ea7c:	e5832000 	str	r2, [r3]

	params->hdr.tag = ATAG_CORE;
21f2ea80:	e59f307c 	ldr	r3, [pc, #124]	; 21f2eb04 <.text+0x2eb04>
21f2ea84:	e5932000 	ldr	r2, [r3]
21f2ea88:	e3a03355 	mov	r3, #1409286145	; 0x54000001
21f2ea8c:	e2833841 	add	r3, r3, #4259840	; 0x410000
21f2ea90:	e5823004 	str	r3, [r2, #4]
	params->hdr.size = tag_size (tag_core);
21f2ea94:	e59f3068 	ldr	r3, [pc, #104]	; 21f2eb04 <.text+0x2eb04>
21f2ea98:	e5932000 	ldr	r2, [r3]
21f2ea9c:	e3a03005 	mov	r3, #5	; 0x5
21f2eaa0:	e5823000 	str	r3, [r2]

	params->u.core.flags = 0;
21f2eaa4:	e59f3058 	ldr	r3, [pc, #88]	; 21f2eb04 <.text+0x2eb04>
21f2eaa8:	e5932000 	ldr	r2, [r3]
21f2eaac:	e3a03000 	mov	r3, #0	; 0x0
21f2eab0:	e5823008 	str	r3, [r2, #8]
	params->u.core.pagesize = 0;
21f2eab4:	e59f3048 	ldr	r3, [pc, #72]	; 21f2eb04 <.text+0x2eb04>
21f2eab8:	e5932000 	ldr	r2, [r3]
21f2eabc:	e3a03000 	mov	r3, #0	; 0x0
21f2eac0:	e582300c 	str	r3, [r2, #12]
	params->u.core.rootdev = 0;
21f2eac4:	e59f3038 	ldr	r3, [pc, #56]	; 21f2eb04 <.text+0x2eb04>
21f2eac8:	e5932000 	ldr	r2, [r3]
21f2eacc:	e3a03000 	mov	r3, #0	; 0x0
21f2ead0:	e5823010 	str	r3, [r2, #16]

	params = tag_next (params);
21f2ead4:	e59f3028 	ldr	r3, [pc, #40]	; 21f2eb04 <.text+0x2eb04>
21f2ead8:	e5933000 	ldr	r3, [r3]
21f2eadc:	e5933000 	ldr	r3, [r3]
21f2eae0:	e1a03103 	mov	r3, r3, lsl #2
21f2eae4:	e1a02003 	mov	r2, r3
21f2eae8:	e59f3014 	ldr	r3, [pc, #20]	; 21f2eb04 <.text+0x2eb04>
21f2eaec:	e5933000 	ldr	r3, [r3]
21f2eaf0:	e0823003 	add	r3, r2, r3
21f2eaf4:	e1a02003 	mov	r2, r3
21f2eaf8:	e59f3004 	ldr	r3, [pc, #4]	; 21f2eb04 <.text+0x2eb04>
21f2eafc:	e5832000 	str	r2, [r3]
}
21f2eb00:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f2eb04:	21f81600 	mvncss	r1, r0, lsl #12

21f2eb08 <setup_memory_tags>:


#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags (bd_t *bd)
{
21f2eb08:	e1a0c00d 	mov	ip, sp
21f2eb0c:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2eb10:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2eb14:	e24dd008 	sub	sp, sp, #8	; 0x8
21f2eb18:	e50b0014 	str	r0, [fp, #-20]
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
21f2eb1c:	e3a03000 	mov	r3, #0	; 0x0
21f2eb20:	e50b3010 	str	r3, [fp, #-16]
21f2eb24:	ea00002a 	b	21f2ebd4 <setup_memory_tags+0xcc>
		params->hdr.tag = ATAG_MEM;
21f2eb28:	e59f30b8 	ldr	r3, [pc, #184]	; 21f2ebe8 <.text+0x2ebe8>
21f2eb2c:	e5932000 	ldr	r2, [r3]
21f2eb30:	e3a03395 	mov	r3, #1409286146	; 0x54000002
21f2eb34:	e2833841 	add	r3, r3, #4259840	; 0x410000
21f2eb38:	e5823004 	str	r3, [r2, #4]
		params->hdr.size = tag_size (tag_mem32);
21f2eb3c:	e59f30a4 	ldr	r3, [pc, #164]	; 21f2ebe8 <.text+0x2ebe8>
21f2eb40:	e5932000 	ldr	r2, [r3]
21f2eb44:	e3a03004 	mov	r3, #4	; 0x4
21f2eb48:	e5823000 	str	r3, [r2]

		params->u.mem.start = bd->bi_dram[i].start;
21f2eb4c:	e59f3094 	ldr	r3, [pc, #148]	; 21f2ebe8 <.text+0x2ebe8>
21f2eb50:	e5930000 	ldr	r0, [r3]
21f2eb54:	e51b3010 	ldr	r3, [fp, #-16]
21f2eb58:	e51b2014 	ldr	r2, [fp, #-20]
21f2eb5c:	e3a0101c 	mov	r1, #28	; 0x1c
21f2eb60:	e1a03183 	mov	r3, r3, lsl #3
21f2eb64:	e0833002 	add	r3, r3, r2
21f2eb68:	e0833001 	add	r3, r3, r1
21f2eb6c:	e5933000 	ldr	r3, [r3]
21f2eb70:	e580300c 	str	r3, [r0, #12]
		params->u.mem.size = bd->bi_dram[i].size;
21f2eb74:	e59f306c 	ldr	r3, [pc, #108]	; 21f2ebe8 <.text+0x2ebe8>
21f2eb78:	e5930000 	ldr	r0, [r3]
21f2eb7c:	e51b3010 	ldr	r3, [fp, #-16]
21f2eb80:	e51b2014 	ldr	r2, [fp, #-20]
21f2eb84:	e3a01020 	mov	r1, #32	; 0x20
21f2eb88:	e1a03183 	mov	r3, r3, lsl #3
21f2eb8c:	e0833002 	add	r3, r3, r2
21f2eb90:	e0833001 	add	r3, r3, r1
21f2eb94:	e5933000 	ldr	r3, [r3]
21f2eb98:	e5803008 	str	r3, [r0, #8]

		params = tag_next (params);
21f2eb9c:	e59f3044 	ldr	r3, [pc, #68]	; 21f2ebe8 <.text+0x2ebe8>
21f2eba0:	e5933000 	ldr	r3, [r3]
21f2eba4:	e5933000 	ldr	r3, [r3]
21f2eba8:	e1a03103 	mov	r3, r3, lsl #2
21f2ebac:	e1a02003 	mov	r2, r3
21f2ebb0:	e59f3030 	ldr	r3, [pc, #48]	; 21f2ebe8 <.text+0x2ebe8>
21f2ebb4:	e5933000 	ldr	r3, [r3]
21f2ebb8:	e0823003 	add	r3, r2, r3
21f2ebbc:	e1a02003 	mov	r2, r3
21f2ebc0:	e59f3020 	ldr	r3, [pc, #32]	; 21f2ebe8 <.text+0x2ebe8>
21f2ebc4:	e5832000 	str	r2, [r3]
21f2ebc8:	e51b3010 	ldr	r3, [fp, #-16]
21f2ebcc:	e2833001 	add	r3, r3, #1	; 0x1
21f2ebd0:	e50b3010 	str	r3, [fp, #-16]
21f2ebd4:	e51b3010 	ldr	r3, [fp, #-16]
21f2ebd8:	e3530000 	cmp	r3, #0	; 0x0
21f2ebdc:	daffffd1 	ble	21f2eb28 <setup_memory_tags+0x20>
	}
}
21f2ebe0:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2ebe4:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2ebe8:	21f81600 	mvncss	r1, r0, lsl #12

21f2ebec <setup_commandline_tag>:
#endif /* CONFIG_SETUP_MEMORY_TAGS */


static void setup_commandline_tag (bd_t *bd, char *commandline)
{
21f2ebec:	e1a0c00d 	mov	ip, sp
21f2ebf0:	e92dd810 	stmdb	sp!, {r4, fp, ip, lr, pc}
21f2ebf4:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2ebf8:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2ebfc:	e50b0018 	str	r0, [fp, #-24]
21f2ec00:	e50b101c 	str	r1, [fp, #-28]
	char *p;

	if (!commandline)
21f2ec04:	e51b301c 	ldr	r3, [fp, #-28]
21f2ec08:	e3530000 	cmp	r3, #0	; 0x0
21f2ec0c:	0a00002c 	beq	21f2ecc4 <setup_commandline_tag+0xd8>
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);
21f2ec10:	e51b301c 	ldr	r3, [fp, #-28]
21f2ec14:	e50b3014 	str	r3, [fp, #-20]
21f2ec18:	ea000002 	b	21f2ec28 <setup_commandline_tag+0x3c>
21f2ec1c:	e51b3014 	ldr	r3, [fp, #-20]
21f2ec20:	e2833001 	add	r3, r3, #1	; 0x1
21f2ec24:	e50b3014 	str	r3, [fp, #-20]
21f2ec28:	e51b3014 	ldr	r3, [fp, #-20]
21f2ec2c:	e5d33000 	ldrb	r3, [r3]
21f2ec30:	e3530020 	cmp	r3, #32	; 0x20
21f2ec34:	0afffff8 	beq	21f2ec1c <setup_commandline_tag+0x30>

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
21f2ec38:	e51b3014 	ldr	r3, [fp, #-20]
21f2ec3c:	e5d33000 	ldrb	r3, [r3]
21f2ec40:	e3530000 	cmp	r3, #0	; 0x0
21f2ec44:	0a00001e 	beq	21f2ecc4 <setup_commandline_tag+0xd8>
		return;

	params->hdr.tag = ATAG_CMDLINE;
21f2ec48:	e59f307c 	ldr	r3, [pc, #124]	; 21f2eccc <.text+0x2eccc>
21f2ec4c:	e5932000 	ldr	r2, [r3]
21f2ec50:	e3a03315 	mov	r3, #1409286144	; 0x54000000
21f2ec54:	e2833841 	add	r3, r3, #4259840	; 0x410000
21f2ec58:	e2833009 	add	r3, r3, #9	; 0x9
21f2ec5c:	e5823004 	str	r3, [r2, #4]
	params->hdr.size =
21f2ec60:	e59f3064 	ldr	r3, [pc, #100]	; 21f2eccc <.text+0x2eccc>
21f2ec64:	e5934000 	ldr	r4, [r3]
21f2ec68:	e51b0014 	ldr	r0, [fp, #-20]
21f2ec6c:	ebffcfd4 	bl	21f22bc4 <strlen>
21f2ec70:	e1a03000 	mov	r3, r0
21f2ec74:	e283300d 	add	r3, r3, #13	; 0xd
21f2ec78:	e1a03123 	mov	r3, r3, lsr #2
21f2ec7c:	e5843000 	str	r3, [r4]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);
21f2ec80:	e59f3044 	ldr	r3, [pc, #68]	; 21f2eccc <.text+0x2eccc>
21f2ec84:	e5933000 	ldr	r3, [r3]
21f2ec88:	e2833008 	add	r3, r3, #8	; 0x8
21f2ec8c:	e1a00003 	mov	r0, r3
21f2ec90:	e51b1014 	ldr	r1, [fp, #-20]
21f2ec94:	ebffce8e 	bl	21f226d4 <strcpy>

	params = tag_next (params);
21f2ec98:	e59f302c 	ldr	r3, [pc, #44]	; 21f2eccc <.text+0x2eccc>
21f2ec9c:	e5933000 	ldr	r3, [r3]
21f2eca0:	e5933000 	ldr	r3, [r3]
21f2eca4:	e1a03103 	mov	r3, r3, lsl #2
21f2eca8:	e1a02003 	mov	r2, r3
21f2ecac:	e59f3018 	ldr	r3, [pc, #24]	; 21f2eccc <.text+0x2eccc>
21f2ecb0:	e5933000 	ldr	r3, [r3]
21f2ecb4:	e0823003 	add	r3, r2, r3
21f2ecb8:	e1a02003 	mov	r2, r3
21f2ecbc:	e59f3008 	ldr	r3, [pc, #8]	; 21f2eccc <.text+0x2eccc>
21f2ecc0:	e5832000 	str	r2, [r3]
}
21f2ecc4:	e24bd010 	sub	sp, fp, #16	; 0x10
21f2ecc8:	e89da810 	ldmia	sp, {r4, fp, sp, pc}
21f2eccc:	21f81600 	mvncss	r1, r0, lsl #12

21f2ecd0 <setup_initrd_tag>:


#ifdef CONFIG_INITRD_TAG
static void setup_initrd_tag (bd_t *bd, ulong initrd_start, ulong initrd_end)
{
21f2ecd0:	e1a0c00d 	mov	ip, sp
21f2ecd4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2ecd8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2ecdc:	e24dd00c 	sub	sp, sp, #12	; 0xc
21f2ece0:	e50b0010 	str	r0, [fp, #-16]
21f2ece4:	e50b1014 	str	r1, [fp, #-20]
21f2ece8:	e50b2018 	str	r2, [fp, #-24]
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
21f2ecec:	e59f307c 	ldr	r3, [pc, #124]	; 21f2ed70 <.text+0x2ed70>
21f2ecf0:	e5932000 	ldr	r2, [r3]
21f2ecf4:	e3a03315 	mov	r3, #1409286144	; 0x54000000
21f2ecf8:	e2833842 	add	r3, r3, #4325376	; 0x420000
21f2ecfc:	e2833005 	add	r3, r3, #5	; 0x5
21f2ed00:	e5823004 	str	r3, [r2, #4]
	params->hdr.size = tag_size (tag_initrd);
21f2ed04:	e59f3064 	ldr	r3, [pc, #100]	; 21f2ed70 <.text+0x2ed70>
21f2ed08:	e5932000 	ldr	r2, [r3]
21f2ed0c:	e3a03004 	mov	r3, #4	; 0x4
21f2ed10:	e5823000 	str	r3, [r2]

	params->u.initrd.start = initrd_start;
21f2ed14:	e59f3054 	ldr	r3, [pc, #84]	; 21f2ed70 <.text+0x2ed70>
21f2ed18:	e5932000 	ldr	r2, [r3]
21f2ed1c:	e51b3014 	ldr	r3, [fp, #-20]
21f2ed20:	e5823008 	str	r3, [r2, #8]
	params->u.initrd.size = initrd_end - initrd_start;
21f2ed24:	e59f3044 	ldr	r3, [pc, #68]	; 21f2ed70 <.text+0x2ed70>
21f2ed28:	e5931000 	ldr	r1, [r3]
21f2ed2c:	e51b2018 	ldr	r2, [fp, #-24]
21f2ed30:	e51b3014 	ldr	r3, [fp, #-20]
21f2ed34:	e0633002 	rsb	r3, r3, r2
21f2ed38:	e581300c 	str	r3, [r1, #12]

	params = tag_next (params);
21f2ed3c:	e59f302c 	ldr	r3, [pc, #44]	; 21f2ed70 <.text+0x2ed70>
21f2ed40:	e5933000 	ldr	r3, [r3]
21f2ed44:	e5933000 	ldr	r3, [r3]
21f2ed48:	e1a03103 	mov	r3, r3, lsl #2
21f2ed4c:	e1a02003 	mov	r2, r3
21f2ed50:	e59f3018 	ldr	r3, [pc, #24]	; 21f2ed70 <.text+0x2ed70>
21f2ed54:	e5933000 	ldr	r3, [r3]
21f2ed58:	e0823003 	add	r3, r2, r3
21f2ed5c:	e1a02003 	mov	r2, r3
21f2ed60:	e59f3008 	ldr	r3, [pc, #8]	; 21f2ed70 <.text+0x2ed70>
21f2ed64:	e5832000 	str	r2, [r3]
}
21f2ed68:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2ed6c:	e89da800 	ldmia	sp, {fp, sp, pc}
21f2ed70:	21f81600 	mvncss	r1, r0, lsl #12

21f2ed74 <setup_end_tag>:
#endif /* CONFIG_INITRD_TAG */


#if defined (CONFIG_VFD) || defined (CONFIG_LCD)
extern ulong calc_fbsize (void);
static void setup_videolfb_tag (gd_t *gd)
{
	/* An ATAG_VIDEOLFB node tells the kernel where and how large
	 * the framebuffer for video was allocated (among other things).
	 * Note that a _physical_ address is passed !
	 *
	 * We only use it to pass the address and size, the other entries
	 * in the tag_videolfb are not of interest.
	 */
	params->hdr.tag = ATAG_VIDEOLFB;
	params->hdr.size = tag_size (tag_videolfb);

	params->u.videolfb.lfb_base = (u32) gd->fb_base;
	/* Fb size is calculated according to parameters for our panel
	 */
	params->u.videolfb.lfb_size = calc_fbsize();

	params = tag_next (params);
}
#endif /* CONFIG_VFD || CONFIG_LCD */

#ifdef CONFIG_SERIAL_TAG
void setup_serial_tag (struct tag **tmp)
{
	struct tag *params = *tmp;
	struct tag_serialnr serialnr;
	void get_board_serial(struct tag_serialnr *serialnr);

	get_board_serial(&serialnr);
	params->hdr.tag = ATAG_SERIAL;
	params->hdr.size = tag_size (tag_serialnr);
	params->u.serialnr.low = serialnr.low;
	params->u.serialnr.high= serialnr.high;
	params = tag_next (params);
	*tmp = params;
}
#endif

#ifdef CONFIG_REVISION_TAG
void setup_revision_tag(struct tag **in_params)
{
	u32 rev = 0;
	u32 get_board_rev(void);

	rev = get_board_rev();
	params->hdr.tag = ATAG_REVISION;
	params->hdr.size = tag_size (tag_revision);
	params->u.revision.rev = rev;
	params = tag_next (params);
}
#endif  /* CONFIG_REVISION_TAG */


static void setup_end_tag (bd_t *bd)
{
21f2ed74:	e1a0c00d 	mov	ip, sp
21f2ed78:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2ed7c:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2ed80:	e24dd004 	sub	sp, sp, #4	; 0x4
21f2ed84:	e50b0010 	str	r0, [fp, #-16]
	params->hdr.tag = ATAG_NONE;
21f2ed88:	e59f301c 	ldr	r3, [pc, #28]	; 21f2edac <.text+0x2edac>
21f2ed8c:	e5932000 	ldr	r2, [r3]
21f2ed90:	e3a03000 	mov	r3, #0	; 0x0
21f2ed94:	e5823004 	str	r3, [r2, #4]
	params->hdr.size = 0;
21f2ed98:	e59f300c 	ldr	r3, [pc, #12]	; 21f2edac <.text+0x2edac>
21f2ed9c:	e5932000 	ldr	r2, [r3]
21f2eda0:	e3a03000 	mov	r3, #0	; 0x0
21f2eda4:	e5823000 	str	r3, [r2]
}
21f2eda8:	e89da808 	ldmia	sp, {r3, fp, sp, pc}
21f2edac:	21f81600 	mvncss	r1, r0, lsl #12

21f2edb0 <flush_cache>:

#include <common.h>

void  flush_cache (unsigned long dummy1, unsigned long dummy2)
{
21f2edb0:	e1a0c00d 	mov	ip, sp
21f2edb4:	e92dd800 	stmdb	sp!, {fp, ip, lr, pc}
21f2edb8:	e24cb004 	sub	fp, ip, #4	; 0x4
21f2edbc:	e24dd008 	sub	sp, sp, #8	; 0x8
21f2edc0:	e50b0010 	str	r0, [fp, #-16]
21f2edc4:	e50b1014 	str	r1, [fp, #-20]
#ifdef CONFIG_OMAP2420
	void arm1136_cache_flush(void);

	arm1136_cache_flush();
#endif
	return;
}
21f2edc8:	e24bd00c 	sub	sp, fp, #12	; 0xc
21f2edcc:	e89da800 	ldmia	sp, {fp, sp, pc}
